//version: 1.2
const values=yaposi();
var Yaposi=values.Yaposi;
var MarkdownRender=values.MarkdownRender;

function yaposi(exports= {}) { 

    //names should be in lower case becasue datasets atributes does not allow uppercase
    class Toolbar{
        constructor(codeMirrorTarget,editorWrapper){
            this.me ="";
            this.editorWrapper=editorWrapper;
            this.codeMirrorTarget=codeMirrorTarget;
            this.icons=this.iconsF();
            this.keyMaps= {
                "120" : {keyboard:"F9",handler:"watch"},
                "121" : {keyboard:"F10",handler:"preview"},
                "122" : {keyboard:"F11",handler:"fullscreen"}
            };
        }
        registerKeyMaps() {
            document.body.addEventListener("keydown",(event) =>{
                const key=event.keyCode;
                const item="";
                if(!(key in this.keyMaps)){
                    return
                }
                const name=this.keyMaps[key].handler;
                for(let i=0,len=this.icons.length;i<len;i++){
                    if(this.icons[i].Name==name){
                        item=this.icons[i];
                        break;
                    }
                }
                if(item!=""){
                    item.Func();
                }
            });
        }
        create(){     
            const lista=document.createElement("ul");
            lista.classList.add("yaposi-toolbar");
           for (let i=0,len=this.icons.length;i<len;i++){
                const icon = this.icons[i];
                const liTag=document.createElement("li");
                liTag.classList.add("icon");
                liTag.dataset.name=icon.Name;
                let add="";
                switch (icon.Img.Kind){
                    case "text":
                        add=document.createElement("span");
                        add.textContent=icon.Img.Value;
                        add.classList.add("text");
                        break;
                    case "svg":
                        let temp=document.createElement("template");
                        temp.innerHTML=icon.Img.Value;
                        add=temp.content.querySelector("svg");
                        add.classList.add("img");
                        break;
                    case "img":
                        add=document.createElement("img");
                        add.src=icon.Img.Value;
                        add.classList.add("img");
                        break;    
                    default:
                        console.log(`Error type: ${icon.Img.Kind}; Valid types: text, svg`);
                        continue       
                }
                if ("Title" in icon){
                    liTag.setAttribute("title",icon.Title);
                }
                if ("Func" in icon){
                    liTag.addEventListener("click",icon.Func);
                }
                liTag.appendChild(add);

                lista.appendChild(liTag);
            }
            this.me =lista;
            return lista
        }
        iconsF() {
            return [
                {
                    Name:"undo",
                    Title:"Undo",
                    Img:{
                        Kind:"svg",
                        Value:`
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path fill="none" d="M0 0h24v24H0V0z"/>
                        <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L3.71 8.71C3.08 8.08 2 8.52 2 9.41V15c0 .55.45 1 1 1h5.59c.89 0 1.34-1.08.71-1.71l-1.91-1.91c1.39-1.16 3.16-1.88 5.12-1.88 3.16 0 5.89 1.84 7.19 4.5.27.56.91.84 1.5.64.71-.23 1.07-1.04.75-1.72C20.23 10.42 16.65 8 12.5 8z"/>
                        </svg>
                `},
                    Func: ()=> {
                        this.codeMirrorTarget.undo();
                        this.codeMirrorTarget.focus();
                    },
                },
                
                {
                    Name:"redo",
                    Title:"Redo",
                    Img:{
                        Kind:"svg",
                        Value:`
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path fill="none" d="M0 0h24v24H0V0z"/>
                        <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.16 0-7.74 2.42-9.44 5.93-.32.67.04 1.47.75 1.71.59.2 1.23-.08 1.5-.64 1.3-2.66 4.03-4.5 7.19-4.5 1.95 0 3.73.72 5.12 1.88l-1.91 1.91c-.63.63-.19 1.71.7 1.71H21c.55 0 1-.45 1-1V9.41c0-.89-1.08-1.34-1.71-.71l-1.89 1.9z"/>
                        </svg>
                `},
                    Func: ()=> {
                        this.codeMirrorTarget.redo();
                        this.codeMirrorTarget.focus();
                    },
                },
               
                { 
                    Name:"bold",
                    Title:"Bold",
                    Img:{
                        Kind:"svg",
                        Value:`
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path fill="none" d="M0 0h24v24H0V0z"/>
                        <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H8c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h5.78c2.07 0 3.96-1.69 3.97-3.77.01-1.53-.85-2.84-2.15-3.44zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/>
                        </svg>
                `},
                    Func: ()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        cm.replaceSelection("**" + selection + "**");
            
                        if(selection === "") {
                            cm.setCursor(cursor.line, cursor.ch + 2);
                        }
                        this.codeMirrorTarget.focus();
                    },
                },
                
                { 
                    Name:"del",
                    Title:"Strikethrough",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0z"/>
                    <path d="M14.59 7.52c0-.31-.05-.59-.15-.85-.09-.27-.24-.49-.44-.68-.2-.19-.45-.33-.75-.44-.3-.1-.66-.16-1.06-.16-.39 0-.74.04-1.03.13s-.53.21-.72.36c-.19.16-.34.34-.44.55-.1.21-.15.43-.15.66 0 .48.25.88.74 1.21.38.25.77.48 1.41.7H7.39c-.05-.08-.11-.17-.15-.25-.26-.48-.39-1.03-.39-1.67 0-.61.13-1.16.4-1.67.26-.5.63-.93 1.11-1.29.48-.35 1.05-.63 1.7-.83.66-.19 1.39-.29 2.18-.29.81 0 1.54.11 2.21.34.66.22 1.23.54 1.69.94.47.4.83.88 1.08 1.43s.38 1.15.38 1.81h-3.01M20 10H4c-.55 0-1 .45-1 1s.45 1 1 1h8.62c.18.07.4.14.55.2.37.17.66.34.87.51s.35.36.43.57c.07.2.11.43.11.69 0 .23-.05.45-.14.66-.09.2-.23.38-.42.53-.19.15-.42.26-.71.35-.29.08-.63.13-1.01.13-.43 0-.83-.04-1.18-.13s-.66-.23-.91-.42c-.25-.19-.45-.44-.59-.75s-.25-.76-.25-1.21H6.4c0 .55.08 1.13.24 1.58s.37.85.65 1.21c.28.35.6.66.98.92.37.26.78.48 1.22.65.44.17.9.3 1.38.39.48.08.96.13 1.44.13.8 0 1.53-.09 2.18-.28s1.21-.45 1.67-.79c.46-.34.82-.77 1.07-1.27s.38-1.07.38-1.71c0-.6-.1-1.14-.31-1.61-.05-.11-.11-.23-.17-.33H20c.55 0 1-.45 1-1V11c0-.55-.45-1-1-1z"/>
                    </svg>
                `},
                    Func: ()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        cm.replaceSelection("~~" + selection + "~~");
            
                        if(selection === "") {
                            cm.setCursor(cursor.line, cursor.ch + 2);
                        }
                        this.codeMirrorTarget.focus();
                    }
                },
               
                {  
                    Name:"italic",
                    Title:"Italic",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M10 5.5c0 .83.67 1.5 1.5 1.5h.71l-3.42 8H7.5c-.83 0-1.5.67-1.5 1.5S6.67 18 7.5 18h5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5h-.71l3.42-8h1.29c.83 0 1.5-.67 1.5-1.5S17.33 4 16.5 4h-5c-.83 0-1.5.67-1.5 1.5z"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        cm.replaceSelection("*" + selection + "*");
            
                        if(selection === "") {
                            cm.setCursor(cursor.line, cursor.ch + 1);
                        }
                        this.codeMirrorTarget.focus();
                    }
                },
                
                {
                    Name:"quote",
                    Title:"Quote",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M7.17 17c.51 0 .98-.29 1.2-.74l1.42-2.84c.14-.28.21-.58.21-.89V8c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2l-1.03 2.06c-.45.89.2 1.94 1.2 1.94zm10 0c.51 0 .98-.29 1.2-.74l1.42-2.84c.14-.28.21-.58.21-.89V8c0-.55-.45-1-1-1h-4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h2l-1.03 2.06c-.45.89.2 1.94 1.2 1.94z"/>
                    </svg>
                `},
                    Func: ()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch !== 0){
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("> " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 2);
                        }
                        else{
                            cm.replaceSelection("> " + selection);
                        }
            
                        this.codeMirrorTarget.focus();
                        //cm.replaceSelection("> " + selection);
                        //cm.setCursor(cursor.line, (selection === "") ? cursor.ch + 2 : cursor.ch + selection.length + 2);
                    }
                },
                
                {
                    Name:"ucfirst",
                    Title:"First letter of each word to upper case, the remaning in lower case",
                    Img:{
                        Kind:"text",
                        Value:"Aa"
                    },
                    Func:()=> {
                        const cm         = this.codeMirrorTarget;
                        const selection  = cm.getSelection();
                        const selections = cm.listSelections();

                        let str=  selection.toLowerCase().replace(/\b(\w)|\s(\w)/g, allLower => allLower.toUpperCase());
                        cm.replaceSelection(str);
                        cm.setSelections(selections);
                        this.codeMirrorTarget.focus();
                    }
                },
               
                {
                    Name:"uppercase",
                    Title:"All selected text to upper case",
                    Img:{
                        Kind:"text",
                        Value:"A"
                    },
                    Func:()=> {
                        const cm         = this.codeMirrorTarget;
                        const selection  = cm.getSelection();
                        const selections = cm.listSelections();
                        
                        cm.replaceSelection(selection.toUpperCase());
                        cm.setSelections(selections);
                        this.codeMirrorTarget.focus();
                    }
                },

                {
                    Name:"lowercase",
                    Title:"All selected text to lower case",
                    Img:{
                        Kind:"text",
                        Value:"a"
                    },
                    Func:()=> {
                        const cm         = this.codeMirrorTarget;
                        const selection  = cm.getSelection();
                        const selections = cm.listSelections();
                        
                        cm.replaceSelection(selection.toLowerCase());
                        cm.setSelections(selections);
                        this.codeMirrorTarget.focus();
                    }
                },

                {
                    Name:"h1",
                    Title:"Heading 1",
                    Img:{
                        Kind:"text",
                        Value:"H1"
                    },
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("# " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("# " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 2);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
               
                {
                    Name:"h2",
                    Title:"Heading 2",
                    Img:{
                        Kind:"text",
                        Value:"H2"
                    },
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("## " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("## " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 3);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
               
                {
                    Name:"h3",
                    Title:"Heading 3",
                    Img:{
                        Kind:"text",
                        Value:"H3"
                    },
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("### " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("### " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 4);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
                
                {
                    Name:"h4",
                    Title:"Heading 4",
                    Img:{
                        Kind:"text",
                        Value:"H4"
                    },
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("#### " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("#### " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 5);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
        
                {
                    Name:"h5",
                    Title:"Heading 5",
                    Img:{
                        Kind:"text",
                        Value:"H5"
                    },
                    Func:()=>{
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("##### " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("##### " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 6);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
                
                {
                    Name:"h6",
                    Title:"Heading 6",
                    Img:{
                        Kind:"text",
                        Value:"H6"
                    },
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        if (cursor.ch === 0){
                            cm.replaceSelection("###### " + selection);
                        }else{
                            cm.setCursor(cursor.line, 0);
                            cm.replaceSelection("###### " + selection);
                            cm.setCursor(cursor.line, cursor.ch + 7);
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
                
                {
                    Name:"list-ul",
                    Title:"Unordered list",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/><path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM8 19h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm0-6h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM7 6c0 .55.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1z"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const selection = cm.getSelection();
            
                        if (selection === "") {
                            cm.replaceSelection("- " + selection);
                        }else{
                            let selectionText = selection.split("\n");
                            for (let i = 0, len = selectionText.length; i < len; i++){
                                if(selectionText[i] != ""){
                                    selectionText[i]="- " + selectionText[i];
                                }
                            }
                            cm.replaceSelection(selectionText.join("\n"));
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
                
                {
                    Name:"list-ol",
                    Title:"Ordered list",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M8 7h12c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zm12 10H8c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm0-6H8c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zM4.5 16h-2c-.28 0-.5.22-.5.5s.22.5.5.5H4v.5h-.5c-.28 0-.5.22-.5.5s.22.5.5.5H4v.5H2.5c-.28 0-.5.22-.5.5s.22.5.5.5h2c.28 0 .5-.22.5-.5v-3c0-.28-.22-.5-.5-.5zm-2-11H3v2.5c0 .28.22.5.5.5s.5-.22.5-.5v-3c0-.28-.22-.5-.5-.5h-1c-.28 0-.5.22-.5.5s.22.5.5.5zm2 5h-2c-.28 0-.5.22-.5.5s.22.5.5.5h1.3l-1.68 1.96c-.08.09-.12.21-.12.32v.22c0 .28.22.5.5.5h2c.28 0 .5-.22.5-.5s-.22-.5-.5-.5H3.2l1.68-1.96c.08-.09.12-.21.12-.32v-.22c0-.28-.22-.5-.5-.5z"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const selection = cm.getSelection();
            
                        if(selection == "") {
                            cm.replaceSelection("1. " + selection);
                        }else{
                            let selectionText = selection.split("\n");
                            for (let i = 0, len = selectionText.length; i < len; i++){
                                if(selectionText[i]!=""){
                                    selectionText[i]=(i+1) + ". " + selectionText[i];
                                }
                            }
                            cm.replaceSelection(selectionText.join("\n"));
                        }
                        this.codeMirrorTarget.focus();
                    }
                } ,
               
                {
                    Name:"hr",
                    Title:"Horizontal rule",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M19 13H5v-2h14v2z"/>
                    <path d="M0 0h24v24H0z" fill="none"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        let put="\n\n";
                        if(cursor.ch==0){
                            put="\n";
                        }
                        put+="------------\n";
                        cm.replaceSelection(put);
                        this.codeMirrorTarget.focus();
                    }
                } ,
                {
                    Name:"link",
                    Title:"Link",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M17 7h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c1.65 0 3 1.35 3 3s-1.35 3-3 3h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c2.76 0 5-2.24 5-5s-2.24-5-5-5zm-9 5c0 .55.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1H9c-.55 0-1 .45-1 1zm2 3H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h3c.55 0 1-.45 1-1s-.45-1-1-1H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h3c.55 0 1-.45 1-1s-.45-1-1-1z"/>
                    </svg>
                `},
                    Func:()=>{
                        const cm        = this.codeMirrorTarget;
                        let selection = cm.getSelection();
                        if(selection.trim()==""){
                            selection="title";
                        }
                        this.codeMirrorTarget.replaceSelection("["+selection+"](link)");
                        this.codeMirrorTarget.focus();
                    }
                },
                {
                    Name:"image",
                    Title:"add image",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
                    <path d="M29.996 4c0.001 0.001 0.003 0.002 0.004 0.004v23.993c-0.001 0.001-0.002 0.003-0.004 0.004h-27.993c-0.001-0.001-0.003-0.002-0.004-0.004v-23.993c0.001-0.001 0.002-0.003 0.004-0.004h27.993zM30 2h-28c-1.1 0-2 0.9-2 2v24c0 1.1 0.9 2 2 2h28c1.1 0 2-0.9 2-2v-24c0-1.1-0.9-2-2-2v0z"></path>
                    <path d="M26 9c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"></path>
                    <path d="M28 26h-24v-4l7-12 8 10h2l7-6z"></path>
                    </svg>
                `}
                },
                
                {
                    Name:"code",
                    Title:"Lineal code",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        cm.replaceSelection("`" + selection + "`");
            
                        if (selection === "") {
                            cm.setCursor(cursor.line, cursor.ch + 1);
                        }
                    }
                },
                
                {
                    Name:"code-block",
                    Title:"Code block",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 32">
                    <path d="M26 23l3 3 10-10-10-10-3 3 7 7z"></path>
                    <path d="M14 9l-3-3-10 10 10 10 3-3-7-7z"></path>
                    <path d="M21.916 4.704l2.171 0.592-6 22.001-2.171-0.592 6-22.001z"></path>
                    </svg>
                `},          
                },
                {
                    Name:"table",
                    Title:"Tables",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/>
                    <path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/>
                    </svg>
                `},       
                },
                {
                    Name:"latex",
                    Title:"Latex",
                    Img:{
                        Kind:"text",
                        Value:"∰"
                    }, 
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        const selection = cm.getSelection();
            
                        cm.replaceSelection("🥚" + selection + "🐤");
            
                        if (selection === "") {
                            cm.setCursor(cursor.line, cursor.ch + 1);
                        }
                    }  
                },
                 {
                    Name:"fullscreen",
                    Title:"Full screen",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M0 0h24v24H0z" fill="none"/>
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                    </svg>
                `},
                    Func:()=>{
                        if (!document.fullscreenElement) {
                            this.editorWrapper.requestFullscreen()
                            .then((me)=>{
                                console.log(me);
                            })
                            .catch((e)=>{
                                console.log(e);
                            });
                        } else {
                          if (document.exitFullscreen) {
                            document.exitFullscreen(); 
                          }
                        }
                        this.codeMirrorTarget.focus();
                    }
                },
                
                {
                    Name:"search",
                    Title:"Search",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/>
                    </svg>
                `},
                    Func:()=>{
                        this.codeMirrorTarget.execCommand("find");
                    }
                },
                
                {
                    Name:"nuevaLinea",
                    Title:"New line",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"/>
                    <path d="M0 0h24v24H0z" fill="none"/>
                    </svg>
                `},
                    Func:()=> {
                        const cm        = this.codeMirrorTarget;
                        const cursor    = cm.getCursor();
                        let put="💥\r\n";
                        if(cursor.ch != 0){
                            put="\r\n"+put;
                        }
                        cm.replaceSelection(put);
                        this.codeMirrorTarget.focus();
                    }
                },
                {
                    Name:"withoutPreview",
                    Title:"Watch only preview",
                    Img:{
                        Kind:"svg",
                        Value:`
                    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
                        <path d="M16 6c-6.979 0-13.028 4.064-16 10 2.972 5.936 9.021 10 16 10s13.027-4.064 16-10c-2.972-5.936-9.021-10-16-10zM23.889 11.303c1.88 1.199 3.473 2.805 4.67 4.697-1.197 1.891-2.79 3.498-4.67 4.697-2.362 1.507-5.090 2.303-7.889 2.303s-5.527-0.796-7.889-2.303c-1.88-1.199-3.473-2.805-4.67-4.697 1.197-1.891 2.79-3.498 4.67-4.697 0.122-0.078 0.246-0.154 0.371-0.228-0.311 0.854-0.482 1.776-0.482 2.737 0 4.418 3.582 8 8 8s8-3.582 8-8c0-0.962-0.17-1.883-0.482-2.737 0.124 0.074 0.248 0.15 0.371 0.228v0zM16 13c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"></path>
                    </svg>
                `},
                    Func:()=>{
                        const preview=this.editorWrapper.querySelector(".yaposi-preview");
                        const cmWrapper=this.editorWrapper.querySelector(".codeMirrorWrapper");
                        const li=this.editorWrapper.querySelector(`.yaposi-toolbar li[data-name="withoutPreview"]`);
                        const img=li.querySelector(".img");
                         switch (preview.dataset.state){
                             case "both":
                                cmWrapper.style.display="none";
                                preview.dataset.state="preview";
                                this.editorWrapper.classList.add("modePreview");
                                li.setAttribute("title","Watch only editor");
                                img.innerHTML=`
                            <path d="M27 0h-24c-1.65 0-3 1.35-3 3v26c0 1.65 1.35 3 3 3h24c1.65 0 3-1.35 3-3v-26c0-1.65-1.35-3-3-3zM26 28h-22v-24h22v24zM8 14h14v2h-14zM8 18h14v2h-14zM8 22h14v2h-14zM8 10h14v2h-14z"/>
                            `;
                                break;
                             case "preview":
                                cmWrapper.style.display="flex";
                                preview.style.display="none";
                                preview.dataset.state="editor";
                                this.editorWrapper.classList.remove("modePreview");
                                this.editorWrapper.classList.add("modeEditor");
                                li.setAttribute("title","Watch both, editor and preview");
                                img.innerHTML=`
                            <path d="M20 8v-8h-14l-6 6v18h12v8h20v-24h-12zM6 2.828v3.172h-3.172l3.172-3.172zM2 22v-14h6v-6h10v6l-6 6v8h-10zM18 10.828v3.172h-3.172l3.172-3.172zM30 30h-16v-14h6v-6h10v20z"/>
                            `;
                                break;
                             case "editor":
                                preview.style.display="block";
                                preview.dataset.state="both";
                                this.editorWrapper.classList.remove("modeEditor");
                                li.setAttribute("title","Watch only preview");
                                img.innerHTML=`
                            <path d="M16 6c-6.979 0-13.028 4.064-16 10 2.972 5.936 9.021 10 16 10s13.027-4.064 16-10c-2.972-5.936-9.021-10-16-10zM23.889 11.303c1.88 1.199 3.473 2.805 4.67 4.697-1.197 1.891-2.79 3.498-4.67 4.697-2.362 1.507-5.090 2.303-7.889 2.303s-5.527-0.796-7.889-2.303c-1.88-1.199-3.473-2.805-4.67-4.697 1.197-1.891 2.79-3.498 4.67-4.697 0.122-0.078 0.246-0.154 0.371-0.228-0.311 0.854-0.482 1.776-0.482 2.737 0 4.418 3.582 8 8 8s8-3.582 8-8c0-0.962-0.17-1.883-0.482-2.737 0.124 0.074 0.248 0.15 0.371 0.228v0zM16 13c0 1.657-1.343 3-3 3s-3-1.343-3-3 1.343-3 3-3 3 1.343 3 3z"></path>
                            `;
                                break;
                         }
                         this.codeMirrorTarget.refresh(); 
                    }
                },
            ]
        }
    }

    class Img{
        constructor(codeMirrorTarget){
            this.insert=this.insert.bind(this);
            this.hide=this.hide.bind(this);
            this.show=this.show.bind(this);
            this.handle=this.handle.bind(this);
            this.dragover=this.dragover.bind(this);
            this.dragleave=this.dragleave.bind(this);
            this.drop=this.drop.bind(this);
            this.putFile=this.putFile.bind(this);
            this.uploadFile=this.uploadFile.bind(this);
            this.generateFetch=this.generateFetch.bind(this);
            this.addURL=this.addURL.bind(this);
            this.uploadImg=false;
            this.urlToUpload="";
            this.insertBtn="";
            this.codeMirrorTarget=codeMirrorTarget;
            this.droppperWrapper="";
            this.stateWrapper="";
            this.stateUp="";
            this.stateCross="";
            this.imgPreviewWrapper="";
            this.droppperImg="";
            this.me="";
            this.imgURL="";
            this.img="";
        }
        getNumber(){//see where image number is starting
            const regex = /\[\d{1,3}]: http/g;//macth all "[number]: http"
            const regexN = /\d{1,3}/g;//macth all numbers from 1 digit to there
            const cmValueRaw = this.codeMirrorTarget.getValue();
            const firtMatch = cmValueRaw.match(regex);//macth all "[number]: http"
            if(firtMatch==null){//no image inside
              return 0
            }
            const secondMatch = firtMatch.join("").match(regexN);//macth all numbers from 1 digit to there
            return  Math.max(...secondMatch) + 1  //spread operator ....
        }
        create() {
            let html = `
        <div class="yaposi-img">
            <div class="yaposi-img-dropper"> 
                <input type="file" accept="image/*">
                <svg class="yaposi-upload" viewBox="0 0 24 24">
                  <path d="M0 0h24v24H0z" fill="none"/>
                  <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
                </svg>
            </div>
            <div class="yaposi-img-state">
                <svg class="yaposi-img-uploading" class="yaposi-spinning" viewBox="25 25 50 50" >
                    <circle class="loader-path" cx="50" cy="50" r="20" fill="none" stroke="#70c542" stroke-width="10" />
                </svg>
                <svg class="yaposi-img-cross" viewBox="0 0 32 32">
                   <path d="M31.708 25.708c-0-0-0-0-0-0l-9.708-9.708 9.708-9.708c0-0 0-0 0-0 0.105-0.105 0.18-0.227 0.229-0.357 0.133-0.356 0.057-0.771-0.229-1.057l-4.586-4.586c-0.286-0.286-0.702-0.361-1.057-0.229-0.13 0.048-0.252 0.124-0.357 0.228 0 0-0 0-0 0l-9.708 9.708-9.708-9.708c-0-0-0-0-0-0-0.105-0.104-0.227-0.18-0.357-0.228-0.356-0.133-0.771-0.057-1.057 0.229l-4.586 4.586c-0.286 0.286-0.361 0.702-0.229 1.057 0.049 0.13 0.124 0.252 0.229 0.357 0 0 0 0 0 0l9.708 9.708-9.708 9.708c-0 0-0 0-0 0-0.104 0.105-0.18 0.227-0.229 0.357-0.133 0.355-0.057 0.771 0.229 1.057l4.586 4.586c0.286 0.286 0.702 0.361 1.057 0.229 0.13-0.049 0.252-0.124 0.357-0.229 0-0 0-0 0-0l9.708-9.708 9.708 9.708c0 0 0 0 0 0 0.105 0.105 0.227 0.18 0.357 0.229 0.356 0.133 0.771 0.057 1.057-0.229l4.586-4.586c0.286-0.286 0.362-0.702 0.229-1.057-0.049-0.13-0.124-0.252-0.229-0.357z" fill="red"/>
                </svg>
            </div>
            <div class="yaposi-img-preview">
                <img src="">
            </div>
            <div class="yaposi-img-actions">
                <button class="cancel">Cancel</button>
                <button class="insert">Insert</button>
            </div>
        </div>
    `;
            let temp=document.createElement("template");
            temp.innerHTML=html;
            let wrapper=temp.content.querySelector(".yaposi-img");
            this.droppperWrapper=wrapper.querySelector(".yaposi-img-dropper");
            this.droppperImg=this.droppperWrapper.querySelector(".yaposi-upload");
            this.me=wrapper;

            this.droppperWrapper.addEventListener("dragover",this.dragover);
            this.droppperWrapper.addEventListener("dragleave",this.dragleave);
            this.droppperWrapper.addEventListener("drop",this.drop);

            let input=this.droppperWrapper.querySelector("input");
            input.addEventListener("change",this.putFile);

            this.droppperImg.addEventListener("click",()=>{input.click();});
            let cancel=this.me.querySelector(".yaposi-img-actions .cancel");
            cancel.addEventListener("click",this.hide);

            this.insertBtn=wrapper.querySelector(".insert");
            this.insertBtn.addEventListener("click",this.insert);
            
            this.stateWrapper=wrapper.querySelector(".yaposi-img-state");
            this.stateUp=this.stateWrapper.querySelector(".yaposi-img-uploading");
            this.stateCross=this.stateWrapper.querySelector(".yaposi-img-cross");

            this.imgPreviewWrapper=wrapper.querySelector(".yaposi-img-preview");
            return wrapper
        }
        handle(){
            let cm        = this.codeMirrorTarget;
            let selection = cm.getSelection();
            if (selection=="" && this.uploadImg){
                this.show(); //there is implemented how to upload the image, use it if you know to do it
                return
            }
            if(selection.includes("http")){
                this.addURL(selection);
                return
            }
            console.log("Your selection must include an url");
        }
        show() {
            this.me.style.display="grid";
            setTimeout(()=>{this.me.style.transform="translate(-50%,-50%)";},0);
        }
        addURL(url){
            const number = this.getNumber();
            let cursor    = this.codeMirrorTarget.getCursor();
            let put=`![Image ${number}][${number}]\n`;

            //check if cursor, in principal editor, it's at the beginning, if not it jumps to new line.
            if (cursor.ch !== 0) {
                put = "\r\n\r\n" + put;
            }
            this.codeMirrorTarget.replaceSelection(put);

            let before=this.codeMirrorTarget.getValue();
            before+=`\r\n[${number}]: ${url} "random title" \n`;
            this.codeMirrorTarget.setValue(before);
            this.counting++;
        }
        async insert(){
            await this.uploadFile();
            const urlImg=this.imgURL;
            if(urlImg==""){
                console.log("No URL");
                return
            }
            this.addURL(urlImg);
            this.hide();
        }
        hide(){
            this.imgURL="";
            this.me.style.transform="translate(-50%,-730px)";
            this.me.addEventListener("transitionend",()=>{this.me.style.display="none";},{once:true});

            this.imgPreviewWrapper.style.display="none";
            this.droppperWrapper.style.display="flex";
            this.insertBtn.style.visibility="hidden";
            this.stateWrapper.style.display="none";
            this.stateUp.style.display="flex";
            this.stateCross.style.display="none";
        }
        dragover(e){
            e.preventDefault();e.stopPropagation();
            e.dataTransfer.dropEffect='copy';
            this.droppperImg.classList.add("dragover");
            this.droppperWrapper.classList.add("dragover");
        }
        dragleave(e){
            e.preventDefault();e.stopPropagation();
            this.droppperImg.classList.remove("dragover");
            this.droppperWrapper.classList.remove("dragover");
        }
        drop(e){
            e.preventDefault();e.stopPropagation();
            this.file=e.dataTransfer.files[0];
            this.droppperImg.classList.remove("dragover");
            this.droppperWrapper.classList.remove("dragover");
            this.prepareImg();

        }
        putFile(e){
            e.preventDefault();e.stopPropagation();
            this.file=e.currentTarget.files[0];
            this.prepareImg();
        }
        prepareImg(){
            let img=this.imgPreviewWrapper.querySelector("img");
            img.onload=()=>{
                this.imgPreviewWrapper.style.display="flex";
                this.droppperWrapper.style.display="none";
                this.insertBtn.style.visibility="visible";
            },{once:true};
            img.onerror=(e)=>{
                console.log(e);
            },{once:true};
            img.src=window.URL.createObjectURL(this.file);
        }
        generateFetch(img){//this fits my needs, you should change it by your needs :D.
            const body= new FormData();
            body.append("c","1");
            body.append("img",img);
            return body
        }
        async uploadFile(){
            this.imgPreviewWrapper.style.display="none";
            this.insertBtn.style.visibility="hidden";
            this.stateWrapper.style.display="flex";
            this.stateUp.style.display="flex";
            
            const body = this.generateFetch(this.file);
            await fetch(this.urlToUpload,{credentials:"include",method:"post",body:body})
            .then((resp)=>{
                if(resp.status==200){
                    return resp.text()
                }else{
                    //handle the error
                    return Promise.reject("server")
                }
            })
            .then((url)=>{
                this.imgURL=url;
            })
            .catch((error)=>{
                this.stateCross.style.display="flex";
                this.stateUp.style.display="none";
                if(error=="server"){
                    return
                }
                //handle the error
                console.log(error);
            });
        }
    }

    class Table{
        constructor(codeMirrorTarget){
            this.insert=this.insert.bind(this);
            this.show=this.show.bind(this);
            this.hide=this.hide.bind(this);
            this.me="";
            this.codeMirrorTarget=codeMirrorTarget;
            this.cols="";
            this.rows="";
            this.valueRandom=Math.floor((Math.random() * 10000) + 1);//this fixes a bug when two editor are created, as input with name yaposi-alineation, get override the default 
            
            this.create();
        }
        create() {
            let html = `
            <div class="yaposi_Tb">
                <div class="yaposi_Tb-number">
                    <h3>Cells</h3>
                    <ul>
                        <li><h2>Rows</h2><input type="number" value="2" min="1"></li>
                        <li><h2>Columns</h2><input type="number" value="2" min="1"></li>
                    </ul>
                </div>
                <div class="yaposi_Tb-alineation">
                    <h3>Alignment</h3>
                    <ul>
                        <li><label>Default </label><input type="radio" name="yaposi-alineation${this.valueRandom}" value="default" checked></li>
                        <li><label>left </label><input type="radio" name="yaposi-alineation${this.valueRandom}" value="left"></li>
                        <li><label>center </label><input type="radio" name="yaposi-alineation${this.valueRandom}" value="center"></li>
                        <li><label>right </label><input type="radio" name="yaposi-alineation${this.valueRandom}" value="right"></li>
                    </ul>
                </div>
                <div class="yaposi_Tb-actions">
                    <button class="cancel">Cancelar</button>
                    <button class="insert">Insert</button>
                </div>
            </div>
        `;
            let temp=document.createElement("template");
            temp.innerHTML=html;
            let me=temp.content.querySelector(".yaposi_Tb");
            let insert=me.querySelector(".insert");
            insert.addEventListener("click",this.insert);
            let cancel=me.querySelector(".cancel");
            cancel.addEventListener("click",this.hide);

            let numbers=me.querySelectorAll(".yaposi_Tb-number li input");
            this.cols=numbers[0];
            this.rows=numbers[1];
            this.me=me;
            return me
        }
        hide(){
            this.me.addEventListener("transitionend",()=>{
                this.me.style.display="none";
            },{once:true});
            this.me.style.transform="translate(-50%,-730px)";
        }
        show() {
            this.me.style.display="flex";
            setTimeout(()=>{this.me.style.transform="translate(-50%,-50%)";},0);
        }
        insert(){
            this.hide();
            let rows=parseInt(this.rows.value);
            let colums=parseInt(this.cols.value);
            let alineation=this.me.querySelector(`.yaposi_Tb-alineation input:checked`).value;
            let putInside="---";
            switch (alineation){
                case "left":
                    putInside=":---";
                    break;
                case "right":
                    putInside="---:";
                    break;
                case "center":
                    putInside=":---:";
                    break;
            }
            let putAlineation="";
            let putAnyWhereElse="|";
            for(let i=0;i<colums;i++){
                putAlineation+="|"+putInside;
                putAnyWhereElse+="   |";
            }
            putAlineation+="|";
            let putGeneral=putAnyWhereElse+"\r\n"+putAlineation;
            for(let i=1;i<rows;i++){
                putGeneral+="\r\n"+putAnyWhereElse;
            }

            //check if cursor, in principal editor, it's at the beginning, if does it jumps to new line.
            let cursor    = this.codeMirrorTarget.getCursor();
            if (cursor.ch !== 0) {
                putGeneral = "\r\n\r\n" + putGeneral;
            }
            this.codeMirrorTarget.replaceSelection(putGeneral);
        }
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Utility function that allows modes to be combined. The mode given
    // as the base argument takes care of most of the normal mode
    // functionality, but a second (typically simple) mode is used, which
    // can override the style of text. Both modes get to parse all of the
    // text, but when both assign a non-null style to a piece of code, the
    // overlay wins, unless the combine argument was true and not overridden,
    // or state.overlay.combineTokens was true, in which case the styles are
    // combined.

    function ModeOverlay(CodeMirror) {
    CodeMirror.overlayMode = function(base, overlay, combine) {
      return {
        startState: function() {
          return {
            base: CodeMirror.startState(base),
            overlay: CodeMirror.startState(overlay),
            basePos: 0, baseCur: null,
            overlayPos: 0, overlayCur: null,
            streamSeen: null
          };
        },
        copyState: function(state) {
          return {
            base: CodeMirror.copyState(base, state.base),
            overlay: CodeMirror.copyState(overlay, state.overlay),
            basePos: state.basePos, baseCur: null,
            overlayPos: state.overlayPos, overlayCur: null
          };
        },

        token: function(stream, state) {
          if (stream != state.streamSeen ||
              Math.min(state.basePos, state.overlayPos) < stream.start) {
            state.streamSeen = stream;
            state.basePos = state.overlayPos = stream.start;
          }

          if (stream.start == state.basePos) {
            state.baseCur = base.token(stream, state.base);
            state.basePos = stream.pos;
          }
          if (stream.start == state.overlayPos) {
            stream.pos = stream.start;
            state.overlayCur = overlay.token(stream, state.overlay);
            state.overlayPos = stream.pos;
          }
          stream.pos = Math.min(state.basePos, state.overlayPos);

          // state.overlay.combineTokens always takes precedence over combine,
          // unless set to null
          if (state.overlayCur == null) return state.baseCur;
          else if (state.baseCur != null &&
                   state.overlay.combineTokens ||
                   combine && state.overlay.combineTokens == null)
            return state.baseCur + " " + state.overlayCur;
          else return state.overlayCur;
        },

        indent: base.indent && function(state, textAfter, line) {
          return base.indent(state.base, textAfter, line);
        },
        electricChars: base.electricChars,

        innerMode: function(state) { return {state: state.base, mode: base}; },

        blankLine: function(state) {
          var baseToken, overlayToken;
          if (base.blankLine) baseToken = base.blankLine(state.base);
          if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);

          return overlayToken == null ?
            baseToken :
            (combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken);
        }
      };
    };

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function ModeSimple(CodeMirror) {
      CodeMirror.defineSimpleMode = function(name, states) {
        CodeMirror.defineMode(name, function(config) {
          return CodeMirror.simpleMode(config, states);
        });
      };

      CodeMirror.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = false;
        for (var state in states) if (state != meta && states.hasOwnProperty(state)) {
          var list = states_[state] = [], orig = states[state];
          for (var i = 0; i < orig.length; i++) {
            var data = orig[i];
            list.push(new Rule(data, states));
            if (data.indent || data.dedent) hasIndentation = true;
          }
        }
        var mode = {
          startState: function() {
            return {state: "start", pending: null,
                    local: null, localState: null,
                    indent: hasIndentation ? [] : null};
          },
          copyState: function(state) {
            var s = {state: state.state, pending: state.pending,
                     local: state.local, localState: null,
                     indent: state.indent && state.indent.slice(0)};
            if (state.localState)
              s.localState = CodeMirror.copyState(state.local.mode, state.localState);
            if (state.stack)
              s.stack = state.stack.slice(0);
            for (var pers = state.persistentStates; pers; pers = pers.next)
              s.persistentStates = {mode: pers.mode,
                                    spec: pers.spec,
                                    state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                                    next: s.persistentStates};
            return s;
          },
          token: tokenFunction(states_, config),
          innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },
          indent: indentFunction(states_, meta)
        };
        if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
          mode[prop] = meta[prop];
        return mode;
      };

      function ensureState(states, name) {
        if (!states.hasOwnProperty(name))
          throw new Error("Undefined state " + name + " in simple mode");
      }

      function toRegex(val, caret) {
        if (!val) return /(?:)/;
        var flags = "";
        if (val instanceof RegExp) {
          if (val.ignoreCase) flags = "i";
          val = val.source;
        } else {
          val = String(val);
        }
        return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
      }

      function asToken(val) {
        if (!val) return null;
        if (val.apply) return val
        if (typeof val == "string") return val.replace(/\./g, " ");
        var result = [];
        for (var i = 0; i < val.length; i++)
          result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
      }

      function Rule(data, states) {
        if (data.next || data.push) ensureState(states, data.next || data.push);
        this.regex = toRegex(data.regex);
        this.token = asToken(data.token);
        this.data = data;
      }

      function tokenFunction(states, config) {
        return function(stream, state) {
          if (state.pending) {
            var pend = state.pending.shift();
            if (state.pending.length == 0) state.pending = null;
            stream.pos += pend.text.length;
            return pend.token;
          }

          if (state.local) {
            if (state.local.end && stream.match(state.local.end)) {
              var tok = state.local.endToken || null;
              state.local = state.localState = null;
              return tok;
            } else {
              var tok = state.local.mode.token(stream, state.localState), m;
              if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
                stream.pos = stream.start + m.index;
              return tok;
            }
          }

          var curState = states[state.state];
          for (var i = 0; i < curState.length; i++) {
            var rule = curState[i];
            var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
            if (matches) {
              if (rule.data.next) {
                state.state = rule.data.next;
              } else if (rule.data.push) {
                (state.stack || (state.stack = [])).push(state.state);
                state.state = rule.data.push;
              } else if (rule.data.pop && state.stack && state.stack.length) {
                state.state = state.stack.pop();
              }

              if (rule.data.mode)
                enterLocalMode(config, state, rule.data.mode, rule.token);
              if (rule.data.indent)
                state.indent.push(stream.indentation() + config.indentUnit);
              if (rule.data.dedent)
                state.indent.pop();
              var token = rule.token;
              if (token && token.apply) token = token(matches);
              if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                state.pending = [];
                for (var j = 2; j < matches.length; j++)
                  if (matches[j])
                    state.pending.push({text: matches[j], token: rule.token[j - 1]});
                stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                return token[0];
              } else if (token && token.join) {
                return token[0];
              } else {
                return token;
              }
            }
          }
          stream.next();
          return null;
        };
      }

      function cmp(a, b) {
        if (a === b) return true;
        if (!a || typeof a != "object" || !b || typeof b != "object") return false;
        var props = 0;
        for (var prop in a) if (a.hasOwnProperty(prop)) {
          if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
          props++;
        }
        for (var prop in b) if (b.hasOwnProperty(prop)) props--;
        return props == 0;
      }

      function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)
          if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
        var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);
        var lState = pers ? pers.state : CodeMirror.startState(mode);
        if (spec.persistent && !pers)
          state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};

        state.localState = lState;
        state.local = {mode: mode,
                       end: spec.end && toRegex(spec.end),
                       endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
                       endToken: token && token.join ? token[token.length - 1] : token};
      }

      function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;
      }

      function indentFunction(states, meta) {
        return function(state, textAfter, line) {
          if (state.local && state.local.mode.indent)
            return state.local.mode.indent(state.localState, textAfter, line);
          if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)
            return CodeMirror.Pass;

          var pos = state.indent.length - 1, rules = states[state.state];
          scan: for (;;) {
            for (var i = 0; i < rules.length; i++) {
              var rule = rules[i];
              if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                var m = rule.regex.exec(textAfter);
                if (m && m[0]) {
                  pos--;
                  if (rule.next || rule.push) rules = states[rule.next || rule.push];
                  textAfter = textAfter.slice(m[0].length);
                  continue scan;
                }
              }
            }
            break;
          }
          return pos < 0 ? 0 : state.indent[pos];
        };
      }
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function ModeMultiplex(CodeMirror) {
    CodeMirror.multiplexingMode = function(outer /*, others */) {
      // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects
      var others = Array.prototype.slice.call(arguments, 1);

      function indexOf(string, pattern, from, returnEnd) {
        if (typeof pattern == "string") {
          var found = string.indexOf(pattern, from);
          return returnEnd && found > -1 ? found + pattern.length : found;
        }
        var m = pattern.exec(from ? string.slice(from) : string);
        return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;
      }

      return {
        startState: function() {
          return {
            outer: CodeMirror.startState(outer),
            innerActive: null,
            inner: null
          };
        },

        copyState: function(state) {
          return {
            outer: CodeMirror.copyState(outer, state.outer),
            innerActive: state.innerActive,
            inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)
          };
        },

        token: function(stream, state) {
          if (!state.innerActive) {
            var cutOff = Infinity, oldContent = stream.string;
            for (var i = 0; i < others.length; ++i) {
              var other = others[i];
              var found = indexOf(oldContent, other.open, stream.pos);
              if (found == stream.pos) {
                if (!other.parseDelimiters) stream.match(other.open);
                state.innerActive = other;

                // Get the outer indent, making sure to handle CodeMirror.Pass
                var outerIndent = 0;
                if (outer.indent) {
                  var possibleOuterIndent = outer.indent(state.outer, "", "");
                  if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;
                }

                state.inner = CodeMirror.startState(other.mode, outerIndent);
                return other.delimStyle && (other.delimStyle + " " + other.delimStyle + "-open");
              } else if (found != -1 && found < cutOff) {
                cutOff = found;
              }
            }
            if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
            var outerToken = outer.token(stream, state.outer);
            if (cutOff != Infinity) stream.string = oldContent;
            return outerToken;
          } else {
            var curInner = state.innerActive, oldContent = stream.string;
            if (!curInner.close && stream.sol()) {
              state.innerActive = state.inner = null;
              return this.token(stream, state);
            }
            var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;
            if (found == stream.pos && !curInner.parseDelimiters) {
              stream.match(curInner.close);
              state.innerActive = state.inner = null;
              return curInner.delimStyle && (curInner.delimStyle + " " + curInner.delimStyle + "-close");
            }
            if (found > -1) stream.string = oldContent.slice(0, found);
            var innerToken = curInner.mode.token(stream, state.inner);
            if (found > -1) stream.string = oldContent;

            if (found == stream.pos && curInner.parseDelimiters)
              state.innerActive = state.inner = null;

            if (curInner.innerStyle) {
              if (innerToken) innerToken = innerToken + " " + curInner.innerStyle;
              else innerToken = curInner.innerStyle;
            }

            return innerToken;
          }
        },

        indent: function(state, textAfter, line) {
          var mode = state.innerActive ? state.innerActive.mode : outer;
          if (!mode.indent) return CodeMirror.Pass;
          return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);
        },

        blankLine: function(state) {
          var mode = state.innerActive ? state.innerActive.mode : outer;
          if (mode.blankLine) {
            mode.blankLine(state.innerActive ? state.inner : state.outer);
          }
          if (!state.innerActive) {
            for (var i = 0; i < others.length; ++i) {
              var other = others[i];
              if (other.open === "\n") {
                state.innerActive = other;
                state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "", "") : 0);
              }
            }
          } else if (state.innerActive.close === "\n") {
            state.innerActive = state.inner = null;
          }
        },

        electricChars: outer.electricChars,

        innerMode: function(state) {
          return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};
        }
      };
    };

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Highlighting text that matches the selection
    //
    // Defines an option highlightSelectionMatches, which, when enabled,
    // will style strings that match the selection throughout the
    // document.
    //
    // The option can be set to true to simply enable it, or to a
    // {minChars, style, wordsOnly, showToken, delay} object to explicitly
    // configure it. minChars is the minimum amount of characters that should be
    // selected for the behavior to occur, and style is the token style to
    // apply to the matches. This will be prefixed by "cm-" to create an
    // actual CSS class name. If wordsOnly is enabled, the matches will be
    // highlighted only if the selected text is a word. showToken, when enabled,
    // will cause the current token to be highlighted when nothing is selected.
    // delay is used to specify how much time to wait, in milliseconds, before
    // highlighting the matches. If annotateScrollbar is enabled, the occurences
    // will be highlighted on the scrollbar via the matchesonscrollbar addon.

    function SearchMatchHighlighter(CodeMirror) {
      var defaults = {
        style: "matchhighlight",
        minChars: 2,
        delay: 100,
        wordsOnly: false,
        annotateScrollbar: false,
        showToken: false,
        trim: true
      };

      function State(options) {
        this.options = {};
        for (var name in defaults)
          this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name];
        this.overlay = this.timeout = null;
        this.matchesonscroll = null;
        this.active = false;
      }

      CodeMirror.defineOption("highlightSelectionMatches", false, function(cm, val, old) {
        if (old && old != CodeMirror.Init) {
          removeOverlay(cm);
          clearTimeout(cm.state.matchHighlighter.timeout);
          cm.state.matchHighlighter = null;
          cm.off("cursorActivity", cursorActivity);
          cm.off("focus", onFocus);
        }
        if (val) {
          var state = cm.state.matchHighlighter = new State(val);
          if (cm.hasFocus()) {
            state.active = true;
            highlightMatches(cm);
          } else {
            cm.on("focus", onFocus);
          }
          cm.on("cursorActivity", cursorActivity);
        }
      });

      function cursorActivity(cm) {
        var state = cm.state.matchHighlighter;
        if (state.active || cm.hasFocus()) scheduleHighlight(cm, state);
      }

      function onFocus(cm) {
        var state = cm.state.matchHighlighter;
        if (!state.active) {
          state.active = true;
          scheduleHighlight(cm, state);
        }
      }

      function scheduleHighlight(cm, state) {
        clearTimeout(state.timeout);
        state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);
      }

      function addOverlay(cm, query, hasBoundary, style) {
        var state = cm.state.matchHighlighter;
        cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));
        if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {
          var searchFor = hasBoundary ? new RegExp("\\b" + query.replace(/[\\\[.+*?(){|^$]/g, "\\$&") + "\\b") : query;
          state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,
            {className: "CodeMirror-selection-highlight-scrollbar"});
        }
      }

      function removeOverlay(cm) {
        var state = cm.state.matchHighlighter;
        if (state.overlay) {
          cm.removeOverlay(state.overlay);
          state.overlay = null;
          if (state.matchesonscroll) {
            state.matchesonscroll.clear();
            state.matchesonscroll = null;
          }
        }
      }

      function highlightMatches(cm) {
        cm.operation(function() {
          var state = cm.state.matchHighlighter;
          removeOverlay(cm);
          if (!cm.somethingSelected() && state.options.showToken) {
            var re = state.options.showToken === true ? /[\w$]/ : state.options.showToken;
            var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;
            while (start && re.test(line.charAt(start - 1))) --start;
            while (end < line.length && re.test(line.charAt(end))) ++end;
            if (start < end)
              addOverlay(cm, line.slice(start, end), re, state.options.style);
            return;
          }
          var from = cm.getCursor("from"), to = cm.getCursor("to");
          if (from.line != to.line) return;
          if (state.options.wordsOnly && !isWord(cm, from, to)) return;
          var selection = cm.getRange(from, to);
          if (state.options.trim) selection = selection.replace(/^\s+|\s+$/g, "");
          if (selection.length >= state.options.minChars)
            addOverlay(cm, selection, false, state.options.style);
        });
      }

      function isWord(cm, from, to) {
        var str = cm.getRange(from, to);
        if (str.match(/^\w+$/) !== null) {
            if (from.ch > 0) {
                var pos = {line: from.line, ch: from.ch - 1};
                var chr = cm.getRange(pos, from);
                if (chr.match(/\W/) === null) return false;
            }
            if (to.ch < cm.getLine(from.line).length) {
                var pos = {line: to.line, ch: to.ch + 1};
                var chr = cm.getRange(to, pos);
                if (chr.match(/\W/) === null) return false;
            }
            return true;
        } else return false;
      }

      function boundariesAround(stream, re) {
        return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&
          (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));
      }

      function makeOverlay(query, hasBoundary, style) {
        return {token: function(stream) {
          if (stream.match(query) &&
              (!hasBoundary || boundariesAround(stream, hasBoundary)))
            return style;
          stream.next();
          stream.skipTo(query.charAt(0)) || stream.skipToEnd();
        }};
      }
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function SearchMatchesOnScrollbar(CodeMirror) {

      CodeMirror.defineExtension("showMatchesOnScrollbar", function(query, caseFold, options) {
        if (typeof options == "string") options = {className: options};
        if (!options) options = {};
        return new SearchAnnotation(this, query, caseFold, options);
      });

      function SearchAnnotation(cm, query, caseFold, options) {
        this.cm = cm;
        this.options = options;
        var annotateOptions = {listenForChanges: false};
        for (var prop in options) annotateOptions[prop] = options[prop];
        if (!annotateOptions.className) annotateOptions.className = "CodeMirror-search-match";
        this.annotation = cm.annotateScrollbar(annotateOptions);
        this.query = query;
        this.caseFold = caseFold;
        this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};
        this.matches = [];
        this.update = null;

        this.findMatches();
        this.annotation.update(this.matches);

        var self = this;
        cm.on("change", this.changeHandler = function(_cm, change) { self.onChange(change); });
      }

      var MAX_MATCHES = 1000;

      SearchAnnotation.prototype.findMatches = function() {
        if (!this.gap) return;
        for (var i = 0; i < this.matches.length; i++) {
          var match = this.matches[i];
          if (match.from.line >= this.gap.to) break;
          if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);
        }
        var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);
        var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;
        while (cursor.findNext()) {
          var match = {from: cursor.from(), to: cursor.to()};
          if (match.from.line >= this.gap.to) break;
          this.matches.splice(i++, 0, match);
          if (this.matches.length > maxMatches) break;
        }
        this.gap = null;
      };

      function offsetLine(line, changeStart, sizeChange) {
        if (line <= changeStart) return line;
        return Math.max(changeStart, line + sizeChange);
      }

      SearchAnnotation.prototype.onChange = function(change) {
        var startLine = change.from.line;
        var endLine = CodeMirror.changeEnd(change).line;
        var sizeChange = endLine - change.to.line;
        if (this.gap) {
          this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);
          this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);
        } else {
          this.gap = {from: change.from.line, to: endLine + 1};
        }

        if (sizeChange) for (var i = 0; i < this.matches.length; i++) {
          var match = this.matches[i];
          var newFrom = offsetLine(match.from.line, startLine, sizeChange);
          if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);
          var newTo = offsetLine(match.to.line, startLine, sizeChange);
          if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);
        }
        clearTimeout(this.update);
        var self = this;
        this.update = setTimeout(function() { self.updateAfterChange(); }, 250);
      };

      SearchAnnotation.prototype.updateAfterChange = function() {
        this.findMatches();
        this.annotation.update(this.matches);
      };

      SearchAnnotation.prototype.clear = function() {
        this.cm.off("change", this.changeHandler);
        this.annotation.clear();
      };
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Define search commands. Depends on dialog.js or another
    // implementation of the openDialog method.

    // Replace works a little oddly -- it will do the replace on the next
    // Ctrl-G (or whatever is bound to findNext) press. You prevent a
    // replace by making sure the match is no longer selected when hitting
    // Ctrl-G.

    function SearchMultiplex(CodeMirror) {
      function searchOverlay(query, caseInsensitive) {
        if (typeof query == "string")
          query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
        else if (!query.global)
          query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

        return {token: function(stream) {
          query.lastIndex = stream.pos;
          var match = query.exec(stream.string);
          if (match && match.index == stream.pos) {
            stream.pos += match[0].length || 1;
            return "searching";
          } else if (match) {
            stream.pos = match.index;
          } else {
            stream.skipToEnd();
          }
        }};
      }

      function SearchState() {
        this.posFrom = this.posTo = this.lastQuery = this.query = null;
        this.overlay = null;
      }

      function getSearchState(cm) {
        return cm.state.search || (cm.state.search = new SearchState());
      }

      function queryCaseInsensitive(query) {
        return typeof query == "string" && query == query.toLowerCase();
      }

      function getSearchCursor(cm, query, pos) {
        // Heuristic: if the query string is all lowercase, do a case insensitive search.
        return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(query), multiline: true});
      }

      function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
        cm.openDialog(text, onEnter, {
          value: deflt,
          selectValueOnOpen: true,
          closeOnEnter: false,
          onClose: function() { clearSearch(cm); },
          onKeyDown: onKeyDown
        });
      }

      function dialog(cm, text, shortText, deflt, f) {
        if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
        else f(prompt(shortText, deflt));
      }

      function confirmDialog(cm, text, shortText, fs) {
        if (cm.openConfirm) cm.openConfirm(text, fs);
        else if (confirm(shortText)) fs[0]();
      }

      function parseString(string) {
        return string.replace(/\\(.)/g, function(_, ch) {
          if (ch == "n") return "\n"
          if (ch == "r") return "\r"
          return ch
        })
      }

      function parseQuery(query) {
        var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
        if (isRE) {
          try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }
          catch(e) {} // Not a regular expression after all, do a string search
        } else {
          query = parseString(query);
        }
        if (typeof query == "string" ? query == "" : query.test(""))
          query = /x^/;
        return query;
      }

      function startSearch(cm, state, query) {
        state.queryText = query;
        state.query = parseQuery(query);
        cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
        cm.addOverlay(state.overlay);
        if (cm.showMatchesOnScrollbar) {
          if (state.annotate) { state.annotate.clear(); state.annotate = null; }
          state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
        }
      }

      function doSearch(cm, rev, persistent, immediate) {
        var state = getSearchState(cm);
        if (state.query) return findNext(cm, rev);
        var q = cm.getSelection() || state.lastQuery;
        if (q instanceof RegExp && q.source == "x^") q = null;
        if (persistent && cm.openDialog) {
          var hiding = null;
          var searchNext = function(query, event) {
            CodeMirror.e_stop(event);
            if (!query) return;
            if (query != state.queryText) {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
            }
            if (hiding) hiding.style.opacity = 1;
            findNext(cm, event.shiftKey, function(_, to) {
              var dialog;
              if (to.line < 3 && document.querySelector &&
                  (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) &&
                  dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
                (hiding = dialog).style.opacity = .4;
            });
          };
          persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {
            var keyName = CodeMirror.keyName(event);
            var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
            if (cmd == "findNext" || cmd == "findPrev" ||
              cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
              CodeMirror.e_stop(event);
              startSearch(cm, getSearchState(cm), query);
              cm.execCommand(cmd);
            } else if (cmd == "find" || cmd == "findPersistent") {
              CodeMirror.e_stop(event);
              searchNext(query, event);
            }
          });
          if (immediate && q) {
            startSearch(cm, state, q);
            findNext(cm, rev);
          }
        } else {
          dialog(cm, getQueryDialog(cm), "Search for:", q, function(query) {
            if (query && !state.query) cm.operation(function() {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
              findNext(cm, rev);
            });
          });
        }
      }

      function findNext(cm, rev, callback) {cm.operation(function() {
        var state = getSearchState(cm);
        var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
        if (!cursor.find(rev)) {
          cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
          if (!cursor.find(rev)) return;
        }
        cm.setSelection(cursor.from(), cursor.to());
        cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
        state.posFrom = cursor.from(); state.posTo = cursor.to();
        if (callback) callback(cursor.from(), cursor.to());
      });}

      function clearSearch(cm) {cm.operation(function() {
        var state = getSearchState(cm);
        state.lastQuery = state.query;
        if (!state.query) return;
        state.query = state.queryText = null;
        cm.removeOverlay(state.overlay);
        if (state.annotate) { state.annotate.clear(); state.annotate = null; }
      });}


      function getQueryDialog(cm)  {
        return '<span class="CodeMirror-search-label">' + cm.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
      }
      function getReplaceQueryDialog(cm) {
        return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
      }
      function getReplacementQueryDialog(cm) {
        return '<span class="CodeMirror-search-label">' + cm.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';
      }
      function getDoReplaceConfirm(cm) {
        return '<span class="CodeMirror-search-label">' + cm.phrase("Replace?") + '</span> <button>' + cm.phrase("Yes") + '</button> <button>' + cm.phrase("No") + '</button> <button>' + cm.phrase("All") + '</button> <button>' + cm.phrase("Stop") + '</button> ';
      }

      function replaceAll(cm, query, text) {
        cm.operation(function() {
          for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
            if (typeof query != "string") {
              var match = cm.getRange(cursor.from(), cursor.to()).match(query);
              cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
            } else cursor.replace(text);
          }
        });
      }

      function replace(cm, all) {
        if (cm.getOption("readOnly")) return;
        var query = cm.getSelection() || getSearchState(cm).lastQuery;
        var dialogText = '<span class="CodeMirror-search-label">' + (all ? cm.phrase("Replace all:") : cm.phrase("Replace:")) + '</span>';
        dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {
          if (!query) return;
          query = parseQuery(query);
          dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function(text) {
            text = parseString(text);
            if (all) {
              replaceAll(cm, query, text);
            } else {
              clearSearch(cm);
              var cursor = getSearchCursor(cm, query, cm.getCursor("from"));
              var advance = function() {
                var start = cursor.from(), match;
                if (!(match = cursor.findNext())) {
                  cursor = getSearchCursor(cm, query);
                  if (!(match = cursor.findNext()) ||
                      (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
                }
                cm.setSelection(cursor.from(), cursor.to());
                cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
                confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"),
                              [function() {doReplace(match);}, advance,
                               function() {replaceAll(cm, query, text);}]);
              };
              var doReplace = function(match) {
                cursor.replace(typeof query == "string" ? text :
                               text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
                advance();
              };
              advance();
            }
          });
        });
      }

      CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
      CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};
      CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};
      CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};
      CodeMirror.commands.findNext = doSearch;
      CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
      CodeMirror.commands.clearSearch = clearSearch;
      CodeMirror.commands.replace = replace;
      CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Searchcursor(CodeMirror) {
      function regexpFlags(regexp) {
        var flags = regexp.flags;
        return flags != null ? flags : (regexp.ignoreCase ? "i" : "")
          + (regexp.global ? "g" : "")
          + (regexp.multiline ? "m" : "")
      }

      function ensureFlags(regexp, flags) {
        var current = regexpFlags(regexp), target = current;
        for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)
          target += flags.charAt(i);
        return current == target ? regexp : new RegExp(regexp.source, target)
      }

      function maybeMultiline(regexp) {
        return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)
      }

      function searchRegexpForward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
          regexp.lastIndex = ch;
          var string = doc.getLine(line), match = regexp.exec(string);
          if (match)
            return {from: Pos(line, match.index),
                    to: Pos(line, match.index + match[0].length),
                    match: match}
        }
      }

      function searchRegexpForwardMultiline(doc, regexp, start) {
        if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)

        regexp = ensureFlags(regexp, "gm");
        var string, chunk = 1;
        for (var line = start.line, last = doc.lastLine(); line <= last;) {
          // This grows the search buffer in exponentially-sized chunks
          // between matches, so that nearby matches are fast and don't
          // require concatenating the whole document (in case we're
          // searching for something that has tons of matches), but at the
          // same time, the amount of retries is limited.
          for (var i = 0; i < chunk; i++) {
            if (line > last) break
            var curLine = doc.getLine(line++);
            string = string == null ? curLine : string + "\n" + curLine;
          }
          chunk = chunk * 2;
          regexp.lastIndex = start.ch;
          var match = regexp.exec(string);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;
            return {from: Pos(startLine, startCh),
                    to: Pos(startLine + inside.length - 1,
                            inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                    match: match}
          }
        }
      }

      function lastMatchIn(string, regexp) {
        var cutOff = 0, match;
        for (;;) {
          regexp.lastIndex = cutOff;
          var newMatch = regexp.exec(string);
          if (!newMatch) return match
          match = newMatch;
          cutOff = match.index + (match[0].length || 1);
          if (cutOff == string.length) return match
        }
      }

      function searchRegexpBackward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
          var string = doc.getLine(line);
          if (ch > -1) string = string.slice(0, ch);
          var match = lastMatchIn(string, regexp);
          if (match)
            return {from: Pos(line, match.index),
                    to: Pos(line, match.index + match[0].length),
                    match: match}
        }
      }

      function searchRegexpBackwardMultiline(doc, regexp, start) {
        regexp = ensureFlags(regexp, "gm");
        var string, chunk = 1;
        for (var line = start.line, first = doc.firstLine(); line >= first;) {
          for (var i = 0; i < chunk; i++) {
            var curLine = doc.getLine(line--);
            string = string == null ? curLine.slice(0, start.ch) : curLine + "\n" + string;
          }
          chunk *= 2;

          var match = lastMatchIn(string, regexp);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = line + before.length, startCh = before[before.length - 1].length;
            return {from: Pos(startLine, startCh),
                    to: Pos(startLine + inside.length - 1,
                            inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
                    match: match}
          }
        }
      }

      var doFold, noFold;
      if (String.prototype.normalize) {
        doFold = function(str) { return str.normalize("NFD").toLowerCase() };
        noFold = function(str) { return str.normalize("NFD") };
      } else {
        doFold = function(str) { return str.toLowerCase() };
        noFold = function(str) { return str };
      }

      // Maps a position in a case-folded line back to a position in the original line
      // (compensating for codepoints increasing in number during folding)
      function adjustPos(orig, folded, pos, foldFunc) {
        if (orig.length == folded.length) return pos
        for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {
          if (min == max) return min
          var mid = (min + max) >> 1;
          var len = foldFunc(orig.slice(0, mid)).length;
          if (len == pos) return mid
          else if (len > pos) max = mid;
          else min = mid + 1;
        }
      }

      function searchStringForward(doc, query, start, caseFold) {
        // Empty string would match anything and never progress, so we
        // define it to match nothing instead.
        if (!query.length) return null
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);

        search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
          var orig = doc.getLine(line).slice(ch), string = fold(orig);
          if (lines.length == 1) {
            var found = string.indexOf(lines[0]);
            if (found == -1) continue search
            var start = adjustPos(orig, string, found, fold) + ch;
            return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}
          } else {
            var cutFrom = string.length - lines[0].length;
            if (string.slice(cutFrom) != lines[0]) continue search
            for (var i = 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(line + i)) != lines[i]) continue search
            var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];
            if (endString.slice(0, lastLine.length) != lastLine) continue search
            return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
                    to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}
          }
        }
      }

      function searchStringBackward(doc, query, start, caseFold) {
        if (!query.length) return null
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);

        search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
          var orig = doc.getLine(line);
          if (ch > -1) orig = orig.slice(0, ch);
          var string = fold(orig);
          if (lines.length == 1) {
            var found = string.lastIndexOf(lines[0]);
            if (found == -1) continue search
            return {from: Pos(line, adjustPos(orig, string, found, fold)),
                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}
          } else {
            var lastLine = lines[lines.length - 1];
            if (string.slice(0, lastLine.length) != lastLine) continue search
            for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(start + i)) != lines[i]) continue search
            var top = doc.getLine(line + 1 - lines.length), topString = fold(top);
            if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search
            return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                    to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}
          }
        }
      }

      function SearchCursor(doc, query, pos, options) {
        this.atOccurrence = false;
        this.doc = doc;
        pos = pos ? doc.clipPos(pos) : Pos(0, 0);
        this.pos = {from: pos, to: pos};

        var caseFold;
        if (typeof options == "object") {
          caseFold = options.caseFold;
        } else { // Backwards compat for when caseFold was the 4th argument
          caseFold = options;
          options = null;
        }

        if (typeof query == "string") {
          if (caseFold == null) caseFold = false;
          this.matches = function(reverse, pos) {
            return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)
          };
        } else {
          query = ensureFlags(query, "gm");
          if (!options || options.multiline !== false)
            this.matches = function(reverse, pos) {
              return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)
            };
          else
            this.matches = function(reverse, pos) {
              return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)
            };
        }
      }

      SearchCursor.prototype = {
        findNext: function() {return this.find(false)},
        findPrevious: function() {return this.find(true)},

        find: function(reverse) {
          var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to));

          // Implements weird auto-growing behavior on null-matches for
          // backwards-compatiblity with the vim code (unfortunately)
          while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {
            if (reverse) {
              if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1);
              else if (result.from.line == this.doc.firstLine()) result = null;
              else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)));
            } else {
              if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1);
              else if (result.to.line == this.doc.lastLine()) result = null;
              else result = this.matches(reverse, Pos(result.to.line + 1, 0));
            }
          }

          if (result) {
            this.pos = result;
            this.atOccurrence = true;
            return this.pos.match || true
          } else {
            var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
            this.pos = {from: end, to: end};
            return this.atOccurrence = false
          }
        },

        from: function() {if (this.atOccurrence) return this.pos.from},
        to: function() {if (this.atOccurrence) return this.pos.to},

        replace: function(newText, origin) {
          if (!this.atOccurrence) return
          var lines = CodeMirror.splitLines(newText);
          this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
          this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                            lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
        }
      };

      CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold)
      });
      CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold)
      });

      CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
        var ranges = [];
        var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
        while (cur.findNext()) {
          if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break
          ranges.push({anchor: cur.from(), head: cur.to()});
        }
        if (ranges.length)
          this.setSelections(ranges, 0);
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Defines jumpToLine command. Uses dialog.js if present.

    function SearchJumpToLine(CodeMirror) {
      function dialog(cm, text, shortText, deflt, f) {
        if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
        else f(prompt(shortText, deflt));
      }

      function getJumpDialog(cm) {
        return cm.phrase("Jump to line:") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use line:column or scroll% syntax)") + '</span>';
      }

      function interpretLine(cm, string) {
        var num = Number(string);
        if (/^[-+]/.test(string)) return cm.getCursor().line + num
        else return num - 1
      }

      CodeMirror.commands.jumpToLine = function(cm) {
        var cur = cm.getCursor();
        dialog(cm, getJumpDialog(cm), cm.phrase("Jump to line:"), (cur.line + 1) + ":" + cur.ch, function(posStr) {
          if (!posStr) return;

          var match;
          if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), Number(match[2]));
          } else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
            var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
            if (/^[-+]/.test(match[1])) line = cur.line + line + 1;
            cm.setCursor(line - 1, cur.ch);
          } else if (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), cur.ch);
          }
        });
      };

      CodeMirror.keyMap["default"]["Alt-G"] = "jumpToLine";
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Open simple dialogs on top of an editor. Relies on dialog.css.

    let Dialog=function(CodeMirror) {
      function dialogDiv(cm, template, bottom) {
        var wrap = cm.getWrapperElement();
        var dialog;
        dialog = wrap.appendChild(document.createElement("div"));
        if (bottom)
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
        else
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";

        if (typeof template == "string") {
          dialog.innerHTML = template;
        } else { // Assuming it's a detached DOM element.
          dialog.appendChild(template);
        }
        CodeMirror.addClass(wrap, 'dialog-opened');
        return dialog;
      }

      function closeNotification(cm, newVal) {
        if (cm.state.currentNotificationClose)
          cm.state.currentNotificationClose();
        cm.state.currentNotificationClose = newVal;
      }

      CodeMirror.defineExtension("openDialog", function(template, callback, options) {
        if (!options) options = {};

        closeNotification(this, null);

        var dialog = dialogDiv(this, template, options.bottom);
        var closed = false, me = this;
        function close(newVal) {
          if (typeof newVal == 'string') {
            inp.value = newVal;
          } else {
            if (closed) return;
            closed = true;
            CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
            dialog.parentNode.removeChild(dialog);
            me.focus();

            if (options.onClose) options.onClose(dialog);
          }
        }

        var inp = dialog.getElementsByTagName("input")[0], button;
        if (inp) {
          inp.focus();

          if (options.value) {
            inp.value = options.value;
            if (options.selectValueOnOpen !== false) {
              inp.select();
            }
          }

          if (options.onInput)
            CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});
          if (options.onKeyUp)
            CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});

          CodeMirror.on(inp, "keydown", function(e) {
            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {
              inp.blur();
              CodeMirror.e_stop(e);
              close();
            }
            if (e.keyCode == 13) callback(inp.value, e);
          });

          if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);
        } else if (button = dialog.getElementsByTagName("button")[0]) {
          CodeMirror.on(button, "click", function() {
            close();
            me.focus();
          });

          if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);

          button.focus();
        }
        return close;
      });

      CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var buttons = dialog.getElementsByTagName("button");
        var closed = false, me = this, blurring = 1;
        function close() {
          if (closed) return;
          closed = true;
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
          me.focus();
        }
        buttons[0].focus();
        for (var i = 0; i < buttons.length; ++i) {
          var b = buttons[i];
          (function(callback) {
            CodeMirror.on(b, "click", function(e) {
              CodeMirror.e_preventDefault(e);
              close();
              if (callback) callback(me);
            });
          })(callbacks[i]);
          CodeMirror.on(b, "blur", function() {
            --blurring;
            setTimeout(function() { if (blurring <= 0) close(); }, 200);
          });
          CodeMirror.on(b, "focus", function() { ++blurring; });
        }
      });

      /*
       * openNotification
       * Opens a notification, that can be closed with an optional timer
       * (default 5000ms timer) and always closes on click.
       *
       * If a notification is opened while another is opened, it will close the
       * currently opened one and open the new one immediately.
       */
      CodeMirror.defineExtension("openNotification", function(template, options) {
        closeNotification(this, close);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var closed = false, doneTimer;
        var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;

        function close() {
          if (closed) return;
          closed = true;
          clearTimeout(doneTimer);
          CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');
          dialog.parentNode.removeChild(dialog);
        }

        CodeMirror.on(dialog, 'click', function(e) {
          CodeMirror.e_preventDefault(e);
          close();
        });

        if (duration)
          doneTimer = setTimeout(close, duration);

        return close;
      });
    };



    var addon = /*#__PURE__*/Object.freeze({
        ModeOverlay: ModeOverlay,
        ModeSimple: ModeSimple,
        ModeMultiplex: ModeMultiplex,
        SearchMatchHighlighter: SearchMatchHighlighter,
        SearchMatchesOnScrollbar: SearchMatchesOnScrollbar,
        SearchMultiplex: SearchMultiplex,
        Searchcursor: Searchcursor,
        SearchJumpToLine: SearchJumpToLine,
        Dialog: Dialog
    });

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function APL(CodeMirror) {
    CodeMirror.defineMode("apl", function() {
      var builtInOps = {
        ".": "innerProduct",
        "\\": "scan",
        "/": "reduce",
        "⌿": "reduce1Axis",
        "⍀": "scan1Axis",
        "¨": "each",
        "⍣": "power"
      };
      var builtInFuncs = {
        "+": ["conjugate", "add"],
        "−": ["negate", "subtract"],
        "×": ["signOf", "multiply"],
        "÷": ["reciprocal", "divide"],
        "⌈": ["ceiling", "greaterOf"],
        "⌊": ["floor", "lesserOf"],
        "∣": ["absolute", "residue"],
        "⍳": ["indexGenerate", "indexOf"],
        "?": ["roll", "deal"],
        "⋆": ["exponentiate", "toThePowerOf"],
        "⍟": ["naturalLog", "logToTheBase"],
        "○": ["piTimes", "circularFuncs"],
        "!": ["factorial", "binomial"],
        "⌹": ["matrixInverse", "matrixDivide"],
        "<": [null, "lessThan"],
        "≤": [null, "lessThanOrEqual"],
        "=": [null, "equals"],
        ">": [null, "greaterThan"],
        "≥": [null, "greaterThanOrEqual"],
        "≠": [null, "notEqual"],
        "≡": ["depth", "match"],
        "≢": [null, "notMatch"],
        "∈": ["enlist", "membership"],
        "⍷": [null, "find"],
        "∪": ["unique", "union"],
        "∩": [null, "intersection"],
        "∼": ["not", "without"],
        "∨": [null, "or"],
        "∧": [null, "and"],
        "⍱": [null, "nor"],
        "⍲": [null, "nand"],
        "⍴": ["shapeOf", "reshape"],
        ",": ["ravel", "catenate"],
        "⍪": [null, "firstAxisCatenate"],
        "⌽": ["reverse", "rotate"],
        "⊖": ["axis1Reverse", "axis1Rotate"],
        "⍉": ["transpose", null],
        "↑": ["first", "take"],
        "↓": [null, "drop"],
        "⊂": ["enclose", "partitionWithAxis"],
        "⊃": ["diclose", "pick"],
        "⌷": [null, "index"],
        "⍋": ["gradeUp", null],
        "⍒": ["gradeDown", null],
        "⊤": ["encode", null],
        "⊥": ["decode", null],
        "⍕": ["format", "formatByExample"],
        "⍎": ["execute", null],
        "⊣": ["stop", "left"],
        "⊢": ["pass", "right"]
      };

      var isOperator = /[\.\/⌿⍀¨⍣]/;
      var isNiladic = /⍬/;
      var isFunction = /[\+−×÷⌈⌊∣⍳\?⋆⍟○!⌹<≤=>≥≠≡≢∈⍷∪∩∼∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⌷⍋⍒⊤⊥⍕⍎⊣⊢]/;
      var isArrow = /←/;
      var isComment = /[⍝#].*$/;

      var stringEater = function(type) {
        var prev;
        prev = false;
        return function(c) {
          prev = c;
          if (c === type) {
            return prev === "\\";
          }
          return true;
        };
      };
      return {
        startState: function() {
          return {
            prev: false,
            func: false,
            op: false,
            string: false,
            escape: false
          };
        },
        token: function(stream, state) {
          var ch, funcName;
          if (stream.eatSpace()) {
            return null;
          }
          ch = stream.next();
          if (ch === '"' || ch === "'") {
            stream.eatWhile(stringEater(ch));
            stream.next();
            state.prev = true;
            return "string";
          }
          if (/[\[{\(]/.test(ch)) {
            state.prev = false;
            return null;
          }
          if (/[\]}\)]/.test(ch)) {
            state.prev = true;
            return null;
          }
          if (isNiladic.test(ch)) {
            state.prev = false;
            return "niladic";
          }
          if (/[¯\d]/.test(ch)) {
            if (state.func) {
              state.func = false;
              state.prev = false;
            } else {
              state.prev = true;
            }
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (isOperator.test(ch)) {
            return "operator apl-" + builtInOps[ch];
          }
          if (isArrow.test(ch)) {
            return "apl-arrow";
          }
          if (isFunction.test(ch)) {
            funcName = "apl-";
            if (builtInFuncs[ch] != null) {
              if (state.prev) {
                funcName += builtInFuncs[ch][1];
              } else {
                funcName += builtInFuncs[ch][0];
              }
            }
            state.func = true;
            state.prev = false;
            return "function " + funcName;
          }
          if (isComment.test(ch)) {
            stream.skipToEnd();
            return "comment";
          }
          if (ch === "∘" && stream.peek() === ".") {
            stream.next();
            return "function jot-dot";
          }
          stream.eatWhile(/[\w\$_]/);
          state.prev = true;
          return "keyword";
        }
      };
    });

    CodeMirror.defineMIME("text/apl", "apl");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Asciiarmor(CodeMirror) {
      function errorIfNotEmpty(stream) {
        var nonWS = stream.match(/^\s*\S/);
        stream.skipToEnd();
        return nonWS ? "error" : null;
      }

      CodeMirror.defineMode("asciiarmor", function() {
        return {
          token: function(stream, state) {
            var m;
            if (state.state == "top") {
              if (stream.sol() && (m = stream.match(/^-----BEGIN (.*)?-----\s*$/))) {
                state.state = "headers";
                state.type = m[1];
                return "tag";
              }
              return errorIfNotEmpty(stream);
            } else if (state.state == "headers") {
              if (stream.sol() && stream.match(/^\w+:/)) {
                state.state = "header";
                return "atom";
              } else {
                var result = errorIfNotEmpty(stream);
                if (result) state.state = "body";
                return result;
              }
            } else if (state.state == "header") {
              stream.skipToEnd();
              state.state = "headers";
              return "string";
            } else if (state.state == "body") {
              if (stream.sol() && (m = stream.match(/^-----END (.*)?-----\s*$/))) {
                if (m[1] != state.type) return "error";
                state.state = "end";
                return "tag";
              } else {
                if (stream.eatWhile(/[A-Za-z0-9+\/=]/)) {
                  return null;
                } else {
                  stream.next();
                  return "error";
                }
              }
            } else if (state.state == "end") {
              return errorIfNotEmpty(stream);
            }
          },
          blankLine: function(state) {
            if (state.state == "headers") state.state = "body";
          },
          startState: function() {
            return {state: "top", type: null};
          }
        };
      });

      CodeMirror.defineMIME("application/pgp", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-encrypted", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-keys", "asciiarmor");
      CodeMirror.defineMIME("application/pgp-signature", "asciiarmor");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Asn1(CodeMirror) {
      CodeMirror.defineMode("asn.1", function(config, parserConfig) {
        var indentUnit = config.indentUnit,
            keywords = parserConfig.keywords || {},
            cmipVerbs = parserConfig.cmipVerbs || {},
            compareTypes = parserConfig.compareTypes || {},
            status = parserConfig.status || {},
            tags = parserConfig.tags || {},
            storage = parserConfig.storage || {},
            modifier = parserConfig.modifier || {},
            accessTypes = parserConfig.accessTypes|| {},
            multiLineStrings = parserConfig.multiLineStrings,
            indentStatements = parserConfig.indentStatements !== false;
        var isOperatorChar = /[\|\^]/;
        var curPunc;

        function tokenBase(stream, state) {
          var ch = stream.next();
          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          if (/[\[\]\(\){}:=,;]/.test(ch)) {
            curPunc = ch;
            return "punctuation";
          }
          if (ch == "-"){
            if (stream.eat("-")) {
              stream.skipToEnd();
              return "comment";
            }
          }
          if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }

          stream.eatWhile(/[\w\-]/);
          var cur = stream.current();
          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          if (cmipVerbs.propertyIsEnumerable(cur)) return "variable cmipVerbs";
          if (compareTypes.propertyIsEnumerable(cur)) return "atom compareTypes";
          if (status.propertyIsEnumerable(cur)) return "comment status";
          if (tags.propertyIsEnumerable(cur)) return "variable-3 tags";
          if (storage.propertyIsEnumerable(cur)) return "builtin storage";
          if (modifier.propertyIsEnumerable(cur)) return "string-2 modifier";
          if (accessTypes.propertyIsEnumerable(cur)) return "atom accessTypes";

          return "variable";
        }

        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped){
                var afterNext = stream.peek();
                //look if the character if the quote is like the B in '10100010'B
                if (afterNext){
                  afterNext = afterNext.toLowerCase();
                  if(afterNext == "b" || afterNext == "h" || afterNext == "o")
                    stream.next();
                }
                end = true; break;
              }
              escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
              state.tokenize = null;
            return "string";
          };
        }

        function Context(indented, column, type, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.align = align;
          this.prev = prev;
        }
        function pushContext(state, col, type) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement")
            indent = state.context.indented;
          return state.context = new Context(indent, col, type, null, state.context);
        }
        function popContext(state) {
          var t = state.context.type;
          if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }

        //Interface
        return {
          startState: function(basecolumn) {
            return {
              tokenize: null,
              context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
              indented: 0,
              startOfLine: true
            };
          },

          token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
              if (ctx.align == null) ctx.align = false;
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
                && ctx.type == "statement"){
              popContext(state);
            }
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
              while (ctx.type == "statement") ctx = popContext(state);
              if (ctx.type == "}") ctx = popContext(state);
              while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")
                && curPunc != ';') || (ctx.type == "statement"
                && curPunc == "newstatement")))
              pushContext(state, stream.column(), "statement");

            state.startOfLine = false;
            return style;
          },

          electricChars: "{}",
          lineComment: "--",
          fold: "brace"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      CodeMirror.defineMIME("text/x-ttcn-asn", {
        name: "asn.1",
        keywords: words("DEFINITIONS OBJECTS IF DERIVED INFORMATION ACTION" +
        " REPLY ANY NAMED CHARACTERIZED BEHAVIOUR REGISTERED" +
        " WITH AS IDENTIFIED CONSTRAINED BY PRESENT BEGIN" +
        " IMPORTS FROM UNITS SYNTAX MIN-ACCESS MAX-ACCESS" +
        " MINACCESS MAXACCESS REVISION STATUS DESCRIPTION" +
        " SEQUENCE SET COMPONENTS OF CHOICE DistinguishedName" +
        " ENUMERATED SIZE MODULE END INDEX AUGMENTS EXTENSIBILITY" +
        " IMPLIED EXPORTS"),
        cmipVerbs: words("ACTIONS ADD GET NOTIFICATIONS REPLACE REMOVE"),
        compareTypes: words("OPTIONAL DEFAULT MANAGED MODULE-TYPE MODULE_IDENTITY" +
        " MODULE-COMPLIANCE OBJECT-TYPE OBJECT-IDENTITY" +
        " OBJECT-COMPLIANCE MODE CONFIRMED CONDITIONAL" +
        " SUBORDINATE SUPERIOR CLASS TRUE FALSE NULL" +
        " TEXTUAL-CONVENTION"),
        status: words("current deprecated mandatory obsolete"),
        tags: words("APPLICATION AUTOMATIC EXPLICIT IMPLICIT PRIVATE TAGS" +
        " UNIVERSAL"),
        storage: words("BOOLEAN INTEGER OBJECT IDENTIFIER BIT OCTET STRING" +
        " UTCTime InterfaceIndex IANAifType CMIP-Attribute" +
        " REAL PACKAGE PACKAGES IpAddress PhysAddress" +
        " NetworkAddress BITS BMPString TimeStamp TimeTicks" +
        " TruthValue RowStatus DisplayString GeneralString" +
        " GraphicString IA5String NumericString" +
        " PrintableString SnmpAdminAtring TeletexString" +
        " UTF8String VideotexString VisibleString StringStore" +
        " ISO646String T61String UniversalString Unsigned32" +
        " Integer32 Gauge Gauge32 Counter Counter32 Counter64"),
        modifier: words("ATTRIBUTE ATTRIBUTES MANDATORY-GROUP MANDATORY-GROUPS" +
        " GROUP GROUPS ELEMENTS EQUALITY ORDERING SUBSTRINGS" +
        " DEFINED"),
        accessTypes: words("not-accessible accessible-for-notify read-only" +
        " read-create read-write"),
        multiLineStrings: true
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
     * =====================================================================================
     *
     *       Filename:  mode/asterisk/asterisk.js
     *
     *    Description:  CodeMirror mode for Asterisk dialplan
     *
     *        Created:  05/17/2012 09:20:25 PM
     *       Revision:  none
     *
     *         Author:  Stas Kobzar (stas@modulis.ca),
     *        Company:  Modulis.ca Inc.
     *
     * =====================================================================================
     */

    function Asterisk(CodeMirror) {
    CodeMirror.defineMode("asterisk", function() {
      var atoms    = ["exten", "same", "include","ignorepat","switch"],
          dpcmd    = ["#include","#exec"],
          apps     = [
                      "addqueuemember","adsiprog","aelsub","agentlogin","agentmonitoroutgoing","agi",
                      "alarmreceiver","amd","answer","authenticate","background","backgrounddetect",
                      "bridge","busy","callcompletioncancel","callcompletionrequest","celgenuserevent",
                      "changemonitor","chanisavail","channelredirect","chanspy","clearhash","confbridge",
                      "congestion","continuewhile","controlplayback","dahdiacceptr2call","dahdibarge",
                      "dahdiras","dahdiscan","dahdisendcallreroutingfacility","dahdisendkeypadfacility",
                      "datetime","dbdel","dbdeltree","deadagi","dial","dictate","directory","disa",
                      "dumpchan","eagi","echo","endwhile","exec","execif","execiftime","exitwhile","extenspy",
                      "externalivr","festival","flash","followme","forkcdr","getcpeid","gosub","gosubif",
                      "goto","gotoif","gotoiftime","hangup","iax2provision","ices","importvar","incomplete",
                      "ivrdemo","jabberjoin","jabberleave","jabbersend","jabbersendgroup","jabberstatus",
                      "jack","log","macro","macroexclusive","macroexit","macroif","mailboxexists","meetme",
                      "meetmeadmin","meetmechanneladmin","meetmecount","milliwatt","minivmaccmess","minivmdelete",
                      "minivmgreet","minivmmwi","minivmnotify","minivmrecord","mixmonitor","monitor","morsecode",
                      "mp3player","mset","musiconhold","nbscat","nocdr","noop","odbc","odbc","odbcfinish",
                      "originate","ospauth","ospfinish","osplookup","ospnext","page","park","parkandannounce",
                      "parkedcall","pausemonitor","pausequeuemember","pickup","pickupchan","playback","playtones",
                      "privacymanager","proceeding","progress","queue","queuelog","raiseexception","read","readexten",
                      "readfile","receivefax","receivefax","receivefax","record","removequeuemember",
                      "resetcdr","retrydial","return","ringing","sayalpha","saycountedadj","saycountednoun",
                      "saycountpl","saydigits","saynumber","sayphonetic","sayunixtime","senddtmf","sendfax",
                      "sendfax","sendfax","sendimage","sendtext","sendurl","set","setamaflags",
                      "setcallerpres","setmusiconhold","sipaddheader","sipdtmfmode","sipremoveheader","skel",
                      "slastation","slatrunk","sms","softhangup","speechactivategrammar","speechbackground",
                      "speechcreate","speechdeactivategrammar","speechdestroy","speechloadgrammar","speechprocessingsound",
                      "speechstart","speechunloadgrammar","stackpop","startmusiconhold","stopmixmonitor","stopmonitor",
                      "stopmusiconhold","stopplaytones","system","testclient","testserver","transfer","tryexec",
                      "trysystem","unpausemonitor","unpausequeuemember","userevent","verbose","vmauthenticate",
                      "vmsayname","voicemail","voicemailmain","wait","waitexten","waitfornoise","waitforring",
                      "waitforsilence","waitmusiconhold","waituntil","while","zapateller"
                     ];

      function basicToken(stream,state){
        var cur = '';
        var ch = stream.next();
        // comment
        if(ch == ";") {
          stream.skipToEnd();
          return "comment";
        }
        // context
        if(ch == '[') {
          stream.skipTo(']');
          stream.eat(']');
          return "header";
        }
        // string
        if(ch == '"') {
          stream.skipTo('"');
          return "string";
        }
        if(ch == "'") {
          stream.skipTo("'");
          return "string-2";
        }
        // dialplan commands
        if(ch == '#') {
          stream.eatWhile(/\w/);
          cur = stream.current();
          if(dpcmd.indexOf(cur) !== -1) {
            stream.skipToEnd();
            return "strong";
          }
        }
        // application args
        if(ch == '$'){
          var ch1 = stream.peek();
          if(ch1 == '{'){
            stream.skipTo('}');
            stream.eat('}');
            return "variable-3";
          }
        }
        // extension
        stream.eatWhile(/\w/);
        cur = stream.current();
        if(atoms.indexOf(cur) !== -1) {
          state.extenStart = true;
          switch(cur) {
            case 'same': state.extenSame = true; break;
            case 'include':
            case 'switch':
            case 'ignorepat':
              state.extenInclude = true;break;
            default:break;
          }
          return "atom";
        }
      }

      return {
        startState: function() {
          return {
            extenStart: false,
            extenSame:  false,
            extenInclude: false,
            extenExten: false,
            extenPriority: false,
            extenApplication: false
          };
        },
        token: function(stream, state) {

          var cur = '';
          if(stream.eatSpace()) return null;
          // extension started
          if(state.extenStart){
            stream.eatWhile(/[^\s]/);
            cur = stream.current();
            if(/^=>?$/.test(cur)){
              state.extenExten = true;
              state.extenStart = false;
              return "strong";
            } else {
              state.extenStart = false;
              stream.skipToEnd();
              return "error";
            }
          } else if(state.extenExten) {
            // set exten and priority
            state.extenExten = false;
            state.extenPriority = true;
            stream.eatWhile(/[^,]/);
            if(state.extenInclude) {
              stream.skipToEnd();
              state.extenPriority = false;
              state.extenInclude = false;
            }
            if(state.extenSame) {
              state.extenPriority = false;
              state.extenSame = false;
              state.extenApplication = true;
            }
            return "tag";
          } else if(state.extenPriority) {
            state.extenPriority = false;
            state.extenApplication = true;
            stream.next(); // get comma
            if(state.extenSame) return null;
            stream.eatWhile(/[^,]/);
            return "number";
          } else if(state.extenApplication) {
            stream.eatWhile(/,/);
            cur = stream.current();
            if(cur === ',') return null;
            stream.eatWhile(/\w/);
            cur = stream.current().toLowerCase();
            state.extenApplication = false;
            if(apps.indexOf(cur) !== -1){
              return "def strong";
            }
          } else{
            return basicToken(stream,state);
          }

          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-asterisk", "asterisk");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Brainfuck mode created by Michael Kaminsky https://github.com/mkaminsky11

    function Brainfuck(CodeMirror) {
      var reserve = "><+-.,[]".split("");
      /*
      comments can be either:
      placed behind lines

            +++    this is a comment

      where reserved characters cannot be used
      or in a loop
      [
        this is ok to use [ ] and stuff
      ]
      or preceded by #
      */
      CodeMirror.defineMode("brainfuck", function() {
        return {
          startState: function() {
            return {
              commentLine: false,
              left: 0,
              right: 0,
              commentLoop: false
            }
          },
          token: function(stream, state) {
            if (stream.eatSpace()) return null
            if(stream.sol()){
              state.commentLine = false;
            }
            var ch = stream.next().toString();
            if(reserve.indexOf(ch) !== -1){
              if(state.commentLine === true){
                if(stream.eol()){
                  state.commentLine = false;
                }
                return "comment";
              }
              if(ch === "]" || ch === "["){
                if(ch === "["){
                  state.left++;
                }
                else{
                  state.right++;
                }
                return "bracket";
              }
              else if(ch === "+" || ch === "-"){
                return "keyword";
              }
              else if(ch === "<" || ch === ">"){
                return "atom";
              }
              else if(ch === "." || ch === ","){
                return "def";
              }
            }
            else{
              state.commentLine = true;
              if(stream.eol()){
                state.commentLine = false;
              }
              return "comment";
            }
            if(stream.eol()){
              state.commentLine = false;
            }
          }
        };
      });
    CodeMirror.defineMIME("text/x-brainfuck","brainfuck");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Clike(CodeMirror) {
    function Context(indented, column, type, info, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.info = info;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type, info) {
      var indent = state.indented;
      if (state.context && state.context.type == "statement" && type != "statement")
        indent = state.context.indented;
      return state.context = new Context(indent, col, type, info, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    function typeBefore(stream, state, pos) {
      if (state.prevToken == "variable" || state.prevToken == "type") return true;
      if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos))) return true;
      if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;
    }

    function isTopScope(context) {
      for (;;) {
        if (!context || context.type == "top") return true;
        if (context.type == "}" && context.prev.info != "namespace") return false;
        context = context.prev;
      }
    }

    CodeMirror.defineMode("clike", function(config, parserConfig) {
      var indentUnit = config.indentUnit,
          statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
          dontAlignCalls = parserConfig.dontAlignCalls,
          keywords = parserConfig.keywords || {},
          types = parserConfig.types || {},
          builtin = parserConfig.builtin || {},
          blockKeywords = parserConfig.blockKeywords || {},
          defKeywords = parserConfig.defKeywords || {},
          atoms = parserConfig.atoms || {},
          hooks = parserConfig.hooks || {},
          multiLineStrings = parserConfig.multiLineStrings,
          indentStatements = parserConfig.indentStatements !== false,
          indentSwitch = parserConfig.indentSwitch !== false,
          namespaceSeparator = parserConfig.namespaceSeparator,
          isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
          numberStart = parserConfig.numberStart || /[\d\.]/,
          number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
          isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
          isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/,
          // An optional function that takes a {string} token and returns true if it
          // should be treated as a builtin.
          isReservedIdentifier = parserConfig.isReservedIdentifier || false;

      var curPunc, isDefKeyword;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (isPunctuationChar.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (numberStart.test(ch)) {
          stream.backUp(1);
          if (stream.match(number)) return "number"
          stream.next();
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {}
          return "operator";
        }
        stream.eatWhile(isIdentifierChar);
        if (namespaceSeparator) while (stream.match(namespaceSeparator))
          stream.eatWhile(isIdentifierChar);

        var cur = stream.current();
        if (contains(keywords, cur)) {
          if (contains(blockKeywords, cur)) curPunc = "newstatement";
          if (contains(defKeywords, cur)) isDefKeyword = true;
          return "keyword";
        }
        if (contains(types, cur)) return "type";
        if (contains(builtin, cur)
            || (isReservedIdentifier && isReservedIdentifier(cur))) {
          if (contains(blockKeywords, cur)) curPunc = "newstatement";
          return "builtin";
        }
        if (contains(atoms, cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = null;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function maybeEOL(stream, state) {
        if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
          state.typeAtEndOfLine = typeBefore(stream, state, stream.pos);
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", null, false),
            indented: 0,
            startOfLine: true,
            prevToken: null
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) { maybeEOL(stream, state); return null; }
          curPunc = isDefKeyword = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false)))
            while (state.context.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (indentStatements &&
                   (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||
                    (ctx.type == "statement" && curPunc == "newstatement"))) {
            pushContext(state, stream.column(), "statement", stream.current());
          }

          if (style == "variable" &&
              ((state.prevToken == "def" ||
                (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&
                 isTopScope(state.context) && stream.match(/^\s*\(/, false)))))
            style = "def";

          if (hooks.token) {
            var result = hooks.token(stream, state, style);
            if (result !== undefined) style = result;
          }

          if (style == "def" && parserConfig.styleDefs === false) style = "variable";

          state.startOfLine = false;
          state.prevToken = isDefKeyword ? "def" : style || curPunc;
          maybeEOL(stream, state);
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
          if (parserConfig.dontIndentStatements)
            while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
              ctx = ctx.prev;
          if (hooks.indent) {
            var hook = hooks.indent(state, ctx, textAfter, indentUnit);
            if (typeof hook == "number") return hook
          }
          var switchBlock = ctx.prev && ctx.prev.info == "switch";
          if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
            while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev;
            return ctx.indented
          }
          if (ctx.type == "statement")
            return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
          if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
            return ctx.column + (closing ? 0 : 1);
          if (ctx.type == ")" && !closing)
            return ctx.indented + statementIndentUnit;

          return ctx.indented + (closing ? 0 : indentUnit) +
            (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? indentUnit : 0);
        },

        electricInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        blockCommentContinue: " * ",
        lineComment: "//",
        fold: "brace"
      };
    });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      function contains(words, word) {
        if (typeof words === "function") {
          return words(word);
        } else {
          return words.propertyIsEnumerable(word);
        }
      }
      var cKeywords = "auto if break case register continue return default do sizeof " +
        "static else struct switch extern typedef union for goto while enum const " +
        "volatile inline restrict asm fortran";

      // Do not use this. Use the cTypes function below. This is global just to avoid
      // excessive calls when cTypes is being called multiple times during a parse.
      var basicCTypes = words("int long char short double float unsigned signed " +
        "void bool");

      // Do not use this. Use the objCTypes function below. This is global just to avoid
      // excessive calls when objCTypes is being called multiple times during a parse.
      var basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");

      // Returns true if identifier is a "C" type.
      // C type is defined as those that are reserved by the compiler (basicTypes),
      // and those that end in _t (Reserved by POSIX for types)
      // http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html
      function cTypes(identifier) {
        return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);
      }

      // Returns true if identifier is a "Objective C" type.
      function objCTypes(identifier) {
        return cTypes(identifier) || contains(basicObjCTypes, identifier);
      }

      var cBlockKeywords = "case do else for if switch while struct enum union";
      var cDefKeywords = "struct enum union";

      function cppHook(stream, state) {
        if (!state.startOfLine) return false
        for (var ch, next = null; ch = stream.peek();) {
          if (ch == "\\" && stream.match(/^.$/)) {
            next = cppHook;
            break
          } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
            break
          }
          stream.next();
        }
        state.tokenize = next;
        return "meta"
      }

      function pointerHook(_stream, state) {
        if (state.prevToken == "type") return "type";
        return false;
      }

      // For C and C++ (and ObjC): identifiers starting with __
      // or _ followed by a capital letter are reserved for the compiler.
      function cIsReservedIdentifier(token) {
        if (!token || token.length < 2) return false;
        if (token[0] != '_') return false;
        return (token[1] == '_') || (token[1] !== token[1].toLowerCase());
      }

      function cpp14Literal(stream) {
        stream.eatWhile(/[\w\.']/);
        return "number";
      }

      function cpp11StringHook(stream, state) {
        stream.backUp(1);
        // Raw strings.
        if (stream.match(/(R|u8R|uR|UR|LR)/)) {
          var match = stream.match(/"([^\s\\()]{0,16})\(/);
          if (!match) {
            return false;
          }
          state.cpp11RawStringDelim = match[1];
          state.tokenize = tokenRawString;
          return tokenRawString(stream, state);
        }
        // Unicode strings/chars.
        if (stream.match(/(u8|u|U|L)/)) {
          if (stream.match(/["']/, /* eat */ false)) {
            return "string";
          }
          return false;
        }
        // Ignore this hook.
        stream.next();
        return false;
      }

      function cppLooksLikeConstructor(word) {
        var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
        return lastTwo && lastTwo[1] == lastTwo[2];
      }

      // C#-style strings where "" escapes a quote.
      function tokenAtString(stream, state) {
        var next;
        while ((next = stream.next()) != null) {
          if (next == '"' && !stream.eat('"')) {
            state.tokenize = null;
            break;
          }
        }
        return "string";
      }

      // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
      // <delim> can be a string up to 16 characters long.
      function tokenRawString(stream, state) {
        // Escape characters that have special regex meanings.
        var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
        var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
        if (match)
          state.tokenize = null;
        else
          stream.skipToEnd();
        return "string";
      }

      function def(mimes, mode) {
        if (typeof mimes == "string") mimes = [mimes];
        var words = [];
        function add(obj) {
          if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
            words.push(prop);
        }
        add(mode.keywords);
        add(mode.types);
        add(mode.builtin);
        add(mode.atoms);
        if (words.length) {
          mode.helperType = mimes[0];
          CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i = 0; i < mimes.length; ++i)
          CodeMirror.defineMIME(mimes[i], mode);
      }

      def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
        name: "clike",
        keywords: words(cKeywords),
        types: cTypes,
        blockKeywords: words(cBlockKeywords),
        defKeywords: words(cDefKeywords),
        typeFirstDefinitions: true,
        atoms: words("NULL true false"),
        isReservedIdentifier: cIsReservedIdentifier,
        hooks: {
          "#": cppHook,
          "*": pointerHook,
        },
        modeProps: {fold: ["brace", "include"]}
      });

      def(["text/x-c++src", "text/x-c++hdr"], {
        name: "clike",
        // Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.
        keywords: words(cKeywords + "alignas alignof and and_eq audit axiom bitand bitor catch " +
                        "class compl concept constexpr const_cast decltype delete dynamic_cast " +
                        "explicit export final friend import module mutable namespace new noexcept " +
                        "not not_eq operator or or_eq override private protected public " +
                        "reinterpret_cast requires static_assert static_cast template this " +
                        "thread_local throw try typeid typename using virtual xor xor_eq"),
        types: cTypes,
        blockKeywords: words(cBlockKeywords + " class try catch"),
        defKeywords: words(cDefKeywords + " class namespace"),
        typeFirstDefinitions: true,
        atoms: words("true false NULL nullptr"),
        dontIndentStatements: /^template$/,
        isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
        isReservedIdentifier: cIsReservedIdentifier,
        hooks: {
          "#": cppHook,
          "*": pointerHook,
          "u": cpp11StringHook,
          "U": cpp11StringHook,
          "L": cpp11StringHook,
          "R": cpp11StringHook,
          "0": cpp14Literal,
          "1": cpp14Literal,
          "2": cpp14Literal,
          "3": cpp14Literal,
          "4": cpp14Literal,
          "5": cpp14Literal,
          "6": cpp14Literal,
          "7": cpp14Literal,
          "8": cpp14Literal,
          "9": cpp14Literal,
          token: function(stream, state, style) {
            if (style == "variable" && stream.peek() == "(" &&
                (state.prevToken == ";" || state.prevToken == null ||
                 state.prevToken == "}") &&
                cppLooksLikeConstructor(stream.current()))
              return "def";
          }
        },
        namespaceSeparator: "::",
        modeProps: {fold: ["brace", "include"]}
      });

      def("text/x-java", {
        name: "clike",
        keywords: words("abstract assert break case catch class const continue default " +
                        "do else enum extends final finally float for goto if implements import " +
                        "instanceof interface native new package private protected public " +
                        "return static strictfp super switch synchronized this throw throws transient " +
                        "try volatile while @interface"),
        types: words("byte short int long float double boolean char void Boolean Byte Character Double Float " +
                     "Integer Long Number Object Short String StringBuffer StringBuilder Void"),
        blockKeywords: words("catch class do else finally for if switch try while"),
        defKeywords: words("class interface enum @interface"),
        typeFirstDefinitions: true,
        atoms: words("true false null"),
        number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
        hooks: {
          "@": function(stream) {
            // Don't match the @interface keyword.
            if (stream.match('interface', false)) return false;

            stream.eatWhile(/[\w\$_]/);
            return "meta";
          }
        },
        modeProps: {fold: ["brace", "import"]}
      });

      def("text/x-csharp", {
        name: "clike",
        keywords: words("abstract as async await base break case catch checked class const continue" +
                        " default delegate do else enum event explicit extern finally fixed for" +
                        " foreach goto if implicit in interface internal is lock namespace new" +
                        " operator out override params private protected public readonly ref return sealed" +
                        " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                        " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                        " global group into join let orderby partial remove select set value var yield"),
        types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func" +
                     " Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32" +
                     " UInt64 bool byte char decimal double short int long object"  +
                     " sbyte float string ushort uint ulong"),
        blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
        defKeywords: words("class interface namespace struct var"),
        typeFirstDefinitions: true,
        atoms: words("true false null"),
        hooks: {
          "@": function(stream, state) {
            if (stream.eat('"')) {
              state.tokenize = tokenAtString;
              return tokenAtString(stream, state);
            }
            stream.eatWhile(/[\w\$_]/);
            return "meta";
          }
        }
      });

      function tokenTripleString(stream, state) {
        var escaped = false;
        while (!stream.eol()) {
          if (!escaped && stream.match('"""')) {
            state.tokenize = null;
            break;
          }
          escaped = stream.next() == "\\" && !escaped;
        }
        return "string";
      }

      function tokenNestedComment(depth) {
        return function (stream, state) {
          var ch;
          while (ch = stream.next()) {
            if (ch == "*" && stream.eat("/")) {
              if (depth == 1) {
                state.tokenize = null;
                break
              } else {
                state.tokenize = tokenNestedComment(depth - 1);
                return state.tokenize(stream, state)
              }
            } else if (ch == "/" && stream.eat("*")) {
              state.tokenize = tokenNestedComment(depth + 1);
              return state.tokenize(stream, state)
            }
          }
          return "comment"
        }
      }

      def("text/x-scala", {
        name: "clike",
        keywords: words(
          /* scala */
          "abstract case catch class def do else extends final finally for forSome if " +
          "implicit import lazy match new null object override package private protected return " +
          "sealed super this throw trait try type val var while with yield _ " +

          /* package scala */
          "assert assume require print println printf readLine readBoolean readByte readShort " +
          "readChar readInt readLong readFloat readDouble"
        ),
        types: words(
          "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
          "Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable " +
          "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
          "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
          "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector " +

          /* package java.lang */
          "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
          "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
          "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
          "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
        ),
        multiLineStrings: true,
        blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
        defKeywords: words("class enum def object package trait type val var"),
        atoms: words("true false null"),
        indentStatements: false,
        indentSwitch: false,
        isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
        hooks: {
          "@": function(stream) {
            stream.eatWhile(/[\w\$_]/);
            return "meta";
          },
          '"': function(stream, state) {
            if (!stream.match('""')) return false;
            state.tokenize = tokenTripleString;
            return state.tokenize(stream, state);
          },
          "'": function(stream) {
            stream.eatWhile(/[\w\$_\xa1-\uffff]/);
            return "atom";
          },
          "=": function(stream, state) {
            var cx = state.context;
            if (cx.type == "}" && cx.align && stream.eat(">")) {
              state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev);
              return "operator"
            } else {
              return false
            }
          },

          "/": function(stream, state) {
            if (!stream.eat("*")) return false
            state.tokenize = tokenNestedComment(1);
            return state.tokenize(stream, state)
          }
        },
        modeProps: {closeBrackets: {pairs: '()[]{}""', triples: '"'}}
      });

      function tokenKotlinString(tripleString){
        return function (stream, state) {
          var escaped = false, next, end = false;
          while (!stream.eol()) {
            if (!tripleString && !escaped && stream.match('"') ) {end = true; break;}
            if (tripleString && stream.match('"""')) {end = true; break;}
            next = stream.next();
            if(!escaped && next == "$" && stream.match('{'))
              stream.skipTo("}");
            escaped = !escaped && next == "\\" && !tripleString;
          }
          if (end || !tripleString)
            state.tokenize = null;
          return "string";
        }
      }

      def("text/x-kotlin", {
        name: "clike",
        keywords: words(
          /*keywords*/
          "package as typealias class interface this super val operator " +
          "var fun for is in This throw return annotation " +
          "break continue object if else while do try when !in !is as? " +

          /*soft keywords*/
          "file import where by get set abstract enum open inner override private public internal " +
          "protected catch finally out final vararg reified dynamic companion constructor init " +
          "sealed field property receiver param sparam lateinit data inline noinline tailrec " +
          "external annotation crossinline const operator infix suspend actual expect setparam"
        ),
        types: words(
          /* package java.lang */
          "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
          "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
          "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
          "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray " +
          "ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy " +
          "LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
        ),
        intendSwitch: false,
        indentStatements: false,
        multiLineStrings: true,
        number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
        blockKeywords: words("catch class do else finally for if where try while enum"),
        defKeywords: words("class val var object interface fun"),
        atoms: words("true false null this"),
        hooks: {
          "@": function(stream) {
            stream.eatWhile(/[\w\$_]/);
            return "meta";
          },
          '*': function(_stream, state) {
            return state.prevToken == '.' ? 'variable' : 'operator';
          },
          '"': function(stream, state) {
            state.tokenize = tokenKotlinString(stream.match('""'));
            return state.tokenize(stream, state);
          },
          indent: function(state, ctx, textAfter, indentUnit) {
            var firstChar = textAfter && textAfter.charAt(0);
            if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
              return state.indented;
            if (state.prevToken == "operator" && textAfter != "}" ||
              state.prevToken == "variable" && firstChar == "." ||
              (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
              return indentUnit * 2 + ctx.indented;
            if (ctx.align && ctx.type == "}")
              return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
          }
        },
        modeProps: {closeBrackets: {triples: '"'}}
      });

      def(["x-shader/x-vertex", "x-shader/x-fragment"], {
        name: "clike",
        keywords: words("sampler1D sampler2D sampler3D samplerCube " +
                        "sampler1DShadow sampler2DShadow " +
                        "const attribute uniform varying " +
                        "break continue discard return " +
                        "for while do if else struct " +
                        "in out inout"),
        types: words("float int bool void " +
                     "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                     "mat2 mat3 mat4"),
        blockKeywords: words("for while do if else struct"),
        builtin: words("radians degrees sin cos tan asin acos atan " +
                        "pow exp log exp2 sqrt inversesqrt " +
                        "abs sign floor ceil fract mod min max clamp mix step smoothstep " +
                        "length distance dot cross normalize ftransform faceforward " +
                        "reflect refract matrixCompMult " +
                        "lessThan lessThanEqual greaterThan greaterThanEqual " +
                        "equal notEqual any all not " +
                        "texture1D texture1DProj texture1DLod texture1DProjLod " +
                        "texture2D texture2DProj texture2DLod texture2DProjLod " +
                        "texture3D texture3DProj texture3DLod texture3DProjLod " +
                        "textureCube textureCubeLod " +
                        "shadow1D shadow2D shadow1DProj shadow2DProj " +
                        "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                        "dFdx dFdy fwidth " +
                        "noise1 noise2 noise3 noise4"),
        atoms: words("true false " +
                    "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                    "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                    "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                    "gl_FogCoord gl_PointCoord " +
                    "gl_Position gl_PointSize gl_ClipVertex " +
                    "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                    "gl_TexCoord gl_FogFragCoord " +
                    "gl_FragCoord gl_FrontFacing " +
                    "gl_FragData gl_FragDepth " +
                    "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                    "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                    "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                    "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                    "gl_ProjectionMatrixInverseTranspose " +
                    "gl_ModelViewProjectionMatrixInverseTranspose " +
                    "gl_TextureMatrixInverseTranspose " +
                    "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                    "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                    "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                    "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                    "gl_FogParameters " +
                    "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                    "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                    "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                    "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                    "gl_MaxDrawBuffers"),
        indentSwitch: false,
        hooks: {"#": cppHook},
        modeProps: {fold: ["brace", "include"]}
      });

      def("text/x-nesc", {
        name: "clike",
        keywords: words(cKeywords + " as atomic async call command component components configuration event generic " +
                        "implementation includes interface module new norace nx_struct nx_union post provides " +
                        "signal task uses abstract extends"),
        types: cTypes,
        blockKeywords: words(cBlockKeywords),
        atoms: words("null true false"),
        hooks: {"#": cppHook},
        modeProps: {fold: ["brace", "include"]}
      });

      def("text/x-objectivec", {
        name: "clike",
        keywords: words(cKeywords + " bycopy byref in inout oneway out self super atomic nonatomic retain copy " +
                        "readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd " +
                        "@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class " +
                        "@public @package @private @protected @required @optional @try @catch @finally @import " +
                        "@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available"),
        types: objCTypes,
        builtin: words("FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION NS_RETURNS_RETAINED " +
                       "NS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER " +
                       "NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN " +
                       "NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT"),
        blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
        defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),
        dontIndentStatements: /^@.*$/,
        typeFirstDefinitions: true,
        atoms: words("YES NO NULL Nil nil true false nullptr"),
        isReservedIdentifier: cIsReservedIdentifier,
        hooks: {
          "#": cppHook,
          "*": pointerHook,
        },
        modeProps: {fold: ["brace", "include"]}
      });

      def("text/x-squirrel", {
        name: "clike",
        keywords: words("base break clone continue const default delete enum extends function in class" +
                        " foreach local resume return this throw typeof yield constructor instanceof static"),
        types: cTypes,
        blockKeywords: words("case catch class else for foreach if switch try while"),
        defKeywords: words("function local class"),
        typeFirstDefinitions: true,
        atoms: words("true false null"),
        hooks: {"#": cppHook},
        modeProps: {fold: ["brace", "include"]}
      });

      // Ceylon Strings need to deal with interpolation
      var stringTokenizer = null;
      function tokenCeylonString(type) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while (!stream.eol()) {
            if (!escaped && stream.match('"') &&
                  (type == "single" || stream.match('""'))) {
              end = true;
              break;
            }
            if (!escaped && stream.match('``')) {
              stringTokenizer = tokenCeylonString(type);
              end = true;
              break;
            }
            next = stream.next();
            escaped = type == "single" && !escaped && next == "\\";
          }
          if (end)
              state.tokenize = null;
          return "string";
        }
      }

      def("text/x-ceylon", {
        name: "clike",
        keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else" +
                        " exists extends finally for function given if import in interface is let module new" +
                        " nonempty object of out outer package return satisfies super switch then this throw" +
                        " try value void while"),
        types: function(word) {
            // In Ceylon all identifiers that start with an uppercase are types
            var first = word.charAt(0);
            return (first === first.toUpperCase() && first !== first.toLowerCase());
        },
        blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
        defKeywords: words("class dynamic function interface module object package value"),
        builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license" +
                       " native optional sealed see serializable shared suppressWarnings tagged throws variable"),
        isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
        isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
        numberStart: /[\d#$]/,
        number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
        multiLineStrings: true,
        typeFirstDefinitions: true,
        atoms: words("true false null larger smaller equal empty finished"),
        indentSwitch: false,
        styleDefs: false,
        hooks: {
          "@": function(stream) {
            stream.eatWhile(/[\w\$_]/);
            return "meta";
          },
          '"': function(stream, state) {
              state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
              return state.tokenize(stream, state);
            },
          '`': function(stream, state) {
              if (!stringTokenizer || !stream.match('`')) return false;
              state.tokenize = stringTokenizer;
              stringTokenizer = null;
              return state.tokenize(stream, state);
            },
          "'": function(stream) {
            stream.eatWhile(/[\w\$_\xa1-\uffff]/);
            return "atom";
          },
          token: function(_stream, state, style) {
              if ((style == "variable" || style == "type") &&
                  state.prevToken == ".") {
                return "variable-2";
              }
            }
        },
        modeProps: {
            fold: ["brace", "import"],
            closeBrackets: {triples: '"'}
        }
      });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Clojure(CodeMirror) {
    CodeMirror.defineMode("clojure", function (options) {
      var atoms = ["false", "nil", "true"];
      var specialForms = [".", "catch", "def", "do", "if", "monitor-enter",
          "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
      var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*",
          "*allow-unresolved-vars*", "*assert*", "*clojure-version*",
          "*command-line-args*", "*compile-files*", "*compile-path*",
          "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e",
          "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*",
          "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*",
          "*print-level*", "*print-meta*", "*print-namespace-maps*",
          "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*",
          "*suppress-read*", "*unchecked-math*", "*use-context-classloader*",
          "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'",
          "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode",
          "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=",
          "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec",
          "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch",
          "agent", "agent-error", "agent-errors", "aget", "alength", "alias",
          "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors",
          "and", "any?", "apply", "areduce", "array-map", "as->", "aset",
          "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float",
          "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!",
          "assoc-in", "associative?", "atom", "await", "await-for", "await1",
          "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and",
          "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set",
          "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean",
          "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*",
          "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes",
          "bytes?", "case", "cast", "cat", "char", "char-array",
          "char-escape-string", "char-name-string", "char?", "chars", "chunk",
          "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next",
          "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors",
          "clojure-version", "coll?", "comment", "commute", "comp", "comparator",
          "compare", "compare-and-set!", "compile", "complement", "completing",
          "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons",
          "constantly", "construct-proxy", "contains?", "count", "counted?",
          "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?",
          "declare", "dedupe", "default-data-readers", "definline", "definterface",
          "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce",
          "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?",
          "deliver", "denominator", "deref", "derive", "descendants", "destructure",
          "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall",
          "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array",
          "double?", "doubles", "drop", "drop-last", "drop-while", "eduction",
          "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq",
          "error-handler", "error-mode", "eval", "even?", "every-pred", "every?",
          "ex-data", "ex-info", "extend", "extend-protocol", "extend-type",
          "extenders", "extends?", "false?", "ffirst", "file-seq", "filter",
          "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl",
          "find-protocol-method", "find-var", "first", "flatten", "float",
          "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil",
          "for", "force", "format", "frequencies", "future", "future-call",
          "future-cancel", "future-cancelled?", "future-done?", "future?",
          "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method",
          "get-proxy-class", "get-thread-bindings", "get-validator", "group-by",
          "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll",
          "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity",
          "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'",
          "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?",
          "int", "int-array", "int?", "integer?", "interleave", "intern",
          "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate",
          "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword",
          "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq",
          "list", "list*", "list?", "load", "load-file", "load-reader",
          "load-string", "loaded-libs", "locking", "long", "long-array", "longs",
          "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy",
          "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max",
          "max-key", "memfn", "memoize", "merge", "merge-with", "meta",
          "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod",
          "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?",
          "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?",
          "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports",
          "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers",
          "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest",
          "num", "number?", "numerator", "object-array", "odd?", "or", "parents",
          "partial", "partition", "partition-all", "partition-by", "pcalls", "peek",
          "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?",
          "pos?", "pr", "pr-str", "prefer-method", "prefers",
          "primitives-classnames", "print", "print-ctor", "print-dup",
          "print-method", "print-simple", "print-str", "printf", "println",
          "println-str", "prn", "prn-str", "promise", "proxy",
          "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super",
          "push-thread-bindings", "pvalues", "qualified-ident?",
          "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int",
          "rand-nth", "random-sample", "range", "ratio?", "rational?",
          "rationalize", "re-find", "re-groups", "re-matcher", "re-matches",
          "re-pattern", "re-seq", "read", "read-line", "read-string",
          "reader-conditional", "reader-conditional?", "realized?", "record?",
          "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref",
          "ref-history-count", "ref-max-history", "ref-min-history", "ref-set",
          "refer", "refer-clojure", "reify", "release-pending-sends", "rem",
          "remove", "remove-all-methods", "remove-method", "remove-ns",
          "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require",
          "reset!", "reset-meta!", "reset-vals!", "resolve", "rest",
          "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq",
          "rsubseq", "run!", "satisfies?", "second", "select-keys", "send",
          "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence",
          "sequential?", "set", "set-agent-send-executor!",
          "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!",
          "set-validator!", "set?", "short", "short-array", "shorts", "shuffle",
          "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?",
          "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort",
          "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by",
          "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str",
          "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers",
          "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal",
          "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test",
          "the-ns", "thread-bound?", "time", "to-array", "to-array-2d",
          "trampoline", "transduce", "transient", "tree-seq", "true?", "type",
          "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char",
          "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int",
          "unchecked-double", "unchecked-float", "unchecked-inc",
          "unchecked-inc-int", "unchecked-int", "unchecked-long",
          "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate",
          "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short",
          "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote",
          "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update",
          "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals",
          "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of",
          "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when",
          "when-first", "when-let", "when-not", "when-some", "while",
          "with-bindings", "with-bindings*", "with-in-str", "with-loading-context",
          "with-local-vars", "with-meta", "with-open", "with-out-str",
          "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?",
          "zipmap"];
      var haveBodyParameter = [
          "->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment",
          "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod",
          "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype",
          "do", "doseq", "dotimes", "doto", "extend", "extend-protocol",
          "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some",
          "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map",
          "some->", "some->>", "try", "when", "when-first", "when-let", "when-not",
          "when-some", "while", "with-bindings", "with-bindings*", "with-in-str",
          "with-loading-context", "with-local-vars", "with-meta", "with-open",
          "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];

      CodeMirror.registerHelper("hintWords", "clojure",
        [].concat(atoms, specialForms, coreSymbols));

      var atom = createLookupMap(atoms);
      var specialForm = createLookupMap(specialForms);
      var coreSymbol = createLookupMap(coreSymbols);
      var hasBodyParameter = createLookupMap(haveBodyParameter);
      var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
      var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
      var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

      // simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*/
      // simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
      // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
      var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;

      function base(stream, state) {
        if (stream.eatSpace()) return ["space", null];
        if (stream.match(numberLiteral)) return [null, "number"];
        if (stream.match(characterLiteral)) return [null, "string-2"];
        if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
        if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
        if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
        if (stream.eat(/^;/)) {stream.skipToEnd(); return ["space", "comment"];}
        if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];

        var matches = stream.match(qualifiedSymbol);
        var symbol = matches && matches[0];

        if (!symbol) {
          // advance stream by at least one character so we don't get stuck.
          stream.next();
          stream.eatWhile(function (c) {return !is(c, delimiter);});
          return [null, "error"];
        }

        if (symbol === "comment" && state.lastToken === "(")
          return (state.tokenize = inComment)(stream, state);
        if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
        if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
        if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

        return ["symbol", "variable"];
      }

      function inString(stream, state) {
        var escaped = false, next;

        while (next = stream.next()) {
          if (next === "\"" && !escaped) {state.tokenize = base; break;}
          escaped = !escaped && next === "\\";
        }

        return [null, "string"];
      }

      function inComment(stream, state) {
        var parenthesisCount = 1;
        var next;

        while (next = stream.next()) {
          if (next === ")") parenthesisCount--;
          if (next === "(") parenthesisCount++;
          if (parenthesisCount === 0) {
            stream.backUp(1);
            state.tokenize = base;
            break;
          }
        }

        return ["space", "comment"];
      }

      function createLookupMap(words) {
        var obj = {};

        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;

        return obj;
      }

      function is(value, test) {
        if (test instanceof RegExp) return test.test(value);
        if (test instanceof Object) return test.propertyIsEnumerable(value);
      }

      return {
        startState: function () {
          return {
            ctx: {prev: null, start: 0, indentTo: 0},
            lastToken: null,
            tokenize: base
          };
        },

        token: function (stream, state) {
          if (stream.sol() && (typeof state.ctx.indentTo !== "number"))
            state.ctx.indentTo = state.ctx.start + 1;

          var typeStylePair = state.tokenize(stream, state);
          var type = typeStylePair[0];
          var style = typeStylePair[1];
          var current = stream.current();

          if (type !== "space") {
            if (state.lastToken === "(" && state.ctx.indentTo === null) {
              if (type === "symbol" && is(current, hasBodyParameter))
                state.ctx.indentTo = state.ctx.start + options.indentUnit;
              else state.ctx.indentTo = "next";
            } else if (state.ctx.indentTo === "next") {
              state.ctx.indentTo = stream.column();
            }

            state.lastToken = current;
          }

          if (type === "open")
            state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
          else if (type === "close") state.ctx = state.ctx.prev || state.ctx;

          return style;
        },

        indent: function (state) {
          var i = state.ctx.indentTo;

          return (typeof i === "number") ?
            i :
            state.ctx.start + 1;
        },

        closeBrackets: {pairs: "()[]{}\"\""},
        lineComment: ";;"
      };
    });

    CodeMirror.defineMIME("text/x-clojure", "clojure");
    CodeMirror.defineMIME("text/x-clojurescript", "clojure");
    CodeMirror.defineMIME("application/edn", "clojure");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Cmake(CodeMirror) {
    CodeMirror.defineMode("cmake", function () {
      var variable_regex = /({)?[a-zA-Z0-9_]+(})?/;

      function tokenString(stream, state) {
        var current, prev, found_var = false;
        while (!stream.eol() && (current = stream.next()) != state.pending) {
          if (current === '$' && prev != '\\' && state.pending == '"') {
            found_var = true;
            break;
          }
          prev = current;
        }
        if (found_var) {
          stream.backUp(1);
        }
        if (current == state.pending) {
          state.continueString = false;
        } else {
          state.continueString = true;
        }
        return "string";
      }

      function tokenize(stream, state) {
        var ch = stream.next();

        // Have we found a variable?
        if (ch === '$') {
          if (stream.match(variable_regex)) {
            return 'variable-2';
          }
          return 'variable';
        }
        // Should we still be looking for the end of a string?
        if (state.continueString) {
          // If so, go through the loop again
          stream.backUp(1);
          return tokenString(stream, state);
        }
        // Do we just have a function on our hands?
        // In 'cmake_minimum_required (VERSION 2.8.8)', 'cmake_minimum_required' is matched
        if (stream.match(/(\s+)?\w+\(/) || stream.match(/(\s+)?\w+\ \(/)) {
          stream.backUp(1);
          return 'def';
        }
        if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        // Have we found a string?
        if (ch == "'" || ch == '"') {
          // Store the type (single or double)
          state.pending = ch;
          // Perform the looping function to find the end
          return tokenString(stream, state);
        }
        if (ch == '(' || ch == ')') {
          return 'bracket';
        }
        if (ch.match(/[0-9]/)) {
          return 'number';
        }
        stream.eatWhile(/[\w-]/);
        return null;
      }
      return {
        startState: function () {
          var state = {};
          state.inDefinition = false;
          state.inInclude = false;
          state.continueString = false;
          state.pending = false;
          return state;
        },
        token: function (stream, state) {
          if (stream.eatSpace()) return null;
          return tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME("text/x-cmake", "cmake");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Author: Gautam Mehta
     * Branched from CodeMirror's Scheme mode
     */
    function Cobol(CodeMirror) {
    CodeMirror.defineMode("cobol", function () {
      var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
          ATOM = "atom", NUMBER = "number", KEYWORD = "keyword", MODTAG = "header",
          COBOLLINENUM = "def", PERIOD = "link";
      function makeKeywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var atoms = makeKeywords("TRUE FALSE ZEROES ZEROS ZERO SPACES SPACE LOW-VALUE LOW-VALUES ");
      var keywords = makeKeywords(
          "ACCEPT ACCESS ACQUIRE ADD ADDRESS " +
          "ADVANCING AFTER ALIAS ALL ALPHABET " +
          "ALPHABETIC ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC ALPHANUMERIC-EDITED " +
          "ALSO ALTER ALTERNATE AND ANY " +
          "ARE AREA AREAS ARITHMETIC ASCENDING " +
          "ASSIGN AT ATTRIBUTE AUTHOR AUTO " +
          "AUTO-SKIP AUTOMATIC B-AND B-EXOR B-LESS " +
          "B-NOT B-OR BACKGROUND-COLOR BACKGROUND-COLOUR BEEP " +
          "BEFORE BELL BINARY BIT BITS " +
          "BLANK BLINK BLOCK BOOLEAN BOTTOM " +
          "BY CALL CANCEL CD CF " +
          "CH CHARACTER CHARACTERS CLASS CLOCK-UNITS " +
          "CLOSE COBOL CODE CODE-SET COL " +
          "COLLATING COLUMN COMMA COMMIT COMMITMENT " +
          "COMMON COMMUNICATION COMP COMP-0 COMP-1 " +
          "COMP-2 COMP-3 COMP-4 COMP-5 COMP-6 " +
          "COMP-7 COMP-8 COMP-9 COMPUTATIONAL COMPUTATIONAL-0 " +
          "COMPUTATIONAL-1 COMPUTATIONAL-2 COMPUTATIONAL-3 COMPUTATIONAL-4 COMPUTATIONAL-5 " +
          "COMPUTATIONAL-6 COMPUTATIONAL-7 COMPUTATIONAL-8 COMPUTATIONAL-9 COMPUTE " +
          "CONFIGURATION CONNECT CONSOLE CONTAINED CONTAINS " +
          "CONTENT CONTINUE CONTROL CONTROL-AREA CONTROLS " +
          "CONVERTING COPY CORR CORRESPONDING COUNT " +
          "CRT CRT-UNDER CURRENCY CURRENT CURSOR " +
          "DATA DATE DATE-COMPILED DATE-WRITTEN DAY " +
          "DAY-OF-WEEK DB DB-ACCESS-CONTROL-KEY DB-DATA-NAME DB-EXCEPTION " +
          "DB-FORMAT-NAME DB-RECORD-NAME DB-SET-NAME DB-STATUS DBCS " +
          "DBCS-EDITED DE DEBUG-CONTENTS DEBUG-ITEM DEBUG-LINE " +
          "DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3 DEBUGGING " +
          "DECIMAL-POINT DECLARATIVES DEFAULT DELETE DELIMITED " +
          "DELIMITER DEPENDING DESCENDING DESCRIBED DESTINATION " +
          "DETAIL DISABLE DISCONNECT DISPLAY DISPLAY-1 " +
          "DISPLAY-2 DISPLAY-3 DISPLAY-4 DISPLAY-5 DISPLAY-6 " +
          "DISPLAY-7 DISPLAY-8 DISPLAY-9 DIVIDE DIVISION " +
          "DOWN DROP DUPLICATE DUPLICATES DYNAMIC " +
          "EBCDIC EGI EJECT ELSE EMI " +
          "EMPTY EMPTY-CHECK ENABLE END END. END-ACCEPT END-ACCEPT. " +
          "END-ADD END-CALL END-COMPUTE END-DELETE END-DISPLAY " +
          "END-DIVIDE END-EVALUATE END-IF END-INVOKE END-MULTIPLY " +
          "END-OF-PAGE END-PERFORM END-READ END-RECEIVE END-RETURN " +
          "END-REWRITE END-SEARCH END-START END-STRING END-SUBTRACT " +
          "END-UNSTRING END-WRITE END-XML ENTER ENTRY " +
          "ENVIRONMENT EOP EQUAL EQUALS ERASE " +
          "ERROR ESI EVALUATE EVERY EXCEEDS " +
          "EXCEPTION EXCLUSIVE EXIT EXTEND EXTERNAL " +
          "EXTERNALLY-DESCRIBED-KEY FD FETCH FILE FILE-CONTROL " +
          "FILE-STREAM FILES FILLER FINAL FIND " +
          "FINISH FIRST FOOTING FOR FOREGROUND-COLOR " +
          "FOREGROUND-COLOUR FORMAT FREE FROM FULL " +
          "FUNCTION GENERATE GET GIVING GLOBAL " +
          "GO GOBACK GREATER GROUP HEADING " +
          "HIGH-VALUE HIGH-VALUES HIGHLIGHT I-O I-O-CONTROL " +
          "ID IDENTIFICATION IF IN INDEX " +
          "INDEX-1 INDEX-2 INDEX-3 INDEX-4 INDEX-5 " +
          "INDEX-6 INDEX-7 INDEX-8 INDEX-9 INDEXED " +
          "INDIC INDICATE INDICATOR INDICATORS INITIAL " +
          "INITIALIZE INITIATE INPUT INPUT-OUTPUT INSPECT " +
          "INSTALLATION INTO INVALID INVOKE IS " +
          "JUST JUSTIFIED KANJI KEEP KEY " +
          "LABEL LAST LD LEADING LEFT " +
          "LEFT-JUSTIFY LENGTH LENGTH-CHECK LESS LIBRARY " +
          "LIKE LIMIT LIMITS LINAGE LINAGE-COUNTER " +
          "LINE LINE-COUNTER LINES LINKAGE LOCAL-STORAGE " +
          "LOCALE LOCALLY LOCK " +
          "MEMBER MEMORY MERGE MESSAGE METACLASS " +
          "MODE MODIFIED MODIFY MODULES MOVE " +
          "MULTIPLE MULTIPLY NATIONAL NATIVE NEGATIVE " +
          "NEXT NO NO-ECHO NONE NOT " +
          "NULL NULL-KEY-MAP NULL-MAP NULLS NUMBER " +
          "NUMERIC NUMERIC-EDITED OBJECT OBJECT-COMPUTER OCCURS " +
          "OF OFF OMITTED ON ONLY " +
          "OPEN OPTIONAL OR ORDER ORGANIZATION " +
          "OTHER OUTPUT OVERFLOW OWNER PACKED-DECIMAL " +
          "PADDING PAGE PAGE-COUNTER PARSE PERFORM " +
          "PF PH PIC PICTURE PLUS " +
          "POINTER POSITION POSITIVE PREFIX PRESENT " +
          "PRINTING PRIOR PROCEDURE PROCEDURE-POINTER PROCEDURES " +
          "PROCEED PROCESS PROCESSING PROGRAM PROGRAM-ID " +
          "PROMPT PROTECTED PURGE QUEUE QUOTE " +
          "QUOTES RANDOM RD READ READY " +
          "REALM RECEIVE RECONNECT RECORD RECORD-NAME " +
          "RECORDS RECURSIVE REDEFINES REEL REFERENCE " +
          "REFERENCE-MONITOR REFERENCES RELATION RELATIVE RELEASE " +
          "REMAINDER REMOVAL RENAMES REPEATED REPLACE " +
          "REPLACING REPORT REPORTING REPORTS REPOSITORY " +
          "REQUIRED RERUN RESERVE RESET RETAINING " +
          "RETRIEVAL RETURN RETURN-CODE RETURNING REVERSE-VIDEO " +
          "REVERSED REWIND REWRITE RF RH " +
          "RIGHT RIGHT-JUSTIFY ROLLBACK ROLLING ROUNDED " +
          "RUN SAME SCREEN SD SEARCH " +
          "SECTION SECURE SECURITY SEGMENT SEGMENT-LIMIT " +
          "SELECT SEND SENTENCE SEPARATE SEQUENCE " +
          "SEQUENTIAL SET SHARED SIGN SIZE " +
          "SKIP1 SKIP2 SKIP3 SORT SORT-MERGE " +
          "SORT-RETURN SOURCE SOURCE-COMPUTER SPACE-FILL " +
          "SPECIAL-NAMES STANDARD STANDARD-1 STANDARD-2 " +
          "START STARTING STATUS STOP STORE " +
          "STRING SUB-QUEUE-1 SUB-QUEUE-2 SUB-QUEUE-3 SUB-SCHEMA " +
          "SUBFILE SUBSTITUTE SUBTRACT SUM SUPPRESS " +
          "SYMBOLIC SYNC SYNCHRONIZED SYSIN SYSOUT " +
          "TABLE TALLYING TAPE TENANT TERMINAL " +
          "TERMINATE TEST TEXT THAN THEN " +
          "THROUGH THRU TIME TIMES TITLE " +
          "TO TOP TRAILING TRAILING-SIGN TRANSACTION " +
          "TYPE TYPEDEF UNDERLINE UNEQUAL UNIT " +
          "UNSTRING UNTIL UP UPDATE UPON " +
          "USAGE USAGE-MODE USE USING VALID " +
          "VALIDATE VALUE VALUES VARYING VLR " +
          "WAIT WHEN WHEN-COMPILED WITH WITHIN " +
          "WORDS WORKING-STORAGE WRITE XML XML-CODE " +
          "XML-EVENT XML-NTEXT XML-TEXT ZERO ZERO-FILL " );

      var builtins = makeKeywords("- * ** / + < <= = > >= ");
      var tests = {
        digit: /\d/,
        digit_or_colon: /[\d:]/,
        hex: /[0-9a-f]/i,
        sign: /[+-]/,
        exponent: /e/i,
        keyword_char: /[^\s\(\[\;\)\]]/,
        symbol: /[\w*+\-]/
      };
      function isNumber(ch, stream){
        // hex
        if ( ch === '0' && stream.eat(/x/i) ) {
          stream.eatWhile(tests.hex);
          return true;
        }
        // leading sign
        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {
          stream.eat(tests.sign);
          ch = stream.next();
        }
        if ( tests.digit.test(ch) ) {
          stream.eat(ch);
          stream.eatWhile(tests.digit);
          if ( '.' == stream.peek()) {
            stream.eat('.');
            stream.eatWhile(tests.digit);
          }
          if ( stream.eat(tests.exponent) ) {
            stream.eat(tests.sign);
            stream.eatWhile(tests.digit);
          }
          return true;
        }
        return false;
      }
      return {
        startState: function () {
          return {
            indentStack: null,
            indentation: 0,
            mode: false
          };
        },
        token: function (stream, state) {
          if (state.indentStack == null && stream.sol()) {
            // update indentation, but only if indentStack is empty
            state.indentation = 6 ; //stream.indentation();
          }
          // skip spaces
          if (stream.eatSpace()) {
            return null;
          }
          var returnType = null;
          switch(state.mode){
          case "string": // multi-line string parsing mode
            var next = false;
            while ((next = stream.next()) != null) {
              if (next == "\"" || next == "\'") {
                state.mode = false;
                break;
              }
            }
            returnType = STRING; // continue on in string mode
            break;
          default: // default parsing mode
            var ch = stream.next();
            var col = stream.column();
            if (col >= 0 && col <= 5) {
              returnType = COBOLLINENUM;
            } else if (col >= 72 && col <= 79) {
              stream.skipToEnd();
              returnType = MODTAG;
            } else if (ch == "*" && col == 6) { // comment
              stream.skipToEnd(); // rest of the line is a comment
              returnType = COMMENT;
            } else if (ch == "\"" || ch == "\'") {
              state.mode = "string";
              returnType = STRING;
            } else if (ch == "'" && !( tests.digit_or_colon.test(stream.peek()) )) {
              returnType = ATOM;
            } else if (ch == ".") {
              returnType = PERIOD;
            } else if (isNumber(ch,stream)){
              returnType = NUMBER;
            } else {
              if (stream.current().match(tests.symbol)) {
                while (col < 71) {
                  if (stream.eat(tests.symbol) === undefined) {
                    break;
                  } else {
                    col++;
                  }
                }
              }
              if (keywords && keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
                returnType = KEYWORD;
              } else if (builtins && builtins.propertyIsEnumerable(stream.current().toUpperCase())) {
                returnType = BUILTIN;
              } else if (atoms && atoms.propertyIsEnumerable(stream.current().toUpperCase())) {
                returnType = ATOM;
              } else returnType = null;
            }
          }
          return returnType;
        },
        indent: function (state) {
          if (state.indentStack == null) return state.indentation;
          return state.indentStack.indent;
        }
      };
    });

    CodeMirror.defineMIME("text/x-cobol", "cobol");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Link to the project's GitHub page:
     * https://github.com/pickhardt/coffeescript-codemirror-mode
     */
    function Coffeescript(CodeMirror) {

    CodeMirror.defineMode("coffeescript", function(conf, parserConf) {
      var ERRORCLASS = "error";

      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
      var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
      var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
      var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

      var wordOperators = wordRegexp(["and", "or", "not",
                                      "is", "isnt", "in",
                                      "instanceof", "typeof"]);
      var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                            "switch", "try", "catch", "finally", "class"];
      var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                            "do", "in", "of", "new", "return", "then",
                            "this", "@", "throw", "when", "until", "extends"];

      var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

      indentKeywords = wordRegexp(indentKeywords);


      var stringPrefixes = /^('{3}|\"{3}|['\"])/;
      var regexPrefixes = /^(\/{3}|\/)/;
      var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
      var constants = wordRegexp(commonConstants);

      // Tokenizers
      function tokenBase(stream, state) {
        // Handle scope changes
        if (stream.sol()) {
          if (state.scope.align === null) state.scope.align = false;
          var scopeOffset = state.scope.offset;
          if (stream.eatSpace()) {
            var lineOffset = stream.indentation();
            if (lineOffset > scopeOffset && state.scope.type == "coffee") {
              return "indent";
            } else if (lineOffset < scopeOffset) {
              return "dedent";
            }
            return null;
          } else {
            if (scopeOffset > 0) {
              dedent(stream, state);
            }
          }
        }
        if (stream.eatSpace()) {
          return null;
        }

        var ch = stream.peek();

        // Handle docco title comment (single line)
        if (stream.match("####")) {
          stream.skipToEnd();
          return "comment";
        }

        // Handle multi line comments
        if (stream.match("###")) {
          state.tokenize = longComment;
          return state.tokenize(stream, state);
        }

        // Single line comment
        if (ch === "#") {
          stream.skipToEnd();
          return "comment";
        }

        // Handle number literals
        if (stream.match(/^-?[0-9\.]/, false)) {
          var floatLiteral = false;
          // Floats
          if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
            floatLiteral = true;
          }
          if (stream.match(/^-?\d+\.\d*/)) {
            floatLiteral = true;
          }
          if (stream.match(/^-?\.\d+/)) {
            floatLiteral = true;
          }

          if (floatLiteral) {
            // prevent from getting extra . on 1..
            if (stream.peek() == "."){
              stream.backUp(1);
            }
            return "number";
          }
          // Integers
          var intLiteral = false;
          // Hex
          if (stream.match(/^-?0x[0-9a-f]+/i)) {
            intLiteral = true;
          }
          // Decimal
          if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
            intLiteral = true;
          }
          // Zero by itself with no other piece of number.
          if (stream.match(/^-?0(?![\dx])/i)) {
            intLiteral = true;
          }
          if (intLiteral) {
            return "number";
          }
        }

        // Handle strings
        if (stream.match(stringPrefixes)) {
          state.tokenize = tokenFactory(stream.current(), false, "string");
          return state.tokenize(stream, state);
        }
        // Handle regex literals
        if (stream.match(regexPrefixes)) {
          if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
            state.tokenize = tokenFactory(stream.current(), true, "string-2");
            return state.tokenize(stream, state);
          } else {
            stream.backUp(1);
          }
        }



        // Handle operators and delimiters
        if (stream.match(operators) || stream.match(wordOperators)) {
          return "operator";
        }
        if (stream.match(delimiters)) {
          return "punctuation";
        }

        if (stream.match(constants)) {
          return "atom";
        }

        if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
          return "property";
        }

        if (stream.match(keywords)) {
          return "keyword";
        }

        if (stream.match(identifiers)) {
          return "variable";
        }

        // Handle non-detected items
        stream.next();
        return ERRORCLASS;
      }

      function tokenFactory(delimiter, singleline, outclass) {
        return function(stream, state) {
          while (!stream.eol()) {
            stream.eatWhile(/[^'"\/\\]/);
            if (stream.eat("\\")) {
              stream.next();
              if (singleline && stream.eol()) {
                return outclass;
              }
            } else if (stream.match(delimiter)) {
              state.tokenize = tokenBase;
              return outclass;
            } else {
              stream.eat(/['"\/]/);
            }
          }
          if (singleline) {
            if (parserConf.singleLineStringErrors) {
              outclass = ERRORCLASS;
            } else {
              state.tokenize = tokenBase;
            }
          }
          return outclass;
        };
      }

      function longComment(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^#]/);
          if (stream.match("###")) {
            state.tokenize = tokenBase;
            break;
          }
          stream.eatWhile("#");
        }
        return "comment";
      }

      function indent(stream, state, type) {
        type = type || "coffee";
        var offset = 0, align = false, alignOffset = null;
        for (var scope = state.scope; scope; scope = scope.prev) {
          if (scope.type === "coffee" || scope.type == "}") {
            offset = scope.offset + conf.indentUnit;
            break;
          }
        }
        if (type !== "coffee") {
          align = null;
          alignOffset = stream.column() + stream.current().length;
        } else if (state.scope.align) {
          state.scope.align = false;
        }
        state.scope = {
          offset: offset,
          type: type,
          prev: state.scope,
          align: align,
          alignOffset: alignOffset
        };
      }

      function dedent(stream, state) {
        if (!state.scope.prev) return;
        if (state.scope.type === "coffee") {
          var _indent = stream.indentation();
          var matched = false;
          for (var scope = state.scope; scope; scope = scope.prev) {
            if (_indent === scope.offset) {
              matched = true;
              break;
            }
          }
          if (!matched) {
            return true;
          }
          while (state.scope.prev && state.scope.offset !== _indent) {
            state.scope = state.scope.prev;
          }
          return false;
        } else {
          state.scope = state.scope.prev;
          return false;
        }
      }

      function tokenLexer(stream, state) {
        var style = state.tokenize(stream, state);
        var current = stream.current();

        // Handle scope changes.
        if (current === "return") {
          state.dedent = true;
        }
        if (((current === "->" || current === "=>") && stream.eol())
            || style === "indent") {
          indent(stream, state);
        }
        var delimiter_index = "[({".indexOf(current);
        if (delimiter_index !== -1) {
          indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
        }
        if (indentKeywords.exec(current)){
          indent(stream, state);
        }
        if (current == "then"){
          dedent(stream, state);
        }


        if (style === "dedent") {
          if (dedent(stream, state)) {
            return ERRORCLASS;
          }
        }
        delimiter_index = "])}".indexOf(current);
        if (delimiter_index !== -1) {
          while (state.scope.type == "coffee" && state.scope.prev)
            state.scope = state.scope.prev;
          if (state.scope.type == current)
            state.scope = state.scope.prev;
        }
        if (state.dedent && stream.eol()) {
          if (state.scope.type == "coffee" && state.scope.prev)
            state.scope = state.scope.prev;
          state.dedent = false;
        }

        return style;
      }

      var external = {
        startState: function(basecolumn) {
          return {
            tokenize: tokenBase,
            scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
            prop: false,
            dedent: 0
          };
        },

        token: function(stream, state) {
          var fillAlign = state.scope.align === null && state.scope;
          if (fillAlign && stream.sol()) fillAlign.align = false;

          var style = tokenLexer(stream, state);
          if (style && style != "comment") {
            if (fillAlign) fillAlign.align = true;
            state.prop = style == "punctuation" && stream.current() == ".";
          }

          return style;
        },

        indent: function(state, text) {
          if (state.tokenize != tokenBase) return 0;
          var scope = state.scope;
          var closer = text && "])}".indexOf(text.charAt(0)) > -1;
          if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
          var closes = closer && scope.type === text.charAt(0);
          if (scope.align)
            return scope.alignOffset - (closes ? 1 : 0);
          else
            return (closes ? scope.prev : scope).offset;
        },

        lineComment: "#",
        fold: "indent"
      };
      return external;
    });

    // IANA registered media type
    // https://www.iana.org/assignments/media-types/
    CodeMirror.defineMIME("application/vnd.coffeescript", "coffeescript");

    CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
    CodeMirror.defineMIME("text/coffeescript", "coffeescript");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Commonlisp(CodeMirror) {
    CodeMirror.defineMode("commonlisp", function (config) {
      var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;
      var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;
      var numLiteral = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/;
      var symbol = /[^\s'`,@()\[\]";]/;
      var type;

      function readSym(stream) {
        var ch;
        while (ch = stream.next()) {
          if (ch == "\\") stream.next();
          else if (!symbol.test(ch)) { stream.backUp(1); break; }
        }
        return stream.current();
      }

      function base(stream, state) {
        if (stream.eatSpace()) {type = "ws"; return null;}
        if (stream.match(numLiteral)) return "number";
        var ch = stream.next();
        if (ch == "\\") ch = stream.next();

        if (ch == '"') return (state.tokenize = inString)(stream, state);
        else if (ch == "(") { type = "open"; return "bracket"; }
        else if (ch == ")" || ch == "]") { type = "close"; return "bracket"; }
        else if (ch == ";") { stream.skipToEnd(); type = "ws"; return "comment"; }
        else if (/['`,@]/.test(ch)) return null;
        else if (ch == "|") {
          if (stream.skipTo("|")) { stream.next(); return "symbol"; }
          else { stream.skipToEnd(); return "error"; }
        } else if (ch == "#") {
          var ch = stream.next();
          if (ch == "(") { type = "open"; return "bracket"; }
          else if (/[+\-=\.']/.test(ch)) return null;
          else if (/\d/.test(ch) && stream.match(/^\d*#/)) return null;
          else if (ch == "|") return (state.tokenize = inComment)(stream, state);
          else if (ch == ":") { readSym(stream); return "meta"; }
          else if (ch == "\\") { stream.next(); readSym(stream); return "string-2" }
          else return "error";
        } else {
          var name = readSym(stream);
          if (name == ".") return null;
          type = "symbol";
          if (name == "nil" || name == "t" || name.charAt(0) == ":") return "atom";
          if (state.lastType == "open" && (specialForm.test(name) || assumeBody.test(name))) return "keyword";
          if (name.charAt(0) == "&") return "variable-2";
          return "variable";
        }
      }

      function inString(stream, state) {
        var escaped = false, next;
        while (next = stream.next()) {
          if (next == '"' && !escaped) { state.tokenize = base; break; }
          escaped = !escaped && next == "\\";
        }
        return "string";
      }

      function inComment(stream, state) {
        var next, last;
        while (next = stream.next()) {
          if (next == "#" && last == "|") { state.tokenize = base; break; }
          last = next;
        }
        type = "ws";
        return "comment";
      }

      return {
        startState: function () {
          return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};
        },

        token: function (stream, state) {
          if (stream.sol() && typeof state.ctx.indentTo != "number")
            state.ctx.indentTo = state.ctx.start + 1;

          type = null;
          var style = state.tokenize(stream, state);
          if (type != "ws") {
            if (state.ctx.indentTo == null) {
              if (type == "symbol" && assumeBody.test(stream.current()))
                state.ctx.indentTo = state.ctx.start + config.indentUnit;
              else
                state.ctx.indentTo = "next";
            } else if (state.ctx.indentTo == "next") {
              state.ctx.indentTo = stream.column();
            }
            state.lastType = type;
          }
          if (type == "open") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
          else if (type == "close") state.ctx = state.ctx.prev || state.ctx;
          return style;
        },

        indent: function (state, _textAfter) {
          var i = state.ctx.indentTo;
          return typeof i == "number" ? i : state.ctx.start + 1;
        },

        closeBrackets: {pairs: "()[]{}\"\""},
        lineComment: ";;",
        blockCommentStart: "#|",
        blockCommentEnd: "|#"
      };
    });

    CodeMirror.defineMIME("text/x-common-lisp", "commonlisp");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Crystal(CodeMirror) {
      CodeMirror.defineMode("crystal", function(config) {
        function wordRegExp(words, end) {
          return new RegExp((end ? "" : "^") + "(?:" + words.join("|") + ")" + (end ? "$" : "\\b"));
        }

        function chain(tokenize, stream, state) {
          state.tokenize.push(tokenize);
          return tokenize(stream, state);
        }

        var operators = /^(?:[-+/%|&^]|\*\*?|[<>]{2})/;
        var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;
        var indexingOperators = /^(?:\[\][?=]?)/;
        var anotherOperators = /^(?:\.(?:\.{2})?|->|[?:])/;
        var idents = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
        var types = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
        var keywords = wordRegExp([
          "abstract", "alias", "as", "asm", "begin", "break", "case", "class", "def", "do",
          "else", "elsif", "end", "ensure", "enum", "extend", "for", "fun", "if",
          "include", "instance_sizeof", "lib", "macro", "module", "next", "of", "out", "pointerof",
          "private", "protected", "rescue", "return", "require", "select", "sizeof", "struct",
          "super", "then", "type", "typeof", "uninitialized", "union", "unless", "until", "when", "while", "with",
          "yield", "__DIR__", "__END_LINE__", "__FILE__", "__LINE__"
        ]);
        var atomWords = wordRegExp(["true", "false", "nil", "self"]);
        var indentKeywordsArray = [
          "def", "fun", "macro",
          "class", "module", "struct", "lib", "enum", "union",
          "do", "for"
        ];
        var indentKeywords = wordRegExp(indentKeywordsArray);
        var indentExpressionKeywordsArray = ["if", "unless", "case", "while", "until", "begin", "then"];
        var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);
        var dedentKeywordsArray = ["end", "else", "elsif", "rescue", "ensure"];
        var dedentKeywords = wordRegExp(dedentKeywordsArray);
        var dedentPunctualsArray = ["\\)", "\\}", "\\]"];
        var dedentPunctuals = new RegExp("^(?:" + dedentPunctualsArray.join("|") + ")$");
        var nextTokenizer = {
          "def": tokenFollowIdent, "fun": tokenFollowIdent, "macro": tokenMacroDef,
          "class": tokenFollowType, "module": tokenFollowType, "struct": tokenFollowType,
          "lib": tokenFollowType, "enum": tokenFollowType, "union": tokenFollowType
        };
        var matching = {"[": "]", "{": "}", "(": ")", "<": ">"};

        function tokenBase(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          // Macros
          if (state.lastToken != "\\" && stream.match("{%", false)) {
            return chain(tokenMacro("%", "%"), stream, state);
          }

          if (state.lastToken != "\\" && stream.match("{{", false)) {
            return chain(tokenMacro("{", "}"), stream, state);
          }

          // Comments
          if (stream.peek() == "#") {
            stream.skipToEnd();
            return "comment";
          }

          // Variables and keywords
          var matched;
          if (stream.match(idents)) {
            stream.eat(/[?!]/);

            matched = stream.current();
            if (stream.eat(":")) {
              return "atom";
            } else if (state.lastToken == ".") {
              return "property";
            } else if (keywords.test(matched)) {
              if (indentKeywords.test(matched)) {
                if (!(matched == "fun" && state.blocks.indexOf("lib") >= 0) && !(matched == "def" && state.lastToken == "abstract")) {
                  state.blocks.push(matched);
                  state.currentIndent += 1;
                }
              } else if ((state.lastStyle == "operator" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {
                state.blocks.push(matched);
                state.currentIndent += 1;
              } else if (matched == "end") {
                state.blocks.pop();
                state.currentIndent -= 1;
              }

              if (nextTokenizer.hasOwnProperty(matched)) {
                state.tokenize.push(nextTokenizer[matched]);
              }

              return "keyword";
            } else if (atomWords.test(matched)) {
              return "atom";
            }

            return "variable";
          }

          // Class variables and instance variables
          // or attributes
          if (stream.eat("@")) {
            if (stream.peek() == "[") {
              return chain(tokenNest("[", "]", "meta"), stream, state);
            }

            stream.eat("@");
            stream.match(idents) || stream.match(types);
            return "variable-2";
          }

          // Constants and types
          if (stream.match(types)) {
            return "tag";
          }

          // Symbols or ':' operator
          if (stream.eat(":")) {
            if (stream.eat("\"")) {
              return chain(tokenQuote("\"", "atom", false), stream, state);
            } else if (stream.match(idents) || stream.match(types) ||
                       stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {
              return "atom";
            }
            stream.eat(":");
            return "operator";
          }

          // Strings
          if (stream.eat("\"")) {
            return chain(tokenQuote("\"", "string", true), stream, state);
          }

          // Strings or regexps or macro variables or '%' operator
          if (stream.peek() == "%") {
            var style = "string";
            var embed = true;
            var delim;

            if (stream.match("%r")) {
              // Regexps
              style = "string-2";
              delim = stream.next();
            } else if (stream.match("%w")) {
              embed = false;
              delim = stream.next();
            } else if (stream.match("%q")) {
              embed = false;
              delim = stream.next();
            } else {
              if(delim = stream.match(/^%([^\w\s=])/)) {
                delim = delim[1];
              } else if (stream.match(/^%[a-zA-Z0-9_\u009F-\uFFFF]*/)) {
                // Macro variables
                return "meta";
              } else {
                // '%' operator
                return "operator";
              }
            }

            if (matching.hasOwnProperty(delim)) {
              delim = matching[delim];
            }
            return chain(tokenQuote(delim, style, embed), stream, state);
          }

          // Here Docs
          if (matched = stream.match(/^<<-('?)([A-Z]\w*)\1/)) {
            return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)
          }

          // Characters
          if (stream.eat("'")) {
            stream.match(/^(?:[^']|\\(?:[befnrtv0'"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]{1,6}\})))/);
            stream.eat("'");
            return "atom";
          }

          // Numbers
          if (stream.eat("0")) {
            if (stream.eat("x")) {
              stream.match(/^[0-9a-fA-F]+/);
            } else if (stream.eat("o")) {
              stream.match(/^[0-7]+/);
            } else if (stream.eat("b")) {
              stream.match(/^[01]+/);
            }
            return "number";
          }

          if (stream.eat(/^\d/)) {
            stream.match(/^\d*(?:\.\d+)?(?:[eE][+-]?\d+)?/);
            return "number";
          }

          // Operators
          if (stream.match(operators)) {
            stream.eat("="); // Operators can follow assign symbol.
            return "operator";
          }

          if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {
            return "operator";
          }

          // Parens and braces
          if (matched = stream.match(/[({[]/, false)) {
            matched = matched[0];
            return chain(tokenNest(matched, matching[matched], null), stream, state);
          }

          // Escapes
          if (stream.eat("\\")) {
            stream.next();
            return "meta";
          }

          stream.next();
          return null;
        }

        function tokenNest(begin, end, style, started) {
          return function (stream, state) {
            if (!started && stream.match(begin)) {
              state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);
              state.currentIndent += 1;
              return style;
            }

            var nextStyle = tokenBase(stream, state);
            if (stream.current() === end) {
              state.tokenize.pop();
              state.currentIndent -= 1;
              nextStyle = style;
            }

            return nextStyle;
          };
        }

        function tokenMacro(begin, end, started) {
          return function (stream, state) {
            if (!started && stream.match("{" + begin)) {
              state.currentIndent += 1;
              state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);
              return "meta";
            }

            if (stream.match(end + "}")) {
              state.currentIndent -= 1;
              state.tokenize.pop();
              return "meta";
            }

            return tokenBase(stream, state);
          };
        }

        function tokenMacroDef(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          var matched;
          if (matched = stream.match(idents)) {
            if (matched == "def") {
              return "keyword";
            }
            stream.eat(/[?!]/);
          }

          state.tokenize.pop();
          return "def";
        }

        function tokenFollowIdent(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          if (stream.match(idents)) {
            stream.eat(/[!?]/);
          } else {
            stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);
          }
          state.tokenize.pop();
          return "def";
        }

        function tokenFollowType(stream, state) {
          if (stream.eatSpace()) {
            return null;
          }

          stream.match(types);
          state.tokenize.pop();
          return "def";
        }

        function tokenQuote(end, style, embed) {
          return function (stream, state) {
            var escaped = false;

            while (stream.peek()) {
              if (!escaped) {
                if (stream.match("{%", false)) {
                  state.tokenize.push(tokenMacro("%", "%"));
                  return style;
                }

                if (stream.match("{{", false)) {
                  state.tokenize.push(tokenMacro("{", "}"));
                  return style;
                }

                if (embed && stream.match("#{", false)) {
                  state.tokenize.push(tokenNest("#{", "}", "meta"));
                  return style;
                }

                var ch = stream.next();

                if (ch == end) {
                  state.tokenize.pop();
                  return style;
                }

                escaped = embed && ch == "\\";
              } else {
                stream.next();
                escaped = false;
              }
            }

            return style;
          };
        }

        function tokenHereDoc(phrase, embed) {
          return function (stream, state) {
            if (stream.sol()) {
              stream.eatSpace();
              if (stream.match(phrase)) {
                state.tokenize.pop();
                return "string";
              }
            }

            var escaped = false;
            while (stream.peek()) {
              if (!escaped) {
                if (stream.match("{%", false)) {
                  state.tokenize.push(tokenMacro("%", "%"));
                  return "string";
                }

                if (stream.match("{{", false)) {
                  state.tokenize.push(tokenMacro("{", "}"));
                  return "string";
                }

                if (embed && stream.match("#{", false)) {
                  state.tokenize.push(tokenNest("#{", "}", "meta"));
                  return "string";
                }

                escaped = embed && stream.next() == "\\";
              } else {
                stream.next();
                escaped = false;
              }
            }

            return "string";
          }
        }

        return {
          startState: function () {
            return {
              tokenize: [tokenBase],
              currentIndent: 0,
              lastToken: null,
              lastStyle: null,
              blocks: []
            };
          },

          token: function (stream, state) {
            var style = state.tokenize[state.tokenize.length - 1](stream, state);
            var token = stream.current();

            if (style && style != "comment") {
              state.lastToken = token;
              state.lastStyle = style;
            }

            return style;
          },

          indent: function (state, textAfter) {
            textAfter = textAfter.replace(/^\s*(?:\{%)?\s*|\s*(?:%\})?\s*$/g, "");

            if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {
              return config.indentUnit * (state.currentIndent - 1);
            }

            return config.indentUnit * state.currentIndent;
          },

          fold: "indent",
          electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),
          lineComment: '#'
        };
      });

      CodeMirror.defineMIME("text/x-crystal", "crystal");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function CSS(CodeMirror) {
    CodeMirror.defineMode("css", function(config, parserConfig) {
      var inline = parserConfig.inline;
      if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

      var indentUnit = config.indentUnit,
          tokenHooks = parserConfig.tokenHooks,
          documentTypes = parserConfig.documentTypes || {},
          mediaTypes = parserConfig.mediaTypes || {},
          mediaFeatures = parserConfig.mediaFeatures || {},
          mediaValueKeywords = parserConfig.mediaValueKeywords || {},
          propertyKeywords = parserConfig.propertyKeywords || {},
          nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
          fontProperties = parserConfig.fontProperties || {},
          counterDescriptors = parserConfig.counterDescriptors || {},
          colorKeywords = parserConfig.colorKeywords || {},
          valueKeywords = parserConfig.valueKeywords || {},
          allowNested = parserConfig.allowNested,
          lineComment = parserConfig.lineComment,
          supportsAtComponent = parserConfig.supportsAtComponent === true;

      var type, override;
      function ret(style, tp) { type = tp; return style; }

      // Tokenizers

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (tokenHooks[ch]) {
          var result = tokenHooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == "@") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("def", stream.current());
        } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
          return ret(null, "compare");
        } else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "#") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("atom", "hash");
        } else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (ch === "-") {
          if (/[\d.]/.test(stream.peek())) {
            stream.eatWhile(/[\w.%]/);
            return ret("number", "unit");
          } else if (stream.match(/^-[\w\\\-]*/)) {
            stream.eatWhile(/[\w\\\-]/);
            if (stream.match(/^\s*:/, false))
              return ret("variable-2", "variable-definition");
            return ret("variable-2", "variable");
          } else if (stream.match(/^\w+-/)) {
            return ret("meta", "meta");
          }
        } else if (/[,+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
          return ret("qualifier", "qualifier");
        } else if (/[:;{}\[\]\(\)]/.test(ch)) {
          return ret(null, ch);
        } else if (stream.match(/[\w-.]+(?=\()/)) {
          if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
            state.tokenize = tokenParenthesized;
          }
          return ret("variable callee", "variable");
        } else if (/[\w\\\-]/.test(ch)) {
          stream.eatWhile(/[\w\\\-]/);
          return ret("property", "word");
        } else {
          return ret(null, null);
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              if (quote == ")") stream.backUp(1);
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          if (ch == quote || !escaped && quote != ")") state.tokenize = null;
          return ret("string", "string");
        };
      }

      function tokenParenthesized(stream, state) {
        stream.next(); // Must be '('
        if (!stream.match(/\s*[\"\')]/, false))
          state.tokenize = tokenString(")");
        else
          state.tokenize = null;
        return ret(null, "(");
      }

      // Context management

      function Context(type, indent, prev) {
        this.type = type;
        this.indent = indent;
        this.prev = prev;
      }

      function pushContext(state, stream, type, indent) {
        state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
        return type;
      }

      function popContext(state) {
        if (state.context.prev)
          state.context = state.context.prev;
        return state.context.type;
      }

      function pass(type, stream, state) {
        return states[state.context.type](type, stream, state);
      }
      function popAndPass(type, stream, state, n) {
        for (var i = n || 1; i > 0; i--)
          state.context = state.context.prev;
        return pass(type, stream, state);
      }

      // Parser

      function wordAsValue(stream) {
        var word = stream.current().toLowerCase();
        if (valueKeywords.hasOwnProperty(word))
          override = "atom";
        else if (colorKeywords.hasOwnProperty(word))
          override = "keyword";
        else
          override = "variable";
      }

      var states = {};

      states.top = function(type, stream, state) {
        if (type == "{") {
          return pushContext(state, stream, "block");
        } else if (type == "}" && state.context.prev) {
          return popContext(state);
        } else if (supportsAtComponent && /@component/i.test(type)) {
          return pushContext(state, stream, "atComponentBlock");
        } else if (/^@(-moz-)?document$/i.test(type)) {
          return pushContext(state, stream, "documentTypes");
        } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
          return pushContext(state, stream, "atBlock");
        } else if (/^@(font-face|counter-style)/i.test(type)) {
          state.stateArg = type;
          return "restricted_atBlock_before";
        } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
          return "keyframes";
        } else if (type && type.charAt(0) == "@") {
          return pushContext(state, stream, "at");
        } else if (type == "hash") {
          override = "builtin";
        } else if (type == "word") {
          override = "tag";
        } else if (type == "variable-definition") {
          return "maybeprop";
        } else if (type == "interpolation") {
          return pushContext(state, stream, "interpolation");
        } else if (type == ":") {
          return "pseudo";
        } else if (allowNested && type == "(") {
          return pushContext(state, stream, "parens");
        }
        return state.context.type;
      };

      states.block = function(type, stream, state) {
        if (type == "word") {
          var word = stream.current().toLowerCase();
          if (propertyKeywords.hasOwnProperty(word)) {
            override = "property";
            return "maybeprop";
          } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
            override = "string-2";
            return "maybeprop";
          } else if (allowNested) {
            override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
            return "block";
          } else {
            override += " error";
            return "maybeprop";
          }
        } else if (type == "meta") {
          return "block";
        } else if (!allowNested && (type == "hash" || type == "qualifier")) {
          override = "error";
          return "block";
        } else {
          return states.top(type, stream, state);
        }
      };

      states.maybeprop = function(type, stream, state) {
        if (type == ":") return pushContext(state, stream, "prop");
        return pass(type, stream, state);
      };

      states.prop = function(type, stream, state) {
        if (type == ";") return popContext(state);
        if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
        if (type == "}" || type == "{") return popAndPass(type, stream, state);
        if (type == "(") return pushContext(state, stream, "parens");

        if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
          override += " error";
        } else if (type == "word") {
          wordAsValue(stream);
        } else if (type == "interpolation") {
          return pushContext(state, stream, "interpolation");
        }
        return "prop";
      };

      states.propBlock = function(type, _stream, state) {
        if (type == "}") return popContext(state);
        if (type == "word") { override = "property"; return "maybeprop"; }
        return state.context.type;
      };

      states.parens = function(type, stream, state) {
        if (type == "{" || type == "}") return popAndPass(type, stream, state);
        if (type == ")") return popContext(state);
        if (type == "(") return pushContext(state, stream, "parens");
        if (type == "interpolation") return pushContext(state, stream, "interpolation");
        if (type == "word") wordAsValue(stream);
        return "parens";
      };

      states.pseudo = function(type, stream, state) {
        if (type == "meta") return "pseudo";

        if (type == "word") {
          override = "variable-3";
          return state.context.type;
        }
        return pass(type, stream, state);
      };

      states.documentTypes = function(type, stream, state) {
        if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
          override = "tag";
          return state.context.type;
        } else {
          return states.atBlock(type, stream, state);
        }
      };

      states.atBlock = function(type, stream, state) {
        if (type == "(") return pushContext(state, stream, "atBlock_parens");
        if (type == "}" || type == ";") return popAndPass(type, stream, state);
        if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

        if (type == "interpolation") return pushContext(state, stream, "interpolation");

        if (type == "word") {
          var word = stream.current().toLowerCase();
          if (word == "only" || word == "not" || word == "and" || word == "or")
            override = "keyword";
          else if (mediaTypes.hasOwnProperty(word))
            override = "attribute";
          else if (mediaFeatures.hasOwnProperty(word))
            override = "property";
          else if (mediaValueKeywords.hasOwnProperty(word))
            override = "keyword";
          else if (propertyKeywords.hasOwnProperty(word))
            override = "property";
          else if (nonStandardPropertyKeywords.hasOwnProperty(word))
            override = "string-2";
          else if (valueKeywords.hasOwnProperty(word))
            override = "atom";
          else if (colorKeywords.hasOwnProperty(word))
            override = "keyword";
          else
            override = "error";
        }
        return state.context.type;
      };

      states.atComponentBlock = function(type, stream, state) {
        if (type == "}")
          return popAndPass(type, stream, state);
        if (type == "{")
          return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
        if (type == "word")
          override = "error";
        return state.context.type;
      };

      states.atBlock_parens = function(type, stream, state) {
        if (type == ")") return popContext(state);
        if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
        return states.atBlock(type, stream, state);
      };

      states.restricted_atBlock_before = function(type, stream, state) {
        if (type == "{")
          return pushContext(state, stream, "restricted_atBlock");
        if (type == "word" && state.stateArg == "@counter-style") {
          override = "variable";
          return "restricted_atBlock_before";
        }
        return pass(type, stream, state);
      };

      states.restricted_atBlock = function(type, stream, state) {
        if (type == "}") {
          state.stateArg = null;
          return popContext(state);
        }
        if (type == "word") {
          if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
              (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
            override = "error";
          else
            override = "property";
          return "maybeprop";
        }
        return "restricted_atBlock";
      };

      states.keyframes = function(type, stream, state) {
        if (type == "word") { override = "variable"; return "keyframes"; }
        if (type == "{") return pushContext(state, stream, "top");
        return pass(type, stream, state);
      };

      states.at = function(type, stream, state) {
        if (type == ";") return popContext(state);
        if (type == "{" || type == "}") return popAndPass(type, stream, state);
        if (type == "word") override = "tag";
        else if (type == "hash") override = "builtin";
        return "at";
      };

      states.interpolation = function(type, stream, state) {
        if (type == "}") return popContext(state);
        if (type == "{" || type == ";") return popAndPass(type, stream, state);
        if (type == "word") override = "variable";
        else if (type != "variable" && type != "(" && type != ")") override = "error";
        return "interpolation";
      };

      return {
        startState: function(base) {
          return {tokenize: null,
                  state: inline ? "block" : "top",
                  stateArg: null,
                  context: new Context(inline ? "block" : "top", base || 0, null)};
        },

        token: function(stream, state) {
          if (!state.tokenize && stream.eatSpace()) return null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style && typeof style == "object") {
            type = style[1];
            style = style[0];
          }
          override = style;
          if (type != "comment")
            state.state = states[state.state](type, stream, state);
          return override;
        },

        indent: function(state, textAfter) {
          var cx = state.context, ch = textAfter && textAfter.charAt(0);
          var indent = cx.indent;
          if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
          if (cx.prev) {
            if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                              cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
              // Resume indentation from parent context.
              cx = cx.prev;
              indent = cx.indent;
            } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
                ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
              // Dedent relative to current context.
              indent = Math.max(0, cx.indent - indentUnit);
            }
          }
          return indent;
        },

        electricChars: "}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        blockCommentContinue: " * ",
        lineComment: lineComment,
        fold: "brace"
      };
    });

      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i].toLowerCase()] = true;
        }
        return keys;
      }

      var documentTypes_ = [
        "domain", "regexp", "url", "url-prefix"
      ], documentTypes = keySet(documentTypes_);

      var mediaTypes_ = [
        "all", "aural", "braille", "handheld", "print", "projection", "screen",
        "tty", "tv", "embossed"
      ], mediaTypes = keySet(mediaTypes_);

      var mediaFeatures_ = [
        "width", "min-width", "max-width", "height", "min-height", "max-height",
        "device-width", "min-device-width", "max-device-width", "device-height",
        "min-device-height", "max-device-height", "aspect-ratio",
        "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
        "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
        "max-color", "color-index", "min-color-index", "max-color-index",
        "monochrome", "min-monochrome", "max-monochrome", "resolution",
        "min-resolution", "max-resolution", "scan", "grid", "orientation",
        "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
        "pointer", "any-pointer", "hover", "any-hover"
      ], mediaFeatures = keySet(mediaFeatures_);

      var mediaValueKeywords_ = [
        "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
        "interlace", "progressive"
      ], mediaValueKeywords = keySet(mediaValueKeywords_);

      var propertyKeywords_ = [
        "align-content", "align-items", "align-self", "alignment-adjust",
        "alignment-baseline", "anchor-point", "animation", "animation-delay",
        "animation-direction", "animation-duration", "animation-fill-mode",
        "animation-iteration-count", "animation-name", "animation-play-state",
        "animation-timing-function", "appearance", "azimuth", "backface-visibility",
        "background", "background-attachment", "background-blend-mode", "background-clip",
        "background-color", "background-image", "background-origin", "background-position",
        "background-repeat", "background-size", "baseline-shift", "binding",
        "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
        "bookmark-target", "border", "border-bottom", "border-bottom-color",
        "border-bottom-left-radius", "border-bottom-right-radius",
        "border-bottom-style", "border-bottom-width", "border-collapse",
        "border-color", "border-image", "border-image-outset",
        "border-image-repeat", "border-image-slice", "border-image-source",
        "border-image-width", "border-left", "border-left-color",
        "border-left-style", "border-left-width", "border-radius", "border-right",
        "border-right-color", "border-right-style", "border-right-width",
        "border-spacing", "border-style", "border-top", "border-top-color",
        "border-top-left-radius", "border-top-right-radius", "border-top-style",
        "border-top-width", "border-width", "bottom", "box-decoration-break",
        "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
        "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
        "column-fill", "column-gap", "column-rule", "column-rule-color",
        "column-rule-style", "column-rule-width", "column-span", "column-width",
        "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
        "cue-after", "cue-before", "cursor", "direction", "display",
        "dominant-baseline", "drop-initial-after-adjust",
        "drop-initial-after-align", "drop-initial-before-adjust",
        "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
        "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
        "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
        "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
        "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
        "font-stretch", "font-style", "font-synthesis", "font-variant",
        "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
        "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
        "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
        "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
        "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
        "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
        "grid-template-rows", "hanging-punctuation", "height", "hyphens",
        "icon", "image-orientation", "image-rendering", "image-resolution",
        "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
        "line-break", "line-height", "line-stacking", "line-stacking-ruby",
        "line-stacking-shift", "line-stacking-strategy", "list-style",
        "list-style-image", "list-style-position", "list-style-type", "margin",
        "margin-bottom", "margin-left", "margin-right", "margin-top",
        "marks", "marquee-direction", "marquee-loop",
        "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
        "max-width", "min-height", "min-width", "mix-blend-mode", "move-to", "nav-down", "nav-index",
        "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
        "opacity", "order", "orphans", "outline",
        "outline-color", "outline-offset", "outline-style", "outline-width",
        "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
        "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
        "page", "page-break-after", "page-break-before", "page-break-inside",
        "page-policy", "pause", "pause-after", "pause-before", "perspective",
        "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
        "presentation-level", "punctuation-trim", "quotes", "region-break-after",
        "region-break-before", "region-break-inside", "region-fragment",
        "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
        "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
        "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
        "shape-outside", "size", "speak", "speak-as", "speak-header",
        "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
        "tab-size", "table-layout", "target", "target-name", "target-new",
        "target-position", "text-align", "text-align-last", "text-decoration",
        "text-decoration-color", "text-decoration-line", "text-decoration-skip",
        "text-decoration-style", "text-emphasis", "text-emphasis-color",
        "text-emphasis-position", "text-emphasis-style", "text-height",
        "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
        "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
        "text-wrap", "top", "transform", "transform-origin", "transform-style",
        "transition", "transition-delay", "transition-duration",
        "transition-property", "transition-timing-function", "unicode-bidi",
        "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
        "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
        "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
        "word-spacing", "word-wrap", "z-index",
        // SVG-specific
        "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
        "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
        "color-interpolation", "color-interpolation-filters",
        "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
        "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
        "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
        "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
        "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
        "glyph-orientation-vertical", "text-anchor", "writing-mode"
      ], propertyKeywords = keySet(propertyKeywords_);

      var nonStandardPropertyKeywords_ = [
        "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
        "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
        "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
        "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
        "searchfield-results-decoration", "zoom"
      ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

      var fontProperties_ = [
        "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
        "font-stretch", "font-weight", "font-style"
      ], fontProperties = keySet(fontProperties_);

      var counterDescriptors_ = [
        "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
        "speak-as", "suffix", "symbols", "system"
      ], counterDescriptors = keySet(counterDescriptors_);

      var colorKeywords_ = [
        "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
        "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
        "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
        "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
        "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
        "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
        "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
        "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
        "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
        "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
        "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
        "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
        "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
        "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
        "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
        "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
        "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
        "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
        "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
        "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
        "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
        "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
        "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
        "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
        "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
        "whitesmoke", "yellow", "yellowgreen"
      ], colorKeywords = keySet(colorKeywords_);

      var valueKeywords_ = [
        "above", "absolute", "activeborder", "additive", "activecaption", "afar",
        "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
        "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
        "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
        "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
        "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
        "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
        "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
        "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
        "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
        "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
        "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
        "compact", "condensed", "contain", "content", "contents",
        "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
        "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
        "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
        "destination-in", "destination-out", "destination-over", "devanagari", "difference",
        "disc", "discard", "disclosure-closed", "disclosure-open", "document",
        "dot-dash", "dot-dot-dash",
        "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
        "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
        "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
        "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
        "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
        "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
        "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
        "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
        "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
        "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
        "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
        "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
        "help", "hidden", "hide", "higher", "highlight", "highlighttext",
        "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
        "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
        "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
        "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
        "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
        "katakana", "katakana-iroha", "keep-all", "khmer",
        "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
        "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
        "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
        "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
        "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
        "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
        "media-controls-background", "media-current-time-display",
        "media-fullscreen-button", "media-mute-button", "media-play-button",
        "media-return-to-realtime-button", "media-rewind-button",
        "media-seek-back-button", "media-seek-forward-button", "media-slider",
        "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
        "media-volume-slider-container", "media-volume-sliderthumb", "medium",
        "menu", "menulist", "menulist-button", "menulist-text",
        "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
        "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
        "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
        "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
        "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
        "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
        "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
        "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
        "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
        "progress", "push-button", "radial-gradient", "radio", "read-only",
        "read-write", "read-write-plaintext-only", "rectangle", "region",
        "relative", "repeat", "repeating-linear-gradient",
        "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
        "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
        "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
        "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
        "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
        "searchfield-cancel-button", "searchfield-decoration",
        "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
        "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
        "simp-chinese-formal", "simp-chinese-informal", "single",
        "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
        "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
        "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
        "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
        "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
        "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
        "table-caption", "table-cell", "table-column", "table-column-group",
        "table-footer-group", "table-header-group", "table-row", "table-row-group",
        "tamil",
        "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
        "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
        "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
        "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
        "trad-chinese-formal", "trad-chinese-informal", "transform",
        "translate", "translate3d", "translateX", "translateY", "translateZ",
        "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
        "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
        "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
        "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
        "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
        "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
        "xx-large", "xx-small"
      ], valueKeywords = keySet(valueKeywords_);

      var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
        .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
        .concat(valueKeywords_);
      CodeMirror.registerHelper("hintWords", "css", allWords);

      function tokenCComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ["comment", "comment"];
      }

      CodeMirror.defineMIME("text/css", {
        documentTypes: documentTypes,
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        fontProperties: fontProperties,
        counterDescriptors: counterDescriptors,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        tokenHooks: {
          "/": function(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
        },
        name: "css"
      });

      CodeMirror.defineMIME("text/x-scss", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          ":": function(stream) {
            if (stream.match(/\s*\{/, false))
              return [null, null]
            return false;
          },
          "$": function(stream) {
            stream.match(/^[\w-]+/);
            if (stream.match(/^\s*:/, false))
              return ["variable-2", "variable-definition"];
            return ["variable-2", "variable"];
          },
          "#": function(stream) {
            if (!stream.eat("{")) return false;
            return [null, "interpolation"];
          }
        },
        name: "css",
        helperType: "scss"
      });

      CodeMirror.defineMIME("text/x-less", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        mediaValueKeywords: mediaValueKeywords,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: true,
        lineComment: "//",
        tokenHooks: {
          "/": function(stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          "@": function(stream) {
            if (stream.eat("{")) return [null, "interpolation"];
            if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
            stream.eatWhile(/[\w\\\-]/);
            if (stream.match(/^\s*:/, false))
              return ["variable-2", "variable-definition"];
            return ["variable-2", "variable"];
          },
          "&": function() {
            return ["atom", "atom"];
          }
        },
        name: "css",
        helperType: "less"
      });

      CodeMirror.defineMIME("text/x-gss", {
        documentTypes: documentTypes,
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        fontProperties: fontProperties,
        counterDescriptors: counterDescriptors,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        supportsAtComponent: true,
        tokenHooks: {
          "/": function(stream, state) {
            if (!stream.eat("*")) return false;
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
        },
        name: "css",
        helperType: "gss"
      });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // By the Neo4j Team and contributors.
    // https://github.com/neo4j-contrib/CodeMirror

    function Cypher(CodeMirror) {
      var wordRegexp = function(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      };

      CodeMirror.defineMode("cypher", function(config) {
        var tokenBase = function(stream/*, state*/) {
          var ch = stream.next();
          if (ch ==='"') {
            stream.match(/.*?"/);
            return "string";
          }
          if (ch === "'") {
            stream.match(/.*?'/);
            return "string";
          }
          if (/[{}\(\),\.;\[\]]/.test(ch)) {
            curPunc = ch;
            return "node";
          } else if (ch === "/" && stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          } else if (operatorChars.test(ch)) {
            stream.eatWhile(operatorChars);
            return null;
          } else {
            stream.eatWhile(/[_\w\d]/);
            if (stream.eat(":")) {
              stream.eatWhile(/[\w\d_\-]/);
              return "atom";
            }
            var word = stream.current();
            if (funcs.test(word)) return "builtin";
            if (preds.test(word)) return "def";
            if (keywords.test(word)) return "keyword";
            return "variable";
          }
        };
        var pushContext = function(state, type, col) {
          return state.context = {
            prev: state.context,
            indent: state.indent,
            col: col,
            type: type
          };
        };
        var popContext = function(state) {
          state.indent = state.context.indent;
          return state.context = state.context.prev;
        };
        var indentUnit = config.indentUnit;
        var curPunc;
        var funcs = wordRegexp(["abs", "acos", "allShortestPaths", "asin", "atan", "atan2", "avg", "ceil", "coalesce", "collect", "cos", "cot", "count", "degrees", "e", "endnode", "exp", "extract", "filter", "floor", "haversin", "head", "id", "keys", "labels", "last", "left", "length", "log", "log10", "lower", "ltrim", "max", "min", "node", "nodes", "percentileCont", "percentileDisc", "pi", "radians", "rand", "range", "reduce", "rel", "relationship", "relationships", "replace", "reverse", "right", "round", "rtrim", "shortestPath", "sign", "sin", "size", "split", "sqrt", "startnode", "stdev", "stdevp", "str", "substring", "sum", "tail", "tan", "timestamp", "toFloat", "toInt", "toString", "trim", "type", "upper"]);
        var preds = wordRegexp(["all", "and", "any", "contains", "exists", "has", "in", "none", "not", "or", "single", "xor"]);
        var keywords = wordRegexp(["as", "asc", "ascending", "assert", "by", "case", "commit", "constraint", "create", "csv", "cypher", "delete", "desc", "descending", "detach", "distinct", "drop", "else", "end", "ends", "explain", "false", "fieldterminator", "foreach", "from", "headers", "in", "index", "is", "join", "limit", "load", "match", "merge", "null", "on", "optional", "order", "periodic", "profile", "remove", "return", "scan", "set", "skip", "start", "starts", "then", "true", "union", "unique", "unwind", "using", "when", "where", "with", "call", "yield"]);
        var operatorChars = /[*+\-<>=&|~%^]/;

        return {
          startState: function(/*base*/) {
            return {
              tokenize: tokenBase,
              context: null,
              indent: 0,
              col: 0
            };
          },
          token: function(stream, state) {
            if (stream.sol()) {
              if (state.context && (state.context.align == null)) {
                state.context.align = false;
              }
              state.indent = stream.indentation();
            }
            if (stream.eatSpace()) {
              return null;
            }
            var style = state.tokenize(stream, state);
            if (style !== "comment" && state.context && (state.context.align == null) && state.context.type !== "pattern") {
              state.context.align = true;
            }
            if (curPunc === "(") {
              pushContext(state, ")", stream.column());
            } else if (curPunc === "[") {
              pushContext(state, "]", stream.column());
            } else if (curPunc === "{") {
              pushContext(state, "}", stream.column());
            } else if (/[\]\}\)]/.test(curPunc)) {
              while (state.context && state.context.type === "pattern") {
                popContext(state);
              }
              if (state.context && curPunc === state.context.type) {
                popContext(state);
              }
            } else if (curPunc === "." && state.context && state.context.type === "pattern") {
              popContext(state);
            } else if (/atom|string|variable/.test(style) && state.context) {
              if (/[\}\]]/.test(state.context.type)) {
                pushContext(state, "pattern", stream.column());
              } else if (state.context.type === "pattern" && !state.context.align) {
                state.context.align = true;
                state.context.col = stream.column();
              }
            }
            return style;
          },
          indent: function(state, textAfter) {
            var firstChar = textAfter && textAfter.charAt(0);
            var context = state.context;
            if (/[\]\}]/.test(firstChar)) {
              while (context && context.type === "pattern") {
                context = context.prev;
              }
            }
            var closing = context && firstChar === context.type;
            if (!context) return 0;
            if (context.type === "keywords") return CodeMirror.commands.newlineAndIndent;
            if (context.align) return context.col + (closing ? 0 : 1);
            return context.indent + (closing ? 0 : indentUnit);
          }
        };
      });

      CodeMirror.modeExtensions["cypher"] = {
        autoFormatLineBreaks: function(text) {
          var i, lines, reProcessedPortion;
          var lines = text.split("\n");
          var reProcessedPortion = /\s+\b(return|where|order by|match|with|skip|limit|create|delete|set)\b\s/g;
          for (var i = 0; i < lines.length; i++)
            lines[i] = lines[i].replace(reProcessedPortion, " \n$1 ").trim();
          return lines.join("\n");
        }
      };

      CodeMirror.defineMIME("application/x-cypher-query", "cypher");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function D(CodeMirror) {
    CodeMirror.defineMode("d", function(config, parserConfig) {
      var indentUnit = config.indentUnit,
          statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
          keywords = parserConfig.keywords || {},
          builtin = parserConfig.builtin || {},
          blockKeywords = parserConfig.blockKeywords || {},
          atoms = parserConfig.atoms || {},
          hooks = parserConfig.hooks || {},
          multiLineStrings = parserConfig.multiLineStrings;
      var isOperatorChar = /[+\-*&%=<>!?|\/]/;

      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"' || ch == "'" || ch == "`") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("+")) {
            state.tokenize = tokenNestedComment;
            return tokenNestedComment(stream, state);
          }
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        }
        if (builtin.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "builtin";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = null;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenNestedComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "+");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        var indent = state.indented;
        if (state.context && state.context.type == "statement")
          indent = state.context.indented;
        return state.context = new Context(indent, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        blockCommentContinue: " * ",
        lineComment: "//",
        fold: "brace"
      };
    });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var blockKeywords = "body catch class do else enum for foreach foreach_reverse if in interface mixin " +
                          "out scope struct switch try union unittest version while with";

      CodeMirror.defineMIME("text/x-d", {
        name: "d",
        keywords: words("abstract alias align asm assert auto break case cast cdouble cent cfloat const continue " +
                        "debug default delegate delete deprecated export extern final finally function goto immutable " +
                        "import inout invariant is lazy macro module new nothrow override package pragma private " +
                        "protected public pure ref return shared short static super synchronized template this " +
                        "throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters " +
                        blockKeywords),
        blockKeywords: words(blockKeywords),
        builtin: words("bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte " +
                       "ucent uint ulong ushort wchar wstring void size_t sizediff_t"),
        atoms: words("exit failure success true false null"),
        hooks: {
          "@": function(stream, _state) {
            stream.eatWhile(/[\w\$_]/);
            return "meta";
          }
        }
      });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Dart(CodeMirror) {
      var keywords = ("this super static final const abstract class extends external factory " +
        "implements mixin get native set typedef with enum throw rethrow " +
        "assert break case continue default in return new deferred async await covariant " +
        "try catch finally do else for if switch while import library export " +
        "part of show hide is as").split(" ");
      var blockKeywords = "try catch finally do else for if switch while".split(" ");
      var atoms = "true false null".split(" ");
      var builtins = "void bool num int double dynamic var String".split(" ");

      function set(words) {
        var obj = {};
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      function pushInterpolationStack(state) {
        (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);
      }

      function popInterpolationStack(state) {
        return (state.interpolationStack || (state.interpolationStack = [])).pop();
      }

      function sizeInterpolationStack(state) {
        return state.interpolationStack ? state.interpolationStack.length : 0;
      }

      CodeMirror.defineMIME("application/dart", {
        name: "clike",
        keywords: set(keywords),
        blockKeywords: set(blockKeywords),
        builtin: set(builtins),
        atoms: set(atoms),
        hooks: {
          "@": function(stream) {
            stream.eatWhile(/[\w\$_\.]/);
            return "meta";
          },

          // custom string handling to deal with triple-quoted strings and string interpolation
          "'": function(stream, state) {
            return tokenString("'", stream, state, false);
          },
          "\"": function(stream, state) {
            return tokenString("\"", stream, state, false);
          },
          "r": function(stream, state) {
            var peek = stream.peek();
            if (peek == "'" || peek == "\"") {
              return tokenString(stream.next(), stream, state, true);
            }
            return false;
          },

          "}": function(_stream, state) {
            // "}" is end of interpolation, if interpolation stack is non-empty
            if (sizeInterpolationStack(state) > 0) {
              state.tokenize = popInterpolationStack(state);
              return null;
            }
            return false;
          },

          "/": function(stream, state) {
            if (!stream.eat("*")) return false
            state.tokenize = tokenNestedComment(1);
            return state.tokenize(stream, state)
          }
        }
      });

      function tokenString(quote, stream, state, raw) {
        var tripleQuoted = false;
        if (stream.eat(quote)) {
          if (stream.eat(quote)) tripleQuoted = true;
          else return "string"; //empty string
        }
        function tokenStringHelper(stream, state) {
          var escaped = false;
          while (!stream.eol()) {
            if (!raw && !escaped && stream.peek() == "$") {
              pushInterpolationStack(state);
              state.tokenize = tokenInterpolation;
              return "string";
            }
            var next = stream.next();
            if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {
              state.tokenize = null;
              break;
            }
            escaped = !raw && !escaped && next == "\\";
          }
          return "string";
        }
        state.tokenize = tokenStringHelper;
        return tokenStringHelper(stream, state);
      }

      function tokenInterpolation(stream, state) {
        stream.eat("$");
        if (stream.eat("{")) {
          // let clike handle the content of ${...},
          // we take over again when "}" appears (see hooks).
          state.tokenize = null;
        } else {
          state.tokenize = tokenInterpolationIdentifier;
        }
        return null;
      }

      function tokenInterpolationIdentifier(stream, state) {
        stream.eatWhile(/[\w_]/);
        state.tokenize = popInterpolationStack(state);
        return "variable";
      }

      function tokenNestedComment(depth) {
        return function (stream, state) {
          var ch;
          while (ch = stream.next()) {
            if (ch == "*" && stream.eat("/")) {
              if (depth == 1) {
                state.tokenize = null;
                break
              } else {
                state.tokenize = tokenNestedComment(depth - 1);
                return state.tokenize(stream, state)
              }
            } else if (ch == "/" && stream.eat("*")) {
              state.tokenize = tokenNestedComment(depth + 1);
              return state.tokenize(stream, state)
            }
          }
          return "comment"
        }
      }

      CodeMirror.registerHelper("hintWords", "application/dart", keywords.concat(atoms).concat(builtins));

      // This is needed to make loading through meta.js work.
      CodeMirror.defineMode("dart", function(conf) {
        return CodeMirror.getMode(conf, "application/dart");
      }, "clike");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Diff(CodeMirror) {
    CodeMirror.defineMode("diff", function() {

      var TOKEN_NAMES = {
        '+': 'positive',
        '-': 'negative',
        '@': 'meta'
      };

      return {
        token: function(stream) {
          var tw_pos = stream.string.search(/[\t ]+?$/);

          if (!stream.sol() || tw_pos === 0) {
            stream.skipToEnd();
            return ("error " + (
              TOKEN_NAMES[stream.string.charAt(0)] || '')).replace(/ $/, '');
          }

          var token_name = TOKEN_NAMES[stream.peek()] || stream.skipToEnd();

          if (tw_pos === -1) {
            stream.skipToEnd();
          } else {
            stream.pos = tw_pos;
          }

          return token_name;
        }
      };
    });

    CodeMirror.defineMIME("text/x-diff", "diff");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Django(CodeMirror) {
      CodeMirror.defineMode("django:inner", function() {
        var keywords = ["block", "endblock", "for", "endfor", "true", "false", "filter", "endfilter",
                        "loop", "none", "self", "super", "if", "elif", "endif", "as", "else", "import",
                        "with", "endwith", "without", "context", "ifequal", "endifequal", "ifnotequal",
                        "endifnotequal", "extends", "include", "load", "comment", "endcomment",
                        "empty", "url", "static", "trans", "blocktrans", "endblocktrans", "now",
                        "regroup", "lorem", "ifchanged", "endifchanged", "firstof", "debug", "cycle",
                        "csrf_token", "autoescape", "endautoescape", "spaceless", "endspaceless",
                        "ssi", "templatetag", "verbatim", "endverbatim", "widthratio"],
            filters = ["add", "addslashes", "capfirst", "center", "cut", "date",
                       "default", "default_if_none", "dictsort",
                       "dictsortreversed", "divisibleby", "escape", "escapejs",
                       "filesizeformat", "first", "floatformat", "force_escape",
                       "get_digit", "iriencode", "join", "last", "length",
                       "length_is", "linebreaks", "linebreaksbr", "linenumbers",
                       "ljust", "lower", "make_list", "phone2numeric", "pluralize",
                       "pprint", "random", "removetags", "rjust", "safe",
                       "safeseq", "slice", "slugify", "stringformat", "striptags",
                       "time", "timesince", "timeuntil", "title", "truncatechars",
                       "truncatechars_html", "truncatewords", "truncatewords_html",
                       "unordered_list", "upper", "urlencode", "urlize",
                       "urlizetrunc", "wordcount", "wordwrap", "yesno"],
            operators = ["==", "!=", "<", ">", "<=", ">="],
            wordOperators = ["in", "not", "or", "and"];

        keywords = new RegExp("^\\b(" + keywords.join("|") + ")\\b");
        filters = new RegExp("^\\b(" + filters.join("|") + ")\\b");
        operators = new RegExp("^\\b(" + operators.join("|") + ")\\b");
        wordOperators = new RegExp("^\\b(" + wordOperators.join("|") + ")\\b");

        // We have to return "null" instead of null, in order to avoid string
        // styling as the default, when using Django templates inside HTML
        // element attributes
        function tokenBase (stream, state) {
          // Attempt to identify a variable, template or comment tag respectively
          if (stream.match("{{")) {
            state.tokenize = inVariable;
            return "tag";
          } else if (stream.match("{%")) {
            state.tokenize = inTag;
            return "tag";
          } else if (stream.match("{#")) {
            state.tokenize = inComment;
            return "comment";
          }

          // Ignore completely any stream series that do not match the
          // Django template opening tags.
          while (stream.next() != null && !stream.match(/\{[{%#]/, false)) {}
          return null;
        }

        // A string can be included in either single or double quotes (this is
        // the delimiter). Mark everything as a string until the start delimiter
        // occurs again.
        function inString (delimiter, previousTokenizer) {
          return function (stream, state) {
            if (!state.escapeNext && stream.eat(delimiter)) {
              state.tokenize = previousTokenizer;
            } else {
              if (state.escapeNext) {
                state.escapeNext = false;
              }

              var ch = stream.next();

              // Take into account the backslash for escaping characters, such as
              // the string delimiter.
              if (ch == "\\") {
                state.escapeNext = true;
              }
            }

            return "string";
          };
        }

        // Apply Django template variable syntax highlighting
        function inVariable (stream, state) {
          // Attempt to match a dot that precedes a property
          if (state.waitDot) {
            state.waitDot = false;

            if (stream.peek() != ".") {
              return "null";
            }

            // Dot followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat(".")) {
              state.waitProperty = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for property.");
            }
          }

          // Attempt to match a pipe that precedes a filter
          if (state.waitPipe) {
            state.waitPipe = false;

            if (stream.peek() != "|") {
              return "null";
            }

            // Pipe followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat("|")) {
              state.waitFilter = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for filter.");
            }
          }

          // Highlight properties
          if (state.waitProperty) {
            state.waitProperty = false;
            if (stream.match(/\b(\w+)\b/)) {
              state.waitDot = true;  // A property can be followed by another property
              state.waitPipe = true;  // A property can be followed by a filter
              return "property";
            }
          }

          // Highlight filters
          if (state.waitFilter) {
              state.waitFilter = false;
            if (stream.match(filters)) {
              return "variable-2";
            }
          }

          // Ignore all white spaces
          if (stream.eatSpace()) {
            state.waitProperty = false;
            return "null";
          }

          // Identify numbers
          if (stream.match(/\b\d+(\.\d+)?\b/)) {
            return "number";
          }

          // Identify strings
          if (stream.match("'")) {
            state.tokenize = inString("'", state.tokenize);
            return "string";
          } else if (stream.match('"')) {
            state.tokenize = inString('"', state.tokenize);
            return "string";
          }

          // Attempt to find the variable
          if (stream.match(/\b(\w+)\b/) && !state.foundVariable) {
            state.waitDot = true;
            state.waitPipe = true;  // A property can be followed by a filter
            return "variable";
          }

          // If found closing tag reset
          if (stream.match("}}")) {
            state.waitProperty = null;
            state.waitFilter = null;
            state.waitDot = null;
            state.waitPipe = null;
            state.tokenize = tokenBase;
            return "tag";
          }

          // If nothing was found, advance to the next character
          stream.next();
          return "null";
        }

        function inTag (stream, state) {
          // Attempt to match a dot that precedes a property
          if (state.waitDot) {
            state.waitDot = false;

            if (stream.peek() != ".") {
              return "null";
            }

            // Dot followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat(".")) {
              state.waitProperty = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for property.");
            }
          }

          // Attempt to match a pipe that precedes a filter
          if (state.waitPipe) {
            state.waitPipe = false;

            if (stream.peek() != "|") {
              return "null";
            }

            // Pipe followed by a non-word character should be considered an error.
            if (stream.match(/\.\W+/)) {
              return "error";
            } else if (stream.eat("|")) {
              state.waitFilter = true;
              return "null";
            } else {
              throw Error ("Unexpected error while waiting for filter.");
            }
          }

          // Highlight properties
          if (state.waitProperty) {
            state.waitProperty = false;
            if (stream.match(/\b(\w+)\b/)) {
              state.waitDot = true;  // A property can be followed by another property
              state.waitPipe = true;  // A property can be followed by a filter
              return "property";
            }
          }

          // Highlight filters
          if (state.waitFilter) {
              state.waitFilter = false;
            if (stream.match(filters)) {
              return "variable-2";
            }
          }

          // Ignore all white spaces
          if (stream.eatSpace()) {
            state.waitProperty = false;
            return "null";
          }

          // Identify numbers
          if (stream.match(/\b\d+(\.\d+)?\b/)) {
            return "number";
          }

          // Identify strings
          if (stream.match("'")) {
            state.tokenize = inString("'", state.tokenize);
            return "string";
          } else if (stream.match('"')) {
            state.tokenize = inString('"', state.tokenize);
            return "string";
          }

          // Attempt to match an operator
          if (stream.match(operators)) {
            return "operator";
          }

          // Attempt to match a word operator
          if (stream.match(wordOperators)) {
            return "keyword";
          }

          // Attempt to match a keyword
          var keywordMatch = stream.match(keywords);
          if (keywordMatch) {
            if (keywordMatch[0] == "comment") {
              state.blockCommentTag = true;
            }
            return "keyword";
          }

          // Attempt to match a variable
          if (stream.match(/\b(\w+)\b/)) {
            state.waitDot = true;
            state.waitPipe = true;  // A property can be followed by a filter
            return "variable";
          }

          // If found closing tag reset
          if (stream.match("%}")) {
            state.waitProperty = null;
            state.waitFilter = null;
            state.waitDot = null;
            state.waitPipe = null;
            // If the tag that closes is a block comment tag, we want to mark the
            // following code as comment, until the tag closes.
            if (state.blockCommentTag) {
              state.blockCommentTag = false;  // Release the "lock"
              state.tokenize = inBlockComment;
            } else {
              state.tokenize = tokenBase;
            }
            return "tag";
          }

          // If nothing was found, advance to the next character
          stream.next();
          return "null";
        }

        // Mark everything as comment inside the tag and the tag itself.
        function inComment (stream, state) {
          if (stream.match(/^.*?#\}/)) state.tokenize = tokenBase;
          else stream.skipToEnd();
          return "comment";
        }

        // Mark everything as a comment until the `blockcomment` tag closes.
        function inBlockComment (stream, state) {
          if (stream.match(/\{%\s*endcomment\s*%\}/, false)) {
            state.tokenize = inTag;
            stream.match("{%");
            return "tag";
          } else {
            stream.next();
            return "comment";
          }
        }

        return {
          startState: function () {
            return {tokenize: tokenBase};
          },
          token: function (stream, state) {
            return state.tokenize(stream, state);
          },
          blockCommentStart: "{% comment %}",
          blockCommentEnd: "{% endcomment %}"
        };
      });

      CodeMirror.defineMode("django", function(config) {
        var htmlBase = CodeMirror.getMode(config, "text/html");
        var djangoInner = CodeMirror.getMode(config, "django:inner");
        return CodeMirror.overlayMode(htmlBase, djangoInner);
      });

      CodeMirror.defineMIME("text/x-django", "django");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Dockerfile(CodeMirror) {
      var from = "from";
      var fromRegex = new RegExp("^(\\s*)\\b(" + from + ")\\b", "i");

      var shells = ["run", "cmd", "entrypoint", "shell"];
      var shellsAsArrayRegex = new RegExp("^(\\s*)(" + shells.join('|') + ")(\\s+\\[)", "i");

      var expose = "expose";
      var exposeRegex = new RegExp("^(\\s*)(" + expose + ")(\\s+)", "i");

      var others = [
        "arg", "from", "maintainer", "label", "env",
        "add", "copy", "volume", "user",
        "workdir", "onbuild", "stopsignal", "healthcheck", "shell"
      ];

      // Collect all Dockerfile directives
      var instructions = [from, expose].concat(shells).concat(others),
          instructionRegex = "(" + instructions.join('|') + ")",
          instructionOnlyLine = new RegExp("^(\\s*)" + instructionRegex + "(\\s*)(#.*)?$", "i"),
          instructionWithArguments = new RegExp("^(\\s*)" + instructionRegex + "(\\s+)", "i");

      CodeMirror.defineSimpleMode("dockerfile", {
        start: [
          // Block comment: This is a line starting with a comment
          {
            regex: /^\s*#.*$/,
            sol: true,
            token: "comment"
          },
          {
            regex: fromRegex,
            token: [null, "keyword"],
            sol: true,
            next: "from"
          },
          // Highlight an instruction without any arguments (for convenience)
          {
            regex: instructionOnlyLine,
            token: [null, "keyword", null, "error"],
            sol: true
          },
          {
            regex: shellsAsArrayRegex,
            token: [null, "keyword", null],
            sol: true,
            next: "array"
          },
          {
            regex: exposeRegex,
            token: [null, "keyword", null],
            sol: true,
            next: "expose"
          },
          // Highlight an instruction followed by arguments
          {
            regex: instructionWithArguments,
            token: [null, "keyword", null],
            sol: true,
            next: "arguments"
          },
          {
            regex: /./,
            token: null
          }
        ],
        from: [
          {
            regex: /\s*$/,
            token: null,
            next: "start"
          },
          {
            // Line comment without instruction arguments is an error
            regex: /(\s*)(#.*)$/,
            token: [null, "error"],
            next: "start"
          },
          {
            regex: /(\s*\S+\s+)(as)/i,
            token: [null, "keyword"],
            next: "start"
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        single: [
          {
            regex: /(?:[^\\']|\\.)/,
            token: "string"
          },
          {
            regex: /'/,
            token: "string",
            pop: true
          }
        ],
        double: [
          {
            regex: /(?:[^\\"]|\\.)/,
            token: "string"
          },
          {
            regex: /"/,
            token: "string",
            pop: true
          }
        ],
        array: [
          {
            regex: /\]/,
            token: null,
            next: "start"
          },
          {
            regex: /"(?:[^\\"]|\\.)*"?/,
            token: "string"
          }
        ],
        expose: [
          {
            regex: /\d+$/,
            token: "number",
            next: "start"
          },
          {
            regex: /[^\d]+$/,
            token: null,
            next: "start"
          },
          {
            regex: /\d+/,
            token: "number"
          },
          {
            regex: /[^\d]+/,
            token: null
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        arguments: [
          {
            regex: /^\s*#.*$/,
            sol: true,
            token: "comment"
          },
          {
            regex: /"(?:[^\\"]|\\.)*"?$/,
            token: "string",
            next: "start"
          },
          {
            regex: /"/,
            token: "string",
            push: "double"
          },
          {
            regex: /'(?:[^\\']|\\.)*'?$/,
            token: "string",
            next: "start"
          },
          {
            regex: /'/,
            token: "string",
            push: "single"
          },
          {
            regex: /[^#"']+[\\`]$/,
            token: null
          },
          {
            regex: /[^#"']+$/,
            token: null,
            next: "start"
          },
          {
            regex: /[^#"']+/,
            token: null
          },
          // Fail safe return to start
          {
            token: null,
            next: "start"
          }
        ],
        meta: {
          lineComment: "#"
        }
      });

      CodeMirror.defineMIME("text/x-dockerfile", "dockerfile");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
      DTD mode
      Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>
      Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
      GitHub: @peterkroon
    */

    function DTD(CodeMirror) {
    CodeMirror.defineMode("dtd", function(config) {
      var indentUnit = config.indentUnit, type;
      function ret(style, tp) {type = tp; return style;}

      function tokenBase(stream, state) {
        var ch = stream.next();

        if (ch == "<" && stream.eat("!") ) {
          if (stream.eatWhile(/[\-]/)) {
            state.tokenize = tokenSGMLComment;
            return tokenSGMLComment(stream, state);
          } else if (stream.eatWhile(/[\w]/)) return ret("keyword", "doindent");
        } else if (ch == "<" && stream.eat("?")) { //xml declaration
          state.tokenize = inBlock("meta", "?>");
          return ret("meta", ch);
        } else if (ch == "#" && stream.eatWhile(/[\w]/)) return ret("atom", "tag");
        else if (ch == "|") return ret("keyword", "seperator");
        else if (ch.match(/[\(\)\[\]\-\.,\+\?>]/)) return ret(null, ch);//if(ch === ">") return ret(null, "endtag"); else
        else if (ch.match(/[\[\]]/)) return ret("rule", ch);
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (stream.eatWhile(/[a-zA-Z\?\+\d]/)) {
          var sc = stream.current();
          if( sc.substr(sc.length-1,sc.length).match(/\?|\+/) !== null )stream.backUp(1);
          return ret("tag", "tag");
        } else if (ch == "%" || ch == "*" ) return ret("number", "number");
        else {
          stream.eatWhile(/[\w\\\-_%.{,]/);
          return ret(null, null);
        }
      }

      function tokenSGMLComment(stream, state) {
        var dashes = 0, ch;
        while ((ch = stream.next()) != null) {
          if (dashes >= 2 && ch == ">") {
            state.tokenize = tokenBase;
            break;
          }
          dashes = (ch == "-") ? dashes + 1 : 0;
        }
        return ret("comment", "comment");
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return ret("string", "tag");
        };
      }

      function inBlock(style, terminator) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = tokenBase;
              break;
            }
            stream.next();
          }
          return style;
        };
      }

      return {
        startState: function(base) {
          return {tokenize: tokenBase,
                  baseIndent: base || 0,
                  stack: []};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);

          var context = state.stack[state.stack.length-1];
          if (stream.current() == "[" || type === "doindent" || type == "[") state.stack.push("rule");
          else if (type === "endtag") state.stack[state.stack.length-1] = "endtag";
          else if (stream.current() == "]" || type == "]" || (type == ">" && context == "rule")) state.stack.pop();
          else if (type == "[") state.stack.push("[");
          return style;
        },

        indent: function(state, textAfter) {
          var n = state.stack.length;

          if( textAfter.match(/\]\s+|\]/) )n=n-1;
          else if(textAfter.substr(textAfter.length-1, textAfter.length) === ">"){
            if(textAfter.substr(0,1) === "<") ;
            else if( type == "doindent" && textAfter.length > 1 ) ;
            else if( type == "doindent")n--;
            else if( type == ">" && textAfter.length > 1) ;
            else if( type == "tag" && textAfter !== ">") ;
            else if( type == "tag" && state.stack[state.stack.length-1] == "rule")n--;
            else if( type == "tag")n++;
            else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule" && type === ">")n--;
            else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule") ;
            else if( textAfter.substr(0,1) !== "<" && textAfter.substr(0,1) === ">" )n=n-1;
            else if( textAfter === ">") ;
            else n=n-1;
            //over rule them all
            if(type == null || type == "]")n--;
          }

          return state.baseIndent + n * indentUnit;
        },

        electricChars: "]>"
      };
    });

    CodeMirror.defineMIME("application/xml-dtd", "dtd");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Dylan(CodeMirror) {
    function forEach(arr, f) {
      for (var i = 0; i < arr.length; i++) f(arr[i], i);
    }
    function some(arr, f) {
      for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
      return false
    }

    CodeMirror.defineMode("dylan", function(_config) {
      // Words
      var words = {
        // Words that introduce unnamed definitions like "define interface"
        unnamedDefinition: ["interface"],

        // Words that introduce simple named definitions like "define library"
        namedDefinition: ["module", "library", "macro",
                          "C-struct", "C-union",
                          "C-function", "C-callable-wrapper"
                         ],

        // Words that introduce type definitions like "define class".
        // These are also parameterized like "define method" and are
        // appended to otherParameterizedDefinitionWords
        typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

        // Words that introduce trickier definitions like "define method".
        // These require special definitions to be added to startExpressions
        otherParameterizedDefinition: ["method", "function",
                                       "C-variable", "C-address"
                                      ],

        // Words that introduce module constant definitions.
        // These must also be simple definitions and are
        // appended to otherSimpleDefinitionWords
        constantSimpleDefinition: ["constant"],

        // Words that introduce module variable definitions.
        // These must also be simple definitions and are
        // appended to otherSimpleDefinitionWords
        variableSimpleDefinition: ["variable"],

        // Other words that introduce simple definitions
        // (without implicit bodies).
        otherSimpleDefinition: ["generic", "domain",
                                "C-pointer-type",
                                "table"
                               ],

        // Words that begin statements with implicit bodies.
        statement: ["if", "block", "begin", "method", "case",
                    "for", "select", "when", "unless", "until",
                    "while", "iterate", "profiling", "dynamic-bind"
                   ],

        // Patterns that act as separators in compound statements.
        // This may include any general pattern that must be indented
        // specially.
        separator: ["finally", "exception", "cleanup", "else",
                    "elseif", "afterwards"
                   ],

        // Keywords that do not require special indentation handling,
        // but which should be highlighted
        other: ["above", "below", "by", "from", "handler", "in",
                "instance", "let", "local", "otherwise", "slot",
                "subclass", "then", "to", "keyed-by", "virtual"
               ],

        // Condition signaling function calls
        signalingCalls: ["signal", "error", "cerror",
                         "break", "check-type", "abort"
                        ]
      };

      words["otherDefinition"] =
        words["unnamedDefinition"]
        .concat(words["namedDefinition"])
        .concat(words["otherParameterizedDefinition"]);

      words["definition"] =
        words["typeParameterizedDefinition"]
        .concat(words["otherDefinition"]);

      words["parameterizedDefinition"] =
        words["typeParameterizedDefinition"]
        .concat(words["otherParameterizedDefinition"]);

      words["simpleDefinition"] =
        words["constantSimpleDefinition"]
        .concat(words["variableSimpleDefinition"])
        .concat(words["otherSimpleDefinition"]);

      words["keyword"] =
        words["statement"]
        .concat(words["separator"])
        .concat(words["other"]);

      // Patterns
      var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
      var symbol = new RegExp("^" + symbolPattern);
      var patterns = {
        // Symbols with special syntax
        symbolKeyword: symbolPattern + ":",
        symbolClass: "<" + symbolPattern + ">",
        symbolGlobal: "\\*" + symbolPattern + "\\*",
        symbolConstant: "\\$" + symbolPattern
      };
      var patternStyles = {
        symbolKeyword: "atom",
        symbolClass: "tag",
        symbolGlobal: "variable-2",
        symbolConstant: "variable-3"
      };

      // Compile all patterns to regular expressions
      for (var patternName in patterns)
        if (patterns.hasOwnProperty(patternName))
          patterns[patternName] = new RegExp("^" + patterns[patternName]);

      // Names beginning "with-" and "without-" are commonly
      // used as statement macro
      patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

      var styles = {};
      styles["keyword"] = "keyword";
      styles["definition"] = "def";
      styles["simpleDefinition"] = "def";
      styles["signalingCalls"] = "builtin";

      // protected words lookup table
      var wordLookup = {};
      var styleLookup = {};

      forEach([
        "keyword",
        "definition",
        "simpleDefinition",
        "signalingCalls"
      ], function(type) {
        forEach(words[type], function(word) {
          wordLookup[word] = type;
          styleLookup[word] = styles[type];
        });
      });


      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function tokenBase(stream, state) {
        // String
        var ch = stream.peek();
        if (ch == "'" || ch == '"') {
          stream.next();
          return chain(stream, state, tokenString(ch, "string"));
        }
        // Comment
        else if (ch == "/") {
          stream.next();
          if (stream.eat("*")) {
            return chain(stream, state, tokenComment);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
          stream.backUp(1);
        }
        // Decimal
        else if (/[+\-\d\.]/.test(ch)) {
          if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
              stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
              stream.match(/^[+-]?\d+/)) {
            return "number";
          }
        }
        // Hash
        else if (ch == "#") {
          stream.next();
          // Symbol with string syntax
          ch = stream.peek();
          if (ch == '"') {
            stream.next();
            return chain(stream, state, tokenString('"', "string"));
          }
          // Binary number
          else if (ch == "b") {
            stream.next();
            stream.eatWhile(/[01]/);
            return "number";
          }
          // Hex number
          else if (ch == "x") {
            stream.next();
            stream.eatWhile(/[\da-f]/i);
            return "number";
          }
          // Octal number
          else if (ch == "o") {
            stream.next();
            stream.eatWhile(/[0-7]/);
            return "number";
          }
          // Token concatenation in macros
          else if (ch == '#') {
            stream.next();
            return "punctuation";
          }
          // Sequence literals
          else if ((ch == '[') || (ch == '(')) {
            stream.next();
            return "bracket";
          // Hash symbol
          } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
            return "atom";
          } else {
            stream.eatWhile(/[-a-zA-Z]/);
            return "error";
          }
        } else if (ch == "~") {
          stream.next();
          ch = stream.peek();
          if (ch == "=") {
            stream.next();
            ch = stream.peek();
            if (ch == "=") {
              stream.next();
              return "operator";
            }
            return "operator";
          }
          return "operator";
        } else if (ch == ":") {
          stream.next();
          ch = stream.peek();
          if (ch == "=") {
            stream.next();
            return "operator";
          } else if (ch == ":") {
            stream.next();
            return "punctuation";
          }
        } else if ("[](){}".indexOf(ch) != -1) {
          stream.next();
          return "bracket";
        } else if (".,".indexOf(ch) != -1) {
          stream.next();
          return "punctuation";
        } else if (stream.match("end")) {
          return "keyword";
        }
        for (var name in patterns) {
          if (patterns.hasOwnProperty(name)) {
            var pattern = patterns[name];
            if ((pattern instanceof Array && some(pattern, function(p) {
              return stream.match(p);
            })) || stream.match(pattern))
              return patternStyles[name];
          }
        }
        if (/[+\-*\/^=<>&|]/.test(ch)) {
          stream.next();
          return "operator";
        }
        if (stream.match("define")) {
          return "def";
        } else {
          stream.eatWhile(/[\w\-]/);
          // Keyword
          if (wordLookup.hasOwnProperty(stream.current())) {
            return styleLookup[stream.current()];
          } else if (stream.current().match(symbol)) {
            return "variable";
          } else {
            stream.next();
            return "variable-2";
          }
        }
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
        while ((ch = stream.next())) {
          if (ch == "/" && maybeEnd) {
            if (nestedCount > 0) {
              nestedCount--;
            } else {
              state.tokenize = tokenBase;
              break;
            }
          } else if (ch == "*" && maybeNested) {
            nestedCount++;
          }
          maybeEnd = (ch == "*");
          maybeNested = (ch == "/");
        }
        return "comment";
      }

      function tokenString(quote, style) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped) {
            state.tokenize = tokenBase;
          }
          return style;
        };
      }

      // Interface
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            currentIndent: 0
          };
        },
        token: function(stream, state) {
          if (stream.eatSpace())
            return null;
          var style = state.tokenize(stream, state);
          return style;
        },
        blockCommentStart: "/*",
        blockCommentEnd: "*/"
      };
    });

    CodeMirror.defineMIME("text/x-dylan", "dylan");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function EBNF(CodeMirror) {
      CodeMirror.defineMode("ebnf", function (config) {
        var commentType = {slash: 0, parenthesis: 1};
        var stateType = {comment: 0, _string: 1, characterClass: 2};
        var bracesMode = null;

        if (config.bracesMode)
          bracesMode = CodeMirror.getMode(config, config.bracesMode);

        return {
          startState: function () {
            return {
              stringType: null,
              commentType: null,
              braced: 0,
              lhs: true,
              localState: null,
              stack: [],
              inDefinition: false
            };
          },
          token: function (stream, state) {
            if (!stream) return;

            //check for state changes
            if (state.stack.length === 0) {
              //strings
              if ((stream.peek() == '"') || (stream.peek() == "'")) {
                state.stringType = stream.peek();
                stream.next(); // Skip quote
                state.stack.unshift(stateType._string);
              } else if (stream.match(/^\/\*/)) { //comments starting with /*
                state.stack.unshift(stateType.comment);
                state.commentType = commentType.slash;
              } else if (stream.match(/^\(\*/)) { //comments starting with (*
                state.stack.unshift(stateType.comment);
                state.commentType = commentType.parenthesis;
              }
            }

            //return state
            //stack has
            switch (state.stack[0]) {
            case stateType._string:
              while (state.stack[0] === stateType._string && !stream.eol()) {
                if (stream.peek() === state.stringType) {
                  stream.next(); // Skip quote
                  state.stack.shift(); // Clear flag
                } else if (stream.peek() === "\\") {
                  stream.next();
                  stream.next();
                } else {
                  stream.match(/^.[^\\\"\']*/);
                }
              }
              return state.lhs ? "property string" : "string"; // Token style

            case stateType.comment:
              while (state.stack[0] === stateType.comment && !stream.eol()) {
                if (state.commentType === commentType.slash && stream.match(/\*\//)) {
                  state.stack.shift(); // Clear flag
                  state.commentType = null;
                } else if (state.commentType === commentType.parenthesis && stream.match(/\*\)/)) {
                  state.stack.shift(); // Clear flag
                  state.commentType = null;
                } else {
                  stream.match(/^.[^\*]*/);
                }
              }
              return "comment";

            case stateType.characterClass:
              while (state.stack[0] === stateType.characterClass && !stream.eol()) {
                if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
                  state.stack.shift();
                }
              }
              return "operator";
            }

            var peek = stream.peek();

            if (bracesMode !== null && (state.braced || peek === "{")) {
              if (state.localState === null)
                state.localState = CodeMirror.startState(bracesMode);

              var token = bracesMode.token(stream, state.localState),
              text = stream.current();

              if (!token) {
                for (var i = 0; i < text.length; i++) {
                  if (text[i] === "{") {
                    if (state.braced === 0) {
                      token = "matchingbracket";
                    }
                    state.braced++;
                  } else if (text[i] === "}") {
                    state.braced--;
                    if (state.braced === 0) {
                      token = "matchingbracket";
                    }
                  }
                }
              }
              return token;
            }

            //no stack
            switch (peek) {
            case "[":
              stream.next();
              state.stack.unshift(stateType.characterClass);
              return "bracket";
            case ":":
            case "|":
            case ";":
              stream.next();
              return "operator";
            case "%":
              if (stream.match("%%")) {
                return "header";
              } else if (stream.match(/[%][A-Za-z]+/)) {
                return "keyword";
              } else if (stream.match(/[%][}]/)) {
                return "matchingbracket";
              }
              break;
            case "/":
              if (stream.match(/[\/][A-Za-z]+/)) {
              return "keyword";
            }
            case "\\":
              if (stream.match(/[\][a-z]+/)) {
                return "string-2";
              }
            case ".":
              if (stream.match(".")) {
                return "atom";
              }
            case "*":
            case "-":
            case "+":
            case "^":
              if (stream.match(peek)) {
                return "atom";
              }
            case "$":
              if (stream.match("$$")) {
                return "builtin";
              } else if (stream.match(/[$][0-9]+/)) {
                return "variable-3";
              }
            case "<":
              if (stream.match(/<<[a-zA-Z_]+>>/)) {
                return "builtin";
              }
            }

            if (stream.match(/^\/\//)) {
              stream.skipToEnd();
              return "comment";
            } else if (stream.match(/return/)) {
              return "operator";
            } else if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
              if (stream.match(/(?=[\(.])/)) {
                return "variable";
              } else if (stream.match(/(?=[\s\n]*[:=])/)) {
                return "def";
              }
              return "variable-2";
            } else if (["[", "]", "(", ")"].indexOf(stream.peek()) != -1) {
              stream.next();
              return "bracket";
            } else if (!stream.eatSpace()) {
              stream.next();
            }
            return null;
          }
        };
      });

      CodeMirror.defineMIME("text/x-ebnf", "ebnf");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function ECL(CodeMirror) {
    CodeMirror.defineMode("ecl", function(config) {

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      function metaHook(stream, state) {
        if (!state.startOfLine) return false;
        stream.skipToEnd();
        return "meta";
      }

      var indentUnit = config.indentUnit;
      var keyword = words("abs acos allnodes ascii asin asstring atan atan2 ave case choose choosen choosesets clustersize combine correlation cos cosh count covariance cron dataset dedup define denormalize distribute distributed distribution ebcdic enth error evaluate event eventextra eventname exists exp failcode failmessage fetch fromunicode getisvalid global graph group hash hash32 hash64 hashcrc hashmd5 having if index intformat isvalid iterate join keyunicode length library limit ln local log loop map matched matchlength matchposition matchtext matchunicode max merge mergejoin min nolocal nonempty normalize parse pipe power preload process project pull random range rank ranked realformat recordof regexfind regexreplace regroup rejected rollup round roundup row rowdiff sample set sin sinh sizeof soapcall sort sorted sqrt stepped stored sum table tan tanh thisnode topn tounicode transfer trim truncate typeof ungroup unicodeorder variance which workunit xmldecode xmlencode xmltext xmlunicode");
      var variable = words("apply assert build buildindex evaluate fail keydiff keypatch loadxml nothor notify output parallel sequential soapcall wait");
      var variable_2 = words("__compressed__ all and any as atmost before beginc++ best between case const counter csv descend encrypt end endc++ endmacro except exclusive expire export extend false few first flat from full function group header heading hole ifblock import in interface joined keep keyed last left limit load local locale lookup macro many maxcount maxlength min skew module named nocase noroot noscan nosort not of only opt or outer overwrite packed partition penalty physicallength pipe quote record relationship repeat return right scan self separator service shared skew skip sql store terminator thor threshold token transform trim true type unicodeorder unsorted validate virtual whole wild within xml xpath");
      var variable_3 = words("ascii big_endian boolean data decimal ebcdic integer pattern qstring real record rule set of string token udecimal unicode unsigned varstring varunicode");
      var builtin = words("checkpoint deprecated failcode failmessage failure global independent onwarning persist priority recovery stored success wait when");
      var blockKeywords = words("catch class do else finally for if switch try while");
      var atoms = words("true false null");
      var hooks = {"#": metaHook};
      var isOperatorChar = /[+\-*&%=<>!?|\/]/;

      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current().toLowerCase();
        if (keyword.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        } else if (variable.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable";
        } else if (variable_2.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable-2";
        } else if (variable_3.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "variable-3";
        } else if (builtin.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "builtin";
        } else { //Data types are of from KEYWORD##
                    var i = cur.length - 1;
                    while(i >= 0 && (!isNaN(cur[i]) || cur[i] == '_'))
                            --i;

                    if (i > 0) {
                            var cur2 = cur.substr(0, i + 1);
                    if (variable_3.propertyIsEnumerable(cur2)) {
                            if (blockKeywords.propertyIsEnumerable(cur2)) curPunc = "newstatement";
                            return "variable-3";
                    }
                }
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return null;
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped)
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-ecl", "ecl");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Eiffel(CodeMirror) {
    CodeMirror.defineMode("eiffel", function() {
      function wordObj(words) {
        var o = {};
        for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
        return o;
      }
      var keywords = wordObj([
        'note',
        'across',
        'when',
        'variant',
        'until',
        'unique',
        'undefine',
        'then',
        'strip',
        'select',
        'retry',
        'rescue',
        'require',
        'rename',
        'reference',
        'redefine',
        'prefix',
        'once',
        'old',
        'obsolete',
        'loop',
        'local',
        'like',
        'is',
        'inspect',
        'infix',
        'include',
        'if',
        'frozen',
        'from',
        'external',
        'export',
        'ensure',
        'end',
        'elseif',
        'else',
        'do',
        'creation',
        'create',
        'check',
        'alias',
        'agent',
        'separate',
        'invariant',
        'inherit',
        'indexing',
        'feature',
        'expanded',
        'deferred',
        'class',
        'Void',
        'True',
        'Result',
        'Precursor',
        'False',
        'Current',
        'create',
        'attached',
        'detachable',
        'as',
        'and',
        'implies',
        'not',
        'or'
      ]);
      var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

      function chain(newtok, stream, state) {
        state.tokenize.push(newtok);
        return newtok(stream, state);
      }

      function tokenBase(stream, state) {
        if (stream.eatSpace()) return null;
        var ch = stream.next();
        if (ch == '"'||ch == "'") {
          return chain(readQuoted(ch, "string"), stream, state);
        } else if (ch == "-"&&stream.eat("-")) {
          stream.skipToEnd();
          return "comment";
        } else if (ch == ":"&&stream.eat("=")) {
          return "operator";
        } else if (/[0-9]/.test(ch)) {
          stream.eatWhile(/[xXbBCc0-9\.]/);
          stream.eat(/[\?\!]/);
          return "ident";
        } else if (/[a-zA-Z_0-9]/.test(ch)) {
          stream.eatWhile(/[a-zA-Z_0-9]/);
          stream.eat(/[\?\!]/);
          return "ident";
        } else if (/[=+\-\/*^%<>~]/.test(ch)) {
          stream.eatWhile(/[=+\-\/*^%<>~]/);
          return "operator";
        } else {
          return null;
        }
      }

      function readQuoted(quote, style,  unescaped) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && (unescaped || !escaped)) {
              state.tokenize.pop();
              break;
            }
            escaped = !escaped && ch == "%";
          }
          return style;
        };
      }

      return {
        startState: function() {
          return {tokenize: [tokenBase]};
        },

        token: function(stream, state) {
          var style = state.tokenize[state.tokenize.length-1](stream, state);
          if (style == "ident") {
            var word = stream.current();
            style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
              : operators.propertyIsEnumerable(stream.current()) ? "operator"
              : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
              : /^0[bB][0-1]+$/g.test(word) ? "number"
              : /^0[cC][0-7]+$/g.test(word) ? "number"
              : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
              : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
              : /^[0-9]+$/g.test(word) ? "number"
              : "variable";
          }
          return style;
        },
        lineComment: "--"
      };
    });

    CodeMirror.defineMIME("text/x-eiffel", "eiffel");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Elm(CodeMirror) {
      CodeMirror.defineMode("elm", function() {

        function switchState(source, setState, f) {
          setState(f);
          return f(source, setState);
        }

        // These should all be Unicode extended, as per the Haskell 2010 report
        var smallRE = /[a-z_]/;
        var largeRE = /[A-Z]/;
        var digitRE = /[0-9]/;
        var hexitRE = /[0-9A-Fa-f]/;
        var octitRE = /[0-7]/;
        var idRE = /[a-z_A-Z0-9\']/;
        var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:\u03BB\u2192]/;
        var specialRE = /[(),;[\]`{}]/;
        var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

        function normal() {
          return function (source, setState) {
            if (source.eatWhile(whiteCharRE)) {
              return null;
            }

            var ch = source.next();
            if (specialRE.test(ch)) {
              if (ch == '{' && source.eat('-')) {
                var t = "comment";
                if (source.eat('#')) t = "meta";
                return switchState(source, setState, ncomment(t, 1));
              }
              return null;
            }

            if (ch == '\'') {
              if (source.eat('\\'))
                source.next();  // should handle other escapes here
              else
                source.next();

              if (source.eat('\''))
                return "string";
              return "error";
            }

            if (ch == '"') {
              return switchState(source, setState, stringLiteral);
            }

            if (largeRE.test(ch)) {
              source.eatWhile(idRE);
              if (source.eat('.'))
                return "qualifier";
              return "variable-2";
            }

            if (smallRE.test(ch)) {
              var isDef = source.pos === 1;
              source.eatWhile(idRE);
              return isDef ? "type" : "variable";
            }

            if (digitRE.test(ch)) {
              if (ch == '0') {
                if (source.eat(/[xX]/)) {
                  source.eatWhile(hexitRE); // should require at least 1
                  return "integer";
                }
                if (source.eat(/[oO]/)) {
                  source.eatWhile(octitRE); // should require at least 1
                  return "number";
                }
              }
              source.eatWhile(digitRE);
              var t = "number";
              if (source.eat('.')) {
                t = "number";
                source.eatWhile(digitRE); // should require at least 1
              }
              if (source.eat(/[eE]/)) {
                t = "number";
                source.eat(/[-+]/);
                source.eatWhile(digitRE); // should require at least 1
              }
              return t;
            }

            if (symbolRE.test(ch)) {
              if (ch == '-' && source.eat(/-/)) {
                source.eatWhile(/-/);
                if (!source.eat(symbolRE)) {
                  source.skipToEnd();
                  return "comment";
                }
              }
              source.eatWhile(symbolRE);
              return "builtin";
            }

            return "error";
          }
        }

        function ncomment(type, nest) {
          if (nest == 0) {
            return normal();
          }
          return function(source, setState) {
            var currNest = nest;
            while (!source.eol()) {
              var ch = source.next();
              if (ch == '{' && source.eat('-')) {
                ++currNest;
              } else if (ch == '-' && source.eat('}')) {
                --currNest;
                if (currNest == 0) {
                  setState(normal());
                  return type;
                }
              }
            }
            setState(ncomment(type, currNest));
            return type;
          }
        }

        function stringLiteral(source, setState) {
          while (!source.eol()) {
            var ch = source.next();
            if (ch == '"') {
              setState(normal());
              return "string";
            }
            if (ch == '\\') {
              if (source.eol() || source.eat(whiteCharRE)) {
                setState(stringGap);
                return "string";
              }
              if (!source.eat('&')) source.next(); // should handle other escapes here
            }
          }
          setState(normal());
          return "error";
        }

        function stringGap(source, setState) {
          if (source.eat('\\')) {
            return switchState(source, setState, stringLiteral);
          }
          source.next();
          setState(normal());
          return "error";
        }


        var wellKnownWords = (function() {
          var wkw = {};

          var keywords = [
            "case", "of", "as",
            "if", "then", "else",
            "let", "in",
            "infix", "infixl", "infixr",
            "type", "alias",
            "input", "output", "foreign", "loopback",
            "module", "where", "import", "exposing",
            "_", "..", "|", ":", "=", "\\", "\"", "->", "<-"
          ];

          for (var i = keywords.length; i--;)
            wkw[keywords[i]] = "keyword";

          return wkw;
        })();



        return {
          startState: function ()  { return { f: normal() }; },
          copyState:  function (s) { return { f: s.f }; },

          token: function(stream, state) {
            var t = state.f(stream, function(s) { state.f = s; });
            var w = stream.current();
            return (wellKnownWords.hasOwnProperty(w)) ? wellKnownWords[w] : t;
          }
        };

      });

      CodeMirror.defineMIME("text/x-elm", "elm");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*jshint unused:true, eqnull:true, curly:true, bitwise:true */
    /*jshint undef:true, latedef:true, trailing:true */
    /*global CodeMirror:true */

    // erlang mode.
    // tokenizer -> token types -> CodeMirror styles
    // tokenizer maintains a parse stack
    // indenter uses the parse stack

    // TODO indenter:
    //   bit syntax
    //   old guard/bif/conversion clashes (e.g. "float/1")
    //   type/spec/opaque

    function Erlang(CodeMirror) {
    CodeMirror.defineMIME("text/x-erlang", "erlang");

    CodeMirror.defineMode("erlang", function(cmCfg) {

    /////////////////////////////////////////////////////////////////////////////
    // constants

      var typeWords = [
        "-type", "-spec", "-export_type", "-opaque"];

      var keywordWords = [
        "after","begin","catch","case","cond","end","fun","if",
        "let","of","query","receive","try","when"];

      var separatorRE    = /[\->,;]/;
      var separatorWords = [
        "->",";",","];

      var operatorAtomWords = [
        "and","andalso","band","bnot","bor","bsl","bsr","bxor",
        "div","not","or","orelse","rem","xor"];

      var operatorSymbolRE    = /[\+\-\*\/<>=\|:!]/;
      var operatorSymbolWords = [
        "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];

      var openParenRE    = /[<\(\[\{]/;
      var openParenWords = [
        "<<","(","[","{"];

      var closeParenRE    = /[>\)\]\}]/;
      var closeParenWords = [
        "}","]",")",">>"];

      var guardWords = [
        "is_atom","is_binary","is_bitstring","is_boolean","is_float",
        "is_function","is_integer","is_list","is_number","is_pid",
        "is_port","is_record","is_reference","is_tuple",
        "atom","binary","bitstring","boolean","function","integer","list",
        "number","pid","port","record","reference","tuple"];

      var bifWords = [
        "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
        "atom_to_list","binary_to_atom","binary_to_existing_atom",
        "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
        "byte_size","check_process_code","contact_binary","crc32",
        "crc32_combine","date","decode_packet","delete_module",
        "disconnect_node","element","erase","exit","float","float_to_list",
        "garbage_collect","get","get_keys","group_leader","halt","hd",
        "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
        "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
        "is_float","is_function","is_integer","is_list","is_number","is_pid",
        "is_port","is_process_alive","is_record","is_reference","is_tuple",
        "length","link","list_to_atom","list_to_binary","list_to_bitstring",
        "list_to_existing_atom","list_to_float","list_to_integer",
        "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
        "monitor_node","node","node_link","node_unlink","nodes","notalive",
        "now","open_port","pid_to_list","port_close","port_command",
        "port_connect","port_control","pre_loaded","process_flag",
        "process_info","processes","purge_module","put","register",
        "registered","round","self","setelement","size","spawn","spawn_link",
        "spawn_monitor","spawn_opt","split_binary","statistics",
        "term_to_binary","time","throw","tl","trunc","tuple_size",
        "tuple_to_list","unlink","unregister","whereis"];

    // upper case: [A-Z] [Ø-Þ] [À-Ö]
    // lower case: [a-z] [ß-ö] [ø-ÿ]
      var anumRE       = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/;
      var escapesRE    =
        /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

    /////////////////////////////////////////////////////////////////////////////
    // tokenizer

      function tokenizer(stream,state) {
        // in multi-line string
        if (state.in_string) {
          state.in_string = (!doubleQuote(stream));
          return rval(state,stream,"string");
        }

        // in multi-line atom
        if (state.in_atom) {
          state.in_atom = (!singleQuote(stream));
          return rval(state,stream,"atom");
        }

        // whitespace
        if (stream.eatSpace()) {
          return rval(state,stream,"whitespace");
        }

        // attributes and type specs
        if (!peekToken(state) &&
            stream.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) {
          if (is_member(stream.current(),typeWords)) {
            return rval(state,stream,"type");
          }else{
            return rval(state,stream,"attribute");
          }
        }

        var ch = stream.next();

        // comment
        if (ch == '%') {
          stream.skipToEnd();
          return rval(state,stream,"comment");
        }

        // colon
        if (ch == ":") {
          return rval(state,stream,"colon");
        }

        // macro
        if (ch == '?') {
          stream.eatSpace();
          stream.eatWhile(anumRE);
          return rval(state,stream,"macro");
        }

        // record
        if (ch == "#") {
          stream.eatSpace();
          stream.eatWhile(anumRE);
          return rval(state,stream,"record");
        }

        // dollar escape
        if (ch == "$") {
          if (stream.next() == "\\" && !stream.match(escapesRE)) {
            return rval(state,stream,"error");
          }
          return rval(state,stream,"number");
        }

        // dot
        if (ch == ".") {
          return rval(state,stream,"dot");
        }

        // quoted atom
        if (ch == '\'') {
          if (!(state.in_atom = (!singleQuote(stream)))) {
            if (stream.match(/\s*\/\s*[0-9]/,false)) {
              stream.match(/\s*\/\s*[0-9]/,true);
              return rval(state,stream,"fun");      // 'f'/0 style fun
            }
            if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
              return rval(state,stream,"function");
            }
          }
          return rval(state,stream,"atom");
        }

        // string
        if (ch == '"') {
          state.in_string = (!doubleQuote(stream));
          return rval(state,stream,"string");
        }

        // variable
        if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {
          stream.eatWhile(anumRE);
          return rval(state,stream,"variable");
        }

        // atom/keyword/BIF/function
        if (/[a-z_ß-öø-ÿ]/.test(ch)) {
          stream.eatWhile(anumRE);

          if (stream.match(/\s*\/\s*[0-9]/,false)) {
            stream.match(/\s*\/\s*[0-9]/,true);
            return rval(state,stream,"fun");      // f/0 style fun
          }

          var w = stream.current();

          if (is_member(w,keywordWords)) {
            return rval(state,stream,"keyword");
          }else if (is_member(w,operatorAtomWords)) {
            return rval(state,stream,"operator");
          }else if (stream.match(/\s*\(/,false)) {
            // 'put' and 'erlang:put' are bifs, 'foo:put' is not
            if (is_member(w,bifWords) &&
                ((peekToken(state).token != ":") ||
                 (peekToken(state,2).token == "erlang"))) {
              return rval(state,stream,"builtin");
            }else if (is_member(w,guardWords)) {
              return rval(state,stream,"guard");
            }else{
              return rval(state,stream,"function");
            }
          }else if (lookahead(stream) == ":") {
            if (w == "erlang") {
              return rval(state,stream,"builtin");
            } else {
              return rval(state,stream,"function");
            }
          }else if (is_member(w,["true","false"])) {
            return rval(state,stream,"boolean");
          }else{
            return rval(state,stream,"atom");
          }
        }

        // number
        var digitRE      = /[0-9]/;
        var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
        if (digitRE.test(ch)) {
          stream.eatWhile(digitRE);
          if (stream.eat('#')) {                // 36#aZ  style integer
            if (!stream.eatWhile(radixRE)) {
              stream.backUp(1);                 //"36#" - syntax error
            }
          } else if (stream.eat('.')) {       // float
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(1);        // "3." - probably end of function
            } else {
              if (stream.eat(/[eE]/)) {        // float with exponent
                if (stream.eat(/[-+]/)) {
                  if (!stream.eatWhile(digitRE)) {
                    stream.backUp(2);            // "2e-" - syntax error
                  }
                } else {
                  if (!stream.eatWhile(digitRE)) {
                    stream.backUp(1);            // "2e" - syntax error
                  }
                }
              }
            }
          }
          return rval(state,stream,"number");   // normal integer
        }

        // open parens
        if (nongreedy(stream,openParenRE,openParenWords)) {
          return rval(state,stream,"open_paren");
        }

        // close parens
        if (nongreedy(stream,closeParenRE,closeParenWords)) {
          return rval(state,stream,"close_paren");
        }

        // separators
        if (greedy(stream,separatorRE,separatorWords)) {
          return rval(state,stream,"separator");
        }

        // operators
        if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
          return rval(state,stream,"operator");
        }

        return rval(state,stream,null);
      }

    /////////////////////////////////////////////////////////////////////////////
    // utilities
      function nongreedy(stream,re,words) {
        if (stream.current().length == 1 && re.test(stream.current())) {
          stream.backUp(1);
          while (re.test(stream.peek())) {
            stream.next();
            if (is_member(stream.current(),words)) {
              return true;
            }
          }
          stream.backUp(stream.current().length-1);
        }
        return false;
      }

      function greedy(stream,re,words) {
        if (stream.current().length == 1 && re.test(stream.current())) {
          while (re.test(stream.peek())) {
            stream.next();
          }
          while (0 < stream.current().length) {
            if (is_member(stream.current(),words)) {
              return true;
            }else{
              stream.backUp(1);
            }
          }
          stream.next();
        }
        return false;
      }

      function doubleQuote(stream) {
        return quote(stream, '"', '\\');
      }

      function singleQuote(stream) {
        return quote(stream,'\'','\\');
      }

      function quote(stream,quoteChar,escapeChar) {
        while (!stream.eol()) {
          var ch = stream.next();
          if (ch == quoteChar) {
            return true;
          }else if (ch == escapeChar) {
            stream.next();
          }
        }
        return false;
      }

      function lookahead(stream) {
        var m = stream.match(/([\n\s]+|%[^\n]*\n)*(.)/,false);
        return m ? m.pop() : "";
      }

      function is_member(element,list) {
        return (-1 < list.indexOf(element));
      }

      function rval(state,stream,type) {

        // parse stack
        pushToken(state,realToken(type,stream));

        // map erlang token type to CodeMirror style class
        //     erlang             -> CodeMirror tag
        switch (type) {
          case "atom":        return "atom";
          case "attribute":   return "attribute";
          case "boolean":     return "atom";
          case "builtin":     return "builtin";
          case "close_paren": return null;
          case "colon":       return null;
          case "comment":     return "comment";
          case "dot":         return null;
          case "error":       return "error";
          case "fun":         return "meta";
          case "function":    return "tag";
          case "guard":       return "property";
          case "keyword":     return "keyword";
          case "macro":       return "variable-2";
          case "number":      return "number";
          case "open_paren":  return null;
          case "operator":    return "operator";
          case "record":      return "bracket";
          case "separator":   return null;
          case "string":      return "string";
          case "type":        return "def";
          case "variable":    return "variable";
          default:            return null;
        }
      }

      function aToken(tok,col,ind,typ) {
        return {token:  tok,
                column: col,
                indent: ind,
                type:   typ};
      }

      function realToken(type,stream) {
        return aToken(stream.current(),
                     stream.column(),
                     stream.indentation(),
                     type);
      }

      function fakeToken(type) {
        return aToken(type,0,0,type);
      }

      function peekToken(state,depth) {
        var len = state.tokenStack.length;
        var dep = (depth ? depth : 1);

        if (len < dep) {
          return false;
        }else{
          return state.tokenStack[len-dep];
        }
      }

      function pushToken(state,token) {

        if (!(token.type == "comment" || token.type == "whitespace")) {
          state.tokenStack = maybe_drop_pre(state.tokenStack,token);
          state.tokenStack = maybe_drop_post(state.tokenStack);
        }
      }

      function maybe_drop_pre(s,token) {
        var last = s.length-1;

        if (0 < last && s[last].type === "record" && token.type === "dot") {
          s.pop();
        }else if (0 < last && s[last].type === "group") {
          s.pop();
          s.push(token);
        }else{
          s.push(token);
        }
        return s;
      }

      function maybe_drop_post(s) {
        if (!s.length) return s
        var last = s.length-1;

        if (s[last].type === "dot") {
          return [];
        }
        if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {
          return s.slice(0,last-1);
        }
        switch (s[last].token) {
          case "}":    return d(s,{g:["{"]});
          case "]":    return d(s,{i:["["]});
          case ")":    return d(s,{i:["("]});
          case ">>":   return d(s,{i:["<<"]});
          case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});
          case ",":    return d(s,{e:["begin","try","when","->",
                                      ",","(","[","{","<<"]});
          case "->":   return d(s,{r:["when"],
                                   m:["try","if","case","receive"]});
          case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});
          case "catch":return d(s,{e:["try"]});
          case "of":   return d(s,{e:["case"]});
          case "after":return d(s,{e:["receive","try"]});
          default:     return s;
        }
      }

      function d(stack,tt) {
        // stack is a stack of Token objects.
        // tt is an object; {type:tokens}
        // type is a char, tokens is a list of token strings.
        // The function returns (possibly truncated) stack.
        // It will descend the stack, looking for a Token such that Token.token
        //  is a member of tokens. If it does not find that, it will normally (but
        //  see "E" below) return stack. If it does find a match, it will remove
        //  all the Tokens between the top and the matched Token.
        // If type is "m", that is all it does.
        // If type is "i", it will also remove the matched Token and the top Token.
        // If type is "g", like "i", but add a fake "group" token at the top.
        // If type is "r", it will remove the matched Token, but not the top Token.
        // If type is "e", it will keep the matched Token but not the top Token.
        // If type is "E", it behaves as for type "e", except if there is no match,
        //  in which case it will return an empty stack.

        for (var type in tt) {
          var len = stack.length-1;
          var tokens = tt[type];
          for (var i = len-1; -1 < i ; i--) {
            if (is_member(stack[i].token,tokens)) {
              var ss = stack.slice(0,i);
              switch (type) {
                  case "m": return ss.concat(stack[i]).concat(stack[len]);
                  case "r": return ss.concat(stack[len]);
                  case "i": return ss;
                  case "g": return ss.concat(fakeToken("group"));
                  case "E": return ss.concat(stack[i]);
                  case "e": return ss.concat(stack[i]);
              }
            }
          }
        }
        return (type == "E" ? [] : stack);
      }

    /////////////////////////////////////////////////////////////////////////////
    // indenter

      function indenter(state,textAfter) {
        var t;
        var unit = cmCfg.indentUnit;
        var wordAfter = wordafter(textAfter);
        var currT = peekToken(state,1);
        var prevT = peekToken(state,2);

        if (state.in_string || state.in_atom) {
          return CodeMirror.Pass;
        }else if (!prevT) {
          return 0;
        }else if (currT.token == "when") {
          return currT.column+unit;
        }else if (wordAfter === "when" && prevT.type === "function") {
          return prevT.indent+unit;
        }else if (wordAfter === "(" && currT.token === "fun") {
          return  currT.column+3;
        }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {
          return t.column;
        }else if (is_member(wordAfter,["end","after","of"])) {
          t = getToken(state,["begin","case","fun","if","receive","try"]);
          return t ? t.column : CodeMirror.Pass;
        }else if (is_member(wordAfter,closeParenWords)) {
          t = getToken(state,openParenWords);
          return t ? t.column : CodeMirror.Pass;
        }else if (is_member(currT.token,[",","|","||"]) ||
                  is_member(wordAfter,[",","|","||"])) {
          t = postcommaToken(state);
          return t ? t.column+t.token.length : unit;
        }else if (currT.token == "->") {
          if (is_member(prevT.token, ["receive","case","if","try"])) {
            return prevT.column+unit+unit;
          }else{
            return prevT.column+unit;
          }
        }else if (is_member(currT.token,openParenWords)) {
          return currT.column+currT.token.length;
        }else{
          t = defaultToken(state);
          return truthy(t) ? t.column+unit : 0;
        }
      }

      function wordafter(str) {
        var m = str.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/);

        return truthy(m) && (m.index === 0) ? m[0] : "";
      }

      function postcommaToken(state) {
        var objs = state.tokenStack.slice(0,-1);
        var i = getTokenIndex(objs,"type",["open_paren"]);

        return truthy(objs[i]) ? objs[i] : false;
      }

      function defaultToken(state) {
        var objs = state.tokenStack;
        var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);
        var oper = getTokenIndex(objs,"type",["operator"]);

        if (truthy(stop) && truthy(oper) && stop < oper) {
          return objs[stop+1];
        } else if (truthy(stop)) {
          return objs[stop];
        } else {
          return false;
        }
      }

      function getToken(state,tokens) {
        var objs = state.tokenStack;
        var i = getTokenIndex(objs,"token",tokens);

        return truthy(objs[i]) ? objs[i] : false;
      }

      function getTokenIndex(objs,propname,propvals) {

        for (var i = objs.length-1; -1 < i ; i--) {
          if (is_member(objs[i][propname],propvals)) {
            return i;
          }
        }
        return false;
      }

      function truthy(x) {
        return (x !== false) && (x != null);
      }

    /////////////////////////////////////////////////////////////////////////////
    // this object defines the mode

      return {
        startState:
          function() {
            return {tokenStack: [],
                    in_string:  false,
                    in_atom:    false};
          },

        token:
          function(stream, state) {
            return tokenizer(stream, state);
          },

        indent:
          function(state, textAfter) {
            return indenter(state,textAfter);
          },

        lineComment: "%"
      };
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Factor syntax highlight - simple mode
    //
    // by Dimage Sapelkin (https://github.com/kerabromsmu)

    function Factor(CodeMirror) {
      CodeMirror.defineSimpleMode("factor", {
        // The start state contains the rules that are intially used
        start: [
          // comments
          {regex: /#?!.*/, token: "comment"},
          // strings """, multiline --> state
          {regex: /"""/, token: "string", next: "string3"},
          {regex: /(STRING:)(\s)/, token: ["keyword", null], next: "string2"},
          {regex: /\S*?"/, token: "string", next: "string"},
          // numbers: dec, hex, unicode, bin, fractional, complex
          {regex: /(?:0x[\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\-?\d+.?\d*)(?=\s)/, token: "number"},
          //{regex: /[+-]?/} //fractional
          // definition: defining word, defined word, etc
          {regex: /((?:GENERIC)|\:?\:)(\s+)(\S+)(\s+)(\()/, token: ["keyword", null, "def", null, "bracket"], next: "stack"},
          // method definition: defining word, type, defined word, etc
          {regex: /(M\:)(\s+)(\S+)(\s+)(\S+)/, token: ["keyword", null, "def", null, "tag"]},
          // vocabulary using --> state
          {regex: /USING\:/, token: "keyword", next: "vocabulary"},
          // vocabulary definition/use
          {regex: /(USE\:|IN\:)(\s+)(\S+)(?=\s|$)/, token: ["keyword", null, "tag"]},
          // definition: a defining word, defined word
          {regex: /(\S+\:)(\s+)(\S+)(?=\s|$)/, token: ["keyword", null, "def"]},
          // "keywords", incl. ; t f . [ ] { } defining words
          {regex: /(?:;|\\|t|f|if|loop|while|until|do|PRIVATE>|<PRIVATE|\.|\S*\[|\]|\S*\{|\})(?=\s|$)/, token: "keyword"},
          // <constructors> and the like
          {regex: /\S+[\)>\.\*\?]+(?=\s|$)/, token: "builtin"},
          {regex: /[\)><]+\S+(?=\s|$)/, token: "builtin"},
          // operators
          {regex: /(?:[\+\-\=\/\*<>])(?=\s|$)/, token: "keyword"},
          // any id (?)
          {regex: /\S+/, token: "variable"},
          {regex: /\s+|./, token: null}
        ],
        vocabulary: [
          {regex: /;/, token: "keyword", next: "start"},
          {regex: /\S+/, token: "tag"},
          {regex: /\s+|./, token: null}
        ],
        string: [
          {regex: /(?:[^\\]|\\.)*?"/, token: "string", next: "start"},
          {regex: /.*/, token: "string"}
        ],
        string2: [
          {regex: /^;/, token: "keyword", next: "start"},
          {regex: /.*/, token: "string"}
        ],
        string3: [
          {regex: /(?:[^\\]|\\.)*?"""/, token: "string", next: "start"},
          {regex: /.*/, token: "string"}
        ],
        stack: [
          {regex: /\)/, token: "bracket", next: "start"},
          {regex: /--/, token: "bracket"},
          {regex: /\S+/, token: "meta"},
          {regex: /\s+|./, token: null}
        ],
        // The meta property contains global information about the mode. It
        // can contain properties like lineComment, which are supported by
        // all modes, and also directives like dontIndentStates, which are
        // specific to simple modes.
        meta: {
          dontIndentStates: ["start", "vocabulary", "string", "string3", "stack"],
          lineComment: [ "!", "#!" ]
        }
      });

      CodeMirror.defineMIME("text/x-factor", "factor");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function FCL(CodeMirror) {
    CodeMirror.defineMode("fcl", function(config) {
      var indentUnit = config.indentUnit;

      var keywords = {
          "term": true,
          "method": true, "accu": true,
          "rule": true, "then": true, "is": true, "and": true, "or": true,
          "if": true, "default": true
      };

      var start_blocks = {
          "var_input": true,
          "var_output": true,
          "fuzzify": true,
          "defuzzify": true,
          "function_block": true,
          "ruleblock": true
      };

      var end_blocks = {
          "end_ruleblock": true,
          "end_defuzzify": true,
          "end_function_block": true,
          "end_fuzzify": true,
          "end_var": true
      };

      var atoms = {
          "true": true, "false": true, "nan": true,
          "real": true, "min": true, "max": true, "cog": true, "cogs": true
      };

      var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

      function tokenBase(stream, state) {
        var ch = stream.next();

        if (/[\d\.]/.test(ch)) {
          if (ch == ".") {
            stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
          } else if (ch == "0") {
            stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
          } else {
            stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
          }
          return "number";
        }

        if (ch == "/" || ch == "(") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);

        var cur = stream.current().toLowerCase();
        if (keywords.propertyIsEnumerable(cur) ||
            start_blocks.propertyIsEnumerable(cur) ||
            end_blocks.propertyIsEnumerable(cur)) {
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }


      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if ((ch == "/" || ch == ")") && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }

      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }

      function popContext(state) {
        if (!state.context.prev) return;
        var t = state.context.type;
        if (t == "end_block")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
                if (ctx.align == null) ctx.align = false;
                state.indented = stream.indentation();
                state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;

            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            var cur = stream.current().toLowerCase();

            if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), "end_block");
            else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);

            state.startOfLine = false;
            return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var ctx = state.context;

          var closing = end_blocks.propertyIsEnumerable(textAfter);
          if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "ryk",
        fold: "brace",
        blockCommentStart: "(*",
        blockCommentEnd: "*)",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-fcl", "fcl");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Author: Aliaksei Chapyzhenka

    function Forth(CodeMirror) {
      function toWordList(words) {
        var ret = [];
        words.split(' ').forEach(function(e){
          ret.push({name: e});
        });
        return ret;
      }

      var coreWordList = toWordList(
    'INVERT AND OR XOR\
 2* 2/ LSHIFT RSHIFT\
 0= = 0< < > U< MIN MAX\
 2DROP 2DUP 2OVER 2SWAP ?DUP DEPTH DROP DUP OVER ROT SWAP\
 >R R> R@\
 + - 1+ 1- ABS NEGATE\
 S>D * M* UM*\
 FM/MOD SM/REM UM/MOD */ */MOD / /MOD MOD\
 HERE , @ ! CELL+ CELLS C, C@ C! CHARS 2@ 2!\
 ALIGN ALIGNED +! ALLOT\
 CHAR [CHAR] [ ] BL\
 FIND EXECUTE IMMEDIATE COUNT LITERAL STATE\
 ; DOES> >BODY\
 EVALUATE\
 SOURCE >IN\
 <# # #S #> HOLD SIGN BASE >NUMBER HEX DECIMAL\
 FILL MOVE\
 . CR EMIT SPACE SPACES TYPE U. .R U.R\
 ACCEPT\
 TRUE FALSE\
 <> U> 0<> 0>\
 NIP TUCK ROLL PICK\
 2>R 2R@ 2R>\
 WITHIN UNUSED MARKER\
 I J\
 TO\
 COMPILE, [COMPILE]\
 SAVE-INPUT RESTORE-INPUT\
 PAD ERASE\
 2LITERAL DNEGATE\
 D- D+ D0< D0= D2* D2/ D< D= DMAX DMIN D>S DABS\
 M+ M*/ D. D.R 2ROT DU<\
 CATCH THROW\
 FREE RESIZE ALLOCATE\
 CS-PICK CS-ROLL\
 GET-CURRENT SET-CURRENT FORTH-WORDLIST GET-ORDER SET-ORDER\
 PREVIOUS SEARCH-WORDLIST WORDLIST FIND ALSO ONLY FORTH DEFINITIONS ORDER\
 -TRAILING /STRING SEARCH COMPARE CMOVE CMOVE> BLANK SLITERAL');

      var immediateWordList = toWordList('IF ELSE THEN BEGIN WHILE REPEAT UNTIL RECURSE [IF] [ELSE] [THEN] ?DO DO LOOP +LOOP UNLOOP LEAVE EXIT AGAIN CASE OF ENDOF ENDCASE');

      CodeMirror.defineMode('forth', function() {
        function searchWordList (wordList, word) {
          var i;
          for (i = wordList.length - 1; i >= 0; i--) {
            if (wordList[i].name === word.toUpperCase()) {
              return wordList[i];
            }
          }
          return undefined;
        }
      return {
        startState: function() {
          return {
            state: '',
            base: 10,
            coreWordList: coreWordList,
            immediateWordList: immediateWordList,
            wordList: []
          };
        },
        token: function (stream, stt) {
          var mat;
          if (stream.eatSpace()) {
            return null;
          }
          if (stt.state === '') { // interpretation
            if (stream.match(/^(\]|:NONAME)(\s|$)/i)) {
              stt.state = ' compilation';
              return 'builtin compilation';
            }
            mat = stream.match(/^(\:)\s+(\S+)(\s|$)+/);
            if (mat) {
              stt.wordList.push({name: mat[2].toUpperCase()});
              stt.state = ' compilation';
              return 'def' + stt.state;
            }
            mat = stream.match(/^(VARIABLE|2VARIABLE|CONSTANT|2CONSTANT|CREATE|POSTPONE|VALUE|WORD)\s+(\S+)(\s|$)+/i);
            if (mat) {
              stt.wordList.push({name: mat[2].toUpperCase()});
              return 'def' + stt.state;
            }
            mat = stream.match(/^(\'|\[\'\])\s+(\S+)(\s|$)+/);
            if (mat) {
              return 'builtin' + stt.state;
            }
            } else { // compilation
            // ; [
            if (stream.match(/^(\;|\[)(\s)/)) {
              stt.state = '';
              stream.backUp(1);
              return 'builtin compilation';
            }
            if (stream.match(/^(\;|\[)($)/)) {
              stt.state = '';
              return 'builtin compilation';
            }
            if (stream.match(/^(POSTPONE)\s+\S+(\s|$)+/)) {
              return 'builtin';
            }
          }

          // dynamic wordlist
          mat = stream.match(/^(\S+)(\s+|$)/);
          if (mat) {
            if (searchWordList(stt.wordList, mat[1]) !== undefined) {
              return 'variable' + stt.state;
            }

            // comments
            if (mat[1] === '\\') {
              stream.skipToEnd();
                return 'comment' + stt.state;
              }

              // core words
              if (searchWordList(stt.coreWordList, mat[1]) !== undefined) {
                return 'builtin' + stt.state;
              }
              if (searchWordList(stt.immediateWordList, mat[1]) !== undefined) {
                return 'keyword' + stt.state;
              }

              if (mat[1] === '(') {
                stream.eatWhile(function (s) { return s !== ')'; });
                stream.eat(')');
                return 'comment' + stt.state;
              }

              // // strings
              if (mat[1] === '.(') {
                stream.eatWhile(function (s) { return s !== ')'; });
                stream.eat(')');
                return 'string' + stt.state;
              }
              if (mat[1] === 'S"' || mat[1] === '."' || mat[1] === 'C"') {
                stream.eatWhile(function (s) { return s !== '"'; });
                stream.eat('"');
                return 'string' + stt.state;
              }

              // numbers
              if (mat[1] - 0xfffffffff) {
                return 'number' + stt.state;
              }
              // if (mat[1].match(/^[-+]?[0-9]+\.[0-9]*/)) {
              //     return 'number' + stt.state;
              // }

              return 'atom' + stt.state;
            }
          }
        };
      });
      CodeMirror.defineMIME("text/x-forth", "forth");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Fortran(CodeMirror) {
    CodeMirror.defineMode("fortran", function() {
      function words(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i]] = true;
        }
        return keys;
      }

      var keywords = words([
                      "abstract", "accept", "allocatable", "allocate",
                      "array", "assign", "asynchronous", "backspace",
                      "bind", "block", "byte", "call", "case",
                      "class", "close", "common", "contains",
                      "continue", "cycle", "data", "deallocate",
                      "decode", "deferred", "dimension", "do",
                      "elemental", "else", "encode", "end",
                      "endif", "entry", "enumerator", "equivalence",
                      "exit", "external", "extrinsic", "final",
                      "forall", "format", "function", "generic",
                      "go", "goto", "if", "implicit", "import", "include",
                      "inquire", "intent", "interface", "intrinsic",
                      "module", "namelist", "non_intrinsic",
                      "non_overridable", "none", "nopass",
                      "nullify", "open", "optional", "options",
                      "parameter", "pass", "pause", "pointer",
                      "print", "private", "program", "protected",
                      "public", "pure", "read", "recursive", "result",
                      "return", "rewind", "save", "select", "sequence",
                      "stop", "subroutine", "target", "then", "to", "type",
                      "use", "value", "volatile", "where", "while",
                      "write"]);
      var builtins = words(["abort", "abs", "access", "achar", "acos",
                              "adjustl", "adjustr", "aimag", "aint", "alarm",
                              "all", "allocated", "alog", "amax", "amin",
                              "amod", "and", "anint", "any", "asin",
                              "associated", "atan", "besj", "besjn", "besy",
                              "besyn", "bit_size", "btest", "cabs", "ccos",
                              "ceiling", "cexp", "char", "chdir", "chmod",
                              "clog", "cmplx", "command_argument_count",
                              "complex", "conjg", "cos", "cosh", "count",
                              "cpu_time", "cshift", "csin", "csqrt", "ctime",
                              "c_funloc", "c_loc", "c_associated", "c_null_ptr",
                              "c_null_funptr", "c_f_pointer", "c_null_char",
                              "c_alert", "c_backspace", "c_form_feed",
                              "c_new_line", "c_carriage_return",
                              "c_horizontal_tab", "c_vertical_tab", "dabs",
                              "dacos", "dasin", "datan", "date_and_time",
                              "dbesj", "dbesj", "dbesjn", "dbesy", "dbesy",
                              "dbesyn", "dble", "dcos", "dcosh", "ddim", "derf",
                              "derfc", "dexp", "digits", "dim", "dint", "dlog",
                              "dlog", "dmax", "dmin", "dmod", "dnint",
                              "dot_product", "dprod", "dsign", "dsinh",
                              "dsin", "dsqrt", "dtanh", "dtan", "dtime",
                              "eoshift", "epsilon", "erf", "erfc", "etime",
                              "exit", "exp", "exponent", "extends_type_of",
                              "fdate", "fget", "fgetc", "float", "floor",
                              "flush", "fnum", "fputc", "fput", "fraction",
                              "fseek", "fstat", "ftell", "gerror", "getarg",
                              "get_command", "get_command_argument",
                              "get_environment_variable", "getcwd",
                              "getenv", "getgid", "getlog", "getpid",
                              "getuid", "gmtime", "hostnm", "huge", "iabs",
                              "iachar", "iand", "iargc", "ibclr", "ibits",
                              "ibset", "ichar", "idate", "idim", "idint",
                              "idnint", "ieor", "ierrno", "ifix", "imag",
                              "imagpart", "index", "int", "ior", "irand",
                              "isatty", "ishft", "ishftc", "isign",
                              "iso_c_binding", "is_iostat_end", "is_iostat_eor",
                              "itime", "kill", "kind", "lbound", "len", "len_trim",
                              "lge", "lgt", "link", "lle", "llt", "lnblnk", "loc",
                              "log", "logical", "long", "lshift", "lstat", "ltime",
                              "matmul", "max", "maxexponent", "maxloc", "maxval",
                              "mclock", "merge", "move_alloc", "min", "minexponent",
                              "minloc", "minval", "mod", "modulo", "mvbits",
                              "nearest", "new_line", "nint", "not", "or", "pack",
                              "perror", "precision", "present", "product", "radix",
                              "rand", "random_number", "random_seed", "range",
                              "real", "realpart", "rename", "repeat", "reshape",
                              "rrspacing", "rshift", "same_type_as", "scale",
                              "scan", "second", "selected_int_kind",
                              "selected_real_kind", "set_exponent", "shape",
                              "short", "sign", "signal", "sinh", "sin", "sleep",
                              "sngl", "spacing", "spread", "sqrt", "srand", "stat",
                              "sum", "symlnk", "system", "system_clock", "tan",
                              "tanh", "time", "tiny", "transfer", "transpose",
                              "trim", "ttynam", "ubound", "umask", "unlink",
                              "unpack", "verify", "xor", "zabs", "zcos", "zexp",
                              "zlog", "zsin", "zsqrt"]);

        var dataTypes =  words(["c_bool", "c_char", "c_double", "c_double_complex",
                         "c_float", "c_float_complex", "c_funptr", "c_int",
                         "c_int16_t", "c_int32_t", "c_int64_t", "c_int8_t",
                         "c_int_fast16_t", "c_int_fast32_t", "c_int_fast64_t",
                         "c_int_fast8_t", "c_int_least16_t", "c_int_least32_t",
                         "c_int_least64_t", "c_int_least8_t", "c_intmax_t",
                         "c_intptr_t", "c_long", "c_long_double",
                         "c_long_double_complex", "c_long_long", "c_ptr",
                         "c_short", "c_signed_char", "c_size_t", "character",
                         "complex", "double", "integer", "logical", "real"]);
      var isOperatorChar = /[+\-*&=<>\/\:]/;
      var litOperator = new RegExp("(\.and\.|\.or\.|\.eq\.|\.lt\.|\.le\.|\.gt\.|\.ge\.|\.ne\.|\.not\.|\.eqv\.|\.neqv\.)", "i");

      function tokenBase(stream, state) {

        if (stream.match(litOperator)){
            return 'operator';
        }

        var ch = stream.next();
        if (ch == "!") {
          stream.skipToEnd();
          return "comment";
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]\(\),]/.test(ch)) {
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var word = stream.current().toLowerCase();

        if (keywords.hasOwnProperty(word)){
                return 'keyword';
        }
        if (builtins.hasOwnProperty(word) || dataTypes.hasOwnProperty(word)) {
                return 'builtin';
        }
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
                end = true;
                break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped) state.tokenize = null;
          return "string";
        };
      }

      // Interface

      return {
        startState: function() {
          return {tokenize: null};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          return style;
        }
      };
    });

    CodeMirror.defineMIME("text/x-fortran", "fortran");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Gas(CodeMirror) {
    CodeMirror.defineMode("gas", function(_config, parserConfig) {

      // If an architecture is specified, its initialization function may
      // populate this array with custom parsing functions which will be
      // tried in the event that the standard functions do not find a match.
      var custom = [];

      // The symbol used to start a line comment changes based on the target
      // architecture.
      // If no architecture is pased in "parserConfig" then only multiline
      // comments will have syntax support.
      var lineCommentStartSymbol = "";

      // These directives are architecture independent.
      // Machine specific directives should go in their respective
      // architecture initialization function.
      // Reference:
      // http://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops
      var directives = {
        ".abort" : "builtin",
        ".align" : "builtin",
        ".altmacro" : "builtin",
        ".ascii" : "builtin",
        ".asciz" : "builtin",
        ".balign" : "builtin",
        ".balignw" : "builtin",
        ".balignl" : "builtin",
        ".bundle_align_mode" : "builtin",
        ".bundle_lock" : "builtin",
        ".bundle_unlock" : "builtin",
        ".byte" : "builtin",
        ".cfi_startproc" : "builtin",
        ".comm" : "builtin",
        ".data" : "builtin",
        ".def" : "builtin",
        ".desc" : "builtin",
        ".dim" : "builtin",
        ".double" : "builtin",
        ".eject" : "builtin",
        ".else" : "builtin",
        ".elseif" : "builtin",
        ".end" : "builtin",
        ".endef" : "builtin",
        ".endfunc" : "builtin",
        ".endif" : "builtin",
        ".equ" : "builtin",
        ".equiv" : "builtin",
        ".eqv" : "builtin",
        ".err" : "builtin",
        ".error" : "builtin",
        ".exitm" : "builtin",
        ".extern" : "builtin",
        ".fail" : "builtin",
        ".file" : "builtin",
        ".fill" : "builtin",
        ".float" : "builtin",
        ".func" : "builtin",
        ".global" : "builtin",
        ".gnu_attribute" : "builtin",
        ".hidden" : "builtin",
        ".hword" : "builtin",
        ".ident" : "builtin",
        ".if" : "builtin",
        ".incbin" : "builtin",
        ".include" : "builtin",
        ".int" : "builtin",
        ".internal" : "builtin",
        ".irp" : "builtin",
        ".irpc" : "builtin",
        ".lcomm" : "builtin",
        ".lflags" : "builtin",
        ".line" : "builtin",
        ".linkonce" : "builtin",
        ".list" : "builtin",
        ".ln" : "builtin",
        ".loc" : "builtin",
        ".loc_mark_labels" : "builtin",
        ".local" : "builtin",
        ".long" : "builtin",
        ".macro" : "builtin",
        ".mri" : "builtin",
        ".noaltmacro" : "builtin",
        ".nolist" : "builtin",
        ".octa" : "builtin",
        ".offset" : "builtin",
        ".org" : "builtin",
        ".p2align" : "builtin",
        ".popsection" : "builtin",
        ".previous" : "builtin",
        ".print" : "builtin",
        ".protected" : "builtin",
        ".psize" : "builtin",
        ".purgem" : "builtin",
        ".pushsection" : "builtin",
        ".quad" : "builtin",
        ".reloc" : "builtin",
        ".rept" : "builtin",
        ".sbttl" : "builtin",
        ".scl" : "builtin",
        ".section" : "builtin",
        ".set" : "builtin",
        ".short" : "builtin",
        ".single" : "builtin",
        ".size" : "builtin",
        ".skip" : "builtin",
        ".sleb128" : "builtin",
        ".space" : "builtin",
        ".stab" : "builtin",
        ".string" : "builtin",
        ".struct" : "builtin",
        ".subsection" : "builtin",
        ".symver" : "builtin",
        ".tag" : "builtin",
        ".text" : "builtin",
        ".title" : "builtin",
        ".type" : "builtin",
        ".uleb128" : "builtin",
        ".val" : "builtin",
        ".version" : "builtin",
        ".vtable_entry" : "builtin",
        ".vtable_inherit" : "builtin",
        ".warning" : "builtin",
        ".weak" : "builtin",
        ".weakref" : "builtin",
        ".word" : "builtin"
      };

      var registers = {};

      function x86(_parserConfig) {
        lineCommentStartSymbol = "#";

        registers.ax  = "variable";
        registers.eax = "variable-2";
        registers.rax = "variable-3";

        registers.bx  = "variable";
        registers.ebx = "variable-2";
        registers.rbx = "variable-3";

        registers.cx  = "variable";
        registers.ecx = "variable-2";
        registers.rcx = "variable-3";

        registers.dx  = "variable";
        registers.edx = "variable-2";
        registers.rdx = "variable-3";

        registers.si  = "variable";
        registers.esi = "variable-2";
        registers.rsi = "variable-3";

        registers.di  = "variable";
        registers.edi = "variable-2";
        registers.rdi = "variable-3";

        registers.sp  = "variable";
        registers.esp = "variable-2";
        registers.rsp = "variable-3";

        registers.bp  = "variable";
        registers.ebp = "variable-2";
        registers.rbp = "variable-3";

        registers.ip  = "variable";
        registers.eip = "variable-2";
        registers.rip = "variable-3";

        registers.cs  = "keyword";
        registers.ds  = "keyword";
        registers.ss  = "keyword";
        registers.es  = "keyword";
        registers.fs  = "keyword";
        registers.gs  = "keyword";
      }

      function armv6(_parserConfig) {
        // Reference:
        // http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
        // http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf
        lineCommentStartSymbol = "@";
        directives.syntax = "builtin";

        registers.r0  = "variable";
        registers.r1  = "variable";
        registers.r2  = "variable";
        registers.r3  = "variable";
        registers.r4  = "variable";
        registers.r5  = "variable";
        registers.r6  = "variable";
        registers.r7  = "variable";
        registers.r8  = "variable";
        registers.r9  = "variable";
        registers.r10 = "variable";
        registers.r11 = "variable";
        registers.r12 = "variable";

        registers.sp  = "variable-2";
        registers.lr  = "variable-2";
        registers.pc  = "variable-2";
        registers.r13 = registers.sp;
        registers.r14 = registers.lr;
        registers.r15 = registers.pc;

        custom.push(function(ch, stream) {
          if (ch === '#') {
            stream.eatWhile(/\w/);
            return "number";
          }
        });
      }

      var arch = (parserConfig.architecture || "x86").toLowerCase();
      if (arch === "x86") {
        x86(parserConfig);
      } else if (arch === "arm" || arch === "armv6") {
        armv6(parserConfig);
      }

      function nextUntilUnescaped(stream, end) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (next === end && !escaped) {
            return false;
          }
          escaped = !escaped && next === "\\";
        }
        return escaped;
      }

      function clikeComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch === "/" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch === "*");
        }
        return "comment";
      }

      return {
        startState: function() {
          return {
            tokenize: null
          };
        },

        token: function(stream, state) {
          if (state.tokenize) {
            return state.tokenize(stream, state);
          }

          if (stream.eatSpace()) {
            return null;
          }

          var style, cur, ch = stream.next();

          if (ch === "/") {
            if (stream.eat("*")) {
              state.tokenize = clikeComment;
              return clikeComment(stream, state);
            }
          }

          if (ch === lineCommentStartSymbol) {
            stream.skipToEnd();
            return "comment";
          }

          if (ch === '"') {
            nextUntilUnescaped(stream, '"');
            return "string";
          }

          if (ch === '.') {
            stream.eatWhile(/\w/);
            cur = stream.current().toLowerCase();
            style = directives[cur];
            return style || null;
          }

          if (ch === '=') {
            stream.eatWhile(/\w/);
            return "tag";
          }

          if (ch === '{') {
            return "braket";
          }

          if (ch === '}') {
            return "braket";
          }

          if (/\d/.test(ch)) {
            if (ch === "0" && stream.eat("x")) {
              stream.eatWhile(/[0-9a-fA-F]/);
              return "number";
            }
            stream.eatWhile(/\d/);
            return "number";
          }

          if (/\w/.test(ch)) {
            stream.eatWhile(/\w/);
            if (stream.eat(":")) {
              return 'tag';
            }
            cur = stream.current().toLowerCase();
            style = registers[cur];
            return style || null;
          }

          for (var i = 0; i < custom.length; i++) {
            style = custom[i](ch, stream, state);
            if (style) {
              return style;
            }
          }
        },

        lineComment: lineCommentStartSymbol,
        blockCommentStart: "/*",
        blockCommentEnd: "*/"
      };
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    function GFM(CodeMirror) {
    var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i;

    CodeMirror.defineMode("gfm", function(config, modeConfig) {
      var codeDepth = 0;
      function blankLine(state) {
        state.code = false;
        return null;
      }
      var gfmOverlay = {
        startState: function() {
          return {
            code: false,
            codeBlock: false,
            ateSpace: false
          };
        },
        copyState: function(s) {
          return {
            code: s.code,
            codeBlock: s.codeBlock,
            ateSpace: s.ateSpace
          };
        },
        token: function(stream, state) {
          state.combineTokens = null;

          // Hack to prevent formatting override inside code blocks (block and inline)
          if (state.codeBlock) {
            if (stream.match(/^```+/)) {
              state.codeBlock = false;
              return null;
            }
            stream.skipToEnd();
            return null;
          }
          if (stream.sol()) {
            state.code = false;
          }
          if (stream.sol() && stream.match(/^```+/)) {
            stream.skipToEnd();
            state.codeBlock = true;
            return null;
          }
          // If this block is changed, it may need to be updated in Markdown mode
          if (stream.peek() === '`') {
            stream.next();
            var before = stream.pos;
            stream.eatWhile('`');
            var difference = 1 + stream.pos - before;
            if (!state.code) {
              codeDepth = difference;
              state.code = true;
            } else {
              if (difference === codeDepth) { // Must be exact
                state.code = false;
              }
            }
            return null;
          } else if (state.code) {
            stream.next();
            return null;
          }
          // Check if space. If so, links can be formatted later on
          if (stream.eatSpace()) {
            state.ateSpace = true;
            return null;
          }
          if (stream.sol() || state.ateSpace) {
            state.ateSpace = false;
            if (modeConfig.gitHubSpice !== false) {
              if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                // User/Project@SHA
                // User@SHA
                // SHA
                state.combineTokens = true;
                return "link";
              } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                // User/Project#Num
                // User#Num
                // #Num
                state.combineTokens = true;
                return "link";
              }
            }
          }
          if (stream.match(urlRE) &&
              stream.string.slice(stream.start - 2, stream.start) != "](" &&
              (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
            // URLs
            // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
            // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
            // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
            state.combineTokens = true;
            return "link";
          }
          stream.next();
          return null;
        },
        blankLine: blankLine
      };

      var markdownConfig = {
        taskLists: true,
        strikethrough: true,
        emoji: true
      };
      for (var attr in modeConfig) {
        markdownConfig[attr] = modeConfig[attr];
      }
      markdownConfig.name = "markdown";
      return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);

    }, "markdown");

      CodeMirror.defineMIME("text/x-gfm", "gfm");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
    Gherkin mode - http://www.cukes.info/
    Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
    */

    // Following Objs from Brackets implementation: https://github.com/tregusti/brackets-gherkin/blob/master/main.js
    //var Quotes = {
    //  SINGLE: 1,
    //  DOUBLE: 2
    //};

    //var regex = {
    //  keywords: /(Feature| {2}(Scenario|In order to|As|I)| {4}(Given|When|Then|And))/
    //};

    function Gherkin(CodeMirror) {
    CodeMirror.defineMode("gherkin", function () {
      return {
        startState: function () {
          return {
            lineNumber: 0,
            tableHeaderLine: false,
            allowFeature: true,
            allowBackground: false,
            allowScenario: false,
            allowSteps: false,
            allowPlaceholders: false,
            allowMultilineArgument: false,
            inMultilineString: false,
            inMultilineTable: false,
            inKeywordLine: false
          };
        },
        token: function (stream, state) {
          if (stream.sol()) {
            state.lineNumber++;
            state.inKeywordLine = false;
            if (state.inMultilineTable) {
                state.tableHeaderLine = false;
                if (!stream.match(/\s*\|/, false)) {
                  state.allowMultilineArgument = false;
                  state.inMultilineTable = false;
                }
            }
          }

          stream.eatSpace();

          if (state.allowMultilineArgument) {

            // STRING
            if (state.inMultilineString) {
              if (stream.match('"""')) {
                state.inMultilineString = false;
                state.allowMultilineArgument = false;
              } else {
                stream.match(/.*/);
              }
              return "string";
            }

            // TABLE
            if (state.inMultilineTable) {
              if (stream.match(/\|\s*/)) {
                return "bracket";
              } else {
                stream.match(/[^\|]*/);
                return state.tableHeaderLine ? "header" : "string";
              }
            }

            // DETECT START
            if (stream.match('"""')) {
              // String
              state.inMultilineString = true;
              return "string";
            } else if (stream.match("|")) {
              // Table
              state.inMultilineTable = true;
              state.tableHeaderLine = true;
              return "bracket";
            }

          }

          // LINE COMMENT
          if (stream.match(/#.*/)) {
            return "comment";

          // TAG
          } else if (!state.inKeywordLine && stream.match(/@\S+/)) {
            return "tag";

          // FEATURE
          } else if (!state.inKeywordLine && state.allowFeature && stream.match(/(機能|功能|フィーチャ|기능|โครงหลัก|ความสามารถ|ความต้องการทางธุรกิจ|ಹೆಚ್ಚಳ|గుణము|ਮੁਹਾਂਦਰਾ|ਨਕਸ਼ ਨੁਹਾਰ|ਖਾਸੀਅਤ|रूप लेख|وِیژگی|خاصية|תכונה|Функціонал|Функция|Функционалност|Функционал|Үзенчәлеклелек|Свойство|Особина|Мөмкинлек|Могућност|Λειτουργία|Δυνατότητα|Właściwość|Vlastnosť|Trajto|Tính năng|Savybė|Pretty much|Požiadavka|Požadavek|Potrzeba biznesowa|Özellik|Osobina|Ominaisuus|Omadus|OH HAI|Mogućnost|Mogucnost|Jellemző|Hwæt|Hwaet|Funzionalità|Funktionalitéit|Funktionalität|Funkcja|Funkcionalnost|Funkcionalitāte|Funkcia|Fungsi|Functionaliteit|Funcționalitate|Funcţionalitate|Functionalitate|Funcionalitat|Funcionalidade|Fonctionnalité|Fitur|Fīča|Feature|Eiginleiki|Egenskap|Egenskab|Característica|Caracteristica|Business Need|Aspekt|Arwedd|Ahoy matey!|Ability):/)) {
            state.allowScenario = true;
            state.allowBackground = true;
            state.allowPlaceholders = false;
            state.allowSteps = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // BACKGROUND
          } else if (!state.inKeywordLine && state.allowBackground && stream.match(/(背景|배경|แนวคิด|ಹಿನ್ನೆಲೆ|నేపథ్యం|ਪਿਛੋਕੜ|पृष्ठभूमि|زمینه|الخلفية|רקע|Тарих|Предыстория|Предистория|Позадина|Передумова|Основа|Контекст|Кереш|Υπόβαθρο|Założenia|Yo\-ho\-ho|Tausta|Taust|Situācija|Rerefons|Pozadina|Pozadie|Pozadí|Osnova|Latar Belakang|Kontext|Konteksts|Kontekstas|Kontekst|Háttér|Hannergrond|Grundlage|Geçmiş|Fundo|Fono|First off|Dis is what went down|Dasar|Contexto|Contexte|Context|Contesto|Cenário de Fundo|Cenario de Fundo|Cefndir|Bối cảnh|Bakgrunnur|Bakgrunn|Bakgrund|Baggrund|Background|B4|Antecedents|Antecedentes|Ær|Aer|Achtergrond):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // SCENARIO OUTLINE
          } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景大綱|场景大纲|劇本大綱|剧本大纲|テンプレ|シナリオテンプレート|シナリオテンプレ|シナリオアウトライン|시나리오 개요|สรุปเหตุการณ์|โครงสร้างของเหตุการณ์|ವಿವರಣೆ|కథనం|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਟਕਥਾ ਢਾਂਚਾ|परिदृश्य रूपरेखा|سيناريو مخطط|الگوی سناریو|תבנית תרחיש|Сценарийның төзелеше|Сценарий структураси|Структура сценарію|Структура сценария|Структура сценарија|Скица|Рамка на сценарий|Концепт|Περιγραφή Σεναρίου|Wharrimean is|Template Situai|Template Senario|Template Keadaan|Tapausaihio|Szenariogrundriss|Szablon scenariusza|Swa hwær swa|Swa hwaer swa|Struktura scenarija|Structură scenariu|Structura scenariu|Skica|Skenario konsep|Shiver me timbers|Senaryo taslağı|Schema dello scenario|Scenariomall|Scenariomal|Scenario Template|Scenario Outline|Scenario Amlinellol|Scenārijs pēc parauga|Scenarijaus šablonas|Reckon it's like|Raamstsenaarium|Plang vum Szenario|Plan du Scénario|Plan du scénario|Osnova scénáře|Osnova Scenára|Náčrt Scenáru|Náčrt Scénáře|Náčrt Scenára|MISHUN SRSLY|Menggariskan Senario|Lýsing Dæma|Lýsing Atburðarásar|Konturo de la scenaro|Koncept|Khung tình huống|Khung kịch bản|Forgatókönyv vázlat|Esquema do Cenário|Esquema do Cenario|Esquema del escenario|Esquema de l'escenari|Esbozo do escenario|Delineação do Cenário|Delineacao do Cenario|All y'all|Abstrakt Scenario|Abstract Scenario):/)) {
            state.allowPlaceholders = true;
            state.allowSteps = true;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // EXAMPLES
          } else if (state.allowScenario && stream.match(/(例子|例|サンプル|예|ชุดของเหตุการณ์|ชุดของตัวอย่าง|ಉದಾಹರಣೆಗಳು|ఉదాహరణలు|ਉਦਾਹਰਨਾਂ|उदाहरण|نمونه ها|امثلة|דוגמאות|Үрнәкләр|Сценарији|Примеры|Примери|Приклади|Мисоллар|Мисаллар|Σενάρια|Παραδείγματα|You'll wanna|Voorbeelden|Variantai|Tapaukset|Se þe|Se the|Se ðe|Scenarios|Scenariji|Scenarijai|Przykłady|Primjeri|Primeri|Příklady|Príklady|Piemēri|Példák|Pavyzdžiai|Paraugs|Örnekler|Juhtumid|Exemplos|Exemples|Exemple|Exempel|EXAMPLZ|Examples|Esempi|Enghreifftiau|Ekzemploj|Eksempler|Ejemplos|Dữ liệu|Dead men tell no tales|Dæmi|Contoh|Cenários|Cenarios|Beispiller|Beispiele|Atburðarásir):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = true;
            return "keyword";

          // SCENARIO
          } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景|场景|劇本|剧本|シナリオ|시나리오|เหตุการณ์|ಕಥಾಸಾರಾಂಶ|సన్నివేశం|ਪਟਕਥਾ|परिदृश्य|سيناريو|سناریو|תרחיש|Сценарій|Сценарио|Сценарий|Пример|Σενάριο|Tình huống|The thing of it is|Tapaus|Szenario|Swa|Stsenaarium|Skenario|Situai|Senaryo|Senario|Scenaro|Scenariusz|Scenariu|Scénario|Scenario|Scenarijus|Scenārijs|Scenarij|Scenarie|Scénář|Scenár|Primer|MISHUN|Kịch bản|Keadaan|Heave to|Forgatókönyv|Escenario|Escenari|Cenário|Cenario|Awww, look mate|Atburðarás):/)) {
            state.allowPlaceholders = false;
            state.allowSteps = true;
            state.allowBackground = false;
            state.allowMultilineArgument = false;
            state.inKeywordLine = true;
            return "keyword";

          // STEPS
          } else if (!state.inKeywordLine && state.allowSteps && stream.match(/(那麼|那么|而且|當|当|并且|同時|同时|前提|假设|假設|假定|假如|但是|但し|並且|もし|ならば|ただし|しかし|かつ|하지만|조건|먼저|만일|만약|단|그리고|그러면|และ |เมื่อ |แต่ |ดังนั้น |กำหนดให้ |ಸ್ಥಿತಿಯನ್ನು |ಮತ್ತು |ನೀಡಿದ |ನಂತರ |ಆದರೆ |మరియు |చెప్పబడినది |కాని |ఈ పరిస్థితిలో |అప్పుడు |ਪਰ |ਤਦ |ਜੇਕਰ |ਜਿਵੇਂ ਕਿ |ਜਦੋਂ |ਅਤੇ |यदि |परन्तु |पर |तब |तदा |तथा |जब |चूंकि |किन्तु |कदा |और |अगर |و |هنگامی |متى |لكن |عندما |ثم |بفرض |با فرض |اما |اذاً |آنگاه |כאשר |וגם |בהינתן |אזי |אז |אבל |Якщо |Һәм |Унда |Тоді |Тогда |То |Также |Та |Пусть |Припустимо, що |Припустимо |Онда |Но |Нехай |Нәтиҗәдә |Лекин |Ләкин |Коли |Когда |Когато |Када |Кад |К тому же |І |И |Задато |Задати |Задате |Если |Допустим |Дано |Дадено |Вә |Ва |Бирок |Әмма |Әйтик |Әгәр |Аммо |Али |Але |Агар |А також |А |Τότε |Όταν |Και |Δεδομένου |Αλλά |Þurh |Þegar |Þa þe |Þá |Þa |Zatati |Zakładając |Zadato |Zadate |Zadano |Zadani |Zadan |Za předpokladu |Za predpokladu |Youse know when youse got |Youse know like when |Yna |Yeah nah |Y'know |Y |Wun |Wtedy |When y'all |When |Wenn |WEN |wann |Ve |Và |Und |Un |ugeholl |Too right |Thurh |Thì |Then y'all |Then |Tha the |Tha |Tetapi |Tapi |Tak |Tada |Tad |Stel |Soit |Siis |Și |Şi |Si |Sed |Se |Så |Quando |Quand |Quan |Pryd |Potom |Pokud |Pokiaľ |Però |Pero |Pak |Oraz |Onda |Ond |Oletetaan |Og |Och |O zaman |Niin |Nhưng |När |Når |Mutta |Men |Mas |Maka |Majd |Mając |Mais |Maar |mä |Ma |Lorsque |Lorsqu'|Logo |Let go and haul |Kun |Kuid |Kui |Kiedy |Khi |Ketika |Kemudian |Keď |Když |Kaj |Kai |Kada |Kad |Jeżeli |Jeśli |Ja |It's just unbelievable |Ir |I CAN HAZ |I |Ha |Givun |Givet |Given y'all |Given |Gitt |Gegeven |Gegeben seien |Gegeben sei |Gdy |Gangway! |Fakat |Étant donnés |Etant donnés |Étant données |Etant données |Étant donnée |Etant donnée |Étant donné |Etant donné |Et |És |Entonces |Entón |Então |Entao |En |Eğer ki |Ef |Eeldades |E |Ðurh |Duota |Dun |Donitaĵo |Donat |Donada |Do |Diyelim ki |Diberi |Dengan |Den youse gotta |DEN |De |Dato |Dați fiind |Daţi fiind |Dati fiind |Dati |Date fiind |Date |Data |Dat fiind |Dar |Dann |dann |Dan |Dados |Dado |Dadas |Dada |Ða ðe |Ða |Cuando |Cho |Cando |Când |Cand |Cal |But y'all |But at the end of the day I reckon |BUT |But |Buh |Blimey! |Biết |Bet |Bagi |Aye |awer |Avast! |Atunci |Atesa |Atès |Apabila |Anrhegedig a |Angenommen |And y'all |And |AN |An |an |Amikor |Amennyiben |Ama |Als |Alors |Allora |Ali |Aleshores |Ale |Akkor |Ak |Adott |Ac |Aber |A zároveň |A tiež |A taktiež |A také |A |a |7 |\* )/)) {
            state.inStep = true;
            state.allowPlaceholders = true;
            state.allowMultilineArgument = true;
            state.inKeywordLine = true;
            return "keyword";

          // INLINE STRING
          } else if (stream.match(/"[^"]*"?/)) {
            return "string";

          // PLACEHOLDER
          } else if (state.allowPlaceholders && stream.match(/<[^>]*>?/)) {
            return "variable";

          // Fall through
          } else {
            stream.next();
            stream.eatWhile(/[^@"<#]/);
            return null;
          }
        }
      };
    });

    CodeMirror.defineMIME("text/x-feature", "gherkin");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Go(CodeMirror) {
    CodeMirror.defineMode("go", function(config) {
      var indentUnit = config.indentUnit;

      var keywords = {
        "break":true, "case":true, "chan":true, "const":true, "continue":true,
        "default":true, "defer":true, "else":true, "fallthrough":true, "for":true,
        "func":true, "go":true, "goto":true, "if":true, "import":true,
        "interface":true, "map":true, "package":true, "range":true, "return":true,
        "select":true, "struct":true, "switch":true, "type":true, "var":true,
        "bool":true, "byte":true, "complex64":true, "complex128":true,
        "float32":true, "float64":true, "int8":true, "int16":true, "int32":true,
        "int64":true, "string":true, "uint8":true, "uint16":true, "uint32":true,
        "uint64":true, "int":true, "uint":true, "uintptr":true, "error": true,
        "rune":true
      };

      var atoms = {
        "true":true, "false":true, "iota":true, "nil":true, "append":true,
        "cap":true, "close":true, "complex":true, "copy":true, "delete":true, "imag":true,
        "len":true, "make":true, "new":true, "panic":true, "print":true,
        "println":true, "real":true, "recover":true
      };

      var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'" || ch == "`") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\d\.]/.test(ch)) {
          if (ch == ".") {
            stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
          } else if (ch == "0") {
            stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
          } else {
            stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
          }
          return "number";
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) {
          if (cur == "case" || cur == "default") curPunc = "case";
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && quote != "`" && next == "\\";
          }
          if (end || !(escaped || quote == "`"))
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        if (!state.context.prev) return;
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
            if (ctx.type == "case") ctx.type = "}";
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment") return style;
          if (ctx.align == null) ctx.align = true;

          if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "case") ctx.type = "case";
          else if (curPunc == "}" && ctx.type == "}") popContext(state);
          else if (curPunc == ctx.type) popContext(state);
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "case" && /^(?:case|default)\b/.test(textAfter)) {
            state.context.type = "}";
            return ctx.indented;
          }
          var closing = firstChar == ctx.type;
          if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}):",
        closeBrackets: "()[]{}''\"\"``",
        fold: "brace",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-go", "go");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Groovy(CodeMirror) {
    CodeMirror.defineMode("groovy", function(config) {
      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = words(
        "abstract as assert boolean break byte case catch char class const continue def default " +
        "do double else enum extends final finally float for goto if implements import in " +
        "instanceof int interface long native new package private protected public return " +
        "short static strictfp super switch synchronized threadsafe throw throws trait transient " +
        "try void volatile while");
      var blockKeywords = words("catch class def do else enum finally for if interface switch trait try while");
      var standaloneKeywords = words("return break continue");
      var atoms = words("null true false this");

      var curPunc;
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          return startString(ch, stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          if (stream.eat(/eE/)) { stream.eat(/\+\-/); stream.eatWhile(/\d/); }
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize.push(tokenComment);
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
          if (expectExpression(state.lastToken, false)) {
            return startString(ch, stream, state);
          }
        }
        if (ch == "-" && stream.eat(">")) {
          curPunc = "->";
          return null;
        }
        if (/[+\-*&%=<>!?|\/~]/.test(ch)) {
          stream.eatWhile(/[+\-*&%=<>|~]/);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        if (ch == "@") { stream.eatWhile(/[\w\$_\.]/); return "meta"; }
        if (state.lastToken == ".") return "property";
        if (stream.eat(":")) { curPunc = "proplabel"; return "property"; }
        var cur = stream.current();
        if (atoms.propertyIsEnumerable(cur)) { return "atom"; }
        if (keywords.propertyIsEnumerable(cur)) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = "standalone";
          return "keyword";
        }
        return "variable";
      }
      tokenBase.isBase = true;

      function startString(quote, stream, state) {
        var tripleQuoted = false;
        if (quote != "/" && stream.eat(quote)) {
          if (stream.eat(quote)) tripleQuoted = true;
          else return "string";
        }
        function t(stream, state) {
          var escaped = false, next, end = !tripleQuoted;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              if (!tripleQuoted) { break; }
              if (stream.match(quote + quote)) { end = true; break; }
            }
            if (quote == '"' && next == "$" && !escaped && stream.eat("{")) {
              state.tokenize.push(tokenBaseUntilBrace());
              return "string";
            }
            escaped = !escaped && next == "\\";
          }
          if (end) state.tokenize.pop();
          return "string";
        }
        state.tokenize.push(t);
        return t(stream, state);
      }

      function tokenBaseUntilBrace() {
        var depth = 1;
        function t(stream, state) {
          if (stream.peek() == "}") {
            depth--;
            if (depth == 0) {
              state.tokenize.pop();
              return state.tokenize[state.tokenize.length-1](stream, state);
            }
          } else if (stream.peek() == "{") {
            depth++;
          }
          return tokenBase(stream, state);
        }
        t.isBase = true;
        return t;
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize.pop();
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function expectExpression(last, newline) {
        return !last || last == "operator" || last == "->" || /[\.\[\{\(,;:]/.test(last) ||
          last == "newstatement" || last == "keyword" || last == "proplabel" ||
          (last == "standalone" && !newline);
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface

      return {
        startState: function(basecolumn) {
          return {
            tokenize: [tokenBase],
            context: new Context((basecolumn || 0) - config.indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true,
            lastToken: null
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
            // Automatic semicolon insertion
            if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) {
              popContext(state); ctx = state.context;
            }
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = state.tokenize[state.tokenize.length-1](stream, state);
          if (style == "comment") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          // Handle indentation for {x -> \n ... }
          else if (curPunc == "->" && ctx.type == "statement" && ctx.prev.type == "}") {
            popContext(state);
            state.context.align = false;
          }
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          state.lastToken = curPunc || style;
          return style;
        },

        indent: function(state, textAfter) {
          if (!state.tokenize[state.tokenize.length-1].isBase) return CodeMirror.Pass;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.context;
          if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;
          var closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : config.indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : config.indentUnit);
        },

        electricChars: "{}",
        closeBrackets: {triples: "'\""},
        fold: "brace"
      };
    });

    CodeMirror.defineMIME("text/x-groovy", "groovy");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Haml(CodeMirror) {
      // full haml mode. This handled embedded ruby and html fragments too
      CodeMirror.defineMode("haml", function(config) {
        var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
        var rubyMode = CodeMirror.getMode(config, "ruby");

        function rubyInQuote(endQuote) {
          return function(stream, state) {
            var ch = stream.peek();
            if (ch == endQuote && state.rubyState.tokenize.length == 1) {
              // step out of ruby context as it seems to complete processing all the braces
              stream.next();
              state.tokenize = html;
              return "closeAttributeTag";
            } else {
              return ruby(stream, state);
            }
          };
        }

        function ruby(stream, state) {
          if (stream.match("-#")) {
            stream.skipToEnd();
            return "comment";
          }
          return rubyMode.token(stream, state.rubyState);
        }

        function html(stream, state) {
          var ch = stream.peek();

          // handle haml declarations. All declarations that cant be handled here
          // will be passed to html mode
          if (state.previousToken.style == "comment" ) {
            if (state.indented > state.previousToken.indented) {
              stream.skipToEnd();
              return "commentLine";
            }
          }

          if (state.startOfLine) {
            if (ch == "!" && stream.match("!!")) {
              stream.skipToEnd();
              return "tag";
            } else if (stream.match(/^%[\w:#\.]+=/)) {
              state.tokenize = ruby;
              return "hamlTag";
            } else if (stream.match(/^%[\w:]+/)) {
              return "hamlTag";
            } else if (ch == "/" ) {
              stream.skipToEnd();
              return "comment";
            }
          }

          if (state.startOfLine || state.previousToken.style == "hamlTag") {
            if ( ch == "#" || ch == ".") {
              stream.match(/[\w-#\.]*/);
              return "hamlAttribute";
            }
          }

          // donot handle --> as valid ruby, make it HTML close comment instead
          if (state.startOfLine && !stream.match("-->", false) && (ch == "=" || ch == "-" )) {
            state.tokenize = ruby;
            return state.tokenize(stream, state);
          }

          if (state.previousToken.style == "hamlTag" ||
              state.previousToken.style == "closeAttributeTag" ||
              state.previousToken.style == "hamlAttribute") {
            if (ch == "(") {
              state.tokenize = rubyInQuote(")");
              return state.tokenize(stream, state);
            } else if (ch == "{") {
              if (!stream.match(/^\{%.*/)) {
                state.tokenize = rubyInQuote("}");
                return state.tokenize(stream, state);
              }
            }
          }

          return htmlMode.token(stream, state.htmlState);
        }

        return {
          // default to html mode
          startState: function() {
            var htmlState = CodeMirror.startState(htmlMode);
            var rubyState = CodeMirror.startState(rubyMode);
            return {
              htmlState: htmlState,
              rubyState: rubyState,
              indented: 0,
              previousToken: { style: null, indented: 0},
              tokenize: html
            };
          },

          copyState: function(state) {
            return {
              htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
              rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
              indented: state.indented,
              previousToken: state.previousToken,
              tokenize: state.tokenize
            };
          },

          token: function(stream, state) {
            if (stream.sol()) {
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            state.startOfLine = false;
            // dont record comment line as we only want to measure comment line with
            // the opening comment block
            if (style && style != "commentLine") {
              state.previousToken = { style: style, indented: state.indented };
            }
            // if current state is ruby and the previous token is not `,` reset the
            // tokenize to html
            if (stream.eol() && state.tokenize == ruby) {
              stream.backUp(1);
              var ch = stream.peek();
              stream.next();
              if (ch && ch != ",") {
                state.tokenize = html;
              }
            }
            // reprocess some of the specific style tag when finish setting previousToken
            if (style == "hamlTag") {
              style = "tag";
            } else if (style == "commentLine") {
              style = "comment";
            } else if (style == "hamlAttribute") {
              style = "attribute";
            } else if (style == "closeAttributeTag") {
              style = null;
            }
            return style;
          }
        };
      }, "htmlmixed", "ruby");

      CodeMirror.defineMIME("text/x-haml", "haml");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Handlebars(CodeMirror) {
      CodeMirror.defineSimpleMode("handlebars-tags", {
        start: [
          { regex: /\{\{!--/, push: "dash_comment", token: "comment" },
          { regex: /\{\{!/,   push: "comment", token: "comment" },
          { regex: /\{\{/,    push: "handlebars", token: "tag" }
        ],
        handlebars: [
          { regex: /\}\}/, pop: true, token: "tag" },

          // Double and single quotes
          { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
          { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },

          // Handlebars keywords
          { regex: />|[#\/]([A-Za-z_]\w*)/, token: "keyword" },
          { regex: /(?:else|this)\b/, token: "keyword" },

          // Numeral
          { regex: /\d+/i, token: "number" },

          // Atoms like = and .
          { regex: /=|~|@|true|false/, token: "atom" },

          // Paths
          { regex: /(?:\.\.\/)*(?:[A-Za-z_][\w\.]*)+/, token: "variable-2" }
        ],
        dash_comment: [
          { regex: /--\}\}/, pop: true, token: "comment" },

          // Commented code
          { regex: /./, token: "comment"}
        ],
        comment: [
          { regex: /\}\}/, pop: true, token: "comment" },
          { regex: /./, token: "comment" }
        ],
        meta: {
          blockCommentStart: "{{--",
          blockCommentEnd: "--}}"
        }
      });

      CodeMirror.defineMode("handlebars", function(config, parserConfig) {
        var handlebars = CodeMirror.getMode(config, "handlebars-tags");
        if (!parserConfig || !parserConfig.base) return handlebars;
        return CodeMirror.multiplexingMode(
          CodeMirror.getMode(config, parserConfig.base),
          {open: "{{", close: "}}", mode: handlebars, parseDelimiters: true}
        );
      });

      CodeMirror.defineMIME("text/x-handlebars-template", "handlebars");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Haskell(CodeMirror) {
    CodeMirror.defineMode("haskell", function(_config, modeConfig) {

      function switchState(source, setState, f) {
        setState(f);
        return f(source, setState);
      }

      // These should all be Unicode extended, as per the Haskell 2010 report
      var smallRE = /[a-z_]/;
      var largeRE = /[A-Z]/;
      var digitRE = /\d/;
      var hexitRE = /[0-9A-Fa-f]/;
      var octitRE = /[0-7]/;
      var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
      var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
      var specialRE = /[(),;[\]`{}]/;
      var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

      function normal(source, setState) {
        if (source.eatWhile(whiteCharRE)) {
          return null;
        }

        var ch = source.next();
        if (specialRE.test(ch)) {
          if (ch == '{' && source.eat('-')) {
            var t = "comment";
            if (source.eat('#')) {
              t = "meta";
            }
            return switchState(source, setState, ncomment(t, 1));
          }
          return null;
        }

        if (ch == '\'') {
          if (source.eat('\\')) {
            source.next();  // should handle other escapes here
          }
          else {
            source.next();
          }
          if (source.eat('\'')) {
            return "string";
          }
          return "string error";
        }

        if (ch == '"') {
          return switchState(source, setState, stringLiteral);
        }

        if (largeRE.test(ch)) {
          source.eatWhile(idRE);
          if (source.eat('.')) {
            return "qualifier";
          }
          return "variable-2";
        }

        if (smallRE.test(ch)) {
          source.eatWhile(idRE);
          return "variable";
        }

        if (digitRE.test(ch)) {
          if (ch == '0') {
            if (source.eat(/[xX]/)) {
              source.eatWhile(hexitRE); // should require at least 1
              return "integer";
            }
            if (source.eat(/[oO]/)) {
              source.eatWhile(octitRE); // should require at least 1
              return "number";
            }
          }
          source.eatWhile(digitRE);
          var t = "number";
          if (source.match(/^\.\d+/)) {
            t = "number";
          }
          if (source.eat(/[eE]/)) {
            t = "number";
            source.eat(/[-+]/);
            source.eatWhile(digitRE); // should require at least 1
          }
          return t;
        }

        if (ch == "." && source.eat("."))
          return "keyword";

        if (symbolRE.test(ch)) {
          if (ch == '-' && source.eat(/-/)) {
            source.eatWhile(/-/);
            if (!source.eat(symbolRE)) {
              source.skipToEnd();
              return "comment";
            }
          }
          var t = "variable";
          if (ch == ':') {
            t = "variable-2";
          }
          source.eatWhile(symbolRE);
          return t;
        }

        return "error";
      }

      function ncomment(type, nest) {
        if (nest == 0) {
          return normal;
        }
        return function(source, setState) {
          var currNest = nest;
          while (!source.eol()) {
            var ch = source.next();
            if (ch == '{' && source.eat('-')) {
              ++currNest;
            }
            else if (ch == '-' && source.eat('}')) {
              --currNest;
              if (currNest == 0) {
                setState(normal);
                return type;
              }
            }
          }
          setState(ncomment(type, currNest));
          return type;
        };
      }

      function stringLiteral(source, setState) {
        while (!source.eol()) {
          var ch = source.next();
          if (ch == '"') {
            setState(normal);
            return "string";
          }
          if (ch == '\\') {
            if (source.eol() || source.eat(whiteCharRE)) {
              setState(stringGap);
              return "string";
            }
            if (source.eat('&')) ;
            else {
              source.next(); // should handle other escapes here
            }
          }
        }
        setState(normal);
        return "string error";
      }

      function stringGap(source, setState) {
        if (source.eat('\\')) {
          return switchState(source, setState, stringLiteral);
        }
        source.next();
        setState(normal);
        return "error";
      }


      var wellKnownWords = (function() {
        var wkw = {};
        function setType(t) {
          return function () {
            for (var i = 0; i < arguments.length; i++)
              wkw[arguments[i]] = t;
          };
        }

        setType("keyword")(
          "case", "class", "data", "default", "deriving", "do", "else", "foreign",
          "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
          "module", "newtype", "of", "then", "type", "where", "_");

        setType("keyword")(
          "\.\.", ":", "::", "=", "\\", "<-", "->", "@", "~", "=>");

        setType("builtin")(
          "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",
          "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",
          "*>", "**");

        setType("builtin")(
          "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",
          "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",
          "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
          "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
          "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
          "String", "True");

        setType("builtin")(
          "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
          "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
          "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
          "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
          "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
          "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
          "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
          "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
          "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
          "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
          "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
          "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
          "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
          "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
          "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",
          "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
          "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
          "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
          "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
          "sequence", "sequence_", "show", "showChar", "showList", "showParen",
          "showString", "shows", "showsPrec", "significand", "signum", "sin",
          "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
          "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
          "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
          "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
          "zip3", "zipWith", "zipWith3");

        var override = modeConfig.overrideKeywords;
        if (override) for (var word in override) if (override.hasOwnProperty(word))
          wkw[word] = override[word];

        return wkw;
      })();



      return {
        startState: function ()  { return { f: normal }; },
        copyState:  function (s) { return { f: s.f }; },

        token: function(stream, state) {
          var t = state.f(stream, function(s) { state.f = s; });
          var w = stream.current();
          return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
        },

        blockCommentStart: "{-",
        blockCommentEnd: "-}",
        lineComment: "--"
      };

    });

    CodeMirror.defineMIME("text/x-haskell", "haskell");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Haskell_literate(CodeMirror) {
      CodeMirror.defineMode("haskell-literate", function (config, parserConfig) {
        var baseMode = CodeMirror.getMode(config, (parserConfig && parserConfig.base) || "haskell");

        return {
          startState: function () {
            return {
              inCode: false,
              baseState: CodeMirror.startState(baseMode)
            }
          },
          token: function (stream, state) {
            if (stream.sol()) {
              if (state.inCode = stream.eat(">"))
                return "meta"
            }
            if (state.inCode) {
              return baseMode.token(stream, state.baseState)
            } else {
              stream.skipToEnd();
              return "comment"
            }
          },
          innerMode: function (state) {
            return state.inCode ? {state: state.baseState, mode: baseMode} : null
          }
        }
      }, "haskell");

      CodeMirror.defineMIME("text/x-literate-haskell", "haskell-literate");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Haxe(CodeMirror) {
    CodeMirror.defineMode("haxe", function(config, parserConfig) {
      var indentUnit = config.indentUnit;

      // Tokenizer

      function kw(type) {return {type: type, style: "keyword"};}
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
      var operator = kw("operator"), atom = {type: "atom", style: "atom"}, attribute = {type:"attribute", style: "attribute"};
      var type = kw("typedef");
      var keywords = {
        "if": A, "while": A, "else": B, "do": B, "try": B,
        "return": C, "break": C, "continue": C, "new": C, "throw": C,
        "var": kw("var"), "inline":attribute, "static": attribute, "using":kw("import"),
        "public": attribute, "private": attribute, "cast": kw("cast"), "import": kw("import"), "macro": kw("macro"),
        "function": kw("function"), "catch": kw("catch"), "untyped": kw("untyped"), "callback": kw("cb"),
        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
        "in": operator, "never": kw("property_access"), "trace":kw("trace"),
        "class": type, "abstract":type, "enum":type, "interface":type, "typedef":type, "extends":type, "implements":type, "dynamic":type,
        "true": atom, "false": atom, "null": atom
      };

      var isOperatorChar = /[+\-*&%=<>!?|]/;

      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function toUnescaped(stream, end) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (next == end && !escaped)
            return true;
          escaped = !escaped && next == "\\";
        }
      }

      // Used as scratch variables to communicate multiple values without
      // consing up tons of objects.
      var type, content;
      function ret(tp, style, cont) {
        type = tp; content = cont;
        return style;
      }

      function haxeTokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          return chain(stream, state, haxeTokenString(ch));
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "0" && stream.eat(/x/i)) {
          stream.eatWhile(/[\da-f]/i);
          return ret("number", "number");
        } else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
          stream.match(/^\d*(?:\.\d*(?!\.))?(?:[eE][+\-]?\d+)?/);
          return ret("number", "number");
        } else if (state.reAllowed && (ch == "~" && stream.eat(/\//))) {
          toUnescaped(stream, "/");
          stream.eatWhile(/[gimsu]/);
          return ret("regexp", "string-2");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            return chain(stream, state, haxeTokenComment);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else {
            stream.eatWhile(isOperatorChar);
            return ret("operator", null, stream.current());
          }
        } else if (ch == "#") {
            stream.skipToEnd();
            return ret("conditional", "meta");
        } else if (ch == "@") {
          stream.eat(/:/);
          stream.eatWhile(/[\w_]/);
          return ret ("metadata", "meta");
        } else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return ret("operator", null, stream.current());
        } else {
          var word;
          if(/[A-Z]/.test(ch)) {
            stream.eatWhile(/[\w_<>]/);
            word = stream.current();
            return ret("type", "variable-3", word);
          } else {
            stream.eatWhile(/[\w_]/);
            var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
            return (known && state.kwAllowed) ? ret(known.type, known.style, word) :
                           ret("variable", "variable", word);
          }
        }
      }

      function haxeTokenString(quote) {
        return function(stream, state) {
          if (toUnescaped(stream, quote))
            state.tokenize = haxeTokenBase;
          return ret("string", "string");
        };
      }

      function haxeTokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = haxeTokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }

      // Parser

      var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true};

      function HaxeLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }

      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next)
          if (v.name == varname) return true;
      }

      function parseHaxe(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;

        while(true) {
          var combinator = cc.length ? cc.pop() : statement;
          if (combinator(type, content)) {
            while(cc.length && cc[cc.length - 1].lex)
              cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            if (type == "variable" && imported(state, content)) return "variable-3";
            return style;
          }
        }
      }

      function imported(state, typename) {
        if (/[a-z]/.test(typename.charAt(0)))
          return false;
        var len = state.importedtypes.length;
        for (var i = 0; i<len; i++)
          if(state.importedtypes[i]==typename) return true;
      }

      function registerimport(importname) {
        var state = cx.state;
        for (var t = state.importedtypes; t; t = t.next)
          if(t.name == importname) return;
        state.importedtypes = { name: importname, next: state.importedtypes };
      }
      // Combinator utils

      var cx = {state: null, column: null, marked: null, cc: null};
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function inList(name, list) {
        for (var v = list; v; v = v.next)
          if (v.name == name) return true;
        return false;
      }
      function register(varname) {
        var state = cx.state;
        if (state.context) {
          cx.marked = "def";
          if (inList(varname, state.localVars)) return;
          state.localVars = {name: varname, next: state.localVars};
        } else if (state.globalVars) {
          if (inList(varname, state.globalVars)) return;
          state.globalVars = {name: varname, next: state.globalVars};
        }
      }

      // Combinators

      var defaultVars = {name: "this", next: null};
      function pushcontext() {
        if (!cx.state.context) cx.state.localVars = defaultVars;
        cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      popcontext.lex = true;
      function pushlex(type, info) {
        var result = function() {
          var state = cx.state;
          state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;

      function expect(wanted) {
        function f(type) {
          if (type == wanted) return cont();
          else if (wanted == ";") return pass();
          else return cont(f);
        }
        return f;
      }

      function statement(type) {
        if (type == "@") return cont(metadef);
        if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "{") return cont(pushlex("}"), pushcontext, block, poplex, popcontext);
        if (type == ";") return cont();
        if (type == "attribute") return cont(maybeattribute);
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                       poplex, statement, poplex);
        if (type == "variable") return cont(pushlex("stat"), maybelabel);
        if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                          block, poplex, poplex);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                         statement, poplex, popcontext);
        if (type == "import") return cont(importdef, expect(";"));
        if (type == "typedef") return cont(typedef);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function expression(type) {
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
        if (type == "type" ) return cont(maybeoperator);
        if (type == "function") return cont(functiondef);
        if (type == "keyword c") return cont(maybeexpression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
        if (type == "operator") return cont(expression);
        if (type == "[") return cont(pushlex("]"), commasep(maybeexpression, "]"), poplex, maybeoperator);
        if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }

      function maybeoperator(type, value) {
        if (type == "operator" && /\+\+|--/.test(value)) return cont(maybeoperator);
        if (type == "operator" || type == ":") return cont(expression);
        if (type == ";") return;
        if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
        if (type == ".") return cont(property, maybeoperator);
        if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
      }

      function maybeattribute(type) {
        if (type == "attribute") return cont(maybeattribute);
        if (type == "function") return cont(functiondef);
        if (type == "var") return cont(vardef1);
      }

      function metadef(type) {
        if(type == ":") return cont(metadef);
        if(type == "variable") return cont(metadef);
        if(type == "(") return cont(pushlex(")"), commasep(metaargs, ")"), poplex, statement);
      }
      function metaargs(type) {
        if(type == "variable") return cont();
      }

      function importdef (type, value) {
        if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
        else if(type == "variable" || type == "property" || type == "." || value == "*") return cont(importdef);
      }

      function typedef (type, value)
      {
        if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
        else if (type == "type" && /[A-Z]/.test(value.charAt(0))) { return cont(); }
      }

      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperator, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {cx.marked = "property"; return cont();}
      }
      function objprop(type) {
        if (type == "variable") cx.marked = "property";
        if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
      }
      function commasep(what, end) {
        function proceed(type) {
          if (type == ",") return cont(what, proceed);
          if (type == end) return cont();
          return cont(expect(end));
        }
        return function(type) {
          if (type == end) return cont();
          else return pass(what, proceed);
        };
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function vardef1(type, value) {
        if (type == "variable"){register(value); return cont(typeuse, vardef2);}
        return cont();
      }
      function vardef2(type, value) {
        if (value == "=") return cont(expression, vardef2);
        if (type == ",") return cont(vardef1);
      }
      function forspec1(type, value) {
        if (type == "variable") {
          register(value);
          return cont(forin, expression)
        } else {
          return pass()
        }
      }
      function forin(_type, value) {
        if (value == "in") return cont();
      }
      function functiondef(type, value) {
        //function names starting with upper-case letters are recognised as types, so cludging them together here.
        if (type == "variable" || type == "type") {register(value); return cont(functiondef);}
        if (value == "new") return cont(functiondef);
        if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, typeuse, statement, popcontext);
      }
      function typeuse(type) {
        if(type == ":") return cont(typestring);
      }
      function typestring(type) {
        if(type == "type") return cont();
        if(type == "variable") return cont();
        if(type == "{") return cont(pushlex("}"), commasep(typeprop, "}"), poplex);
      }
      function typeprop(type) {
        if(type == "variable") return cont(typeuse);
      }
      function funarg(type, value) {
        if (type == "variable") {register(value); return cont(typeuse);}
      }

      // Interface
      return {
        startState: function(basecolumn) {
          var defaulttypes = ["Int", "Float", "String", "Void", "Std", "Bool", "Dynamic", "Array"];
          var state = {
            tokenize: haxeTokenBase,
            reAllowed: true,
            kwAllowed: true,
            cc: [],
            lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            importedtypes: defaulttypes,
            context: parserConfig.localVars && {vars: parserConfig.localVars},
            indented: 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.reAllowed = !!(type == "operator" || type == "keyword c" || type.match(/^[\[{}\(,;:]$/));
          state.kwAllowed = type != '.';
          return parseHaxe(state, style, type, content, stream);
        },

        indent: function(state, textAfter) {
          if (state.tokenize != haxeTokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
          if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
          var type = lexical.type, closing = firstChar == type;
          if (type == "vardef") return lexical.indented + 4;
          else if (type == "form" && firstChar == "{") return lexical.indented;
          else if (type == "stat" || type == "form") return lexical.indented + indentUnit;
          else if (lexical.info == "switch" && !closing)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align) return lexical.column + (closing ? 0 : 1);
          else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME("text/x-haxe", "haxe");

    CodeMirror.defineMode("hxml", function () {

      return {
        startState: function () {
          return {
            define: false,
            inString: false
          };
        },
        token: function (stream, state) {
          var ch = stream.peek();
          var sol = stream.sol();

          ///* comments */
          if (ch == "#") {
            stream.skipToEnd();
            return "comment";
          }
          if (sol && ch == "-") {
            var style = "variable-2";

            stream.eat(/-/);

            if (stream.peek() == "-") {
              stream.eat(/-/);
              style = "keyword a";
            }

            if (stream.peek() == "D") {
              stream.eat(/[D]/);
              style = "keyword c";
              state.define = true;
            }

            stream.eatWhile(/[A-Z]/i);
            return style;
          }

          var ch = stream.peek();

          if (state.inString == false && ch == "'") {
            state.inString = true;
            stream.next();
          }

          if (state.inString == true) {
            if (stream.skipTo("'")) ; else {
              stream.skipToEnd();
            }

            if (stream.peek() == "'") {
              stream.next();
              state.inString = false;
            }

            return "string";
          }

          stream.next();
          return null;
        },
        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("text/x-hxml", "hxml");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function HTMLembedded(CodeMirror) {
      CodeMirror.defineMode("htmlembedded", function(config, parserConfig) {
        var closeComment = parserConfig.closeComment || "--%>";
        return CodeMirror.multiplexingMode(CodeMirror.getMode(config, "htmlmixed"), {
          open: parserConfig.openComment || "<%--",
          close: closeComment,
          delimStyle: "comment",
          mode: {token: function(stream) {
            stream.skipTo(closeComment) || stream.skipToEnd();
            return "comment"
          }}
        }, {
          open: parserConfig.open || parserConfig.scriptStartRegex || "<%",
          close: parserConfig.close || parserConfig.scriptEndRegex || "%>",
          mode: CodeMirror.getMode(config, parserConfig.scriptingModeSpec)
        });
      }, "htmlmixed");

      CodeMirror.defineMIME("application/x-ejs", {name: "htmlembedded", scriptingModeSpec:"javascript"});
      CodeMirror.defineMIME("application/x-aspx", {name: "htmlembedded", scriptingModeSpec:"text/x-csharp"});
      CodeMirror.defineMIME("application/x-jsp", {name: "htmlembedded", scriptingModeSpec:"text/x-java"});
      CodeMirror.defineMIME("application/x-erb", {name: "htmlembedded", scriptingModeSpec:"ruby"});
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function HTMLMixed(CodeMirror) {
      var defaultTags = {
        script: [
          ["lang", /(javascript|babel)/i, "javascript"],
          ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
          ["type", /./, "text/plain"],
          [null, null, "javascript"]
        ],
        style:  [
          ["lang", /^css$/i, "css"],
          ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
          ["type", /./, "text/plain"],
          [null, null, "css"]
        ]
      };

      function maybeBackup(stream, pat, style) {
        var cur = stream.current(), close = cur.search(pat);
        if (close > -1) {
          stream.backUp(cur.length - close);
        } else if (cur.match(/<\/?$/)) {
          stream.backUp(cur.length);
          if (!stream.match(pat, false)) stream.match(cur);
        }
        return style;
      }

      var attrRegexpCache = {};
      function getAttrRegexp(attr) {
        var regexp = attrRegexpCache[attr];
        if (regexp) return regexp;
        return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
      }

      function getAttrValue(text, attr) {
        var match = text.match(getAttrRegexp(attr));
        return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
      }

      function getTagRegexp(tagName, anchored) {
        return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
      }

      function addTags(from, to) {
        for (var tag in from) {
          var dest = to[tag] || (to[tag] = []);
          var source = from[tag];
          for (var i = source.length - 1; i >= 0; i--)
            dest.unshift(source[i]);
        }
      }

      function findMatchingMode(tagInfo, tagText) {
        for (var i = 0; i < tagInfo.length; i++) {
          var spec = tagInfo[i];
          if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
        }
      }

      CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
        var htmlMode = CodeMirror.getMode(config, {
          name: "xml",
          htmlMode: true,
          multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
          multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
        });

        var tags = {};
        var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
        addTags(defaultTags, tags);
        if (configTags) addTags(configTags, tags);
        if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
          tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);

        function html(stream, state) {
          var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName;
          if (tag && !/[<>\s\/]/.test(stream.current()) &&
              (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
              tags.hasOwnProperty(tagName)) {
            state.inTag = tagName + " ";
          } else if (state.inTag && tag && />$/.test(stream.current())) {
            var inTag = /^([\S]+) (.*)/.exec(state.inTag);
            state.inTag = null;
            var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
            var mode = CodeMirror.getMode(config, modeSpec);
            var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
            state.token = function (stream, state) {
              if (stream.match(endTagA, false)) {
                state.token = html;
                state.localState = state.localMode = null;
                return null;
              }
              return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
            };
            state.localMode = mode;
            state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
          } else if (state.inTag) {
            state.inTag += stream.current();
            if (stream.eol()) state.inTag += " ";
          }
          return style;
        }
        return {
          startState: function () {
            var state = CodeMirror.startState(htmlMode);
            return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
          },

          copyState: function (state) {
            var local;
            if (state.localState) {
              local = CodeMirror.copyState(state.localMode, state.localState);
            }
            return {token: state.token, inTag: state.inTag,
                    localMode: state.localMode, localState: local,
                    htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
          },

          token: function (stream, state) {
            return state.token(stream, state);
          },

          indent: function (state, textAfter, line) {
            if (!state.localMode || /^\s*<\//.test(textAfter))
              return htmlMode.indent(state.htmlState, textAfter, line);
            else if (state.localMode.indent)
              return state.localMode.indent(state.localState, textAfter, line);
            else
              return CodeMirror.Pass;
          },

          innerMode: function (state) {
            return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
          }
        };
      }, "xml", "javascript", "css");

      CodeMirror.defineMIME("text/html", "htmlmixed");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function HTTP(CodeMirror) {
    CodeMirror.defineMode("http", function() {
      function failFirstLine(stream, state) {
        stream.skipToEnd();
        state.cur = header;
        return "error";
      }

      function start(stream, state) {
        if (stream.match(/^HTTP\/\d\.\d/)) {
          state.cur = responseStatusCode;
          return "keyword";
        } else if (stream.match(/^[A-Z]+/) && /[ \t]/.test(stream.peek())) {
          state.cur = requestPath;
          return "keyword";
        } else {
          return failFirstLine(stream, state);
        }
      }

      function responseStatusCode(stream, state) {
        var code = stream.match(/^\d+/);
        if (!code) return failFirstLine(stream, state);

        state.cur = responseStatusText;
        var status = Number(code[0]);
        if (status >= 100 && status < 200) {
          return "positive informational";
        } else if (status >= 200 && status < 300) {
          return "positive success";
        } else if (status >= 300 && status < 400) {
          return "positive redirect";
        } else if (status >= 400 && status < 500) {
          return "negative client-error";
        } else if (status >= 500 && status < 600) {
          return "negative server-error";
        } else {
          return "error";
        }
      }

      function responseStatusText(stream, state) {
        stream.skipToEnd();
        state.cur = header;
        return null;
      }

      function requestPath(stream, state) {
        stream.eatWhile(/\S/);
        state.cur = requestProtocol;
        return "string-2";
      }

      function requestProtocol(stream, state) {
        if (stream.match(/^HTTP\/\d\.\d$/)) {
          state.cur = header;
          return "keyword";
        } else {
          return failFirstLine(stream, state);
        }
      }

      function header(stream) {
        if (stream.sol() && !stream.eat(/[ \t]/)) {
          if (stream.match(/^.*?:/)) {
            return "atom";
          } else {
            stream.skipToEnd();
            return "error";
          }
        } else {
          stream.skipToEnd();
          return "string";
        }
      }

      function body(stream) {
        stream.skipToEnd();
        return null;
      }

      return {
        token: function(stream, state) {
          var cur = state.cur;
          if (cur != header && cur != body && stream.eatSpace()) return null;
          return cur(stream, state);
        },

        blankLine: function(state) {
          state.cur = body;
        },

        startState: function() {
          return {cur: start};
        }
      };
    });

    CodeMirror.defineMIME("message/http", "http");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function IDL(CodeMirror) {
      function wordRegexp(words) {
        return new RegExp('^((' + words.join(')|(') + '))\\b', 'i');
      }
      var builtinArray = [
        'a_correlate', 'abs', 'acos', 'adapt_hist_equal', 'alog',
        'alog2', 'alog10', 'amoeba', 'annotate', 'app_user_dir',
        'app_user_dir_query', 'arg_present', 'array_equal', 'array_indices',
        'arrow', 'ascii_template', 'asin', 'assoc', 'atan',
        'axis', 'axis', 'bandpass_filter', 'bandreject_filter', 'barplot',
        'bar_plot', 'beseli', 'beselj', 'beselk', 'besely',
        'beta', 'biginteger', 'bilinear', 'bin_date', 'binary_template',
        'bindgen', 'binomial', 'bit_ffs', 'bit_population', 'blas_axpy',
        'blk_con', 'boolarr', 'boolean', 'boxplot', 'box_cursor',
        'breakpoint', 'broyden', 'bubbleplot', 'butterworth', 'bytarr',
        'byte', 'byteorder', 'bytscl', 'c_correlate', 'calendar',
        'caldat', 'call_external', 'call_function', 'call_method',
        'call_procedure', 'canny', 'catch', 'cd', 'cdf', 'ceil',
        'chebyshev', 'check_math', 'chisqr_cvf', 'chisqr_pdf', 'choldc',
        'cholsol', 'cindgen', 'cir_3pnt', 'clipboard', 'close',
        'clust_wts', 'cluster', 'cluster_tree', 'cmyk_convert', 'code_coverage',
        'color_convert', 'color_exchange', 'color_quan', 'color_range_map',
        'colorbar', 'colorize_sample', 'colormap_applicable',
        'colormap_gradient', 'colormap_rotation', 'colortable',
        'comfit', 'command_line_args', 'common', 'compile_opt', 'complex',
        'complexarr', 'complexround', 'compute_mesh_normals', 'cond', 'congrid',
        'conj', 'constrained_min', 'contour', 'contour', 'convert_coord',
        'convol', 'convol_fft', 'coord2to3', 'copy_lun', 'correlate',
        'cos', 'cosh', 'cpu', 'cramer', 'createboxplotdata',
        'create_cursor', 'create_struct', 'create_view', 'crossp', 'crvlength',
        'ct_luminance', 'cti_test', 'cursor', 'curvefit', 'cv_coord',
        'cvttobm', 'cw_animate', 'cw_animate_getp', 'cw_animate_load',
        'cw_animate_run', 'cw_arcball', 'cw_bgroup', 'cw_clr_index',
        'cw_colorsel', 'cw_defroi', 'cw_field', 'cw_filesel', 'cw_form',
        'cw_fslider', 'cw_light_editor', 'cw_light_editor_get',
        'cw_light_editor_set', 'cw_orient', 'cw_palette_editor',
        'cw_palette_editor_get', 'cw_palette_editor_set', 'cw_pdmenu',
        'cw_rgbslider', 'cw_tmpl', 'cw_zoom', 'db_exists',
        'dblarr', 'dcindgen', 'dcomplex', 'dcomplexarr', 'define_key',
        'define_msgblk', 'define_msgblk_from_file', 'defroi', 'defsysv',
        'delvar', 'dendro_plot', 'dendrogram', 'deriv', 'derivsig',
        'determ', 'device', 'dfpmin', 'diag_matrix', 'dialog_dbconnect',
        'dialog_message', 'dialog_pickfile', 'dialog_printersetup',
        'dialog_printjob', 'dialog_read_image',
        'dialog_write_image', 'dictionary', 'digital_filter', 'dilate', 'dindgen',
        'dissolve', 'dist', 'distance_measure', 'dlm_load', 'dlm_register',
        'doc_library', 'double', 'draw_roi', 'edge_dog', 'efont',
        'eigenql', 'eigenvec', 'ellipse', 'elmhes', 'emboss',
        'empty', 'enable_sysrtn', 'eof', 'eos', 'erase',
        'erf', 'erfc', 'erfcx', 'erode', 'errorplot',
        'errplot', 'estimator_filter', 'execute', 'exit', 'exp',
        'expand', 'expand_path', 'expint', 'extrac', 'extract_slice',
        'f_cvf', 'f_pdf', 'factorial', 'fft', 'file_basename',
        'file_chmod', 'file_copy', 'file_delete', 'file_dirname',
        'file_expand_path', 'file_gunzip', 'file_gzip', 'file_info',
        'file_lines', 'file_link', 'file_mkdir', 'file_move',
        'file_poll_input', 'file_readlink', 'file_same',
        'file_search', 'file_tar', 'file_test', 'file_untar', 'file_unzip',
        'file_which', 'file_zip', 'filepath', 'findgen', 'finite',
        'fix', 'flick', 'float', 'floor', 'flow3',
        'fltarr', 'flush', 'format_axis_values', 'forward_function', 'free_lun',
        'fstat', 'fulstr', 'funct', 'function', 'fv_test',
        'fx_root', 'fz_roots', 'gamma', 'gamma_ct', 'gauss_cvf',
        'gauss_pdf', 'gauss_smooth', 'gauss2dfit', 'gaussfit',
        'gaussian_function', 'gaussint', 'get_drive_list', 'get_dxf_objects',
        'get_kbrd', 'get_login_info',
        'get_lun', 'get_screen_size', 'getenv', 'getwindows', 'greg2jul',
        'grib', 'grid_input', 'grid_tps', 'grid3', 'griddata',
        'gs_iter', 'h_eq_ct', 'h_eq_int', 'hanning', 'hash',
        'hdf', 'hdf5', 'heap_free', 'heap_gc', 'heap_nosave',
        'heap_refcount', 'heap_save', 'help', 'hilbert', 'hist_2d',
        'hist_equal', 'histogram', 'hls', 'hough', 'hqr',
        'hsv', 'i18n_multibytetoutf8',
        'i18n_multibytetowidechar', 'i18n_utf8tomultibyte',
        'i18n_widechartomultibyte',
        'ibeta', 'icontour', 'iconvertcoord', 'idelete', 'identity',
        'idl_base64', 'idl_container', 'idl_validname',
        'idlexbr_assistant', 'idlitsys_createtool',
        'idlunit', 'iellipse', 'igamma', 'igetcurrent', 'igetdata',
        'igetid', 'igetproperty', 'iimage', 'image', 'image_cont',
        'image_statistics', 'image_threshold', 'imaginary', 'imap', 'indgen',
        'int_2d', 'int_3d', 'int_tabulated', 'intarr', 'interpol',
        'interpolate', 'interval_volume', 'invert', 'ioctl', 'iopen',
        'ir_filter', 'iplot', 'ipolygon', 'ipolyline', 'iputdata',
        'iregister', 'ireset', 'iresolve', 'irotate', 'isa',
        'isave', 'iscale', 'isetcurrent', 'isetproperty', 'ishft',
        'isocontour', 'isosurface', 'isurface', 'itext', 'itranslate',
        'ivector', 'ivolume', 'izoom', 'journal', 'json_parse',
        'json_serialize', 'jul2greg', 'julday', 'keyword_set', 'krig2d',
        'kurtosis', 'kw_test', 'l64indgen', 'la_choldc', 'la_cholmprove',
        'la_cholsol', 'la_determ', 'la_eigenproblem', 'la_eigenql', 'la_eigenvec',
        'la_elmhes', 'la_gm_linear_model', 'la_hqr', 'la_invert',
        'la_least_square_equality', 'la_least_squares', 'la_linear_equation',
        'la_ludc', 'la_lumprove', 'la_lusol',
        'la_svd', 'la_tridc', 'la_trimprove', 'la_triql', 'la_trired',
        'la_trisol', 'label_date', 'label_region', 'ladfit', 'laguerre',
        'lambda', 'lambdap', 'lambertw', 'laplacian', 'least_squares_filter',
        'leefilt', 'legend', 'legendre', 'linbcg', 'lindgen',
        'linfit', 'linkimage', 'list', 'll_arc_distance', 'lmfit',
        'lmgr', 'lngamma', 'lnp_test', 'loadct', 'locale_get',
        'logical_and', 'logical_or', 'logical_true', 'lon64arr', 'lonarr',
        'long', 'long64', 'lsode', 'lu_complex', 'ludc',
        'lumprove', 'lusol', 'm_correlate', 'machar', 'make_array',
        'make_dll', 'make_rt', 'map', 'mapcontinents', 'mapgrid',
        'map_2points', 'map_continents', 'map_grid', 'map_image', 'map_patch',
        'map_proj_forward', 'map_proj_image', 'map_proj_info',
        'map_proj_init', 'map_proj_inverse',
        'map_set', 'matrix_multiply', 'matrix_power', 'max', 'md_test',
        'mean', 'meanabsdev', 'mean_filter', 'median', 'memory',
        'mesh_clip', 'mesh_decimate', 'mesh_issolid',
        'mesh_merge', 'mesh_numtriangles',
        'mesh_obj', 'mesh_smooth', 'mesh_surfacearea',
        'mesh_validate', 'mesh_volume',
        'message', 'min', 'min_curve_surf', 'mk_html_help', 'modifyct',
        'moment', 'morph_close', 'morph_distance',
        'morph_gradient', 'morph_hitormiss',
        'morph_open', 'morph_thin', 'morph_tophat', 'multi', 'n_elements',
        'n_params', 'n_tags', 'ncdf', 'newton', 'noise_hurl',
        'noise_pick', 'noise_scatter', 'noise_slur', 'norm', 'obj_class',
        'obj_destroy', 'obj_hasmethod', 'obj_isa', 'obj_new', 'obj_valid',
        'objarr', 'on_error', 'on_ioerror', 'online_help', 'openr',
        'openu', 'openw', 'oplot', 'oploterr', 'orderedhash',
        'p_correlate', 'parse_url', 'particle_trace', 'path_cache', 'path_sep',
        'pcomp', 'plot', 'plot3d', 'plot', 'plot_3dbox',
        'plot_field', 'ploterr', 'plots', 'polar_contour', 'polar_surface',
        'polyfill', 'polyshade', 'pnt_line', 'point_lun', 'polarplot',
        'poly', 'poly_2d', 'poly_area', 'poly_fit', 'polyfillv',
        'polygon', 'polyline', 'polywarp', 'popd', 'powell',
        'pref_commit', 'pref_get', 'pref_set', 'prewitt', 'primes',
        'print', 'printf', 'printd', 'pro', 'product',
        'profile', 'profiler', 'profiles', 'project_vol', 'ps_show_fonts',
        'psafm', 'pseudo', 'ptr_free', 'ptr_new', 'ptr_valid',
        'ptrarr', 'pushd', 'qgrid3', 'qhull', 'qromb',
        'qromo', 'qsimp', 'query_*', 'query_ascii', 'query_bmp',
        'query_csv', 'query_dicom', 'query_gif', 'query_image', 'query_jpeg',
        'query_jpeg2000', 'query_mrsid', 'query_pict', 'query_png', 'query_ppm',
        'query_srf', 'query_tiff', 'query_video', 'query_wav', 'r_correlate',
        'r_test', 'radon', 'randomn', 'randomu', 'ranks',
        'rdpix', 'read', 'readf', 'read_ascii', 'read_binary',
        'read_bmp', 'read_csv', 'read_dicom', 'read_gif', 'read_image',
        'read_interfile', 'read_jpeg', 'read_jpeg2000', 'read_mrsid', 'read_pict',
        'read_png', 'read_ppm', 'read_spr', 'read_srf', 'read_sylk',
        'read_tiff', 'read_video', 'read_wav', 'read_wave', 'read_x11_bitmap',
        'read_xwd', 'reads', 'readu', 'real_part', 'rebin',
        'recall_commands', 'recon3', 'reduce_colors', 'reform', 'region_grow',
        'register_cursor', 'regress', 'replicate',
        'replicate_inplace', 'resolve_all',
        'resolve_routine', 'restore', 'retall', 'return', 'reverse',
        'rk4', 'roberts', 'rot', 'rotate', 'round',
        'routine_filepath', 'routine_info', 'rs_test', 's_test', 'save',
        'savgol', 'scale3', 'scale3d', 'scatterplot', 'scatterplot3d',
        'scope_level', 'scope_traceback', 'scope_varfetch',
        'scope_varname', 'search2d',
        'search3d', 'sem_create', 'sem_delete', 'sem_lock', 'sem_release',
        'set_plot', 'set_shading', 'setenv', 'sfit', 'shade_surf',
        'shade_surf_irr', 'shade_volume', 'shift', 'shift_diff', 'shmdebug',
        'shmmap', 'shmunmap', 'shmvar', 'show3', 'showfont',
        'signum', 'simplex', 'sin', 'sindgen', 'sinh',
        'size', 'skewness', 'skip_lun', 'slicer3', 'slide_image',
        'smooth', 'sobel', 'socket', 'sort', 'spawn',
        'sph_4pnt', 'sph_scat', 'spher_harm', 'spl_init', 'spl_interp',
        'spline', 'spline_p', 'sprsab', 'sprsax', 'sprsin',
        'sprstp', 'sqrt', 'standardize', 'stddev', 'stop',
        'strarr', 'strcmp', 'strcompress', 'streamline', 'streamline',
        'stregex', 'stretch', 'string', 'strjoin', 'strlen',
        'strlowcase', 'strmatch', 'strmessage', 'strmid', 'strpos',
        'strput', 'strsplit', 'strtrim', 'struct_assign', 'struct_hide',
        'strupcase', 'surface', 'surface', 'surfr', 'svdc',
        'svdfit', 'svsol', 'swap_endian', 'swap_endian_inplace', 'symbol',
        'systime', 't_cvf', 't_pdf', 't3d', 'tag_names',
        'tan', 'tanh', 'tek_color', 'temporary', 'terminal_size',
        'tetra_clip', 'tetra_surface', 'tetra_volume', 'text', 'thin',
        'thread', 'threed', 'tic', 'time_test2', 'timegen',
        'timer', 'timestamp', 'timestamptovalues', 'tm_test', 'toc',
        'total', 'trace', 'transpose', 'tri_surf', 'triangulate',
        'trigrid', 'triql', 'trired', 'trisol', 'truncate_lun',
        'ts_coef', 'ts_diff', 'ts_fcast', 'ts_smooth', 'tv',
        'tvcrs', 'tvlct', 'tvrd', 'tvscl', 'typename',
        'uindgen', 'uint', 'uintarr', 'ul64indgen', 'ulindgen',
        'ulon64arr', 'ulonarr', 'ulong', 'ulong64', 'uniq',
        'unsharp_mask', 'usersym', 'value_locate', 'variance', 'vector',
        'vector_field', 'vel', 'velovect', 'vert_t3d', 'voigt',
        'volume', 'voronoi', 'voxel_proj', 'wait', 'warp_tri',
        'watershed', 'wdelete', 'wf_draw', 'where', 'widget_base',
        'widget_button', 'widget_combobox', 'widget_control',
        'widget_displaycontextmenu', 'widget_draw',
        'widget_droplist', 'widget_event', 'widget_info',
        'widget_label', 'widget_list',
        'widget_propertysheet', 'widget_slider', 'widget_tab',
        'widget_table', 'widget_text',
        'widget_tree', 'widget_tree_move', 'widget_window',
        'wiener_filter', 'window',
        'window', 'write_bmp', 'write_csv', 'write_gif', 'write_image',
        'write_jpeg', 'write_jpeg2000', 'write_nrif', 'write_pict', 'write_png',
        'write_ppm', 'write_spr', 'write_srf', 'write_sylk', 'write_tiff',
        'write_video', 'write_wav', 'write_wave', 'writeu', 'wset',
        'wshow', 'wtn', 'wv_applet', 'wv_cwt', 'wv_cw_wavelet',
        'wv_denoise', 'wv_dwt', 'wv_fn_coiflet',
        'wv_fn_daubechies', 'wv_fn_gaussian',
        'wv_fn_haar', 'wv_fn_morlet', 'wv_fn_paul',
        'wv_fn_symlet', 'wv_import_data',
        'wv_import_wavelet', 'wv_plot3d_wps', 'wv_plot_multires',
        'wv_pwt', 'wv_tool_denoise',
        'xbm_edit', 'xdisplayfile', 'xdxf', 'xfont', 'xinteranimate',
        'xloadct', 'xmanager', 'xmng_tmpl', 'xmtool', 'xobjview',
        'xobjview_rotate', 'xobjview_write_image',
        'xpalette', 'xpcolor', 'xplot3d',
        'xregistered', 'xroi', 'xsq_test', 'xsurface', 'xvaredit',
        'xvolume', 'xvolume_rotate', 'xvolume_write_image',
        'xyouts', 'zlib_compress', 'zlib_uncompress', 'zoom', 'zoom_24'
      ];
      var builtins = wordRegexp(builtinArray);

      var keywordArray = [
        'begin', 'end', 'endcase', 'endfor',
        'endwhile', 'endif', 'endrep', 'endforeach',
        'break', 'case', 'continue', 'for',
        'foreach', 'goto', 'if', 'then', 'else',
        'repeat', 'until', 'switch', 'while',
        'do', 'pro', 'function'
      ];
      var keywords = wordRegexp(keywordArray);

      CodeMirror.registerHelper("hintWords", "idl", builtinArray.concat(keywordArray));

      var identifiers = new RegExp('^[_a-z\xa1-\uffff][_a-z0-9\xa1-\uffff]*', 'i');

      var singleOperators = /[+\-*&=<>\/@#~$]/;
      var boolOperators = new RegExp('(and|or|eq|lt|le|gt|ge|ne|not)', 'i');

      function tokenBase(stream) {
        // whitespaces
        if (stream.eatSpace()) return null;

        // Handle one line Comments
        if (stream.match(';')) {
          stream.skipToEnd();
          return 'comment';
        }

        // Handle Number Literals
        if (stream.match(/^[0-9\.+-]/, false)) {
          if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))
            return 'number';
          if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?/))
            return 'number';
          if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?/))
            return 'number';
        }

        // Handle Strings
        if (stream.match(/^"([^"]|(""))*"/)) { return 'string'; }
        if (stream.match(/^'([^']|(''))*'/)) { return 'string'; }

        // Handle words
        if (stream.match(keywords)) { return 'keyword'; }
        if (stream.match(builtins)) { return 'builtin'; }
        if (stream.match(identifiers)) { return 'variable'; }

        if (stream.match(singleOperators) || stream.match(boolOperators)) {
          return 'operator'; }

        // Handle non-detected items
        stream.next();
        return null;
      }
      CodeMirror.defineMode('idl', function() {
        return {
          token: function(stream) {
            return tokenBase(stream);
          }
        };
      });

      CodeMirror.defineMIME('text/x-idl', 'idl');
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Javascript(CodeMirror) {
    CodeMirror.defineMode("javascript", function(config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

      // Tokenizer

      var keywords = function(){
        function kw(type) {return {type: type, style: "keyword"};}
        var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
        var operator = kw("operator"), atom = {type: "atom", style: "atom"};

        return {
          "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
          "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
          "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
          "function": kw("function"), "catch": kw("catch"),
          "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
          "in": operator, "typeof": operator, "instanceof": operator,
          "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
          "this": kw("this"), "class": kw("class"), "super": kw("atom"),
          "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
          "await": C
        };
      }();

      var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

      function readRegexp(stream) {
        var escaped = false, next, inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet) return;
            if (next == "[") inSet = true;
            else if (inSet && next == "]") inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }

      // Used as scratch variables to communicate multiple values without
      // consing up tons of objects.
      var type, content;
      function ret(tp, style, cont) {
        type = tp; content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch == "0" && stream.match(/^(?:x[\da-f]+|o[0-7]+|b[01]+)n?/i)) {
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:n|(?:\.\d*)?(?:[eE][+\-]?\d+)?)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (expressionAllowed(stream, state, 1)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eat("=");
            return ret("operator", "operator", stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
          if (ch != ">" || !state.lexical || state.lexical.type != ">") {
            if (stream.eat("=")) {
              if (ch == "!" || ch == "=") stream.eat("=");
            } else if (/[<>*+\-]/.test(ch)) {
              stream.eat(ch);
              if (ch == ">") stream.eat(ch);
            }
          }
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch)) {
          stream.eatWhile(wordRE);
          var word = stream.current();
          if (state.lastType != ".") {
            if (keywords.propertyIsEnumerable(word)) {
              var kw = keywords[word];
              return ret(kw.type, kw.style, word)
            }
            if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
              return ret("async", "keyword", word)
          }
          return ret("variable", "variable", word)
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }

      function tokenQuasi(stream, state) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }

      var brackets = "([{}])";
      // This is a crude lookahead trick to try and notice that we're
      // parsing the argument patterns for a fat-arrow function before we
      // actually hit the arrow token. It only works if the arrow is on
      // the same line as the arguments and there's no strange noise
      // (comments) in between. Fallback is to only notice when we hit the
      // arrow, and not declare the arguments as locals for the arrow
      // body.
      function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;

        if (isTS) { // Try to skip TypeScript return type declarations after the arguments
          var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
          if (m) arrow = m.index;
        }

        var depth = 0, sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) { ++pos; break; }
            if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch)) {
            sawSomething = true;
          } else if (/["'\/]/.test(ch)) {
            return;
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
      }

      // Parser

      var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }

      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next)
          if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next)
            if (v.name == varname) return true;
        }
      }

      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;

        while(true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while(cc.length && cc[cc.length - 1].lex)
              cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            return style;
          }
        }
      }

      // Combinator utils

      var cx = {state: null, column: null, marked: null, cc: null};
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function inList(name, list) {
        for (var v = list; v; v = v.next) if (v.name == name) return true
        return false;
      }
      function register(varname) {
        var state = cx.state;
        cx.marked = "def";
        if (state.context) {
          if (state.lexical.info == "var" && state.context && state.context.block) {
            // FIXME function decls are also not block scoped
            var newContext = registerVarScoped(varname, state.context);
            if (newContext != null) {
              state.context = newContext;
              return
            }
          } else if (!inList(varname, state.localVars)) {
            state.localVars = new Var(varname, state.localVars);
            return
          }
        }
        // Fall through means this is global
        if (parserConfig.globalVars && !inList(varname, state.globalVars))
          state.globalVars = new Var(varname, state.globalVars);
      }
      function registerVarScoped(varname, context) {
        if (!context) {
          return null
        } else if (context.block) {
          var inner = registerVarScoped(varname, context.prev);
          if (!inner) return null
          if (inner == context.prev) return context
          return new Context(inner, context.vars, true)
        } else if (inList(varname, context.vars)) {
          return context
        } else {
          return new Context(context.prev, new Var(varname, context.vars), false)
        }
      }

      function isModifier(name) {
        return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
      }

      // Combinators

      function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block; }
      function Var(name, next) { this.name = name; this.next = next; }

      var defaultVars = new Var("this", new Var("arguments", null));
      function pushcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
        cx.state.localVars = defaultVars;
      }
      function pushblockcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
        cx.state.localVars = null;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      popcontext.lex = true;
      function pushlex(type, info) {
        var result = function() {
          var state = cx.state, indent = state.indented;
          if (state.lexical.type == "stat") indent = state.lexical.indented;
          else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
            indent = outer.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;

      function expect(wanted) {
        function exp(type) {
          if (type == wanted) return cont();
          else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
          else return cont(exp);
        }    return exp;
      }

      function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
        if (type == "debugger") return cont(expect(";"));
        if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
        if (type == ";") return cont();
        if (type == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
            cx.state.cc.pop()();
          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
        }
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
        if (type == "class" || (isTS && value == "interface")) {
          cx.marked = "keyword";
          return cont(pushlex("form", type == "class" ? type : value), className, poplex)
        }
        if (type == "variable") {
          if (isTS && value == "declare") {
            cx.marked = "keyword";
            return cont(statement)
          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
            cx.marked = "keyword";
            if (value == "enum") return cont(enumdef);
            else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
            else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
          } else if (isTS && value == "namespace") {
            cx.marked = "keyword";
            return cont(pushlex("form"), expression, statement, poplex)
          } else if (isTS && value == "abstract") {
            cx.marked = "keyword";
            return cont(statement)
          } else {
            return cont(pushlex("stat"), maybelabel);
          }
        }
        if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                          block, poplex, poplex, popcontext);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
        if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
        if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
        if (type == "async") return cont(statement)
        if (value == "@") return cont(expression, statement)
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function maybeCatchBinding(type) {
        if (type == "(") return cont(funarg, expect(")"))
      }
      function expression(type, value) {
        return expressionInner(type, value, false);
      }
      function expressionNoComma(type, value) {
        return expressionInner(type, value, true);
      }
      function parenExpr(type) {
        if (type != "(") return pass()
        return cont(pushlex(")"), expression, expect(")"), poplex)
      }
      function expressionInner(type, value, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
          else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }

        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef, maybeop);
        if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
        if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type == "{") return contCommasep(objprop, "}", null, maybeop);
        if (type == "quasi") return pass(quasi, maybeop);
        if (type == "new") return cont(maybeTarget(noComma));
        if (type == "import") return cont(expression);
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }

      function maybeoperatorComma(type, value) {
        if (type == ",") return cont(expression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
          if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false))
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
          if (value == "?") return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") { return pass(quasi, me); }
        if (type == ";") return;
        if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
        if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
        if (type == "regexp") {
          cx.state.lastType = cx.marked = "operator";
          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
          return cont(expr)
        }
      }
      function quasi(type, value) {
        if (type != "quasi") return pass();
        if (value.slice(value.length - 2) != "${") return cont(quasi);
        return cont(expression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        return pass(type == "{" ? statement : expressionNoComma);
      }
      function maybeTarget(noComma) {
        return function(type) {
          if (type == ".") return cont(noComma ? targetNoComma : target);
          else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
          else return pass(noComma ? expressionNoComma : expression);
        };
      }
      function target(_, value) {
        if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
      }
      function targetNoComma(_, value) {
        if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
      }
      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {cx.marked = "property"; return cont();}
      }
      function objprop(type, value) {
        if (type == "async") {
          cx.marked = "property";
          return cont(objprop);
        } else if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set") return cont(getterSetter);
          var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params
          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
            cx.state.fatArrowAt = cx.stream.pos + m[0].length;
          return cont(afterprop);
        } else if (type == "number" || type == "string") {
          cx.marked = jsonldMode ? "property" : (cx.style + " property");
          return cont(afterprop);
        } else if (type == "jsonld-keyword") {
          return cont(afterprop);
        } else if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(objprop)
        } else if (type == "[") {
          return cont(expression, maybetype, expect("]"), afterprop);
        } else if (type == "spread") {
          return cont(expressionNoComma, afterprop);
        } else if (value == "*") {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type == ":") {
          return pass(afterprop)
        }
      }
      function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
      }
      function commasep(what, end, sep) {
        function proceed(type, value) {
          if (sep ? sep.indexOf(type) > -1 : type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
            return cont(function(type, value) {
              if (type == end || value == end) return pass()
              return pass(what)
            }, proceed);
          }
          if (type == end || value == end) return cont();
          if (sep && sep.indexOf(";") > -1) return pass(what)
          return cont(expect(end));
        }
        return function(type, value) {
          if (type == end || value == end) return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end, info) {
        for (var i = 3; i < arguments.length; i++)
          cx.cc.push(arguments[i]);
        return cont(pushlex(end, info), commasep(what, end), poplex);
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function maybetype(type, value) {
        if (isTS) {
          if (type == ":" || value == "in") return cont(typeexpr);
          if (value == "?") return cont(maybetype);
        }
      }
      function mayberettype(type) {
        if (isTS && type == ":") {
          if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
          else return cont(typeexpr)
        }
      }
      function isKW(_, value) {
        if (value == "is") {
          cx.marked = "keyword";
          return cont()
        }
      }
      function typeexpr(type, value) {
        if (value == "keyof" || value == "typeof" || value == "infer") {
          cx.marked = "keyword";
          return cont(value == "typeof" ? expressionNoComma : typeexpr)
        }
        if (type == "variable" || value == "void") {
          cx.marked = "type";
          return cont(afterType)
        }
        if (value == "|" || value == "&") return cont(typeexpr)
        if (type == "string" || type == "number" || type == "atom") return cont(afterType);
        if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
        if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
        if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
        if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
      }
      function maybeReturnType(type) {
        if (type == "=>") return cont(typeexpr)
      }
      function typeprop(type, value) {
        if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(typeprop)
        } else if (value == "?" || type == "number" || type == "string") {
          return cont(typeprop)
        } else if (type == ":") {
          return cont(typeexpr)
        } else if (type == "[") {
          return cont(expect("variable"), maybetype, expect("]"), typeprop)
        } else if (type == "(") {
          return pass(functiondecl, typeprop)
        }
      }
      function typearg(type, value) {
        if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
        if (type == ":") return cont(typeexpr)
        if (type == "spread") return cont(typearg)
        return pass(typeexpr)
      }
      function afterType(type, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
        if (value == "|" || type == "." || value == "&") return cont(typeexpr)
        if (type == "[") return cont(typeexpr, expect("]"), afterType)
        if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
        if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
      }
      function maybeTypeArgs(_, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
      }
      function typeparam() {
        return pass(typeexpr, maybeTypeDefault)
      }
      function maybeTypeDefault(_, value) {
        if (value == "=") return cont(typeexpr)
      }
      function vardef(_, value) {
        if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
        if (type == "variable") { register(value); return cont(); }
        if (type == "spread") return cont(pattern);
        if (type == "[") return contCommasep(eltpattern, "]");
        if (type == "{") return contCommasep(proppattern, "}");
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        if (type == "spread") return cont(pattern);
        if (type == "}") return pass();
        if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
        return cont(expect(":"), pattern, maybeAssign);
      }
      function eltpattern() {
        return pass(pattern, maybeAssign)
      }
      function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",") return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type, value) {
        if (value == "await") return cont(forspec);
        if (type == "(") return cont(pushlex(")"), forspec1, poplex);
      }
      function forspec1(type) {
        if (type == "var") return cont(vardef, forspec2);
        if (type == "variable") return cont(forspec2);
        return pass(forspec2)
      }
      function forspec2(type, value) {
        if (type == ")") return cont()
        if (type == ";") return cont(forspec2)
        if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
        return pass(expression, forspec2)
      }
      function functiondef(type, value) {
        if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
        if (type == "variable") {register(value); return cont(functiondef);}
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
        if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
      }
      function functiondecl(type, value) {
        if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
        if (type == "variable") {register(value); return cont(functiondecl);}
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
        if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
      }
      function typename(type, value) {
        if (type == "keyword" || type == "variable") {
          cx.marked = "type";
          return cont(typename)
        } else if (value == "<") {
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
        }
      }
      function funarg(type, value) {
        if (value == "@") cont(expression, funarg);
        if (type == "spread") return cont(funarg);
        if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
        if (isTS && type == "this") return cont(maybetype, maybeAssign)
        return pass(pattern, maybetype, maybeAssign);
      }
      function classExpression(type, value) {
        // Class expressions may have an optional name.
        if (type == "variable") return className(type, value);
        return classNameAfter(type, value);
      }
      function className(type, value) {
        if (type == "variable") {register(value); return cont(classNameAfter);}
      }
      function classNameAfter(type, value) {
        if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
        if (value == "extends" || value == "implements" || (isTS && type == ",")) {
          if (value == "implements") cx.marked = "keyword";
          return cont(isTS ? typeexpr : expression, classNameAfter);
        }
        if (type == "{") return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type, value) {
        if (type == "async" ||
            (type == "variable" &&
             (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
             cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(isTS ? classfield : functiondef, classBody);
        }
        if (type == "number" || type == "string") return cont(isTS ? classfield : functiondef, classBody);
        if (type == "[")
          return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody)
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (isTS && type == "(") return pass(functiondecl, classBody)
        if (type == ";" || type == ",") return cont(classBody);
        if (type == "}") return cont();
        if (value == "@") return cont(expression, classBody)
      }
      function classfield(type, value) {
        if (value == "?") return cont(classfield)
        if (type == ":") return cont(typeexpr, maybeAssign)
        if (value == "=") return cont(expressionNoComma)
        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
        return pass(isInterface ? functiondecl : functiondef)
      }
      function afterExport(type, value) {
        if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
        if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
        if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
        return pass(statement);
      }
      function exportField(type, value) {
        if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
        if (type == "variable") return pass(expressionNoComma, exportField);
      }
      function afterImport(type) {
        if (type == "string") return cont();
        if (type == "(") return pass(expression);
        return pass(importSpec, maybeMoreImports, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{") return contCommasep(importSpec, "}");
        if (type == "variable") register(value);
        if (value == "*") cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeMoreImports(type) {
        if (type == ",") return cont(importSpec, maybeMoreImports)
      }
      function maybeAs(_type, value) {
        if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
      }
      function maybeFrom(_type, value) {
        if (value == "from") { cx.marked = "keyword"; return cont(expression); }
      }
      function arrayLiteral(type) {
        if (type == "]") return cont();
        return pass(commasep(expressionNoComma, "]"));
      }
      function enumdef() {
        return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
      }
      function enummember() {
        return pass(pattern, maybeAssign);
      }

      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," ||
          isOperatorChar.test(textAfter.charAt(0)) ||
          /[,.]/.test(textAfter.charAt(0));
      }

      function expressionAllowed(stream, state, backUp) {
        return state.tokenize == tokenBase &&
          /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
          (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
      }

      // Interface

      return {
        startState: function(basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && new Context(null, null, false),
            indented: basecolumn || 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },

        indent: function(state, textAfter) {
          if (state.tokenize == tokenComment) return CodeMirror.Pass;
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
          // Kludge to prevent 'maybelse' from blocking lexical scope pops
          if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
            var c = state.cc[i];
            if (c == poplex) lexical = lexical.prev;
            else if (c != maybeelse) break;
          }
          while ((lexical.type == "stat" || lexical.type == "form") &&
                 (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                       (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                       !/^[,\.=+\-*:?[\(]/.test(textAfter))))
            lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
            lexical = lexical.prev;
          var type = lexical.type, closing = firstChar == type;

          if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
          else if (type == "form" && firstChar == "{") return lexical.indented;
          else if (type == "form") return lexical.indented + indentUnit;
          else if (type == "stat")
            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align) return lexical.column + (closing ? 0 : 1);
          else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        blockCommentContinue: jsonMode ? null : " * ",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",

        helperType: jsonMode ? "json" : "javascript",
        jsonldMode: jsonldMode,
        jsonMode: jsonMode,

        expressionAllowed: expressionAllowed,

        skipExpression: function(state) {
          var top = state.cc[state.cc.length - 1];
          if (top == expression || top == expressionNoComma) state.cc.pop();
        }
      };
    });

    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/x-javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
    CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
    CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Jinja2(CodeMirror) {
      CodeMirror.defineMode("jinja2", function() {
        var keywords = ["and", "as", "block", "endblock", "by", "cycle", "debug", "else", "elif",
          "extends", "filter", "endfilter", "firstof", "for",
          "endfor", "if", "endif", "ifchanged", "endifchanged",
          "ifequal", "endifequal", "ifnotequal",
          "endifnotequal", "in", "include", "load", "not", "now", "or",
          "parsed", "regroup", "reversed", "spaceless",
          "endspaceless", "ssi", "templatetag", "openblock",
          "closeblock", "openvariable", "closevariable",
          "openbrace", "closebrace", "opencomment",
          "closecomment", "widthratio", "url", "with", "endwith",
          "get_current_language", "trans", "endtrans", "noop", "blocktrans",
          "endblocktrans", "get_available_languages",
          "get_current_language_bidi", "plural"],
        operator = /^[+\-*&%=<>!?|~^]/,
        sign = /^[:\[\(\{]/,
        atom = ["true", "false"],
        number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

        keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
        atom = new RegExp("((" + atom.join(")|(") + "))\\b");

        function tokenBase (stream, state) {
          var ch = stream.peek();

          //Comment
          if (state.incomment) {
            if(!stream.skipTo("#}")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\#|}/);
              state.incomment = false;
            }
            return "comment";
          //Tag
          } else if (state.intag) {
            //After operator
            if(state.operator) {
              state.operator = false;
              if(stream.match(atom)) {
                return "atom";
              }
              if(stream.match(number)) {
                return "number";
              }
            }
            //After sign
            if(state.sign) {
              state.sign = false;
              if(stream.match(atom)) {
                return "atom";
              }
              if(stream.match(number)) {
                return "number";
              }
            }

            if(state.instring) {
              if(ch == state.instring) {
                state.instring = false;
              }
              stream.next();
              return "string";
            } else if(ch == "'" || ch == '"') {
              state.instring = ch;
              stream.next();
              return "string";
            } else if(stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
              state.intag = false;
              return "tag";
            } else if(stream.match(operator)) {
              state.operator = true;
              return "operator";
            } else if(stream.match(sign)) {
              state.sign = true;
            } else {
              if(stream.eat(" ") || stream.sol()) {
                if(stream.match(keywords)) {
                  return "keyword";
                }
                if(stream.match(atom)) {
                  return "atom";
                }
                if(stream.match(number)) {
                  return "number";
                }
                if(stream.sol()) {
                  stream.next();
                }
              } else {
                stream.next();
              }

            }
            return "variable";
          } else if (stream.eat("{")) {
            if (stream.eat("#")) {
              state.incomment = true;
              if(!stream.skipTo("#}")) {
                stream.skipToEnd();
              } else {
                stream.eatWhile(/\#|}/);
                state.incomment = false;
              }
              return "comment";
            //Open tag
            } else if (ch = stream.eat(/\{|%/)) {
              //Cache close tag
              state.intag = ch;
              if(ch == "{") {
                state.intag = "}";
              }
              stream.eat("-");
              return "tag";
            }
          }
          stream.next();
        }
        return {
          startState: function () {
            return {tokenize: tokenBase};
          },
          token: function (stream, state) {
            return state.tokenize(stream, state);
          },
          blockCommentStart: "{#",
          blockCommentEnd: "#}"
        };
      });

      CodeMirror.defineMIME("text/jinja2", "jinja2");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function JSX(CodeMirror) {
      // Depth means the amount of open braces in JS context, in XML
      // context 0 means not in tag, 1 means in tag, and 2 means in tag
      // and js block comment.
      function Context(state, mode, depth, prev) {
        this.state = state; this.mode = mode; this.depth = depth; this.prev = prev;
      }

      function copyContext(context) {
        return new Context(CodeMirror.copyState(context.mode, context.state),
                           context.mode,
                           context.depth,
                           context.prev && copyContext(context.prev))
      }

      CodeMirror.defineMode("jsx", function(config, modeConfig) {
        var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true});
        var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");

        function flatXMLIndent(state) {
          var tagName = state.tagName;
          state.tagName = null;
          var result = xmlMode.indent(state, "", "");
          state.tagName = tagName;
          return result
        }

        function token(stream, state) {
          if (state.context.mode == xmlMode)
            return xmlToken(stream, state, state.context)
          else
            return jsToken(stream, state, state.context)
        }

        function xmlToken(stream, state, cx) {
          if (cx.depth == 2) { // Inside a JS /* */ comment
            if (stream.match(/^.*?\*\//)) cx.depth = 1;
            else stream.skipToEnd();
            return "comment"
          }

          if (stream.peek() == "{") {
            xmlMode.skipAttribute(cx.state);

            var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context;
            // If JS starts on same line as tag
            if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
              while (xmlContext.prev && !xmlContext.startOfLine)
                xmlContext = xmlContext.prev;
              // If tag starts the line, use XML indentation level
              if (xmlContext.startOfLine) indent -= config.indentUnit;
              // Else use JS indentation level
              else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented;
            // Else if inside of tag
            } else if (cx.depth == 1) {
              indent += config.indentUnit;
            }

            state.context = new Context(CodeMirror.startState(jsMode, indent),
                                        jsMode, 0, state.context);
            return null
          }

          if (cx.depth == 1) { // Inside of tag
            if (stream.peek() == "<") { // Tag inside of tag
              xmlMode.skipAttribute(cx.state);
              state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
                                          xmlMode, 0, state.context);
              return null
            } else if (stream.match("//")) {
              stream.skipToEnd();
              return "comment"
            } else if (stream.match("/*")) {
              cx.depth = 2;
              return token(stream, state)
            }
          }

          var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop;
          if (/\btag\b/.test(style)) {
            if (/>$/.test(cur)) {
              if (cx.state.context) cx.depth = 0;
              else state.context = state.context.prev;
            } else if (/^</.test(cur)) {
              cx.depth = 1;
            }
          } else if (!style && (stop = cur.indexOf("{")) > -1) {
            stream.backUp(cur.length - stop);
          }
          return style
        }

        function jsToken(stream, state, cx) {
          if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
            jsMode.skipExpression(cx.state);
            state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "", "")),
                                        xmlMode, 0, state.context);
            return null
          }

          var style = jsMode.token(stream, cx.state);
          if (!style && cx.depth != null) {
            var cur = stream.current();
            if (cur == "{") {
              cx.depth++;
            } else if (cur == "}") {
              if (--cx.depth == 0) state.context = state.context.prev;
            }
          }
          return style
        }

        return {
          startState: function() {
            return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
          },

          copyState: function(state) {
            return {context: copyContext(state.context)}
          },

          token: token,

          indent: function(state, textAfter, fullLine) {
            return state.context.mode.indent(state.context.state, textAfter, fullLine)
          },

          innerMode: function(state) {
            return state.context
          }
        }
      }, "xml", "javascript");

      CodeMirror.defineMIME("text/jsx", "jsx");
      CodeMirror.defineMIME("text/typescript-jsx", {name: "jsx", base: {name: "javascript", typescript: true}});
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Julia(CodeMirror) {
    CodeMirror.defineMode("julia", function(config, parserConf) {
      function wordRegexp(words, end) {
        if (typeof end === "undefined") { end = "\\b"; }
        return new RegExp("^((" + words.join(")|(") + "))" + end);
      }

      var octChar = "\\\\[0-7]{1,3}";
      var hexChar = "\\\\x[A-Fa-f0-9]{1,2}";
      var sChar = "\\\\[abefnrtv0%?'\"\\\\]";
      var uChar = "([^\\u0027\\u005C\\uD800-\\uDFFF]|[\\uD800-\\uDFFF][\\uDC00-\\uDFFF])";

      var operators = parserConf.operators || wordRegexp([
            "[<>]:", "[<>=]=", "<<=?", ">>>?=?", "=>", "->", "\\/\\/",
            "[\\\\%*+\\-<>!=\\/^|&\\u00F7\\u22BB]=?", "\\?", "\\$", "~", ":",
            "\\u00D7", "\\u2208", "\\u2209", "\\u220B", "\\u220C", "\\u2218",
            "\\u221A", "\\u221B", "\\u2229", "\\u222A", "\\u2260", "\\u2264",
            "\\u2265", "\\u2286", "\\u2288", "\\u228A", "\\u22C5",
            "\\b(in|isa)\\b(?!\.?\\()"], "");
      var delimiters = parserConf.delimiters || /^[;,()[\]{}]/;
      var identifiers = parserConf.identifiers ||
            /^[_A-Za-z\u00A1-\u2217\u2219-\uFFFF][\w\u00A1-\u2217\u2219-\uFFFF]*!*/;

      var chars = wordRegexp([octChar, hexChar, sChar, uChar], "'");

      var openersList = ["begin", "function", "type", "struct", "immutable", "let",
            "macro", "for", "while", "quote", "if", "else", "elseif", "try",
            "finally", "catch", "do"];

      var closersList = ["end", "else", "elseif", "catch", "finally"];

      var keywordsList = ["if", "else", "elseif", "while", "for", "begin", "let",
            "end", "do", "try", "catch", "finally", "return", "break", "continue",
            "global", "local", "const", "export", "import", "importall", "using",
            "function", "where", "macro", "module", "baremodule", "struct", "type",
            "mutable", "immutable", "quote", "typealias", "abstract", "primitive",
            "bitstype"];

      var builtinsList = ["true", "false", "nothing", "NaN", "Inf"];

      CodeMirror.registerHelper("hintWords", "julia", keywordsList.concat(builtinsList));

      var openers = wordRegexp(openersList);
      var closers = wordRegexp(closersList);
      var keywords = wordRegexp(keywordsList);
      var builtins = wordRegexp(builtinsList);

      var macro = /^@[_A-Za-z][\w]*/;
      var symbol = /^:[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
      var stringPrefixes = /^(`|([_A-Za-z\u00A1-\uFFFF]*"("")?))/;

      function inArray(state) {
        return (state.nestedArrays > 0);
      }

      function inGenerator(state) {
        return (state.nestedGenerators > 0);
      }

      function currentScope(state, n) {
        if (typeof(n) === "undefined") { n = 0; }
        if (state.scopes.length <= n) {
          return null;
        }
        return state.scopes[state.scopes.length - (n + 1)];
      }

      // tokenizers
      function tokenBase(stream, state) {
        // Handle multiline comments
        if (stream.match(/^#=/, false)) {
          state.tokenize = tokenComment;
          return state.tokenize(stream, state);
        }

        // Handle scope changes
        var leavingExpr = state.leavingExpr;
        if (stream.sol()) {
          leavingExpr = false;
        }
        state.leavingExpr = false;

        if (leavingExpr) {
          if (stream.match(/^'+/)) {
            return "operator";
          }
        }

        if (stream.match(/\.{4,}/)) {
          return "error";
        } else if (stream.match(/\.{1,3}/)) {
          return "operator";
        }

        if (stream.eatSpace()) {
          return null;
        }

        var ch = stream.peek();

        // Handle single line comments
        if (ch === '#') {
          stream.skipToEnd();
          return "comment";
        }

        if (ch === '[') {
          state.scopes.push('[');
          state.nestedArrays++;
        }

        if (ch === '(') {
          state.scopes.push('(');
          state.nestedGenerators++;
        }

        if (inArray(state) && ch === ']') {
          if (currentScope(state) === "if") { state.scopes.pop(); }
          while (currentScope(state) === "for") { state.scopes.pop(); }
          state.scopes.pop();
          state.nestedArrays--;
          state.leavingExpr = true;
        }

        if (inGenerator(state) && ch === ')') {
          if (currentScope(state) === "if") { state.scopes.pop(); }
          while (currentScope(state) === "for") { state.scopes.pop(); }
          state.scopes.pop();
          state.nestedGenerators--;
          state.leavingExpr = true;
        }

        if (inArray(state)) {
          if (state.lastToken == "end" && stream.match(/^:/)) {
            return "operator";
          }
          if (stream.match(/^end/)) {
            return "number";
          }
        }

        var match;
        if (match = stream.match(openers, false)) {
          state.scopes.push(match[0]);
        }

        if (stream.match(closers, false)) {
          state.scopes.pop();
        }

        // Handle type annotations
        if (stream.match(/^::(?![:\$])/)) {
          state.tokenize = tokenAnnotation;
          return state.tokenize(stream, state);
        }

        // Handle symbols
        if (!leavingExpr && stream.match(symbol) ||
            stream.match(/:([<>]:|<<=?|>>>?=?|->|\/\/|\.{2,3}|[\.\\%*+\-<>!\/^|&]=?|[~\?\$])/)) {
          return "builtin";
        }

        // Handle parametric types
        //if (stream.match(/^{[^}]*}(?=\()/)) {
        //  return "builtin";
        //}

        // Handle operators and Delimiters
        if (stream.match(operators)) {
          return "operator";
        }

        // Handle Number Literals
        if (stream.match(/^\.?\d/, false)) {
          var imMatcher = RegExp(/^im\b/);
          var numberLiteral = false;
          // Floats
          if (stream.match(/^\d*\.(?!\.)\d*([Eef][\+\-]?\d+)?/i)) { numberLiteral = true; }
          if (stream.match(/^\d+\.(?!\.)\d*/)) { numberLiteral = true; }
          if (stream.match(/^\.\d+/)) { numberLiteral = true; }
          if (stream.match(/^0x\.[0-9a-f]+p[\+\-]?\d+/i)) { numberLiteral = true; }
          // Integers
          if (stream.match(/^0x[0-9a-f]+/i)) { numberLiteral = true; } // Hex
          if (stream.match(/^0b[01]+/i)) { numberLiteral = true; } // Binary
          if (stream.match(/^0o[0-7]+/i)) { numberLiteral = true; } // Octal
          if (stream.match(/^[1-9]\d*(e[\+\-]?\d+)?/)) { numberLiteral = true; } // Decimal
          // Zero by itself with no other piece of number.
          if (stream.match(/^0(?![\dx])/i)) { numberLiteral = true; }
          if (numberLiteral) {
              // Integer literals may be "long"
              stream.match(imMatcher);
              state.leavingExpr = true;
              return "number";
          }
        }

        // Handle Chars
        if (stream.match(/^'/)) {
          state.tokenize = tokenChar;
          return state.tokenize(stream, state);
        }

        // Handle Strings
        if (stream.match(stringPrefixes)) {
          state.tokenize = tokenStringFactory(stream.current());
          return state.tokenize(stream, state);
        }

        if (stream.match(macro)) {
          return "meta";
        }

        if (stream.match(delimiters)) {
          return null;
        }

        if (stream.match(keywords)) {
          return "keyword";
        }

        if (stream.match(builtins)) {
          return "builtin";
        }

        var isDefinition = state.isDefinition || state.lastToken == "function" ||
                           state.lastToken == "macro" || state.lastToken == "type" ||
                           state.lastToken == "struct" || state.lastToken == "immutable";

        if (stream.match(identifiers)) {
          if (isDefinition) {
            if (stream.peek() === '.') {
              state.isDefinition = true;
              return "variable";
            }
            state.isDefinition = false;
            return "def";
          }
          if (stream.match(/^({[^}]*})*\(/, false)) {
            state.tokenize = tokenCallOrDef;
            return state.tokenize(stream, state);
          }
          state.leavingExpr = true;
          return "variable";
        }

        // Handle non-detected items
        stream.next();
        return "error";
      }

      function tokenCallOrDef(stream, state) {
        var match = stream.match(/^(\(\s*)/);
        if (match) {
          if (state.firstParenPos < 0)
            state.firstParenPos = state.scopes.length;
          state.scopes.push('(');
          state.charsAdvanced += match[1].length;
        }
        if (currentScope(state) == '(' && stream.match(/^\)/)) {
          state.scopes.pop();
          state.charsAdvanced += 1;
          if (state.scopes.length <= state.firstParenPos) {
            var isDefinition = stream.match(/^(\s*where\s+[^\s=]+)*\s*?=(?!=)/, false);
            stream.backUp(state.charsAdvanced);
            state.firstParenPos = -1;
            state.charsAdvanced = 0;
            state.tokenize = tokenBase;
            if (isDefinition)
              return "def";
            return "builtin";
          }
        }
        // Unfortunately javascript does not support multiline strings, so we have
        // to undo anything done upto here if a function call or definition splits
        // over two or more lines.
        if (stream.match(/^$/g, false)) {
          stream.backUp(state.charsAdvanced);
          while (state.scopes.length > state.firstParenPos)
            state.scopes.pop();
          state.firstParenPos = -1;
          state.charsAdvanced = 0;
          state.tokenize = tokenBase;
          return "builtin";
        }
        state.charsAdvanced += stream.match(/^([^()]*)/)[1].length;
        return state.tokenize(stream, state);
      }

      function tokenAnnotation(stream, state) {
        stream.match(/.*?(?=,|;|{|}|\(|\)|=|$|\s)/);
        if (stream.match(/^{/)) {
          state.nestedParameters++;
        } else if (stream.match(/^}/) && state.nestedParameters > 0) {
          state.nestedParameters--;
        }
        if (state.nestedParameters > 0) {
          stream.match(/.*?(?={|})/) || stream.next();
        } else if (state.nestedParameters == 0) {
          state.tokenize = tokenBase;
        }
        return "builtin";
      }

      function tokenComment(stream, state) {
        if (stream.match(/^#=/)) {
          state.nestedComments++;
        }
        if (!stream.match(/.*?(?=(#=|=#))/)) {
          stream.skipToEnd();
        }
        if (stream.match(/^=#/)) {
          state.nestedComments--;
          if (state.nestedComments == 0)
            state.tokenize = tokenBase;
        }
        return "comment";
      }

      function tokenChar(stream, state) {
        var isChar = false, match;
        if (stream.match(chars)) {
          isChar = true;
        } else if (match = stream.match(/\\u([a-f0-9]{1,4})(?=')/i)) {
          var value = parseInt(match[1], 16);
          if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)
            isChar = true;
            stream.next();
          }
        } else if (match = stream.match(/\\U([A-Fa-f0-9]{5,8})(?=')/)) {
          var value = parseInt(match[1], 16);
          if (value <= 1114111) { // U+10FFFF
            isChar = true;
            stream.next();
          }
        }
        if (isChar) {
          state.leavingExpr = true;
          state.tokenize = tokenBase;
          return "string";
        }
        if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }
        if (stream.match(/^'/)) { state.tokenize = tokenBase; }
        return "error";
      }

      function tokenStringFactory(delimiter) {
        if (delimiter.substr(-3) === '"""') {
          delimiter = '"""';
        } else if (delimiter.substr(-1) === '"') {
          delimiter = '"';
        }
        function tokenString(stream, state) {
          if (stream.eat('\\')) {
            stream.next();
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenBase;
            state.leavingExpr = true;
            return "string";
          } else {
            stream.eat(/[`"]/);
          }
          stream.eatWhile(/[^\\`"]/);
          return "string";
        }
        return tokenString;
      }

      var external = {
        startState: function() {
          return {
            tokenize: tokenBase,
            scopes: [],
            lastToken: null,
            leavingExpr: false,
            isDefinition: false,
            nestedArrays: 0,
            nestedComments: 0,
            nestedGenerators: 0,
            nestedParameters: 0,
            charsAdvanced: 0,
            firstParenPos: -1
          };
        },

        token: function(stream, state) {
          var style = state.tokenize(stream, state);
          var current = stream.current();

          if (current && style) {
            state.lastToken = current;
          }

          return style;
        },

        indent: function(state, textAfter) {
          var delta = 0;
          if ( textAfter === ']' || textAfter === ')' || textAfter === "end" ||
               textAfter === "else" || textAfter === "catch" || textAfter === "elseif" ||
               textAfter === "finally" ) {
            delta = -1;
          }
          return (state.scopes.length + delta) * config.indentUnit;
        },

        electricInput: /\b(end|else|catch|finally)\b/,
        blockCommentStart: "#=",
        blockCommentEnd: "=#",
        lineComment: "#",
        closeBrackets: "()[]{}\"\"",
        fold: "indent"
      };
      return external;
    });


    CodeMirror.defineMIME("text/x-julia", "julia");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Link to the project's GitHub page:
     * https://github.com/duralog/CodeMirror
     */

    function LiveScript(CodeMirror) {
      CodeMirror.defineMode('livescript', function(){
        var tokenBase = function(stream, state) {
          var next_rule = state.next || "start";
          if (next_rule) {
            state.next = state.next;
            var nr = Rules[next_rule];
            if (nr.splice) {
              for (var i$ = 0; i$ < nr.length; ++i$) {
                var r = nr[i$];
                if (r.regex && stream.match(r.regex)) {
                  state.next = r.next || state.next;
                  return r.token;
                }
              }
              stream.next();
              return 'error';
            }
            if (stream.match(r = Rules[next_rule])) {
              if (r.regex && stream.match(r.regex)) {
                state.next = r.next;
                return r.token;
              } else {
                stream.next();
                return 'error';
              }
            }
          }
          stream.next();
          return 'error';
        };
        var external = {
          startState: function(){
            return {
              next: 'start',
              lastToken: {style: null, indent: 0, content: ""}
            };
          },
          token: function(stream, state){
            while (stream.pos == stream.start)
              var style = tokenBase(stream, state);
            state.lastToken = {
              style: style,
              indent: stream.indentation(),
              content: stream.current()
            };
            return style.replace(/\./g, ' ');
          },
          indent: function(state){
            var indentation = state.lastToken.indent;
            if (state.lastToken.content.match(indenter)) {
              indentation += 2;
            }
            return indentation;
          }
        };
        return external;
      });

      var identifier = '(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*';
      var indenter = RegExp('(?:[({[=:]|[-~]>|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*' + identifier + ')?))\\s*$');
      var keywordend = '(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))';
      var stringfill = {
        token: 'string',
        regex: '.+'
      };
      var Rules = {
        start: [
          {
            token: 'comment.doc',
            regex: '/\\*',
            next: 'comment'
          }, {
            token: 'comment',
            regex: '#.*'
          }, {
            token: 'keyword',
            regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend
          }, {
            token: 'constant.language',
            regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend
          }, {
            token: 'invalid.illegal',
            regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend
          }, {
            token: 'language.support.class',
            regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend
          }, {
            token: 'language.support.function',
            regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend
          }, {
            token: 'variable.language',
            regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend
          }, {
            token: 'identifier',
            regex: identifier + '\\s*:(?![:=])'
          }, {
            token: 'variable',
            regex: identifier
          }, {
            token: 'keyword.operator',
            regex: '(?:\\.{3}|\\s+\\?)'
          }, {
            token: 'keyword.variable',
            regex: '(?:@+|::|\\.\\.)',
            next: 'key'
          }, {
            token: 'keyword.operator',
            regex: '\\.\\s*',
            next: 'key'
          }, {
            token: 'string',
            regex: '\\\\\\S[^\\s,;)}\\]]*'
          }, {
            token: 'string.doc',
            regex: '\'\'\'',
            next: 'qdoc'
          }, {
            token: 'string.doc',
            regex: '"""',
            next: 'qqdoc'
          }, {
            token: 'string',
            regex: '\'',
            next: 'qstring'
          }, {
            token: 'string',
            regex: '"',
            next: 'qqstring'
          }, {
            token: 'string',
            regex: '`',
            next: 'js'
          }, {
            token: 'string',
            regex: '<\\[',
            next: 'words'
          }, {
            token: 'string.regex',
            regex: '//',
            next: 'heregex'
          }, {
            token: 'string.regex',
            regex: '\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}',
            next: 'key'
          }, {
            token: 'constant.numeric',
            regex: '(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)'
          }, {
            token: 'lparen',
            regex: '[({[]'
          }, {
            token: 'rparen',
            regex: '[)}\\]]',
            next: 'key'
          }, {
            token: 'keyword.operator',
            regex: '\\S+'
          }, {
            token: 'text',
            regex: '\\s+'
          }
        ],
        heregex: [
          {
            token: 'string.regex',
            regex: '.*?//[gimy$?]{0,4}',
            next: 'start'
          }, {
            token: 'string.regex',
            regex: '\\s*#{'
          }, {
            token: 'comment.regex',
            regex: '\\s+(?:#.*)?'
          }, {
            token: 'string.regex',
            regex: '\\S+'
          }
        ],
        key: [
          {
            token: 'keyword.operator',
            regex: '[.?@!]+'
          }, {
            token: 'identifier',
            regex: identifier,
            next: 'start'
          }, {
            token: 'text',
            regex: '',
            next: 'start'
          }
        ],
        comment: [
          {
            token: 'comment.doc',
            regex: '.*?\\*/',
            next: 'start'
          }, {
            token: 'comment.doc',
            regex: '.+'
          }
        ],
        qdoc: [
          {
            token: 'string',
            regex: ".*?'''",
            next: 'key'
          }, stringfill
        ],
        qqdoc: [
          {
            token: 'string',
            regex: '.*?"""',
            next: 'key'
          }, stringfill
        ],
        qstring: [
          {
            token: 'string',
            regex: '[^\\\\\']*(?:\\\\.[^\\\\\']*)*\'',
            next: 'key'
          }, stringfill
        ],
        qqstring: [
          {
            token: 'string',
            regex: '[^\\\\"]*(?:\\\\.[^\\\\"]*)*"',
            next: 'key'
          }, stringfill
        ],
        js: [
          {
            token: 'string',
            regex: '[^\\\\`]*(?:\\\\.[^\\\\`]*)*`',
            next: 'key'
          }, stringfill
        ],
        words: [
          {
            token: 'string',
            regex: '.*?\\]>',
            next: 'key'
          }, stringfill
        ]
      };
      for (var idx in Rules) {
        var r = Rules[idx];
        if (r.splice) {
          for (var i = 0, len = r.length; i < len; ++i) {
            var rr = r[i];
            if (typeof rr.regex === 'string') {
              Rules[idx][i].regex = new RegExp('^' + rr.regex);
            }
          }
        } else if (typeof rr.regex === 'string') {
          Rules[idx].regex = new RegExp('^' + r.regex);
        }
      }

      CodeMirror.defineMIME('text/x-livescript', 'livescript');

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // LUA mode. Ported to CodeMirror 2 from Franciszek Wawrzak's
    // CodeMirror 1 mode.
    // highlights keywords, strings, comments (no leveling supported! ("[==[")), tokens, basic indenting

    function Lua(CodeMirror) {
    CodeMirror.defineMode("lua", function(config, parserConfig) {
      var indentUnit = config.indentUnit;

      function prefixRE(words) {
        return new RegExp("^(?:" + words.join("|") + ")", "i");
      }
      function wordRE(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      }
      var specials = wordRE(parserConfig.specials || []);

      // long list of standard functions from lua manual
      var builtins = wordRE([
        "_G","_VERSION","assert","collectgarbage","dofile","error","getfenv","getmetatable","ipairs","load",
        "loadfile","loadstring","module","next","pairs","pcall","print","rawequal","rawget","rawset","require",
        "select","setfenv","setmetatable","tonumber","tostring","type","unpack","xpcall",

        "coroutine.create","coroutine.resume","coroutine.running","coroutine.status","coroutine.wrap","coroutine.yield",

        "debug.debug","debug.getfenv","debug.gethook","debug.getinfo","debug.getlocal","debug.getmetatable",
        "debug.getregistry","debug.getupvalue","debug.setfenv","debug.sethook","debug.setlocal","debug.setmetatable",
        "debug.setupvalue","debug.traceback",

        "close","flush","lines","read","seek","setvbuf","write",

        "io.close","io.flush","io.input","io.lines","io.open","io.output","io.popen","io.read","io.stderr","io.stdin",
        "io.stdout","io.tmpfile","io.type","io.write",

        "math.abs","math.acos","math.asin","math.atan","math.atan2","math.ceil","math.cos","math.cosh","math.deg",
        "math.exp","math.floor","math.fmod","math.frexp","math.huge","math.ldexp","math.log","math.log10","math.max",
        "math.min","math.modf","math.pi","math.pow","math.rad","math.random","math.randomseed","math.sin","math.sinh",
        "math.sqrt","math.tan","math.tanh",

        "os.clock","os.date","os.difftime","os.execute","os.exit","os.getenv","os.remove","os.rename","os.setlocale",
        "os.time","os.tmpname",

        "package.cpath","package.loaded","package.loaders","package.loadlib","package.path","package.preload",
        "package.seeall",

        "string.byte","string.char","string.dump","string.find","string.format","string.gmatch","string.gsub",
        "string.len","string.lower","string.match","string.rep","string.reverse","string.sub","string.upper",

        "table.concat","table.insert","table.maxn","table.remove","table.sort"
      ]);
      var keywords = wordRE(["and","break","elseif","false","nil","not","or","return",
                             "true","function", "end", "if", "then", "else", "do",
                             "while", "repeat", "until", "for", "in", "local" ]);

      var indentTokens = wordRE(["function", "if","repeat","do", "\\(", "{"]);
      var dedentTokens = wordRE(["end", "until", "\\)", "}"]);
      var dedentPartial = prefixRE(["end", "until", "\\)", "}", "else", "elseif"]);

      function readBracket(stream) {
        var level = 0;
        while (stream.eat("=")) ++level;
        stream.eat("[");
        return level;
      }

      function normal(stream, state) {
        var ch = stream.next();
        if (ch == "-" && stream.eat("-")) {
          if (stream.eat("[") && stream.eat("["))
            return (state.cur = bracketed(readBracket(stream), "comment"))(stream, state);
          stream.skipToEnd();
          return "comment";
        }
        if (ch == "\"" || ch == "'")
          return (state.cur = string(ch))(stream, state);
        if (ch == "[" && /[\[=]/.test(stream.peek()))
          return (state.cur = bracketed(readBracket(stream), "string"))(stream, state);
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w.%]/);
          return "number";
        }
        if (/[\w_]/.test(ch)) {
          stream.eatWhile(/[\w\\\-_.]/);
          return "variable";
        }
        return null;
      }

      function bracketed(level, style) {
        return function(stream, state) {
          var curlev = null, ch;
          while ((ch = stream.next()) != null) {
            if (curlev == null) {if (ch == "]") curlev = 0;}
            else if (ch == "=") ++curlev;
            else if (ch == "]" && curlev == level) { state.cur = normal; break; }
            else curlev = null;
          }
          return style;
        };
      }

      function string(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) state.cur = normal;
          return "string";
        };
      }

      return {
        startState: function(basecol) {
          return {basecol: basecol || 0, indentDepth: 0, cur: normal};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.cur(stream, state);
          var word = stream.current();
          if (style == "variable") {
            if (keywords.test(word)) style = "keyword";
            else if (builtins.test(word)) style = "builtin";
            else if (specials.test(word)) style = "variable-2";
          }
          if ((style != "comment") && (style != "string")){
            if (indentTokens.test(word)) ++state.indentDepth;
            else if (dedentTokens.test(word)) --state.indentDepth;
          }
          return style;
        },

        indent: function(state, textAfter) {
          var closing = dedentPartial.test(textAfter);
          return state.basecol + indentUnit * (state.indentDepth - (closing ? 1 : 0));
        },

        lineComment: "--",
        blockCommentStart: "--[[",
        blockCommentEnd: "]]"
      };
    });

    CodeMirror.defineMIME("text/x-lua", "lua");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Markdown(CodeMirror) {
    CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {

      var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
      var htmlModeMissing = htmlMode.name == "null";

      function getMode(name) {
        if (CodeMirror.findModeByName) {
          var found = CodeMirror.findModeByName(name);
          if (found) name = found.mime || found.mimes[0];
        }
        var mode = CodeMirror.getMode(cmCfg, name);
        return mode.name == "null" ? null : mode;
      }

      // Should characters that affect highlighting be highlighted separate?
      // Does not include characters that will be output (such as `1.` and `-` for lists)
      if (modeCfg.highlightFormatting === undefined)
        modeCfg.highlightFormatting = false;

      // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
      // Excess `>` will emit `error` token.
      if (modeCfg.maxBlockquoteDepth === undefined)
        modeCfg.maxBlockquoteDepth = 0;

      // Turn on task lists? ("- [ ] " and "- [x] ")
      if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

      // Turn on strikethrough syntax
      if (modeCfg.strikethrough === undefined)
        modeCfg.strikethrough = false;

      if (modeCfg.emoji === undefined)
        modeCfg.emoji = false;

      if (modeCfg.fencedCodeBlockHighlighting === undefined)
        modeCfg.fencedCodeBlockHighlighting = true;

      if (modeCfg.xml === undefined)
        modeCfg.xml = true;

      // Allow token types to be overridden by user-provided token types.
      if (modeCfg.tokenTypeOverrides === undefined)
        modeCfg.tokenTypeOverrides = {};

      var tokenTypes = {
        header: "header",
        code: "comment",
        quote: "quote",
        list1: "variable-2",
        list2: "variable-3",
        list3: "keyword",
        hr: "hr",
        image: "image",
        imageAltText: "image-alt-text",
        imageMarker: "image-marker",
        formatting: "formatting",
        linkInline: "link",
        linkEmail: "link",
        linkText: "link",
        linkHref: "string",
        em: "em",
        strong: "strong",
        strikethrough: "strikethrough",
        emoji: "builtin"
      };

      for (var tokenType in tokenTypes) {
        if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
          tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
        }
      }

      var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
      ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
      ,   taskListRE = /^\[(x| )\](?=\s)/i // Must follow listRE
      ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
      ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
      ,   textRE = /^[^#!\[\]*_\\<>` "'(~:]+/
      ,   fencedCodeRE = /^(~~~+|```+)[ \t]*([\w+#-]*)[^\n`]*$/
      ,   linkDefRE = /^\s*\[[^\]]+?\]:.*$/ // naive link-definition
      ,   punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/
      ,   expandedTab = "    "; // CommonMark specifies tab as 4 spaces

      function switchInline(stream, state, f) {
        state.f = state.inline = f;
        return f(stream, state);
      }

      function switchBlock(stream, state, f) {
        state.f = state.block = f;
        return f(stream, state);
      }

      function lineIsEmpty(line) {
        return !line || !/\S/.test(line.string)
      }

      // Blocks

      function blankLine(state) {
        // Reset linkTitle state
        state.linkTitle = false;
        state.linkHref = false;
        state.linkText = false;
        // Reset EM state
        state.em = false;
        // Reset STRONG state
        state.strong = false;
        // Reset strikethrough state
        state.strikethrough = false;
        // Reset state.quote
        state.quote = 0;
        // Reset state.indentedCode
        state.indentedCode = false;
        if (state.f == htmlBlock) {
          var exit = htmlModeMissing;
          if (!exit) {
            var inner = CodeMirror.innerMode(htmlMode, state.htmlState);
            exit = inner.mode.name == "xml" && inner.state.tagStart === null &&
              (!inner.state.context && inner.state.tokenize.isInText);
          }
          if (exit) {
            state.f = inlineNormal;
            state.block = blockNormal;
            state.htmlState = null;
          }
        }
        // Reset state.trailingSpace
        state.trailingSpace = 0;
        state.trailingSpaceNewLine = false;
        // Mark this line as blank
        state.prevLine = state.thisLine;
        state.thisLine = {stream: null};
        return null;
      }

      function blockNormal(stream, state) {
        var firstTokenOnLine = stream.column() === state.indentation;
        var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
        var prevLineIsIndentedCode = state.indentedCode;
        var prevLineIsHr = state.prevLine.hr;
        var prevLineIsList = state.list !== false;
        var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;

        state.indentedCode = false;

        var lineIndentation = state.indentation;
        // compute once per line (on first token)
        if (state.indentationDiff === null) {
          state.indentationDiff = state.indentation;
          if (prevLineIsList) {
            // Reset inline styles which shouldn't propagate aross list items
            state.em = false;
            state.strong = false;
            state.code = false;
            state.strikethrough = false;

            state.list = null;
            // While this list item's marker's indentation is less than the deepest
            //  list item's content's indentation,pop the deepest list item
            //  indentation off the stack, and update block indentation state
            while (lineIndentation < state.listStack[state.listStack.length - 1]) {
              state.listStack.pop();
              if (state.listStack.length) {
                state.indentation = state.listStack[state.listStack.length - 1];
              // less than the first list's indent -> the line is no longer a list
              } else {
                state.list = false;
              }
            }
            if (state.list !== false) {
              state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
            }
          }
        }

        // not comprehensive (currently only for setext detection purposes)
        var allowsInlineContinuation = (
            !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&
            (!prevLineIsList || !prevLineIsIndentedCode) &&
            !state.prevLine.fencedCodeEnd
        );

        var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&
          state.indentation <= maxNonCodeIndentation && stream.match(hrRE);

        var match = null;
        if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||
             state.prevLine.header || prevLineLineIsEmpty)) {
          stream.skipToEnd();
          state.indentedCode = true;
          return tokenTypes.code;
        } else if (stream.eatSpace()) {
          return null;
        } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
          state.quote = 0;
          state.header = match[1].length;
          state.thisLine.header = true;
          if (modeCfg.highlightFormatting) state.formatting = "header";
          state.f = state.inline;
          return getType(state);
        } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {
          state.quote = firstTokenOnLine ? 1 : state.quote + 1;
          if (modeCfg.highlightFormatting) state.formatting = "quote";
          stream.eatSpace();
          return getType(state);
        } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
          var listType = match[1] ? "ol" : "ul";

          state.indentation = lineIndentation + stream.current().length;
          state.list = true;
          state.quote = 0;

          // Add this list item's content's indentation to the stack
          state.listStack.push(state.indentation);

          if (modeCfg.taskLists && stream.match(taskListRE, false)) {
            state.taskList = true;
          }
          state.f = state.inline;
          if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
          return getType(state);
        } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
          state.quote = 0;
          state.fencedEndRE = new RegExp(match[1] + "+ *$");
          // try switching mode
          state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);
          if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
          state.f = state.block = local;
          if (modeCfg.highlightFormatting) state.formatting = "code-block";
          state.code = -1;
          return getType(state);
        // SETEXT has lowest block-scope precedence after HR, so check it after
        //  the others (code, blockquote, list...)
        } else if (
          // if setext set, indicates line after ---/===
          state.setext || (
            // line before ---/===
            (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&
            !state.code && !isHr && !linkDefRE.test(stream.string) &&
            (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
          )
        ) {
          if ( !state.setext ) {
            state.header = match[0].charAt(0) == '=' ? 1 : 2;
            state.setext = state.header;
          } else {
            state.header = state.setext;
            // has no effect on type so we can reset it now
            state.setext = 0;
            stream.skipToEnd();
            if (modeCfg.highlightFormatting) state.formatting = "header";
          }
          state.thisLine.header = true;
          state.f = state.inline;
          return getType(state);
        } else if (isHr) {
          stream.skipToEnd();
          state.hr = true;
          state.thisLine.hr = true;
          return tokenTypes.hr;
        } else if (stream.peek() === '[') {
          return switchInline(stream, state, footnoteLink);
        }

        return switchInline(stream, state, state.inline);
      }

      function htmlBlock(stream, state) {
        var style = htmlMode.token(stream, state.htmlState);
        if (!htmlModeMissing) {
          var inner = CodeMirror.innerMode(htmlMode, state.htmlState);
          if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
               (!inner.state.context && inner.state.tokenize.isInText)) ||
              (state.md_inside && stream.current().indexOf(">") > -1)) {
            state.f = inlineNormal;
            state.block = blockNormal;
            state.htmlState = null;
          }
        }
        return style;
      }

      function local(stream, state) {
        var currListInd = state.listStack[state.listStack.length - 1] || 0;
        var hasExitedList = state.indentation < currListInd;
        var maxFencedEndInd = currListInd + 3;
        if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
          if (modeCfg.highlightFormatting) state.formatting = "code-block";
          var returnType;
          if (!hasExitedList) returnType = getType(state);
          state.localMode = state.localState = null;
          state.block = blockNormal;
          state.f = inlineNormal;
          state.fencedEndRE = null;
          state.code = 0;
          state.thisLine.fencedCodeEnd = true;
          if (hasExitedList) return switchBlock(stream, state, state.block);
          return returnType;
        } else if (state.localMode) {
          return state.localMode.token(stream, state.localState);
        } else {
          stream.skipToEnd();
          return tokenTypes.code;
        }
      }

      // Inline
      function getType(state) {
        var styles = [];

        if (state.formatting) {
          styles.push(tokenTypes.formatting);

          if (typeof state.formatting === "string") state.formatting = [state.formatting];

          for (var i = 0; i < state.formatting.length; i++) {
            styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

            if (state.formatting[i] === "header") {
              styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
            }

            // Add `formatting-quote` and `formatting-quote-#` for blockquotes
            // Add `error` instead if the maximum blockquote nesting depth is passed
            if (state.formatting[i] === "quote") {
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
              } else {
                styles.push("error");
              }
            }
          }
        }

        if (state.taskOpen) {
          styles.push("meta");
          return styles.length ? styles.join(' ') : null;
        }
        if (state.taskClosed) {
          styles.push("property");
          return styles.length ? styles.join(' ') : null;
        }

        if (state.linkHref) {
          styles.push(tokenTypes.linkHref, "url");
        } else { // Only apply inline styles to non-url text
          if (state.strong) { styles.push(tokenTypes.strong); }
          if (state.em) { styles.push(tokenTypes.em); }
          if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
          if (state.emoji) { styles.push(tokenTypes.emoji); }
          if (state.linkText) { styles.push(tokenTypes.linkText); }
          if (state.code) { styles.push(tokenTypes.code); }
          if (state.image) { styles.push(tokenTypes.image); }
          if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
          if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
        }

        if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }

        if (state.quote) {
          styles.push(tokenTypes.quote);

          // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
            styles.push(tokenTypes.quote + "-" + state.quote);
          } else {
            styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
          }
        }

        if (state.list !== false) {
          var listMod = (state.listStack.length - 1) % 3;
          if (!listMod) {
            styles.push(tokenTypes.list1);
          } else if (listMod === 1) {
            styles.push(tokenTypes.list2);
          } else {
            styles.push(tokenTypes.list3);
          }
        }

        if (state.trailingSpaceNewLine) {
          styles.push("trailing-space-new-line");
        } else if (state.trailingSpace) {
          styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
        }

        return styles.length ? styles.join(' ') : null;
      }

      function handleText(stream, state) {
        if (stream.match(textRE, true)) {
          return getType(state);
        }
        return undefined;
      }

      function inlineNormal(stream, state) {
        var style = state.text(stream, state);
        if (typeof style !== 'undefined')
          return style;

        if (state.list) { // List marker (*, +, -, 1., etc)
          state.list = null;
          return getType(state);
        }

        if (state.taskList) {
          var taskOpen = stream.match(taskListRE, true)[1] === " ";
          if (taskOpen) state.taskOpen = true;
          else state.taskClosed = true;
          if (modeCfg.highlightFormatting) state.formatting = "task";
          state.taskList = false;
          return getType(state);
        }

        state.taskOpen = false;
        state.taskClosed = false;

        if (state.header && stream.match(/^#+$/, true)) {
          if (modeCfg.highlightFormatting) state.formatting = "header";
          return getType(state);
        }

        var ch = stream.next();

        // Matches link titles present on next line
        if (state.linkTitle) {
          state.linkTitle = false;
          var matchCh = ch;
          if (ch === '(') {
            matchCh = ')';
          }
          matchCh = (matchCh+'').replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
          var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
          if (stream.match(new RegExp(regex), true)) {
            return tokenTypes.linkHref;
          }
        }

        // If this block is changed, it may need to be updated in GFM mode
        if (ch === '`') {
          var previousFormatting = state.formatting;
          if (modeCfg.highlightFormatting) state.formatting = "code";
          stream.eatWhile('`');
          var count = stream.current().length;
          if (state.code == 0 && (!state.quote || count == 1)) {
            state.code = count;
            return getType(state)
          } else if (count == state.code) { // Must be exact
            var t = getType(state);
            state.code = 0;
            return t
          } else {
            state.formatting = previousFormatting;
            return getType(state)
          }
        } else if (state.code) {
          return getType(state);
        }

        if (ch === '\\') {
          stream.next();
          if (modeCfg.highlightFormatting) {
            var type = getType(state);
            var formattingEscape = tokenTypes.formatting + "-escape";
            return type ? type + " " + formattingEscape : formattingEscape;
          }
        }

        if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
          state.imageMarker = true;
          state.image = true;
          if (modeCfg.highlightFormatting) state.formatting = "image";
          return getType(state);
        }

        if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
          state.imageMarker = false;
          state.imageAltText = true;
          if (modeCfg.highlightFormatting) state.formatting = "image";
          return getType(state);
        }

        if (ch === ']' && state.imageAltText) {
          if (modeCfg.highlightFormatting) state.formatting = "image";
          var type = getType(state);
          state.imageAltText = false;
          state.image = false;
          state.inline = state.f = linkHref;
          return type;
        }

        if (ch === '[' && !state.image) {
          if (state.linkText && stream.match(/^.*?\]/)) return getType(state)
          state.linkText = true;
          if (modeCfg.highlightFormatting) state.formatting = "link";
          return getType(state);
        }

        if (ch === ']' && state.linkText) {
          if (modeCfg.highlightFormatting) state.formatting = "link";
          var type = getType(state);
          state.linkText = false;
          state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
          return type;
        }

        if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
          state.f = state.inline = linkInline;
          if (modeCfg.highlightFormatting) state.formatting = "link";
          var type = getType(state);
          if (type){
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }

        if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
          state.f = state.inline = linkInline;
          if (modeCfg.highlightFormatting) state.formatting = "link";
          var type = getType(state);
          if (type){
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkEmail;
        }

        if (modeCfg.xml && ch === '<' && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
          var end = stream.string.indexOf(">", stream.pos);
          if (end != -1) {
            var atts = stream.string.substring(stream.start, end);
            if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
          }
          stream.backUp(1);
          state.htmlState = CodeMirror.startState(htmlMode);
          return switchBlock(stream, state, htmlBlock);
        }

        if (modeCfg.xml && ch === '<' && stream.match(/^\/\w*?>/)) {
          state.md_inside = false;
          return "tag";
        } else if (ch === "*" || ch === "_") {
          var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
          while (len < 3 && stream.eat(ch)) len++;
          var after = stream.peek() || " ";
          // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis
          var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
          var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
          var setEm = null, setStrong = null;
          if (len % 2) { // Em
            if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setEm = true;
            else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setEm = false;
          }
          if (len > 1) { // Strong
            if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setStrong = true;
            else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setStrong = false;
          }
          if (setStrong != null || setEm != null) {
            if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
            if (setEm === true) state.em = ch;
            if (setStrong === true) state.strong = ch;
            var t = getType(state);
            if (setEm === false) state.em = false;
            if (setStrong === false) state.strong = false;
            return t
          }
        } else if (ch === ' ') {
          if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
            if (stream.peek() === ' ') { // Surrounded by spaces, ignore
              return getType(state);
            } else { // Not surrounded by spaces, back up pointer
              stream.backUp(1);
            }
          }
        }

        if (modeCfg.strikethrough) {
          if (ch === '~' && stream.eatWhile(ch)) {
            if (state.strikethrough) {// Remove strikethrough
              if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
              var t = getType(state);
              state.strikethrough = false;
              return t;
            } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
              state.strikethrough = true;
              if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
              return getType(state);
            }
          } else if (ch === ' ') {
            if (stream.match(/^~~/, true)) { // Probably surrounded by space
              if (stream.peek() === ' ') { // Surrounded by spaces, ignore
                return getType(state);
              } else { // Not surrounded by spaces, back up pointer
                stream.backUp(2);
              }
            }
          }
        }

        if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
          state.emoji = true;
          if (modeCfg.highlightFormatting) state.formatting = "emoji";
          var retType = getType(state);
          state.emoji = false;
          return retType;
        }

        if (ch === ' ') {
          if (stream.match(/^ +$/, false)) {
            state.trailingSpace++;
          } else if (state.trailingSpace) {
            state.trailingSpaceNewLine = true;
          }
        }

        return getType(state);
      }

      function linkInline(stream, state) {
        var ch = stream.next();

        if (ch === ">") {
          state.f = state.inline = inlineNormal;
          if (modeCfg.highlightFormatting) state.formatting = "link";
          var type = getType(state);
          if (type){
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }

        stream.match(/^[^>]+/, true);

        return tokenTypes.linkInline;
      }

      function linkHref(stream, state) {
        // Check if space, and return NULL if so (to avoid marking the space)
        if(stream.eatSpace()){
          return null;
        }
        var ch = stream.next();
        if (ch === '(' || ch === '[') {
          state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
          if (modeCfg.highlightFormatting) state.formatting = "link-string";
          state.linkHref = true;
          return getType(state);
        }
        return 'error';
      }

      var linkRE = {
        ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
        "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
      };

      function getLinkHrefInside(endChar) {
        return function(stream, state) {
          var ch = stream.next();

          if (ch === endChar) {
            state.f = state.inline = inlineNormal;
            if (modeCfg.highlightFormatting) state.formatting = "link-string";
            var returnState = getType(state);
            state.linkHref = false;
            return returnState;
          }

          stream.match(linkRE[endChar]);
          state.linkHref = true;
          return getType(state);
        };
      }

      function footnoteLink(stream, state) {
        if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
          state.f = footnoteLinkInside;
          stream.next(); // Consume [
          if (modeCfg.highlightFormatting) state.formatting = "link";
          state.linkText = true;
          return getType(state);
        }
        return switchInline(stream, state, inlineNormal);
      }

      function footnoteLinkInside(stream, state) {
        if (stream.match(/^\]:/, true)) {
          state.f = state.inline = footnoteUrl;
          if (modeCfg.highlightFormatting) state.formatting = "link";
          var returnType = getType(state);
          state.linkText = false;
          return returnType;
        }

        stream.match(/^([^\]\\]|\\.)+/, true);

        return tokenTypes.linkText;
      }

      function footnoteUrl(stream, state) {
        // Check if space, and return NULL if so (to avoid marking the space)
        if(stream.eatSpace()){
          return null;
        }
        // Match URL
        stream.match(/^[^\s]+/, true);
        // Check for link title
        if (stream.peek() === undefined) { // End of line, set flag to check next line
          state.linkTitle = true;
        } else { // More content on line, check if link title
          stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
        }
        state.f = state.inline = inlineNormal;
        return tokenTypes.linkHref + " url";
      }

      var mode = {
        startState: function() {
          return {
            f: blockNormal,

            prevLine: {stream: null},
            thisLine: {stream: null},

            block: blockNormal,
            htmlState: null,
            indentation: 0,

            inline: inlineNormal,
            text: handleText,

            formatting: false,
            linkText: false,
            linkHref: false,
            linkTitle: false,
            code: 0,
            em: false,
            strong: false,
            header: 0,
            setext: 0,
            hr: false,
            taskList: false,
            list: false,
            listStack: [],
            quote: 0,
            trailingSpace: 0,
            trailingSpaceNewLine: false,
            strikethrough: false,
            emoji: false,
            fencedEndRE: null
          };
        },

        copyState: function(s) {
          return {
            f: s.f,

            prevLine: s.prevLine,
            thisLine: s.thisLine,

            block: s.block,
            htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
            indentation: s.indentation,

            localMode: s.localMode,
            localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

            inline: s.inline,
            text: s.text,
            formatting: false,
            linkText: s.linkText,
            linkTitle: s.linkTitle,
            linkHref: s.linkHref,
            code: s.code,
            em: s.em,
            strong: s.strong,
            strikethrough: s.strikethrough,
            emoji: s.emoji,
            header: s.header,
            setext: s.setext,
            hr: s.hr,
            taskList: s.taskList,
            list: s.list,
            listStack: s.listStack.slice(0),
            quote: s.quote,
            indentedCode: s.indentedCode,
            trailingSpace: s.trailingSpace,
            trailingSpaceNewLine: s.trailingSpaceNewLine,
            md_inside: s.md_inside,
            fencedEndRE: s.fencedEndRE
          };
        },

        token: function(stream, state) {

          // Reset state.formatting
          state.formatting = false;

          if (stream != state.thisLine.stream) {
            state.header = 0;
            state.hr = false;

            if (stream.match(/^\s*$/, true)) {
              blankLine(state);
              return null;
            }

            state.prevLine = state.thisLine;
            state.thisLine = {stream: stream};

            // Reset state.taskList
            state.taskList = false;

            // Reset state.trailingSpace
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;

            if (!state.localState) {
              state.f = state.block;
              if (state.f != htmlBlock) {
                var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                state.indentation = indentation;
                state.indentationDiff = null;
                if (indentation > 0) return null;
              }
            }
          }
          return state.f(stream, state);
        },

        innerMode: function(state) {
          if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
          if (state.localState) return {state: state.localState, mode: state.localMode};
          return {state: state, mode: mode};
        },

        indent: function(state, textAfter, line) {
          if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)
          if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)
          return CodeMirror.Pass
        },

        blankLine: blankLine,

        getType: getType,

        blockCommentStart: "<!--",
        blockCommentEnd: "-->",
        closeBrackets: "()[]{}''\"\"``",
        fold: "markdown"
      };
      return mode;
    }, "xml");

    CodeMirror.defineMIME("text/markdown", "markdown");

    CodeMirror.defineMIME("text/x-markdown", "markdown");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Mathematica mode copyright (c) 2015 by Calin Barbat
    // Based on code by Patrick Scheibe (halirutan)
    // See: https://github.com/halirutan/Mathematica-Source-Highlighting/tree/master/src/lang-mma.js

    function Mathematica(CodeMirror) {
    CodeMirror.defineMode('mathematica', function(_config, _parserConfig) {

      // used pattern building blocks
      var Identifier = '[a-zA-Z\\$][a-zA-Z0-9\\$]*';
      var pBase      = "(?:\\d+)";
      var pFloat     = "(?:\\.\\d+|\\d+\\.\\d*|\\d+)";
      var pFloatBase = "(?:\\.\\w+|\\w+\\.\\w*|\\w+)";
      var pPrecision = "(?:`(?:`?"+pFloat+")?)";

      // regular expressions
      var reBaseForm        = new RegExp('(?:'+pBase+'(?:\\^\\^'+pFloatBase+pPrecision+'?(?:\\*\\^[+-]?\\d+)?))');
      var reFloatForm       = new RegExp('(?:' + pFloat + pPrecision + '?(?:\\*\\^[+-]?\\d+)?)');
      var reIdInContext     = new RegExp('(?:`?)(?:' + Identifier + ')(?:`(?:' + Identifier + '))*(?:`?)');

      function tokenBase(stream, state) {
        var ch;

        // get next character
        ch = stream.next();

        // string
        if (ch === '"') {
          state.tokenize = tokenString;
          return state.tokenize(stream, state);
        }

        // comment
        if (ch === '(') {
          if (stream.eat('*')) {
            state.commentLevel++;
            state.tokenize = tokenComment;
            return state.tokenize(stream, state);
          }
        }

        // go back one character
        stream.backUp(1);

        // look for numbers
        // Numbers in a baseform
        if (stream.match(reBaseForm, true, false)) {
          return 'number';
        }

        // Mathematica numbers. Floats (1.2, .2, 1.) can have optionally a precision (`float) or an accuracy definition
        // (``float). Note: while 1.2` is possible 1.2`` is not. At the end an exponent (float*^+12) can follow.
        if (stream.match(reFloatForm, true, false)) {
          return 'number';
        }

        /* In[23] and Out[34] */
        if (stream.match(/(?:In|Out)\[[0-9]*\]/, true, false)) {
          return 'atom';
        }

        // usage
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::usage)/, true, false)) {
          return 'meta';
        }

        // message
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::[a-zA-Z\$][a-zA-Z0-9\$]*):?/, true, false)) {
          return 'string-2';
        }

        // this makes a look-ahead match for something like variable:{_Integer}
        // the match is then forwarded to the mma-patterns tokenizer.
        if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*\s*:)(?:(?:[a-zA-Z\$][a-zA-Z0-9\$]*)|(?:[^:=>~@\^\&\*\)\[\]'\?,\|])).*/, true, false)) {
          return 'variable-2';
        }

        // catch variables which are used together with Blank (_), BlankSequence (__) or BlankNullSequence (___)
        // Cannot start with a number, but can have numbers at any other position. Examples
        // blub__Integer, a1_, b34_Integer32
        if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
          return 'variable-2';
        }
        if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+/, true, false)) {
          return 'variable-2';
        }
        if (stream.match(/_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
          return 'variable-2';
        }

        // Named characters in Mathematica, like \[Gamma].
        if (stream.match(/\\\[[a-zA-Z\$][a-zA-Z0-9\$]*\]/, true, false)) {
          return 'variable-3';
        }

        // Match all braces separately
        if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
          return 'bracket';
        }

        // Catch Slots (#, ##, #3, ##9 and the V10 named slots #name). I have never seen someone using more than one digit after #, so we match
        // only one.
        if (stream.match(/(?:#[a-zA-Z\$][a-zA-Z0-9\$]*|#+[0-9]?)/, true, false)) {
          return 'variable-2';
        }

        // Literals like variables, keywords, functions
        if (stream.match(reIdInContext, true, false)) {
          return 'keyword';
        }

        // operators. Note that operators like @@ or /; are matched separately for each symbol.
        if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%)/, true, false)) {
          return 'operator';
        }

        // everything else is an error
        stream.next(); // advance the stream.
        return 'error';
      }

      function tokenString(stream, state) {
        var next, end = false, escaped = false;
        while ((next = stream.next()) != null) {
          if (next === '"' && !escaped) {
            end = true;
            break;
          }
          escaped = !escaped && next === '\\';
        }
        if (end && !escaped) {
          state.tokenize = tokenBase;
        }
        return 'string';
      }
      function tokenComment(stream, state) {
        var prev, next;
        while(state.commentLevel > 0 && (next = stream.next()) != null) {
          if (prev === '(' && next === '*') state.commentLevel++;
          if (prev === '*' && next === ')') state.commentLevel--;
          prev = next;
        }
        if (state.commentLevel <= 0) {
          state.tokenize = tokenBase;
        }
        return 'comment';
      }

      return {
        startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        },
        blockCommentStart: "(*",
        blockCommentEnd: "*)"
      };
    });

    CodeMirror.defineMIME('text/x-mathematica', {
      name: 'mathematica'
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Mbox(CodeMirror) {
    var rfc2822 = [
      "From", "Sender", "Reply-To", "To", "Cc", "Bcc", "Message-ID",
      "In-Reply-To", "References", "Resent-From", "Resent-Sender", "Resent-To",
      "Resent-Cc", "Resent-Bcc", "Resent-Message-ID", "Return-Path", "Received"
    ];
    var rfc2822NoEmail = [
      "Date", "Subject", "Comments", "Keywords", "Resent-Date"
    ];

    CodeMirror.registerHelper("hintWords", "mbox", rfc2822.concat(rfc2822NoEmail));

    var whitespace = /^[ \t]/;
    var separator = /^From /; // See RFC 4155
    var rfc2822Header = new RegExp("^(" + rfc2822.join("|") + "): ");
    var rfc2822HeaderNoEmail = new RegExp("^(" + rfc2822NoEmail.join("|") + "): ");
    var header = /^[^:]+:/; // Optional fields defined in RFC 2822
    var email = /^[^ ]+@[^ ]+/;
    var untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;
    var bracketedEmail = /^<.*?>/;
    var untilBracketedEmail = /^.*?(?=<.*>)/;

    function styleForHeader(header) {
      if (header === "Subject") return "header";
      return "string";
    }

    function readToken(stream, state) {
      if (stream.sol()) {
        // From last line
        state.inSeparator = false;
        if (state.inHeader && stream.match(whitespace)) {
          // Header folding
          return null;
        } else {
          state.inHeader = false;
          state.header = null;
        }

        if (stream.match(separator)) {
          state.inHeaders = true;
          state.inSeparator = true;
          return "atom";
        }

        var match;
        var emailPermitted = false;
        if ((match = stream.match(rfc2822HeaderNoEmail)) ||
            (emailPermitted = true) && (match = stream.match(rfc2822Header))) {
          state.inHeaders = true;
          state.inHeader = true;
          state.emailPermitted = emailPermitted;
          state.header = match[1];
          return "atom";
        }

        // Use vim's heuristics: recognize custom headers only if the line is in a
        // block of legitimate headers.
        if (state.inHeaders && (match = stream.match(header))) {
          state.inHeader = true;
          state.emailPermitted = true;
          state.header = match[1];
          return "atom";
        }

        state.inHeaders = false;
        stream.skipToEnd();
        return null;
      }

      if (state.inSeparator) {
        if (stream.match(email)) return "link";
        if (stream.match(untilEmail)) return "atom";
        stream.skipToEnd();
        return "atom";
      }

      if (state.inHeader) {
        var style = styleForHeader(state.header);

        if (state.emailPermitted) {
          if (stream.match(bracketedEmail)) return style + " link";
          if (stream.match(untilBracketedEmail)) return style;
        }
        stream.skipToEnd();
        return style;
      }

      stream.skipToEnd();
      return null;
    }
    CodeMirror.defineMode("mbox", function() {
      return {
        startState: function() {
          return {
            // Is in a mbox separator
            inSeparator: false,
            // Is in a mail header
            inHeader: false,
            // If bracketed email is permitted. Only applicable when inHeader
            emailPermitted: false,
            // Name of current header
            header: null,
            // Is in a region of mail headers
            inHeaders: false
          };
        },
        token: readToken,
        blankLine: function(state) {
          state.inHeaders = state.inSeparator = state.inHeader = false;
        }
      };
    });

    CodeMirror.defineMIME("application/mbox", "mbox");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    //mIRC mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

    function Mirc(CodeMirror) {
    CodeMirror.defineMIME("text/mirc", "mirc");
    CodeMirror.defineMode("mirc", function() {
      function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var specials = parseWords("$! $$ $& $? $+ $abook $abs $active $activecid " +
                                "$activewid $address $addtok $agent $agentname $agentstat $agentver " +
                                "$alias $and $anick $ansi2mirc $aop $appactive $appstate $asc $asctime " +
                                "$asin $atan $avoice $away $awaymsg $awaytime $banmask $base $bfind " +
                                "$binoff $biton $bnick $bvar $bytes $calc $cb $cd $ceil $chan $chanmodes " +
                                "$chantypes $chat $chr $cid $clevel $click $cmdbox $cmdline $cnick $color " +
                                "$com $comcall $comchan $comerr $compact $compress $comval $cos $count " +
                                "$cr $crc $creq $crlf $ctime $ctimer $ctrlenter $date $day $daylight " +
                                "$dbuh $dbuw $dccignore $dccport $dde $ddename $debug $decode $decompress " +
                                "$deltok $devent $dialog $did $didreg $didtok $didwm $disk $dlevel $dll " +
                                "$dllcall $dname $dns $duration $ebeeps $editbox $emailaddr $encode $error " +
                                "$eval $event $exist $feof $ferr $fgetc $file $filename $filtered $finddir " +
                                "$finddirn $findfile $findfilen $findtok $fline $floor $fopen $fread $fserve " +
                                "$fulladdress $fulldate $fullname $fullscreen $get $getdir $getdot $gettok $gmt " +
                                "$group $halted $hash $height $hfind $hget $highlight $hnick $hotline " +
                                "$hotlinepos $ial $ialchan $ibl $idle $iel $ifmatch $ignore $iif $iil " +
                                "$inelipse $ini $inmidi $inpaste $inpoly $input $inrect $inroundrect " +
                                "$insong $instok $int $inwave $ip $isalias $isbit $isdde $isdir $isfile " +
                                "$isid $islower $istok $isupper $keychar $keyrpt $keyval $knick $lactive " +
                                "$lactivecid $lactivewid $left $len $level $lf $line $lines $link $lock " +
                                "$lock $locked $log $logstamp $logstampfmt $longfn $longip $lower $ltimer " +
                                "$maddress $mask $matchkey $matchtok $md5 $me $menu $menubar $menucontext " +
                                "$menutype $mid $middir $mircdir $mircexe $mircini $mklogfn $mnick $mode " +
                                "$modefirst $modelast $modespl $mouse $msfile $network $newnick $nick $nofile " +
                                "$nopath $noqt $not $notags $notify $null $numeric $numok $oline $onpoly " +
                                "$opnick $or $ord $os $passivedcc $pic $play $pnick $port $portable $portfree " +
                                "$pos $prefix $prop $protect $puttok $qt $query $rand $r $rawmsg $read $readomo " +
                                "$readn $regex $regml $regsub $regsubex $remove $remtok $replace $replacex " +
                                "$reptok $result $rgb $right $round $scid $scon $script $scriptdir $scriptline " +
                                "$sdir $send $server $serverip $sfile $sha1 $shortfn $show $signal $sin " +
                                "$site $sline $snick $snicks $snotify $sock $sockbr $sockerr $sockname " +
                                "$sorttok $sound $sqrt $ssl $sreq $sslready $status $strip $str $stripped " +
                                "$syle $submenu $switchbar $tan $target $ticks $time $timer $timestamp " +
                                "$timestampfmt $timezone $tip $titlebar $toolbar $treebar $trust $ulevel " +
                                "$ulist $upper $uptime $url $usermode $v1 $v2 $var $vcmd $vcmdstat $vcmdver " +
                                "$version $vnick $vol $wid $width $wildsite $wildtok $window $wrap $xor");
      var keywords = parseWords("abook ajinvite alias aline ame amsg anick aop auser autojoin avoice " +
                                "away background ban bcopy beep bread break breplace bset btrunc bunset bwrite " +
                                "channel clear clearall cline clipboard close cnick color comclose comopen " +
                                "comreg continue copy creq ctcpreply ctcps dcc dccserver dde ddeserver " +
                                "debug dec describe dialog did didtok disable disconnect dlevel dline dll " +
                                "dns dqwindow drawcopy drawdot drawfill drawline drawpic drawrect drawreplace " +
                                "drawrot drawsave drawscroll drawtext ebeeps echo editbox emailaddr enable " +
                                "events exit fclose filter findtext finger firewall flash flist flood flush " +
                                "flushini font fopen fseek fsend fserve fullname fwrite ghide gload gmove " +
                                "gopts goto gplay gpoint gqreq groups gshow gsize gstop gtalk gunload hadd " +
                                "halt haltdef hdec hdel help hfree hinc hload hmake hop hsave ial ialclear " +
                                "ialmark identd if ignore iline inc invite iuser join kick linesep links list " +
                                "load loadbuf localinfo log mdi me menubar mkdir mnick mode msg nick noop notice " +
                                "notify omsg onotice part partall pdcc perform play playctrl pop protect pvoice " +
                                "qme qmsg query queryn quit raw reload remini remote remove rename renwin " +
                                "reseterror resetidle return rlevel rline rmdir run ruser save savebuf saveini " +
                                "say scid scon server set showmirc signam sline sockaccept sockclose socklist " +
                                "socklisten sockmark sockopen sockpause sockread sockrename sockudp sockwrite " +
                                "sound speak splay sreq strip switchbar timer timestamp titlebar tnick tokenize " +
                                "toolbar topic tray treebar ulist unload unset unsetall updatenl url uwho " +
                                "var vcadd vcmd vcrem vol while whois window winhelp write writeint if isalnum " +
                                "isalpha isaop isavoice isban ischan ishop isignore isin isincs isletter islower " +
                                "isnotify isnum ison isop isprotect isreg isupper isvoice iswm iswmcs " +
                                "elseif else goto menu nicklist status title icon size option text edit " +
                                "button check radio box scroll list combo link tab item");
      var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
      var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }
      function tokenBase(stream, state) {
        var beforeParams = state.beforeParams;
        state.beforeParams = false;
        var ch = stream.next();
        if (/[\[\]{}\(\),\.]/.test(ch)) {
          if (ch == "(" && beforeParams) state.inParams = true;
          else if (ch == ")") state.inParams = false;
          return null;
        }
        else if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        else if (ch == "\\") {
          stream.eat("\\");
          stream.eat(/./);
          return "number";
        }
        else if (ch == "/" && stream.eat("*")) {
          return chain(stream, state, tokenComment);
        }
        else if (ch == ";" && stream.match(/ *\( *\(/)) {
          return chain(stream, state, tokenUnparsed);
        }
        else if (ch == ";" && !state.inParams) {
          stream.skipToEnd();
          return "comment";
        }
        else if (ch == '"') {
          stream.eat(/"/);
          return "keyword";
        }
        else if (ch == "$") {
          stream.eatWhile(/[$_a-z0-9A-Z\.:]/);
          if (specials && specials.propertyIsEnumerable(stream.current().toLowerCase())) {
            return "keyword";
          }
          else {
            state.beforeParams = true;
            return "builtin";
          }
        }
        else if (ch == "%") {
          stream.eatWhile(/[^,\s()]/);
          state.beforeParams = true;
          return "string";
        }
        else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        else {
          stream.eatWhile(/[\w\$_{}]/);
          var word = stream.current().toLowerCase();
          if (keywords && keywords.propertyIsEnumerable(word))
            return "keyword";
          if (functions && functions.propertyIsEnumerable(word)) {
            state.beforeParams = true;
            return "keyword";
          }
          return null;
        }
      }
      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }
      function tokenUnparsed(stream, state) {
        var maybeEnd = 0, ch;
        while (ch = stream.next()) {
          if (ch == ";" && maybeEnd == 2) {
            state.tokenize = tokenBase;
            break;
          }
          if (ch == ")")
            maybeEnd++;
          else if (ch != " ")
            maybeEnd = 0;
        }
        return "meta";
      }
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            beforeParams: false,
            inParams: false
          };
        },
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        }
      };
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Mllike(CodeMirror) {
    CodeMirror.defineMode('mllike', function(_config, parserConfig) {
      var words = {
        'as': 'keyword',
        'do': 'keyword',
        'else': 'keyword',
        'end': 'keyword',
        'exception': 'keyword',
        'fun': 'keyword',
        'functor': 'keyword',
        'if': 'keyword',
        'in': 'keyword',
        'include': 'keyword',
        'let': 'keyword',
        'of': 'keyword',
        'open': 'keyword',
        'rec': 'keyword',
        'struct': 'keyword',
        'then': 'keyword',
        'type': 'keyword',
        'val': 'keyword',
        'while': 'keyword',
        'with': 'keyword'
      };

      var extraWords = parserConfig.extraWords || {};
      for (var prop in extraWords) {
        if (extraWords.hasOwnProperty(prop)) {
          words[prop] = parserConfig.extraWords[prop];
        }
      }
      var hintWords = [];
      for (var k in words) { hintWords.push(k); }
      CodeMirror.registerHelper("hintWords", "mllike", hintWords);

      function tokenBase(stream, state) {
        var ch = stream.next();

        if (ch === '"') {
          state.tokenize = tokenString;
          return state.tokenize(stream, state);
        }
        if (ch === '{') {
          if (stream.eat('|')) {
            state.longString = true;
            state.tokenize = tokenLongString;
            return state.tokenize(stream, state);
          }
        }
        if (ch === '(') {
          if (stream.eat('*')) {
            state.commentLevel++;
            state.tokenize = tokenComment;
            return state.tokenize(stream, state);
          }
        }
        if (ch === '~' || ch === '?') {
          stream.eatWhile(/\w/);
          return 'variable-2';
        }
        if (ch === '`') {
          stream.eatWhile(/\w/);
          return 'quote';
        }
        if (ch === '/' && parserConfig.slashComments && stream.eat('/')) {
          stream.skipToEnd();
          return 'comment';
        }
        if (/\d/.test(ch)) {
          if (ch === '0' && stream.eat(/[bB]/)) {
            stream.eatWhile(/[01]/);
          } if (ch === '0' && stream.eat(/[xX]/)) {
            stream.eatWhile(/[0-9a-fA-F]/);
          } if (ch === '0' && stream.eat(/[oO]/)) {
            stream.eatWhile(/[0-7]/);
          } else {
            stream.eatWhile(/[\d_]/);
            if (stream.eat('.')) {
              stream.eatWhile(/[\d]/);
            }
            if (stream.eat(/[eE]/)) {
              stream.eatWhile(/[\d\-+]/);
            }
          }
          return 'number';
        }
        if ( /[+\-*&%=<>!?|@\.~:]/.test(ch)) {
          return 'operator';
        }
        if (/[\w\xa1-\uffff]/.test(ch)) {
          stream.eatWhile(/[\w\xa1-\uffff]/);
          var cur = stream.current();
          return words.hasOwnProperty(cur) ? words[cur] : 'variable';
        }
        return null
      }

      function tokenString(stream, state) {
        var next, end = false, escaped = false;
        while ((next = stream.next()) != null) {
          if (next === '"' && !escaped) {
            end = true;
            break;
          }
          escaped = !escaped && next === '\\';
        }
        if (end && !escaped) {
          state.tokenize = tokenBase;
        }
        return 'string';
      }
      function tokenComment(stream, state) {
        var prev, next;
        while(state.commentLevel > 0 && (next = stream.next()) != null) {
          if (prev === '(' && next === '*') state.commentLevel++;
          if (prev === '*' && next === ')') state.commentLevel--;
          prev = next;
        }
        if (state.commentLevel <= 0) {
          state.tokenize = tokenBase;
        }
        return 'comment';
      }

      function tokenLongString(stream, state) {
        var prev, next;
        while (state.longString && (next = stream.next()) != null) {
          if (prev === '|' && next === '}') state.longString = false;
          prev = next;
        }
        if (!state.longString) {
          state.tokenize = tokenBase;
        }
        return 'string';
      }

      return {
        startState: function() {return {tokenize: tokenBase, commentLevel: 0, longString: false};},
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        },

        blockCommentStart: "(*",
        blockCommentEnd: "*)",
        lineComment: parserConfig.slashComments ? "//" : null
      };
    });

    CodeMirror.defineMIME('text/x-ocaml', {
      name: 'mllike',
      extraWords: {
        'and': 'keyword',
        'assert': 'keyword',
        'begin': 'keyword',
        'class': 'keyword',
        'constraint': 'keyword',
        'done': 'keyword',
        'downto': 'keyword',
        'external': 'keyword',
        'function': 'keyword',
        'initializer': 'keyword',
        'lazy': 'keyword',
        'match': 'keyword',
        'method': 'keyword',
        'module': 'keyword',
        'mutable': 'keyword',
        'new': 'keyword',
        'nonrec': 'keyword',
        'object': 'keyword',
        'private': 'keyword',
        'sig': 'keyword',
        'to': 'keyword',
        'try': 'keyword',
        'value': 'keyword',
        'virtual': 'keyword',
        'when': 'keyword',

        // builtins
        'raise': 'builtin',
        'failwith': 'builtin',
        'true': 'builtin',
        'false': 'builtin',

        // Pervasives builtins
        'asr': 'builtin',
        'land': 'builtin',
        'lor': 'builtin',
        'lsl': 'builtin',
        'lsr': 'builtin',
        'lxor': 'builtin',
        'mod': 'builtin',
        'or': 'builtin',

        // More Pervasives
        'raise_notrace': 'builtin',
        'trace': 'builtin',
        'exit': 'builtin',
        'print_string': 'builtin',
        'print_endline': 'builtin',

         'int': 'type',
         'float': 'type',
         'bool': 'type',
         'char': 'type',
         'string': 'type',
         'unit': 'type',

         // Modules
         'List': 'builtin'
      }
    });

    CodeMirror.defineMIME('text/x-fsharp', {
      name: 'mllike',
      extraWords: {
        'abstract': 'keyword',
        'assert': 'keyword',
        'base': 'keyword',
        'begin': 'keyword',
        'class': 'keyword',
        'default': 'keyword',
        'delegate': 'keyword',
        'do!': 'keyword',
        'done': 'keyword',
        'downcast': 'keyword',
        'downto': 'keyword',
        'elif': 'keyword',
        'extern': 'keyword',
        'finally': 'keyword',
        'for': 'keyword',
        'function': 'keyword',
        'global': 'keyword',
        'inherit': 'keyword',
        'inline': 'keyword',
        'interface': 'keyword',
        'internal': 'keyword',
        'lazy': 'keyword',
        'let!': 'keyword',
        'match': 'keyword',
        'member': 'keyword',
        'module': 'keyword',
        'mutable': 'keyword',
        'namespace': 'keyword',
        'new': 'keyword',
        'null': 'keyword',
        'override': 'keyword',
        'private': 'keyword',
        'public': 'keyword',
        'return!': 'keyword',
        'return': 'keyword',
        'select': 'keyword',
        'static': 'keyword',
        'to': 'keyword',
        'try': 'keyword',
        'upcast': 'keyword',
        'use!': 'keyword',
        'use': 'keyword',
        'void': 'keyword',
        'when': 'keyword',
        'yield!': 'keyword',
        'yield': 'keyword',

        // Reserved words
        'atomic': 'keyword',
        'break': 'keyword',
        'checked': 'keyword',
        'component': 'keyword',
        'const': 'keyword',
        'constraint': 'keyword',
        'constructor': 'keyword',
        'continue': 'keyword',
        'eager': 'keyword',
        'event': 'keyword',
        'external': 'keyword',
        'fixed': 'keyword',
        'method': 'keyword',
        'mixin': 'keyword',
        'object': 'keyword',
        'parallel': 'keyword',
        'process': 'keyword',
        'protected': 'keyword',
        'pure': 'keyword',
        'sealed': 'keyword',
        'tailcall': 'keyword',
        'trait': 'keyword',
        'virtual': 'keyword',
        'volatile': 'keyword',

        // builtins
        'List': 'builtin',
        'Seq': 'builtin',
        'Map': 'builtin',
        'Set': 'builtin',
        'Option': 'builtin',
        'int': 'builtin',
        'string': 'builtin',
        'not': 'builtin',
        'true': 'builtin',
        'false': 'builtin',

        'raise': 'builtin',
        'failwith': 'builtin'
      },
      slashComments: true
    });


    CodeMirror.defineMIME('text/x-sml', {
      name: 'mllike',
      extraWords: {
        'abstype': 'keyword',
        'and': 'keyword',
        'andalso': 'keyword',
        'case': 'keyword',
        'datatype': 'keyword',
        'fn': 'keyword',
        'handle': 'keyword',
        'infix': 'keyword',
        'infixr': 'keyword',
        'local': 'keyword',
        'nonfix': 'keyword',
        'op': 'keyword',
        'orelse': 'keyword',
        'raise': 'keyword',
        'withtype': 'keyword',
        'eqtype': 'keyword',
        'sharing': 'keyword',
        'sig': 'keyword',
        'signature': 'keyword',
        'structure': 'keyword',
        'where': 'keyword',
        'true': 'keyword',
        'false': 'keyword',

        // types
        'int': 'builtin',
        'real': 'builtin',
        'string': 'builtin',
        'char': 'builtin',
        'bool': 'builtin'
      },
      slashComments: true
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Modelica support for CodeMirror, copyright (c) by Lennart Ochel

    function Modelica(CodeMirror) {
      CodeMirror.defineMode("modelica", function(config, parserConfig) {

        var indentUnit = config.indentUnit;
        var keywords = parserConfig.keywords || {};
        var builtin = parserConfig.builtin || {};
        var atoms = parserConfig.atoms || {};

        var isSingleOperatorChar = /[;=\(:\),{}.*<>+\-\/^\[\]]/;
        var isDoubleOperatorChar = /(:=|<=|>=|==|<>|\.\+|\.\-|\.\*|\.\/|\.\^)/;
        var isDigit = /[0-9]/;
        var isNonDigit = /[_a-zA-Z]/;

        function tokenLineComment(stream, state) {
          stream.skipToEnd();
          state.tokenize = null;
          return "comment";
        }

        function tokenBlockComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }

        function tokenString(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == '"' && !escaped) {
              state.tokenize = null;
              state.sol = false;
              break;
            }
            escaped = !escaped && ch == "\\";
          }

          return "string";
        }

        function tokenIdent(stream, state) {
          stream.eatWhile(isDigit);
          while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }


          var cur = stream.current();

          if(state.sol && (cur == "package" || cur == "model" || cur == "when" || cur == "connector")) state.level++;
          else if(state.sol && cur == "end" && state.level > 0) state.level--;

          state.tokenize = null;
          state.sol = false;

          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          else if (builtin.propertyIsEnumerable(cur)) return "builtin";
          else if (atoms.propertyIsEnumerable(cur)) return "atom";
          else return "variable";
        }

        function tokenQIdent(stream, state) {
          while (stream.eat(/[^']/)) { }

          state.tokenize = null;
          state.sol = false;

          if(stream.eat("'"))
            return "variable";
          else
            return "error";
        }

        function tokenUnsignedNuber(stream, state) {
          stream.eatWhile(isDigit);
          if (stream.eat('.')) {
            stream.eatWhile(isDigit);
          }
          if (stream.eat('e') || stream.eat('E')) {
            if (!stream.eat('-'))
              stream.eat('+');
            stream.eatWhile(isDigit);
          }

          state.tokenize = null;
          state.sol = false;
          return "number";
        }

        // Interface
        return {
          startState: function() {
            return {
              tokenize: null,
              level: 0,
              sol: true
            };
          },

          token: function(stream, state) {
            if(state.tokenize != null) {
              return state.tokenize(stream, state);
            }

            if(stream.sol()) {
              state.sol = true;
            }

            // WHITESPACE
            if(stream.eatSpace()) {
              state.tokenize = null;
              return null;
            }

            var ch = stream.next();

            // LINECOMMENT
            if(ch == '/' && stream.eat('/')) {
              state.tokenize = tokenLineComment;
            }
            // BLOCKCOMMENT
            else if(ch == '/' && stream.eat('*')) {
              state.tokenize = tokenBlockComment;
            }
            // TWO SYMBOL TOKENS
            else if(isDoubleOperatorChar.test(ch+stream.peek())) {
              stream.next();
              state.tokenize = null;
              return "operator";
            }
            // SINGLE SYMBOL TOKENS
            else if(isSingleOperatorChar.test(ch)) {
              state.tokenize = null;
              return "operator";
            }
            // IDENT
            else if(isNonDigit.test(ch)) {
              state.tokenize = tokenIdent;
            }
            // Q-IDENT
            else if(ch == "'" && stream.peek() && stream.peek() != "'") {
              state.tokenize = tokenQIdent;
            }
            // STRING
            else if(ch == '"') {
              state.tokenize = tokenString;
            }
            // UNSIGNED_NUBER
            else if(isDigit.test(ch)) {
              state.tokenize = tokenUnsignedNuber;
            }
            // ERROR
            else {
              state.tokenize = null;
              return "error";
            }

            return state.tokenize(stream, state);
          },

          indent: function(state, textAfter) {
            if (state.tokenize != null) return CodeMirror.Pass;

            var level = state.level;
            if(/(algorithm)/.test(textAfter)) level--;
            if(/(equation)/.test(textAfter)) level--;
            if(/(initial algorithm)/.test(textAfter)) level--;
            if(/(initial equation)/.test(textAfter)) level--;
            if(/(end)/.test(textAfter)) level--;

            if(level > 0)
              return indentUnit*level;
            else
              return 0;
          },

          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i=0; i<words.length; ++i)
          obj[words[i]] = true;
        return obj;
      }

      var modelicaKeywords = "algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within";
      var modelicaBuiltin = "abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh";
      var modelicaAtoms = "Real Boolean Integer String";

      function def(mimes, mode) {
        if (typeof mimes == "string")
          mimes = [mimes];

        var words = [];

        function add(obj) {
          if (obj)
            for (var prop in obj)
              if (obj.hasOwnProperty(prop))
                words.push(prop);
        }

        add(mode.keywords);
        add(mode.builtin);
        add(mode.atoms);

        if (words.length) {
          mode.helperType = mimes[0];
          CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i=0; i<mimes.length; ++i)
          CodeMirror.defineMIME(mimes[i], mode);
      }

      def(["text/x-modelica"], {
        name: "modelica",
        keywords: words(modelicaKeywords),
        builtin: words(modelicaBuiltin),
        atoms: words(modelicaAtoms)
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // mode(s) for the sequence chart dsl's mscgen, xù and msgenny
    // For more information on mscgen, see the site of the original author:
    // http://www.mcternan.me.uk/mscgen
    //
    // This mode for mscgen and the two derivative languages were
    // originally made for use in the mscgen_js interpreter
    // (https://sverweij.github.io/mscgen_js)

    function MscGen(CodeMirror) {
      var languages = {
        mscgen: {
          "keywords" : ["msc"],
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs"],
          "constants" : ["true", "false", "on", "off"],
          "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],
          "brackets" : ["\\{", "\\}"], // [ and  ] are brackets too, but these get handled in with lists
          "arcsWords" : ["note", "abox", "rbox", "box"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        },
        xu: {
          "keywords" : ["msc", "xu"],
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
          "constants" : ["true", "false", "on", "off", "auto"],
          "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip", "title", "deactivate", "activate", "activation"],
          "brackets" : ["\\{", "\\}"],  // [ and  ] are brackets too, but these get handled in with lists
          "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        },
        msgenny: {
          "keywords" : null,
          "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
          "constants" : ["true", "false", "on", "off", "auto"],
          "attributes" : null,
          "brackets" : ["\\{", "\\}"],
          "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
          "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
          "singlecomment" : ["//", "#"],
          "operators" : ["="]
        }
      };

      CodeMirror.defineMode("mscgen", function(_, modeConfig) {
        var language = languages[modeConfig && modeConfig.language || "mscgen"];
        return {
          startState: startStateFn,
          copyState: copyStateFn,
          token: produceTokenFunction(language),
          lineComment : "#",
          blockCommentStart : "/*",
          blockCommentEnd : "*/"
        };
      });

      CodeMirror.defineMIME("text/x-mscgen", "mscgen");
      CodeMirror.defineMIME("text/x-xu", {name: "mscgen", language: "xu"});
      CodeMirror.defineMIME("text/x-msgenny", {name: "mscgen", language: "msgenny"});

      function wordRegexpBoundary(pWords) {
        return new RegExp("\\b(" + pWords.join("|") + ")\\b", "i");
      }

      function wordRegexp(pWords) {
        return new RegExp("(" + pWords.join("|") + ")", "i");
      }

      function startStateFn() {
        return {
          inComment : false,
          inString : false,
          inAttributeList : false,
          inScript : false
        };
      }

      function copyStateFn(pState) {
        return {
          inComment : pState.inComment,
          inString : pState.inString,
          inAttributeList : pState.inAttributeList,
          inScript : pState.inScript
        };
      }

      function produceTokenFunction(pConfig) {

        return function(pStream, pState) {
          if (pStream.match(wordRegexp(pConfig.brackets), true, true)) {
            return "bracket";
          }
          /* comments */
          if (!pState.inComment) {
            if (pStream.match(/\/\*[^\*\/]*/, true, true)) {
              pState.inComment = true;
              return "comment";
            }
            if (pStream.match(wordRegexp(pConfig.singlecomment), true, true)) {
              pStream.skipToEnd();
              return "comment";
            }
          }
          if (pState.inComment) {
            if (pStream.match(/[^\*\/]*\*\//, true, true))
              pState.inComment = false;
            else
              pStream.skipToEnd();
            return "comment";
          }
          /* strings */
          if (!pState.inString && pStream.match(/\"(\\\"|[^\"])*/, true, true)) {
            pState.inString = true;
            return "string";
          }
          if (pState.inString) {
            if (pStream.match(/[^\"]*\"/, true, true))
              pState.inString = false;
            else
              pStream.skipToEnd();
            return "string";
          }
          /* keywords & operators */
          if (!!pConfig.keywords && pStream.match(wordRegexpBoundary(pConfig.keywords), true, true))
            return "keyword";

          if (pStream.match(wordRegexpBoundary(pConfig.options), true, true))
            return "keyword";

          if (pStream.match(wordRegexpBoundary(pConfig.arcsWords), true, true))
            return "keyword";

          if (pStream.match(wordRegexp(pConfig.arcsOthers), true, true))
            return "keyword";

          if (!!pConfig.operators && pStream.match(wordRegexp(pConfig.operators), true, true))
            return "operator";

          if (!!pConfig.constants && pStream.match(wordRegexp(pConfig.constants), true, true))
            return "variable";

          /* attribute lists */
          if (!pConfig.inAttributeList && !!pConfig.attributes && pStream.match(/\[/, true, true)) {
            pConfig.inAttributeList = true;
            return "bracket";
          }
          if (pConfig.inAttributeList) {
            if (pConfig.attributes !== null && pStream.match(wordRegexpBoundary(pConfig.attributes), true, true)) {
              return "attribute";
            }
            if (pStream.match(/]/, true, true)) {
              pConfig.inAttributeList = false;
              return "bracket";
            }
          }

          pStream.next();
          return "base";
        };
      }

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
      This MUMPS Language script was constructed using vbscript.js as a template.
    */

    function Mumps(CodeMirror) {
      CodeMirror.defineMode("mumps", function() {
        function wordRegexp(words) {
          return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/&#!_?\\\\<>=\\'\\[\\]]");
        var doubleOperators = new RegExp("^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))");
        var singleDelimiters = new RegExp("^[\\.,:]");
        var brackets = new RegExp("[()]");
        var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
        var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
        // The following list includes instrinsic functions _and_ special variables
        var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
        var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
        var command = wordRegexp(commandKeywords);

        function tokenBase(stream, state) {
          if (stream.sol()) {
            state.label = true;
            state.commandMode = 0;
          }

          // The <space> character has meaning in MUMPS. Ignoring consecutive
          // spaces would interfere with interpreting whether the next non-space
          // character belongs to the command or argument context.

          // Examine each character and update a mode variable whose interpretation is:
          //   >0 => command    0 => argument    <0 => command post-conditional
          var ch = stream.peek();

          if (ch == " " || ch == "\t") { // Pre-process <space>
            state.label = false;
            if (state.commandMode == 0)
              state.commandMode = 1;
            else if ((state.commandMode < 0) || (state.commandMode == 2))
              state.commandMode = 0;
          } else if ((ch != ".") && (state.commandMode > 0)) {
            if (ch == ":")
              state.commandMode = -1;   // SIS - Command post-conditional
            else
              state.commandMode = 2;
          }

          // Do not color parameter list as line tag
          if ((ch === "(") || (ch === "\u0009"))
            state.label = false;

          // MUMPS comment starts with ";"
          if (ch === ";") {
            stream.skipToEnd();
            return "comment";
          }

          // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
          if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
            return "number";

          // Handle Strings
          if (ch == '"') {
            if (stream.skipTo('"')) {
              stream.next();
              return "string";
            } else {
              stream.skipToEnd();
              return "error";
            }
          }

          // Handle operators and Delimiters
          if (stream.match(doubleOperators) || stream.match(singleOperators))
            return "operator";

          // Prevents leading "." in DO block from falling through to error
          if (stream.match(singleDelimiters))
            return null;

          if (brackets.test(ch)) {
            stream.next();
            return "bracket";
          }

          if (state.commandMode > 0 && stream.match(command))
            return "variable-2";

          if (stream.match(intrinsicFuncs))
            return "builtin";

          if (stream.match(identifiers))
            return "variable";

          // Detect dollar-sign when not a documented intrinsic function
          // "^" may introduce a GVN or SSVN - Color same as function
          if (ch === "$" || ch === "^") {
            stream.next();
            return "builtin";
          }

          // MUMPS Indirection
          if (ch === "@") {
            stream.next();
            return "string-2";
          }

          if (/[\w%]/.test(ch)) {
            stream.eatWhile(/[\w%]/);
            return "variable";
          }

          // Handle non-detected items
          stream.next();
          return "error";
        }

        return {
          startState: function() {
            return {
              label: false,
              commandMode: 0
            };
          },

          token: function(stream, state) {
            var style = tokenBase(stream, state);
            if (state.label) return "tag";
            return style;
          }
        };
      });

      CodeMirror.defineMIME("text/x-mumps", "mumps");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Nginx(CodeMirror) {
    CodeMirror.defineMode("nginx", function(config) {

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var keywords = words(
        /* ngxDirectiveControl */ "break return rewrite set" +
        /* ngxDirective */ " accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23"
        );

      var keywords_block = words(
        /* ngxDirectiveBlock */ "http mail events server types location upstream charset_map limit_except if geo map"
        );

      var keywords_important = words(
        /* ngxDirectiveImportant */ "include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files"
        );

      var indentUnit = config.indentUnit, type;
      function ret(style, tp) {type = tp; return style;}

      function tokenBase(stream, state) {


        stream.eatWhile(/[\w\$_]/);

        var cur = stream.current();


        if (keywords.propertyIsEnumerable(cur)) {
          return "keyword";
        }
        else if (keywords_block.propertyIsEnumerable(cur)) {
          return "variable-2";
        }
        else if (keywords_important.propertyIsEnumerable(cur)) {
          return "string-2";
        }
        /**/

        var ch = stream.next();
        if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("meta", stream.current());}
        else if (ch == "/" && stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }
        else if (ch == "<" && stream.eat("!")) {
          state.tokenize = tokenSGMLComment;
          return tokenSGMLComment(stream, state);
        }
        else if (ch == "=") ret(null, "compare");
        else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        else if (ch == "#") {
          stream.skipToEnd();
          return ret("comment", "comment");
        }
        else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        }
        else if (/\d/.test(ch)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        }
        else if (/[,.+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        }
        else if (/[;{}:\[\]]/.test(ch)) {
          return ret(null, ch);
        }
        else {
          stream.eatWhile(/[\w\\\-]/);
          return ret("variable", "variable");
        }
      }

      function tokenCComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
      }

      function tokenSGMLComment(stream, state) {
        var dashes = 0, ch;
        while ((ch = stream.next()) != null) {
          if (dashes >= 2 && ch == ">") {
            state.tokenize = tokenBase;
            break;
          }
          dashes = (ch == "-") ? dashes + 1 : 0;
        }
        return ret("comment", "comment");
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped)
              break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      return {
        startState: function(base) {
          return {tokenize: tokenBase,
                  baseIndent: base || 0,
                  stack: []};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          type = null;
          var style = state.tokenize(stream, state);

          var context = state.stack[state.stack.length-1];
          if (type == "hash" && context == "rule") style = "atom";
          else if (style == "variable") {
            if (context == "rule") style = "number";
            else if (!context || context == "@media{") style = "tag";
          }

          if (context == "rule" && /^[\{\};]$/.test(type))
            state.stack.pop();
          if (type == "{") {
            if (context == "@media") state.stack[state.stack.length-1] = "@media{";
            else state.stack.push("{");
          }
          else if (type == "}") state.stack.pop();
          else if (type == "@media") state.stack.push("@media");
          else if (context == "{" && type != "comment") state.stack.push("rule");
          return style;
        },

        indent: function(state, textAfter) {
          var n = state.stack.length;
          if (/^\}/.test(textAfter))
            n -= state.stack[state.stack.length-1] == "rule" ? 2 : 1;
          return state.baseIndent + n * indentUnit;
        },

        electricChars: "}"
      };
    });

    CodeMirror.defineMIME("text/x-nginx-conf", "nginx");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Author: Jan T. Sott (http://github.com/idleberg)

    function Nsis(CodeMirror) {
    CodeMirror.defineSimpleMode("nsis",{
      start:[
        // Numbers
        {regex: /(?:[+-]?)(?:0x[\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\d+.?\d*)/, token: "number"},

        // Strings
        { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
        { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },
        { regex: /`(?:[^\\`]|\\.)*`?/, token: "string" },

        // Compile Time Commands
        {regex: /^\s*(?:\!(include|addincludedir|addplugindir|appendfile|cd|delfile|echo|error|execute|packhdr|pragma|finalize|getdllversion|gettlbversion|system|tempfile|warning|verbose|define|undef|insertmacro|macro|macroend|makensis|searchparse|searchreplace))\b/, token: "keyword"},

        // Conditional Compilation
        {regex: /^\s*(?:\!(if(?:n?def)?|ifmacron?def|macro))\b/, token: "keyword", indent: true},
        {regex: /^\s*(?:\!(else|endif|macroend))\b/, token: "keyword", dedent: true},

        // Runtime Commands
        {regex: /^\s*(?:Abort|AddBrandingImage|AddSize|AllowRootDirInstall|AllowSkipFiles|AutoCloseWindow|BGFont|BGGradient|BrandingText|BringToFront|Call|CallInstDLL|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|CreateDirectory|CreateFont|CreateShortCut|Delete|DeleteINISec|DeleteINIStr|DeleteRegKey|DeleteRegValue|DetailPrint|DetailsButtonText|DirText|DirVar|DirVerify|EnableWindow|EnumRegKey|EnumRegValue|Exch|Exec|ExecShell|ExecShellWait|ExecWait|ExpandEnvStrings|File|FileBufSize|FileClose|FileErrorText|FileOpen|FileRead|FileReadByte|FileReadUTF16LE|FileReadWord|FileWriteUTF16LE|FileSeek|FileWrite|FileWriteByte|FileWriteWord|FindClose|FindFirst|FindNext|FindWindow|FlushINI|GetCurInstType|GetCurrentAddress|GetDlgItem|GetDLLVersion|GetDLLVersionLocal|GetErrorLevel|GetFileTime|GetFileTimeLocal|GetFullPathName|GetFunctionAddress|GetInstDirError|GetLabelAddress|GetTempFileName|Goto|HideWindow|Icon|IfAbort|IfErrors|IfFileExists|IfRebootFlag|IfSilent|InitPluginsDir|InstallButtonText|InstallColors|InstallDir|InstallDirRegKey|InstProgressFlags|InstType|InstTypeGetText|InstTypeSetText|Int64Cmp|Int64CmpU|Int64Fmt|IntCmp|IntCmpU|IntFmt|IntOp|IntPtrCmp|IntPtrCmpU|IntPtrOp|IsWindow|LangString|LicenseBkColor|LicenseData|LicenseForceSelection|LicenseLangString|LicenseText|LoadLanguageFile|LockWindow|LogSet|LogText|ManifestDPIAware|ManifestSupportedOS|MessageBox|MiscButtonText|Name|Nop|OutFile|Page|PageCallbacks|PEDllCharacteristics|PESubsysVer|Pop|Push|Quit|ReadEnvStr|ReadINIStr|ReadRegDWORD|ReadRegStr|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|SectionGetFlags|SectionGetInstTypes|SectionGetSize|SectionGetText|SectionIn|SectionSetFlags|SectionSetInstTypes|SectionSetSize|SectionSetText|SendMessage|SetAutoClose|SetBrandingImage|SetCompress|SetCompressor|SetCompressorDictSize|SetCtlColors|SetCurInstType|SetDatablockOptimize|SetDateSave|SetDetailsPrint|SetDetailsView|SetErrorLevel|SetErrors|SetFileAttributes|SetFont|SetOutPath|SetOverwrite|SetRebootFlag|SetRegView|SetShellVarContext|SetSilent|ShowInstDetails|ShowUninstDetails|ShowWindow|SilentInstall|SilentUnInstall|Sleep|SpaceTexts|StrCmp|StrCmpS|StrCpy|StrLen|SubCaption|Unicode|UninstallButtonText|UninstallCaption|UninstallIcon|UninstallSubCaption|UninstallText|UninstPage|UnRegDLL|Var|VIAddVersionKey|VIFileVersion|VIProductVersion|WindowIcon|WriteINIStr|WriteRegBin|WriteRegDWORD|WriteRegExpandStr|WriteRegMultiStr|WriteRegNone|WriteRegStr|WriteUninstaller|XPStyle)\b/, token: "keyword"},
        {regex: /^\s*(?:Function|PageEx|Section(?:Group)?)\b/, token: "keyword", indent: true},
        {regex: /^\s*(?:(Function|PageEx|Section(?:Group)?)End)\b/, token: "keyword", dedent: true},

        // Command Options
        {regex: /\b(?:ARCHIVE|FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_OFFLINE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_TEMPORARY|HIDDEN|HKCC|HKCR(32|64)?|HKCU(32|64)?|HKDD|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_DYN_DATA|HKEY_LOCAL_MACHINE|HKEY_PERFORMANCE_DATA|HKEY_USERS|HKLM(32|64)?|HKPD|HKU|IDABORT|IDCANCEL|IDD_DIR|IDD_INST|IDD_INSTFILES|IDD_LICENSE|IDD_SELCOM|IDD_UNINST|IDD_VERIFY|IDIGNORE|IDNO|IDOK|IDRETRY|IDYES|MB_ABORTRETRYIGNORE|MB_DEFBUTTON1|MB_DEFBUTTON2|MB_DEFBUTTON3|MB_DEFBUTTON4|MB_ICONEXCLAMATION|MB_ICONINFORMATION|MB_ICONQUESTION|MB_ICONSTOP|MB_OK|MB_OKCANCEL|MB_RETRYCANCEL|MB_RIGHT|MB_RTLREADING|MB_SETFOREGROUND|MB_TOPMOST|MB_USERICON|MB_YESNO|MB_YESNOCANCEL|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SW_HIDE|SW_SHOWDEFAULT|SW_SHOWMAXIMIZED|SW_SHOWMINIMIZED|SW_SHOWNORMAL|SYSTEM|TEMPORARY)\b/, token: "atom"},
        {regex: /\b(?:admin|all|auto|both|bottom|bzip2|components|current|custom|directory|false|force|hide|highest|ifdiff|ifnewer|instfiles|lastused|leave|left|license|listonly|lzma|nevershow|none|normal|notset|off|on|right|show|silent|silentlog|textonly|top|true|try|un\.components|un\.custom|un\.directory|un\.instfiles|un\.license|uninstConfirm|user|Win10|Win7|Win8|WinVista|zlib)\b/, token: "builtin"},

        // LogicLib.nsh
        {regex: /\$\{(?:And(?:If(?:Not)?|Unless)|Break|Case(?:Else)?|Continue|Default|Do(?:Until|While)?|Else(?:If(?:Not)?|Unless)?|End(?:If|Select|Switch)|Exit(?:Do|For|While)|For(?:Each)?|If(?:Cmd|Not(?:Then)?|Then)?|Loop(?:Until|While)?|Or(?:If(?:Not)?|Unless)|Select|Switch|Unless|While)\}/, token: "variable-2", indent: true},

        // FileFunc.nsh
        {regex: /\$\{(?:BannerTrimPath|DirState|DriveSpace|Get(BaseName|Drives|ExeName|ExePath|FileAttributes|FileExt|FileName|FileVersion|Options|OptionsS|Parameters|Parent|Root|Size|Time)|Locate|RefreshShellIcons)\}/, token: "variable-2", dedent: true},

        // Memento.nsh
        {regex: /\$\{(?:Memento(?:Section(?:Done|End|Restore|Save)?|UnselectedSection))\}/, token: "variable-2", dedent: true},

        // TextFunc.nsh
        {regex: /\$\{(?:Config(?:Read|ReadS|Write|WriteS)|File(?:Join|ReadFromEnd|Recode)|Line(?:Find|Read|Sum)|Text(?:Compare|CompareS)|TrimNewLines)\}/, token: "variable-2", dedent: true},

        // WinVer.nsh
        {regex: /\$\{(?:(?:At(?:Least|Most)|Is)(?:ServicePack|Win(?:7|8|10|95|98|200(?:0|3|8(?:R2)?)|ME|NT4|Vista|XP))|Is(?:NT|Server))\}/, token: "variable", dedent: true},

        // WordFunc.nsh
        {regex: /\$\{(?:StrFilterS?|Version(?:Compare|Convert)|Word(?:AddS?|Find(?:(?:2|3)X)?S?|InsertS?|ReplaceS?))\}/, token: "variable-2", dedent: true},

        // x64.nsh
        {regex: /\$\{(?:RunningX64)\}/, token: "variable", dedent: true},
        {regex: /\$\{(?:Disable|Enable)X64FSRedirection\}/, token: "variable-2", dedent: true},

        // Line Comment
        {regex: /(#|;).*/, token: "comment"},

        // Block Comment
        {regex: /\/\*/, token: "comment", next: "comment"},

        // Operator
        {regex: /[-+\/*=<>!]+/, token: "operator"},

        // Variable
        {regex: /\$\w+/, token: "variable"},

        // Constant
        {regex: /\${[\w\.:-]+}/, token: "variable-2"},

        // Language String
        {regex: /\$\([\w\.:-]+\)/, token: "variable-3"}
      ],
      comment: [
        {regex: /.*?\*\//, token: "comment", next: "start"},
        {regex: /.*/, token: "comment"}
      ],
      meta: {
        electricInput: /^\s*((Function|PageEx|Section|Section(Group)?)End|(\!(endif|macroend))|\$\{(End(If|Unless|While)|Loop(Until)|Next)\})$/,
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: ["#", ";"]
      }
    });

    CodeMirror.defineMIME("text/x-nsis", "nsis");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**********************************************************
    * This script provides syntax highlighting support for
    * the N-Triples format.
    * N-Triples format specification:
    *     https://www.w3.org/TR/n-triples/
    ***********************************************************/

    /*
        The following expression defines the defined ASF grammar transitions.

        pre_subject ->
            {
            ( writing_subject_uri | writing_bnode_uri )
                -> pre_predicate
                    -> writing_predicate_uri
                        -> pre_object
                            -> writing_object_uri | writing_object_bnode |
                              (
                                writing_object_literal
                                    -> writing_literal_lang | writing_literal_type
                              )
                                -> post_object
                                    -> BEGIN
             } otherwise {
                 -> ERROR
             }
    */

    function Ntriples(CodeMirror) {
    CodeMirror.defineMode("ntriples", function() {

      var Location = {
        PRE_SUBJECT         : 0,
        WRITING_SUB_URI     : 1,
        WRITING_BNODE_URI   : 2,
        PRE_PRED            : 3,
        WRITING_PRED_URI    : 4,
        PRE_OBJ             : 5,
        WRITING_OBJ_URI     : 6,
        WRITING_OBJ_BNODE   : 7,
        WRITING_OBJ_LITERAL : 8,
        WRITING_LIT_LANG    : 9,
        WRITING_LIT_TYPE    : 10,
        POST_OBJ            : 11,
        ERROR               : 12
      };
      function transitState(currState, c) {
        var currLocation = currState.location;
        var ret;

        // Opening.
        if     (currLocation == Location.PRE_SUBJECT && c == '<') ret = Location.WRITING_SUB_URI;
        else if(currLocation == Location.PRE_SUBJECT && c == '_') ret = Location.WRITING_BNODE_URI;
        else if(currLocation == Location.PRE_PRED    && c == '<') ret = Location.WRITING_PRED_URI;
        else if(currLocation == Location.PRE_OBJ     && c == '<') ret = Location.WRITING_OBJ_URI;
        else if(currLocation == Location.PRE_OBJ     && c == '_') ret = Location.WRITING_OBJ_BNODE;
        else if(currLocation == Location.PRE_OBJ     && c == '"') ret = Location.WRITING_OBJ_LITERAL;

        // Closing.
        else if(currLocation == Location.WRITING_SUB_URI     && c == '>') ret = Location.PRE_PRED;
        else if(currLocation == Location.WRITING_BNODE_URI   && c == ' ') ret = Location.PRE_PRED;
        else if(currLocation == Location.WRITING_PRED_URI    && c == '>') ret = Location.PRE_OBJ;
        else if(currLocation == Location.WRITING_OBJ_URI     && c == '>') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_OBJ_BNODE   && c == ' ') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '"') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_LIT_LANG && c == ' ') ret = Location.POST_OBJ;
        else if(currLocation == Location.WRITING_LIT_TYPE && c == '>') ret = Location.POST_OBJ;

        // Closing typed and language literal.
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '@') ret = Location.WRITING_LIT_LANG;
        else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '^') ret = Location.WRITING_LIT_TYPE;

        // Spaces.
        else if( c == ' ' &&
                 (
                   currLocation == Location.PRE_SUBJECT ||
                   currLocation == Location.PRE_PRED    ||
                   currLocation == Location.PRE_OBJ     ||
                   currLocation == Location.POST_OBJ
                 )
               ) ret = currLocation;

        // Reset.
        else if(currLocation == Location.POST_OBJ && c == '.') ret = Location.PRE_SUBJECT;

        // Error
        else ret = Location.ERROR;

        currState.location=ret;
      }

      return {
        startState: function() {
           return {
               location : Location.PRE_SUBJECT,
               uris     : [],
               anchors  : [],
               bnodes   : [],
               langs    : [],
               types    : []
           };
        },
        token: function(stream, state) {
          var ch = stream.next();
          if(ch == '<') {
             transitState(state, ch);
             var parsedURI = '';
             stream.eatWhile( function(c) { if( c != '#' && c != '>' ) { parsedURI += c; return true; } return false;} );
             state.uris.push(parsedURI);
             if( stream.match('#', false) ) return 'variable';
             stream.next();
             transitState(state, '>');
             return 'variable';
          }
          if(ch == '#') {
            var parsedAnchor = '';
            stream.eatWhile(function(c) { if(c != '>' && c != ' ') { parsedAnchor+= c; return true; } return false;});
            state.anchors.push(parsedAnchor);
            return 'variable-2';
          }
          if(ch == '>') {
              transitState(state, '>');
              return 'variable';
          }
          if(ch == '_') {
              transitState(state, ch);
              var parsedBNode = '';
              stream.eatWhile(function(c) { if( c != ' ' ) { parsedBNode += c; return true; } return false;});
              state.bnodes.push(parsedBNode);
              stream.next();
              transitState(state, ' ');
              return 'builtin';
          }
          if(ch == '"') {
              transitState(state, ch);
              stream.eatWhile( function(c) { return c != '"'; } );
              stream.next();
              if( stream.peek() != '@' && stream.peek() != '^' ) {
                  transitState(state, '"');
              }
              return 'string';
          }
          if( ch == '@' ) {
              transitState(state, '@');
              var parsedLang = '';
              stream.eatWhile(function(c) { if( c != ' ' ) { parsedLang += c; return true; } return false;});
              state.langs.push(parsedLang);
              stream.next();
              transitState(state, ' ');
              return 'string-2';
          }
          if( ch == '^' ) {
              stream.next();
              transitState(state, '^');
              var parsedType = '';
              stream.eatWhile(function(c) { if( c != '>' ) { parsedType += c; return true; } return false;} );
              state.types.push(parsedType);
              stream.next();
              transitState(state, '>');
              return 'variable';
          }
          if( ch == ' ' ) {
              transitState(state, ch);
          }
          if( ch == '.' ) {
              transitState(state, ch);
          }
        }
      };
    });

    // define the registered Media Type for n-triples:
    // https://www.w3.org/TR/n-triples/#n-triples-mediatype
    CodeMirror.defineMIME("application/n-triples", "ntriples");

    // N-Quads is based on the N-Triples format (so same highlighting works)
    // https://www.w3.org/TR/n-quads/
    CodeMirror.defineMIME("application/n-quads", "ntriples");

    // previously used, though technically incorrect media type for n-triples
    CodeMirror.defineMIME("text/n-triples", "ntriples");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Octave(CodeMirror) {
    CodeMirror.defineMode("octave", function() {
      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var singleOperators = new RegExp("^[\\+\\-\\*/&|\\^~<>!@'\\\\]");
      var singleDelimiters = new RegExp('^[\\(\\[\\{\\},:=;]');
      var doubleOperators = new RegExp("^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\.[\\+\\-\\*/\\^\\\\]))");
      var doubleDelimiters = new RegExp("^((!=)|(\\+=)|(\\-=)|(\\*=)|(/=)|(&=)|(\\|=)|(\\^=))");
      var tripleDelimiters = new RegExp("^((>>=)|(<<=))");
      var expressionEnd = new RegExp("^[\\]\\)]");
      var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

      var builtins = wordRegexp([
        'error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos',
        'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh',
        'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones',
        'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov',
        'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot',
        'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str',
        'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember'
      ]);

      var keywords = wordRegexp([
        'return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction',
        'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events',
        'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until',
        'continue', 'pkg'
      ]);


      // tokenizers
      function tokenTranspose(stream, state) {
        if (!stream.sol() && stream.peek() === '\'') {
          stream.next();
          state.tokenize = tokenBase;
          return 'operator';
        }
        state.tokenize = tokenBase;
        return tokenBase(stream, state);
      }


      function tokenComment(stream, state) {
        if (stream.match(/^.*%}/)) {
          state.tokenize = tokenBase;
          return 'comment';
        }    stream.skipToEnd();
        return 'comment';
      }

      function tokenBase(stream, state) {
        // whitespaces
        if (stream.eatSpace()) return null;

        // Handle one line Comments
        if (stream.match('%{')){
          state.tokenize = tokenComment;
          stream.skipToEnd();
          return 'comment';
        }

        if (stream.match(/^[%#]/)){
          stream.skipToEnd();
          return 'comment';
        }

        // Handle Number Literals
        if (stream.match(/^[0-9\.+-]/, false)) {
          if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {
            stream.tokenize = tokenBase;
            return 'number'; }      if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; }      if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; }    }
        if (stream.match(wordRegexp(['nan','NaN','inf','Inf']))) { return 'number'; }
        // Handle Strings
        var m = stream.match(/^"(?:[^"]|"")*("|$)/) || stream.match(/^'(?:[^']|'')*('|$)/);
        if (m) { return m[1] ? 'string' : "string error"; }

        // Handle words
        if (stream.match(keywords)) { return 'keyword'; }    if (stream.match(builtins)) { return 'builtin'; }    if (stream.match(identifiers)) { return 'variable'; }
        if (stream.match(singleOperators) || stream.match(doubleOperators)) { return 'operator'; }    if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) { return null; }
        if (stream.match(expressionEnd)) {
          state.tokenize = tokenTranspose;
          return null;
        }

        // Handle non-detected items
        stream.next();
        return 'error';
      }

      return {
        startState: function() {
          return {
            tokenize: tokenBase
          };
        },

        token: function(stream, state) {
          var style = state.tokenize(stream, state);
          if (style === 'number' || style === 'variable'){
            state.tokenize = tokenTranspose;
          }
          return style;
        },

        lineComment: '%',

        fold: 'indent'
      };
    });

    CodeMirror.defineMIME("text/x-octave", "octave");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Oz(CodeMirror) {
    CodeMirror.defineMode("oz", function (conf) {

      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var singleOperators = /[\^@!\|<>#~\.\*\-\+\\/,=]/;
      var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\=)|(\\=:)|(!!)|(==)|(::)/;
      var tripleOperators = /(:::)|(\.\.\.)|(=<:)|(>=:)/;

      var middle = ["in", "then", "else", "of", "elseof", "elsecase", "elseif", "catch",
        "finally", "with", "require", "prepare", "import", "export", "define", "do"];
      var end = ["end"];

      var atoms = wordRegexp(["true", "false", "nil", "unit"]);
      var commonKeywords = wordRegexp(["andthen", "at", "attr", "declare", "feat", "from", "lex",
        "mod", "div", "mode", "orelse", "parser", "prod", "prop", "scanner", "self", "syn", "token"]);
      var openingKeywords = wordRegexp(["local", "proc", "fun", "case", "class", "if", "cond", "or", "dis",
        "choice", "not", "thread", "try", "raise", "lock", "for", "suchthat", "meth", "functor"]);
      var middleKeywords = wordRegexp(middle);
      var endKeywords = wordRegexp(end);

      // Tokenizers
      function tokenBase(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }

        // Brackets
        if(stream.match(/[{}]/)) {
          return "bracket";
        }

        // Special [] keyword
        if (stream.match(/(\[])/)) {
            return "keyword"
        }

        // Operators
        if (stream.match(tripleOperators) || stream.match(doubleOperators)) {
          return "operator";
        }

        // Atoms
        if(stream.match(atoms)) {
          return 'atom';
        }

        // Opening keywords
        var matched = stream.match(openingKeywords);
        if (matched) {
          if (!state.doInCurrentLine)
            state.currentIndent++;
          else
            state.doInCurrentLine = false;

          // Special matching for signatures
          if(matched[0] == "proc" || matched[0] == "fun")
            state.tokenize = tokenFunProc;
          else if(matched[0] == "class")
            state.tokenize = tokenClass;
          else if(matched[0] == "meth")
            state.tokenize = tokenMeth;

          return 'keyword';
        }

        // Middle and other keywords
        if (stream.match(middleKeywords) || stream.match(commonKeywords)) {
          return "keyword"
        }

        // End keywords
        if (stream.match(endKeywords)) {
          state.currentIndent--;
          return 'keyword';
        }

        // Eat the next char for next comparisons
        var ch = stream.next();

        // Strings
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }

        // Numbers
        if (/[~\d]/.test(ch)) {
          if (ch == "~") {
            if(! /^[0-9]/.test(stream.peek()))
              return null;
            else if (( stream.next() == "0" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
              return "number";
          }

          if ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
            return "number";

          return null;
        }

        // Comments
        if (ch == "%") {
          stream.skipToEnd();
          return 'comment';
        }
        else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
        }

        // Single operators
        if(singleOperators.test(ch)) {
          return "operator";
        }

        // If nothing match, we skip the entire alphanumerical block
        stream.eatWhile(/\w/);

        return "variable";
      }

      function tokenClass(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }
        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);
        state.tokenize = tokenBase;
        return "variable-3"
      }

      function tokenMeth(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }
        stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);
        state.tokenize = tokenBase;
        return "def"
      }

      function tokenFunProc(stream, state) {
        if (stream.eatSpace()) {
          return null;
        }

        if(!state.hasPassedFirstStage && stream.eat("{")) {
          state.hasPassedFirstStage = true;
          return "bracket";
        }
        else if(state.hasPassedFirstStage) {
          stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\$/);
          state.hasPassedFirstStage = false;
          state.tokenize = tokenBase;
          return "def"
        }
        else {
          state.tokenize = tokenBase;
          return null;
        }
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenString(quote) {
        return function (stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped)
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function buildElectricInputRegEx() {
        // Reindentation should occur on [] or on a match of any of
        // the block closing keywords, at the end of a line.
        var allClosings = middle.concat(end);
        return new RegExp("[\\[\\]]|(" + allClosings.join("|") + ")$");
      }

      return {

        startState: function () {
          return {
            tokenize: tokenBase,
            currentIndent: 0,
            doInCurrentLine: false,
            hasPassedFirstStage: false
          };
        },

        token: function (stream, state) {
          if (stream.sol())
            state.doInCurrentLine = 0;

          return state.tokenize(stream, state);
        },

        indent: function (state, textAfter) {
          var trueText = textAfter.replace(/^\s+|\s+$/g, '');

          if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\[])/))
            return conf.indentUnit * (state.currentIndent - 1);

          if (state.currentIndent < 0)
            return 0;

          return state.currentIndent * conf.indentUnit;
        },
        fold: "indent",
        electricInput: buildElectricInputRegEx(),
        lineComment: "%",
        blockCommentStart: "/*",
        blockCommentEnd: "*/"
      };
    });

    CodeMirror.defineMIME("text/x-oz", "oz");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Pascal(CodeMirror) {
    CodeMirror.defineMode("pascal", function() {
      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = words(
        "absolute and array asm begin case const constructor destructor div do " +
        "downto else end file for function goto if implementation in inherited " +
        "inline interface label mod nil not object of operator or packed procedure " +
        "program record reintroduce repeat self set shl shr string then to type " +
        "unit until uses var while with xor as class dispinterface except exports " +
        "finalization finally initialization inline is library on out packed " +
        "property raise resourcestring threadvar try absolute abstract alias " +
        "assembler bitpacked break cdecl continue cppdecl cvar default deprecated " +
        "dynamic enumerator experimental export external far far16 forward generic " +
        "helper implements index interrupt iocheck local message name near " +
        "nodefault noreturn nostackframe oldfpccall otherwise overload override " +
        "pascal platform private protected public published read register " +
        "reintroduce result safecall saveregisters softfloat specialize static " +
        "stdcall stored strict unaligned unimplemented varargs virtual write");
      var atoms = {"null": true};

      var isOperatorChar = /[+\-*&%=<>!?|\/]/;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == "#" && state.startOfLine) {
          stream.skipToEnd();
          return "meta";
        }
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (ch == "(" && stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return null;
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        if (ch == "/") {
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) return "keyword";
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !escaped) state.tokenize = null;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == ")" && maybeEnd) {
            state.tokenize = null;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      // Interface

      return {
        startState: function() {
          return {tokenize: null};
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          return style;
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-pascal", "pascal");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Pegjs(CodeMirror) {
    CodeMirror.defineMode("pegjs", function (config) {
      var jsMode = CodeMirror.getMode(config, "javascript");

      function identifier(stream) {
        return stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
      }

      return {
        startState: function () {
          return {
            inString: false,
            stringType: null,
            inComment: false,
            inCharacterClass: false,
            braced: 0,
            lhs: true,
            localState: null
          };
        },
        token: function (stream, state) {
          if (stream)

          //check for state changes
          if (!state.inString && !state.inComment && ((stream.peek() == '"') || (stream.peek() == "'"))) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.inString = true; // Update state
          }
          if (!state.inString && !state.inComment && stream.match(/^\/\*/)) {
            state.inComment = true;
          }

          //return state
          if (state.inString) {
            while (state.inString && !stream.eol()) {
              if (stream.peek() === state.stringType) {
                stream.next(); // Skip quote
                state.inString = false; // Clear flag
              } else if (stream.peek() === '\\') {
                stream.next();
                stream.next();
              } else {
                stream.match(/^.[^\\\"\']*/);
              }
            }
            return state.lhs ? "property string" : "string"; // Token style
          } else if (state.inComment) {
            while (state.inComment && !stream.eol()) {
              if (stream.match(/\*\//)) {
                state.inComment = false; // Clear flag
              } else {
                stream.match(/^.[^\*]*/);
              }
            }
            return "comment";
          } else if (state.inCharacterClass) {
              while (state.inCharacterClass && !stream.eol()) {
                if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
                  state.inCharacterClass = false;
                }
              }
          } else if (stream.peek() === '[') {
            stream.next();
            state.inCharacterClass = true;
            return 'bracket';
          } else if (stream.match(/^\/\//)) {
            stream.skipToEnd();
            return "comment";
          } else if (state.braced || stream.peek() === '{') {
            if (state.localState === null) {
              state.localState = CodeMirror.startState(jsMode);
            }
            var token = jsMode.token(stream, state.localState);
            var text = stream.current();
            if (!token) {
              for (var i = 0; i < text.length; i++) {
                if (text[i] === '{') {
                  state.braced++;
                } else if (text[i] === '}') {
                  state.braced--;
                }
              }        }
            return token;
          } else if (identifier(stream)) {
            if (stream.peek() === ':') {
              return 'variable';
            }
            return 'variable-2';
          } else if (['[', ']', '(', ')'].indexOf(stream.peek()) != -1) {
            stream.next();
            return 'bracket';
          } else if (!stream.eatSpace()) {
            stream.next();
          }
          return null;
        }
      };
    }, "javascript");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // CodeMirror2 mode/perl/perl.js (text/x-perl) beta 0.10 (2011-11-08)
    // This is a part of CodeMirror from https://github.com/sabaca/CodeMirror_mode_perl (mail@sabaca.com)

    function Perl(CodeMirror) {
    CodeMirror.defineMode("perl",function(){
            // http://perldoc.perl.org
            var PERL={                                      //   null - magic touch
                                                            //   1 - keyword
                                                            //   2 - def
                                                            //   3 - atom
                                                            //   4 - operator
                                                            //   5 - variable-2 (predefined)
                                                            //   [x,y] - x=1,2,3; y=must be defined if x{...}
                                                    //      PERL operators
                    '->'                            :   4,
                    '++'                            :   4,
                    '--'                            :   4,
                    '**'                            :   4,
                                                            //   ! ~ \ and unary + and -
                    '=~'                            :   4,
                    '!~'                            :   4,
                    '*'                             :   4,
                    '/'                             :   4,
                    '%'                             :   4,
                    'x'                             :   4,
                    '+'                             :   4,
                    '-'                             :   4,
                    '.'                             :   4,
                    '<<'                            :   4,
                    '>>'                            :   4,
                                                            //   named unary operators
                    '<'                             :   4,
                    '>'                             :   4,
                    '<='                            :   4,
                    '>='                            :   4,
                    'lt'                            :   4,
                    'gt'                            :   4,
                    'le'                            :   4,
                    'ge'                            :   4,
                    '=='                            :   4,
                    '!='                            :   4,
                    '<=>'                           :   4,
                    'eq'                            :   4,
                    'ne'                            :   4,
                    'cmp'                           :   4,
                    '~~'                            :   4,
                    '&'                             :   4,
                    '|'                             :   4,
                    '^'                             :   4,
                    '&&'                            :   4,
                    '||'                            :   4,
                    '//'                            :   4,
                    '..'                            :   4,
                    '...'                           :   4,
                    '?'                             :   4,
                    ':'                             :   4,
                    '='                             :   4,
                    '+='                            :   4,
                    '-='                            :   4,
                    '*='                            :   4,  //   etc. ???
                    ','                             :   4,
                    '=>'                            :   4,
                    '::'                            :   4,
                                                            //   list operators (rightward)
                    'not'                           :   4,
                    'and'                           :   4,
                    'or'                            :   4,
                    'xor'                           :   4,
                                                    //      PERL predefined variables (I know, what this is a paranoid idea, but may be needed for people, who learn PERL, and for me as well, ...and may be for you?;)
                    'BEGIN'                         :   [5,1],
                    'END'                           :   [5,1],
                    'PRINT'                         :   [5,1],
                    'PRINTF'                        :   [5,1],
                    'GETC'                          :   [5,1],
                    'READ'                          :   [5,1],
                    'READLINE'                      :   [5,1],
                    'DESTROY'                       :   [5,1],
                    'TIE'                           :   [5,1],
                    'TIEHANDLE'                     :   [5,1],
                    'UNTIE'                         :   [5,1],
                    'STDIN'                         :    5,
                    'STDIN_TOP'                     :    5,
                    'STDOUT'                        :    5,
                    'STDOUT_TOP'                    :    5,
                    'STDERR'                        :    5,
                    'STDERR_TOP'                    :    5,
                    '$ARG'                          :    5,
                    '$_'                            :    5,
                    '@ARG'                          :    5,
                    '@_'                            :    5,
                    '$LIST_SEPARATOR'               :    5,
                    '$"'                            :    5,
                    '$PROCESS_ID'                   :    5,
                    '$PID'                          :    5,
                    '$$'                            :    5,
                    '$REAL_GROUP_ID'                :    5,
                    '$GID'                          :    5,
                    '$('                            :    5,
                    '$EFFECTIVE_GROUP_ID'           :    5,
                    '$EGID'                         :    5,
                    '$)'                            :    5,
                    '$PROGRAM_NAME'                 :    5,
                    '$0'                            :    5,
                    '$SUBSCRIPT_SEPARATOR'          :    5,
                    '$SUBSEP'                       :    5,
                    '$;'                            :    5,
                    '$REAL_USER_ID'                 :    5,
                    '$UID'                          :    5,
                    '$<'                            :    5,
                    '$EFFECTIVE_USER_ID'            :    5,
                    '$EUID'                         :    5,
                    '$>'                            :    5,
                    '$a'                            :    5,
                    '$b'                            :    5,
                    '$COMPILING'                    :    5,
                    '$^C'                           :    5,
                    '$DEBUGGING'                    :    5,
                    '$^D'                           :    5,
                    '${^ENCODING}'                  :    5,
                    '$ENV'                          :    5,
                    '%ENV'                          :    5,
                    '$SYSTEM_FD_MAX'                :    5,
                    '$^F'                           :    5,
                    '@F'                            :    5,
                    '${^GLOBAL_PHASE}'              :    5,
                    '$^H'                           :    5,
                    '%^H'                           :    5,
                    '@INC'                          :    5,
                    '%INC'                          :    5,
                    '$INPLACE_EDIT'                 :    5,
                    '$^I'                           :    5,
                    '$^M'                           :    5,
                    '$OSNAME'                       :    5,
                    '$^O'                           :    5,
                    '${^OPEN}'                      :    5,
                    '$PERLDB'                       :    5,
                    '$^P'                           :    5,
                    '$SIG'                          :    5,
                    '%SIG'                          :    5,
                    '$BASETIME'                     :    5,
                    '$^T'                           :    5,
                    '${^TAINT}'                     :    5,
                    '${^UNICODE}'                   :    5,
                    '${^UTF8CACHE}'                 :    5,
                    '${^UTF8LOCALE}'                :    5,
                    '$PERL_VERSION'                 :    5,
                    '$^V'                           :    5,
                    '${^WIN32_SLOPPY_STAT}'         :    5,
                    '$EXECUTABLE_NAME'              :    5,
                    '$^X'                           :    5,
                    '$1'                            :    5, // - regexp $1, $2...
                    '$MATCH'                        :    5,
                    '$&'                            :    5,
                    '${^MATCH}'                     :    5,
                    '$PREMATCH'                     :    5,
                    '$`'                            :    5,
                    '${^PREMATCH}'                  :    5,
                    '$POSTMATCH'                    :    5,
                    "$'"                            :    5,
                    '${^POSTMATCH}'                 :    5,
                    '$LAST_PAREN_MATCH'             :    5,
                    '$+'                            :    5,
                    '$LAST_SUBMATCH_RESULT'         :    5,
                    '$^N'                           :    5,
                    '@LAST_MATCH_END'               :    5,
                    '@+'                            :    5,
                    '%LAST_PAREN_MATCH'             :    5,
                    '%+'                            :    5,
                    '@LAST_MATCH_START'             :    5,
                    '@-'                            :    5,
                    '%LAST_MATCH_START'             :    5,
                    '%-'                            :    5,
                    '$LAST_REGEXP_CODE_RESULT'      :    5,
                    '$^R'                           :    5,
                    '${^RE_DEBUG_FLAGS}'            :    5,
                    '${^RE_TRIE_MAXBUF}'            :    5,
                    '$ARGV'                         :    5,
                    '@ARGV'                         :    5,
                    'ARGV'                          :    5,
                    'ARGVOUT'                       :    5,
                    '$OUTPUT_FIELD_SEPARATOR'       :    5,
                    '$OFS'                          :    5,
                    '$,'                            :    5,
                    '$INPUT_LINE_NUMBER'            :    5,
                    '$NR'                           :    5,
                    '$.'                            :    5,
                    '$INPUT_RECORD_SEPARATOR'       :    5,
                    '$RS'                           :    5,
                    '$/'                            :    5,
                    '$OUTPUT_RECORD_SEPARATOR'      :    5,
                    '$ORS'                          :    5,
                    '$\\'                           :    5,
                    '$OUTPUT_AUTOFLUSH'             :    5,
                    '$|'                            :    5,
                    '$ACCUMULATOR'                  :    5,
                    '$^A'                           :    5,
                    '$FORMAT_FORMFEED'              :    5,
                    '$^L'                           :    5,
                    '$FORMAT_PAGE_NUMBER'           :    5,
                    '$%'                            :    5,
                    '$FORMAT_LINES_LEFT'            :    5,
                    '$-'                            :    5,
                    '$FORMAT_LINE_BREAK_CHARACTERS' :    5,
                    '$:'                            :    5,
                    '$FORMAT_LINES_PER_PAGE'        :    5,
                    '$='                            :    5,
                    '$FORMAT_TOP_NAME'              :    5,
                    '$^'                            :    5,
                    '$FORMAT_NAME'                  :    5,
                    '$~'                            :    5,
                    '${^CHILD_ERROR_NATIVE}'        :    5,
                    '$EXTENDED_OS_ERROR'            :    5,
                    '$^E'                           :    5,
                    '$EXCEPTIONS_BEING_CAUGHT'      :    5,
                    '$^S'                           :    5,
                    '$WARNING'                      :    5,
                    '$^W'                           :    5,
                    '${^WARNING_BITS}'              :    5,
                    '$OS_ERROR'                     :    5,
                    '$ERRNO'                        :    5,
                    '$!'                            :    5,
                    '%OS_ERROR'                     :    5,
                    '%ERRNO'                        :    5,
                    '%!'                            :    5,
                    '$CHILD_ERROR'                  :    5,
                    '$?'                            :    5,
                    '$EVAL_ERROR'                   :    5,
                    '$@'                            :    5,
                    '$OFMT'                         :    5,
                    '$#'                            :    5,
                    '$*'                            :    5,
                    '$ARRAY_BASE'                   :    5,
                    '$['                            :    5,
                    '$OLD_PERL_VERSION'             :    5,
                    '$]'                            :    5,
                                                    //      PERL blocks
                    'if'                            :[1,1],
                    elsif                           :[1,1],
                    'else'                          :[1,1],
                    'while'                         :[1,1],
                    unless                          :[1,1],
                    'for'                           :[1,1],
                    foreach                         :[1,1],
                                                    //      PERL functions
                    'abs'                           :1,     // - absolute value function
                    accept                          :1,     // - accept an incoming socket connect
                    alarm                           :1,     // - schedule a SIGALRM
                    'atan2'                         :1,     // - arctangent of Y/X in the range -PI to PI
                    bind                            :1,     // - binds an address to a socket
                    binmode                         :1,     // - prepare binary files for I/O
                    bless                           :1,     // - create an object
                    bootstrap                       :1,     //
                    'break'                         :1,     // - break out of a "given" block
                    caller                          :1,     // - get context of the current subroutine call
                    chdir                           :1,     // - change your current working directory
                    chmod                           :1,     // - changes the permissions on a list of files
                    chomp                           :1,     // - remove a trailing record separator from a string
                    chop                            :1,     // - remove the last character from a string
                    chown                           :1,     // - change the ownership on a list of files
                    chr                             :1,     // - get character this number represents
                    chroot                          :1,     // - make directory new root for path lookups
                    close                           :1,     // - close file (or pipe or socket) handle
                    closedir                        :1,     // - close directory handle
                    connect                         :1,     // - connect to a remote socket
                    'continue'                      :[1,1], // - optional trailing block in a while or foreach
                    'cos'                           :1,     // - cosine function
                    crypt                           :1,     // - one-way passwd-style encryption
                    dbmclose                        :1,     // - breaks binding on a tied dbm file
                    dbmopen                         :1,     // - create binding on a tied dbm file
                    'default'                       :1,     //
                    defined                         :1,     // - test whether a value, variable, or function is defined
                    'delete'                        :1,     // - deletes a value from a hash
                    die                             :1,     // - raise an exception or bail out
                    'do'                            :1,     // - turn a BLOCK into a TERM
                    dump                            :1,     // - create an immediate core dump
                    each                            :1,     // - retrieve the next key/value pair from a hash
                    endgrent                        :1,     // - be done using group file
                    endhostent                      :1,     // - be done using hosts file
                    endnetent                       :1,     // - be done using networks file
                    endprotoent                     :1,     // - be done using protocols file
                    endpwent                        :1,     // - be done using passwd file
                    endservent                      :1,     // - be done using services file
                    eof                             :1,     // - test a filehandle for its end
                    'eval'                          :1,     // - catch exceptions or compile and run code
                    'exec'                          :1,     // - abandon this program to run another
                    exists                          :1,     // - test whether a hash key is present
                    exit                            :1,     // - terminate this program
                    'exp'                           :1,     // - raise I to a power
                    fcntl                           :1,     // - file control system call
                    fileno                          :1,     // - return file descriptor from filehandle
                    flock                           :1,     // - lock an entire file with an advisory lock
                    fork                            :1,     // - create a new process just like this one
                    format                          :1,     // - declare a picture format with use by the write() function
                    formline                        :1,     // - internal function used for formats
                    getc                            :1,     // - get the next character from the filehandle
                    getgrent                        :1,     // - get next group record
                    getgrgid                        :1,     // - get group record given group user ID
                    getgrnam                        :1,     // - get group record given group name
                    gethostbyaddr                   :1,     // - get host record given its address
                    gethostbyname                   :1,     // - get host record given name
                    gethostent                      :1,     // - get next hosts record
                    getlogin                        :1,     // - return who logged in at this tty
                    getnetbyaddr                    :1,     // - get network record given its address
                    getnetbyname                    :1,     // - get networks record given name
                    getnetent                       :1,     // - get next networks record
                    getpeername                     :1,     // - find the other end of a socket connection
                    getpgrp                         :1,     // - get process group
                    getppid                         :1,     // - get parent process ID
                    getpriority                     :1,     // - get current nice value
                    getprotobyname                  :1,     // - get protocol record given name
                    getprotobynumber                :1,     // - get protocol record numeric protocol
                    getprotoent                     :1,     // - get next protocols record
                    getpwent                        :1,     // - get next passwd record
                    getpwnam                        :1,     // - get passwd record given user login name
                    getpwuid                        :1,     // - get passwd record given user ID
                    getservbyname                   :1,     // - get services record given its name
                    getservbyport                   :1,     // - get services record given numeric port
                    getservent                      :1,     // - get next services record
                    getsockname                     :1,     // - retrieve the sockaddr for a given socket
                    getsockopt                      :1,     // - get socket options on a given socket
                    given                           :1,     //
                    glob                            :1,     // - expand filenames using wildcards
                    gmtime                          :1,     // - convert UNIX time into record or string using Greenwich time
                    'goto'                          :1,     // - create spaghetti code
                    grep                            :1,     // - locate elements in a list test true against a given criterion
                    hex                             :1,     // - convert a string to a hexadecimal number
                    'import'                        :1,     // - patch a module's namespace into your own
                    index                           :1,     // - find a substring within a string
                    'int'                           :1,     // - get the integer portion of a number
                    ioctl                           :1,     // - system-dependent device control system call
                    'join'                          :1,     // - join a list into a string using a separator
                    keys                            :1,     // - retrieve list of indices from a hash
                    kill                            :1,     // - send a signal to a process or process group
                    last                            :1,     // - exit a block prematurely
                    lc                              :1,     // - return lower-case version of a string
                    lcfirst                         :1,     // - return a string with just the next letter in lower case
                    length                          :1,     // - return the number of bytes in a string
                    'link'                          :1,     // - create a hard link in the filesytem
                    listen                          :1,     // - register your socket as a server
                    local                           : 2,    // - create a temporary value for a global variable (dynamic scoping)
                    localtime                       :1,     // - convert UNIX time into record or string using local time
                    lock                            :1,     // - get a thread lock on a variable, subroutine, or method
                    'log'                           :1,     // - retrieve the natural logarithm for a number
                    lstat                           :1,     // - stat a symbolic link
                    m                               :null,  // - match a string with a regular expression pattern
                    map                             :1,     // - apply a change to a list to get back a new list with the changes
                    mkdir                           :1,     // - create a directory
                    msgctl                          :1,     // - SysV IPC message control operations
                    msgget                          :1,     // - get SysV IPC message queue
                    msgrcv                          :1,     // - receive a SysV IPC message from a message queue
                    msgsnd                          :1,     // - send a SysV IPC message to a message queue
                    my                              : 2,    // - declare and assign a local variable (lexical scoping)
                    'new'                           :1,     //
                    next                            :1,     // - iterate a block prematurely
                    no                              :1,     // - unimport some module symbols or semantics at compile time
                    oct                             :1,     // - convert a string to an octal number
                    open                            :1,     // - open a file, pipe, or descriptor
                    opendir                         :1,     // - open a directory
                    ord                             :1,     // - find a character's numeric representation
                    our                             : 2,    // - declare and assign a package variable (lexical scoping)
                    pack                            :1,     // - convert a list into a binary representation
                    'package'                       :1,     // - declare a separate global namespace
                    pipe                            :1,     // - open a pair of connected filehandles
                    pop                             :1,     // - remove the last element from an array and return it
                    pos                             :1,     // - find or set the offset for the last/next m//g search
                    print                           :1,     // - output a list to a filehandle
                    printf                          :1,     // - output a formatted list to a filehandle
                    prototype                       :1,     // - get the prototype (if any) of a subroutine
                    push                            :1,     // - append one or more elements to an array
                    q                               :null,  // - singly quote a string
                    qq                              :null,  // - doubly quote a string
                    qr                              :null,  // - Compile pattern
                    quotemeta                       :null,  // - quote regular expression magic characters
                    qw                              :null,  // - quote a list of words
                    qx                              :null,  // - backquote quote a string
                    rand                            :1,     // - retrieve the next pseudorandom number
                    read                            :1,     // - fixed-length buffered input from a filehandle
                    readdir                         :1,     // - get a directory from a directory handle
                    readline                        :1,     // - fetch a record from a file
                    readlink                        :1,     // - determine where a symbolic link is pointing
                    readpipe                        :1,     // - execute a system command and collect standard output
                    recv                            :1,     // - receive a message over a Socket
                    redo                            :1,     // - start this loop iteration over again
                    ref                             :1,     // - find out the type of thing being referenced
                    rename                          :1,     // - change a filename
                    require                         :1,     // - load in external functions from a library at runtime
                    reset                           :1,     // - clear all variables of a given name
                    'return'                        :1,     // - get out of a function early
                    reverse                         :1,     // - flip a string or a list
                    rewinddir                       :1,     // - reset directory handle
                    rindex                          :1,     // - right-to-left substring search
                    rmdir                           :1,     // - remove a directory
                    s                               :null,  // - replace a pattern with a string
                    say                             :1,     // - print with newline
                    scalar                          :1,     // - force a scalar context
                    seek                            :1,     // - reposition file pointer for random-access I/O
                    seekdir                         :1,     // - reposition directory pointer
                    select                          :1,     // - reset default output or do I/O multiplexing
                    semctl                          :1,     // - SysV semaphore control operations
                    semget                          :1,     // - get set of SysV semaphores
                    semop                           :1,     // - SysV semaphore operations
                    send                            :1,     // - send a message over a socket
                    setgrent                        :1,     // - prepare group file for use
                    sethostent                      :1,     // - prepare hosts file for use
                    setnetent                       :1,     // - prepare networks file for use
                    setpgrp                         :1,     // - set the process group of a process
                    setpriority                     :1,     // - set a process's nice value
                    setprotoent                     :1,     // - prepare protocols file for use
                    setpwent                        :1,     // - prepare passwd file for use
                    setservent                      :1,     // - prepare services file for use
                    setsockopt                      :1,     // - set some socket options
                    shift                           :1,     // - remove the first element of an array, and return it
                    shmctl                          :1,     // - SysV shared memory operations
                    shmget                          :1,     // - get SysV shared memory segment identifier
                    shmread                         :1,     // - read SysV shared memory
                    shmwrite                        :1,     // - write SysV shared memory
                    shutdown                        :1,     // - close down just half of a socket connection
                    'sin'                           :1,     // - return the sine of a number
                    sleep                           :1,     // - block for some number of seconds
                    socket                          :1,     // - create a socket
                    socketpair                      :1,     // - create a pair of sockets
                    'sort'                          :1,     // - sort a list of values
                    splice                          :1,     // - add or remove elements anywhere in an array
                    'split'                         :1,     // - split up a string using a regexp delimiter
                    sprintf                         :1,     // - formatted print into a string
                    'sqrt'                          :1,     // - square root function
                    srand                           :1,     // - seed the random number generator
                    stat                            :1,     // - get a file's status information
                    state                           :1,     // - declare and assign a state variable (persistent lexical scoping)
                    study                           :1,     // - optimize input data for repeated searches
                    'sub'                           :1,     // - declare a subroutine, possibly anonymously
                    'substr'                        :1,     // - get or alter a portion of a stirng
                    symlink                         :1,     // - create a symbolic link to a file
                    syscall                         :1,     // - execute an arbitrary system call
                    sysopen                         :1,     // - open a file, pipe, or descriptor
                    sysread                         :1,     // - fixed-length unbuffered input from a filehandle
                    sysseek                         :1,     // - position I/O pointer on handle used with sysread and syswrite
                    system                          :1,     // - run a separate program
                    syswrite                        :1,     // - fixed-length unbuffered output to a filehandle
                    tell                            :1,     // - get current seekpointer on a filehandle
                    telldir                         :1,     // - get current seekpointer on a directory handle
                    tie                             :1,     // - bind a variable to an object class
                    tied                            :1,     // - get a reference to the object underlying a tied variable
                    time                            :1,     // - return number of seconds since 1970
                    times                           :1,     // - return elapsed time for self and child processes
                    tr                              :null,  // - transliterate a string
                    truncate                        :1,     // - shorten a file
                    uc                              :1,     // - return upper-case version of a string
                    ucfirst                         :1,     // - return a string with just the next letter in upper case
                    umask                           :1,     // - set file creation mode mask
                    undef                           :1,     // - remove a variable or function definition
                    unlink                          :1,     // - remove one link to a file
                    unpack                          :1,     // - convert binary structure into normal perl variables
                    unshift                         :1,     // - prepend more elements to the beginning of a list
                    untie                           :1,     // - break a tie binding to a variable
                    use                             :1,     // - load in a module at compile time
                    utime                           :1,     // - set a file's last access and modify times
                    values                          :1,     // - return a list of the values in a hash
                    vec                             :1,     // - test or set particular bits in a string
                    wait                            :1,     // - wait for any child process to die
                    waitpid                         :1,     // - wait for a particular child process to die
                    wantarray                       :1,     // - get void vs scalar vs list context of current subroutine call
                    warn                            :1,     // - print debugging info
                    when                            :1,     //
                    write                           :1,     // - print a picture record
                    y                               :null}; // - transliterate a string

            var RXstyle="string-2";
            var RXmodifiers=/[goseximacplud]/;              // NOTE: "m", "s", "y" and "tr" need to correct real modifiers for each regexp type

            function tokenChain(stream,state,chain,style,tail){     // NOTE: chain.length > 2 is not working now (it's for s[...][...]geos;)
                    state.chain=null;                               //                                                          12   3tail
                    state.style=null;
                    state.tail=null;
                    state.tokenize=function(stream,state){
                            var e=false,c,i=0;
                            while(c=stream.next()){
                                    if(c===chain[i]&&!e){
                                            if(chain[++i]!==undefined){
                                                    state.chain=chain[i];
                                                    state.style=style;
                                                    state.tail=tail;}
                                            else if(tail)
                                                    stream.eatWhile(tail);
                                            state.tokenize=tokenPerl;
                                            return style;}
                                    e=!e&&c=="\\";}
                            return style;};
                    return state.tokenize(stream,state);}

            function tokenSOMETHING(stream,state,string){
                    state.tokenize=function(stream,state){
                            if(stream.string==string)
                                    state.tokenize=tokenPerl;
                            stream.skipToEnd();
                            return "string";};
                    return state.tokenize(stream,state);}

            function tokenPerl(stream,state){
                    if(stream.eatSpace())
                            return null;
                    if(state.chain)
                            return tokenChain(stream,state,state.chain,state.style,state.tail);
                    if(stream.match(/^\-?[\d\.]/,false))
                            if(stream.match(/^(\-?(\d*\.\d+(e[+-]?\d+)?|\d+\.\d*)|0x[\da-fA-F]+|0b[01]+|\d+(e[+-]?\d+)?)/))
                                    return 'number';
                    if(stream.match(/^<<(?=\w)/)){                  // NOTE: <<SOMETHING\n...\nSOMETHING\n
                            stream.eatWhile(/\w/);
                            return tokenSOMETHING(stream,state,stream.current().substr(2));}
                    if(stream.sol()&&stream.match(/^\=item(?!\w)/)){// NOTE: \n=item...\n=cut\n
                            return tokenSOMETHING(stream,state,'=cut');}
                    var ch=stream.next();
                    if(ch=='"'||ch=="'"){                           // NOTE: ' or " or <<'SOMETHING'\n...\nSOMETHING\n or <<"SOMETHING"\n...\nSOMETHING\n
                            if(prefix(stream, 3)=="<<"+ch){
                                    var p=stream.pos;
                                    stream.eatWhile(/\w/);
                                    var n=stream.current().substr(1);
                                    if(n&&stream.eat(ch))
                                            return tokenSOMETHING(stream,state,n);
                                    stream.pos=p;}
                            return tokenChain(stream,state,[ch],"string");}
                    if(ch=="q"){
                            var c=look(stream, -2);
                            if(!(c&&/\w/.test(c))){
                                    c=look(stream, 0);
                                    if(c=="x"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                    else if(c=="q"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],"string");}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],"string");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],"string");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],"string");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],"string");}}
                                    else if(c=="w"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],"bracket");}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],"bracket");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],"bracket");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],"bracket");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],"bracket");}}
                                    else if(c=="r"){
                                            c=look(stream, 1);
                                            if(c=="("){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    eatSuffix(stream, 2);
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                    else if(/[\^'"!~\/(\[{<]/.test(c)){
                                            if(c=="("){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[")"],"string");}
                                            if(c=="["){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,["]"],"string");}
                                            if(c=="{"){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,["}"],"string");}
                                            if(c=="<"){
                                                    eatSuffix(stream, 1);
                                                    return tokenChain(stream,state,[">"],"string");}
                                            if(/[\^'"!~\/]/.test(c)){
                                                    return tokenChain(stream,state,[stream.eat(c)],"string");}}}}
                    if(ch=="m"){
                            var c=look(stream, -2);
                            if(!(c&&/\w/.test(c))){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(/[\^'"!~\/]/.test(c)){
                                                    return tokenChain(stream,state,[c],RXstyle,RXmodifiers);}
                                            if(c=="("){
                                                    return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                            if(c=="["){
                                                    return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                            if(c=="{"){
                                                    return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                            if(c=="<"){
                                                    return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}}}}
                    if(ch=="s"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                    if(ch=="y"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                    if(ch=="t"){
                            var c=/[\/>\]})\w]/.test(look(stream, -2));
                            if(!c){
                                    c=stream.eat("r");if(c){
                                    c=stream.eat(/[(\[{<\^'"!~\/]/);
                                    if(c){
                                            if(c=="[")
                                                    return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                            if(c=="{")
                                                    return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                            if(c=="<")
                                                    return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                            if(c=="(")
                                                    return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                            return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}}
                    if(ch=="`"){
                            return tokenChain(stream,state,[ch],"variable-2");}
                    if(ch=="/"){
                            if(!/~\s*$/.test(prefix(stream)))
                                    return "operator";
                            else
                                    return tokenChain(stream,state,[ch],RXstyle,RXmodifiers);}
                    if(ch=="$"){
                            var p=stream.pos;
                            if(stream.eatWhile(/\d/)||stream.eat("{")&&stream.eatWhile(/\d/)&&stream.eat("}"))
                                    return "variable-2";
                            else
                                    stream.pos=p;}
                    if(/[$@%]/.test(ch)){
                            var p=stream.pos;
                            if(stream.eat("^")&&stream.eat(/[A-Z]/)||!/[@$%&]/.test(look(stream, -2))&&stream.eat(/[=|\\\-#?@;:&`~\^!\[\]*'"$+.,\/<>()]/)){
                                    var c=stream.current();
                                    if(PERL[c])
                                            return "variable-2";}
                            stream.pos=p;}
                    if(/[$@%&]/.test(ch)){
                            if(stream.eatWhile(/[\w$\[\]]/)||stream.eat("{")&&stream.eatWhile(/[\w$\[\]]/)&&stream.eat("}")){
                                    var c=stream.current();
                                    if(PERL[c])
                                            return "variable-2";
                                    else
                                            return "variable";}}
                    if(ch=="#"){
                            if(look(stream, -2)!="$"){
                                    stream.skipToEnd();
                                    return "comment";}}
                    if(/[:+\-\^*$&%@=<>!?|\/~\.]/.test(ch)){
                            var p=stream.pos;
                            stream.eatWhile(/[:+\-\^*$&%@=<>!?|\/~\.]/);
                            if(PERL[stream.current()])
                                    return "operator";
                            else
                                    stream.pos=p;}
                    if(ch=="_"){
                            if(stream.pos==1){
                                    if(suffix(stream, 6)=="_END__"){
                                            return tokenChain(stream,state,['\0'],"comment");}
                                    else if(suffix(stream, 7)=="_DATA__"){
                                            return tokenChain(stream,state,['\0'],"variable-2");}
                                    else if(suffix(stream, 7)=="_C__"){
                                            return tokenChain(stream,state,['\0'],"string");}}}
                    if(/\w/.test(ch)){
                            var p=stream.pos;
                            if(look(stream, -2)=="{"&&(look(stream, 0)=="}"||stream.eatWhile(/\w/)&&look(stream, 0)=="}"))
                                    return "string";
                            else
                                    stream.pos=p;}
                    if(/[A-Z]/.test(ch)){
                            var l=look(stream, -2);
                            var p=stream.pos;
                            stream.eatWhile(/[A-Z_]/);
                            if(/[\da-z]/.test(look(stream, 0))){
                                    stream.pos=p;}
                            else{
                                    var c=PERL[stream.current()];
                                    if(!c)
                                            return "meta";
                                    if(c[1])
                                            c=c[0];
                                    if(l!=":"){
                                            if(c==1)
                                                    return "keyword";
                                            else if(c==2)
                                                    return "def";
                                            else if(c==3)
                                                    return "atom";
                                            else if(c==4)
                                                    return "operator";
                                            else if(c==5)
                                                    return "variable-2";
                                            else
                                                    return "meta";}
                                    else
                                            return "meta";}}
                    if(/[a-zA-Z_]/.test(ch)){
                            var l=look(stream, -2);
                            stream.eatWhile(/\w/);
                            var c=PERL[stream.current()];
                            if(!c)
                                    return "meta";
                            if(c[1])
                                    c=c[0];
                            if(l!=":"){
                                    if(c==1)
                                            return "keyword";
                                    else if(c==2)
                                            return "def";
                                    else if(c==3)
                                            return "atom";
                                    else if(c==4)
                                            return "operator";
                                    else if(c==5)
                                            return "variable-2";
                                    else
                                            return "meta";}
                            else
                                    return "meta";}
                    return null;}

            return {
                startState: function() {
                    return {
                        tokenize: tokenPerl,
                        chain: null,
                        style: null,
                        tail: null
                    };
                },
                token: function(stream, state) {
                    return (state.tokenize || tokenPerl)(stream, state);
                },
                lineComment: '#'
            };
    });

    CodeMirror.registerHelper("wordChars", "perl", /[\w$]/);

    CodeMirror.defineMIME("text/x-perl", "perl");

    // it's like "peek", but need for look-ahead or look-behind if index < 0
    function look(stream, c){
      return stream.string.charAt(stream.pos+(c||0));
    }

    // return a part of prefix of current stream from current position
    function prefix(stream, c){
      if(c){
        var x=stream.pos-c;
        return stream.string.substr((x>=0?x:0),c);}
      else{
        return stream.string.substr(0,stream.pos-1);
      }
    }

    // return a part of suffix of current stream from current position
    function suffix(stream, c){
      var y=stream.string.length;
      var x=y-stream.pos+1;
      return stream.string.substr(stream.pos,(c&&c<y?c:x));
    }

    // eating and vomiting a part of stream from current position
    function eatSuffix(stream, c){
      var x=stream.pos+c;
      var y;
      if(x<=0)
        stream.pos=0;
      else if(x>=(y=stream.string.length-1))
        stream.pos=y;
      else
        stream.pos=x;
    }

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function PHP(CodeMirror) {
      function keywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      // Helper for phpString
      function matchSequence(list, end, escapes) {
        if (list.length == 0) return phpString(end);
        return function (stream, state) {
          var patterns = list[0];
          for (var i = 0; i < patterns.length; i++) if (stream.match(patterns[i][0])) {
            state.tokenize = matchSequence(list.slice(1), end);
            return patterns[i][1];
          }
          state.tokenize = phpString(end, escapes);
          return "string";
        };
      }
      function phpString(closing, escapes) {
        return function(stream, state) { return phpString_(stream, state, closing, escapes); };
      }
      function phpString_(stream, state, closing, escapes) {
        // "Complex" syntax
        if (escapes !== false && stream.match("${", false) || stream.match("{$", false)) {
          state.tokenize = null;
          return "string";
        }

        // Simple syntax
        if (escapes !== false && stream.match(/^\$[a-zA-Z_][a-zA-Z0-9_]*/)) {
          // After the variable name there may appear array or object operator.
          if (stream.match("[", false)) {
            // Match array operator
            state.tokenize = matchSequence([
              [["[", null]],
              [[/\d[\w\.]*/, "number"],
               [/\$[a-zA-Z_][a-zA-Z0-9_]*/, "variable-2"],
               [/[\w\$]+/, "variable"]],
              [["]", null]]
            ], closing, escapes);
          }
          if (stream.match(/\-\>\w/, false)) {
            // Match object operator
            state.tokenize = matchSequence([
              [["->", null]],
              [[/[\w]+/, "variable"]]
            ], closing, escapes);
          }
          return "variable-2";
        }

        var escaped = false;
        // Normal string
        while (!stream.eol() &&
               (escaped || escapes === false ||
                (!stream.match("{$", false) &&
                 !stream.match(/^(\$[a-zA-Z_][a-zA-Z0-9_]*|\$\{)/, false)))) {
          if (!escaped && stream.match(closing)) {
            state.tokenize = null;
            state.tokStack.pop(); state.tokStack.pop();
            break;
          }
          escaped = stream.next() == "\\" && !escaped;
        }
        return "string";
      }

      var phpKeywords = "abstract and array as break case catch class clone const continue declare default " +
        "do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final " +
        "for foreach function global goto if implements interface instanceof namespace " +
        "new or private protected public static switch throw trait try use var while xor " +
        "die echo empty exit eval include include_once isset list require require_once return " +
        "print unset __halt_compiler self static parent yield insteadof finally";
      var phpAtoms = "true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__";
      var phpBuiltin = "func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count";
      CodeMirror.registerHelper("hintWords", "php", [phpKeywords, phpAtoms, phpBuiltin].join(" ").split(" "));
      CodeMirror.registerHelper("wordChars", "php", /[\w$]/);

      var phpConfig = {
        name: "clike",
        helperType: "php",
        keywords: keywords(phpKeywords),
        blockKeywords: keywords("catch do else elseif for foreach if switch try while finally"),
        defKeywords: keywords("class function interface namespace trait"),
        atoms: keywords(phpAtoms),
        builtin: keywords(phpBuiltin),
        multiLineStrings: true,
        hooks: {
          "$": function(stream) {
            stream.eatWhile(/[\w\$_]/);
            return "variable-2";
          },
          "<": function(stream, state) {
            var before;
            if (before = stream.match(/<<\s*/)) {
              var quoted = stream.eat(/['"]/);
              stream.eatWhile(/[\w\.]/);
              var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));
              if (quoted) stream.eat(quoted);
              if (delim) {
                (state.tokStack || (state.tokStack = [])).push(delim, 0);
                state.tokenize = phpString(delim, quoted != "'");
                return "string";
              }
            }
            return false;
          },
          "#": function(stream) {
            while (!stream.eol() && !stream.match("?>", false)) stream.next();
            return "comment";
          },
          "/": function(stream) {
            if (stream.eat("/")) {
              while (!stream.eol() && !stream.match("?>", false)) stream.next();
              return "comment";
            }
            return false;
          },
          '"': function(_stream, state) {
            (state.tokStack || (state.tokStack = [])).push('"', 0);
            state.tokenize = phpString('"');
            return "string";
          },
          "{": function(_stream, state) {
            if (state.tokStack && state.tokStack.length)
              state.tokStack[state.tokStack.length - 1]++;
            return false;
          },
          "}": function(_stream, state) {
            if (state.tokStack && state.tokStack.length > 0 &&
                !--state.tokStack[state.tokStack.length - 1]) {
              state.tokenize = phpString(state.tokStack[state.tokStack.length - 2]);
            }
            return false;
          }
        }
      };

      CodeMirror.defineMode("php", function(config, parserConfig) {
        var htmlMode = CodeMirror.getMode(config, (parserConfig && parserConfig.htmlMode) || "text/html");
        var phpMode = CodeMirror.getMode(config, phpConfig);

        function dispatch(stream, state) {
          var isPHP = state.curMode == phpMode;
          if (stream.sol() && state.pending && state.pending != '"' && state.pending != "'") state.pending = null;
          if (!isPHP) {
            if (stream.match(/^<\?\w*/)) {
              state.curMode = phpMode;
              if (!state.php) state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, "", ""));
              state.curState = state.php;
              return "meta";
            }
            if (state.pending == '"' || state.pending == "'") {
              while (!stream.eol() && stream.next() != state.pending) {}
              var style = "string";
            } else if (state.pending && stream.pos < state.pending.end) {
              stream.pos = state.pending.end;
              var style = state.pending.style;
            } else {
              var style = htmlMode.token(stream, state.curState);
            }
            if (state.pending) state.pending = null;
            var cur = stream.current(), openPHP = cur.search(/<\?/), m;
            if (openPHP != -1) {
              if (style == "string" && (m = cur.match(/[\'\"]$/)) && !/\?>/.test(cur)) state.pending = m[0];
              else state.pending = {end: stream.pos, style: style};
              stream.backUp(cur.length - openPHP);
            }
            return style;
          } else if (isPHP && state.php.tokenize == null && stream.match("?>")) {
            state.curMode = htmlMode;
            state.curState = state.html;
            if (!state.php.context.prev) state.php = null;
            return "meta";
          } else {
            return phpMode.token(stream, state.curState);
          }
        }

        return {
          startState: function() {
            var html = CodeMirror.startState(htmlMode);
            var php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null;
            return {html: html,
                    php: php,
                    curMode: parserConfig.startOpen ? phpMode : htmlMode,
                    curState: parserConfig.startOpen ? php : html,
                    pending: null};
          },

          copyState: function(state) {
            var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),
                php = state.php, phpNew = php && CodeMirror.copyState(phpMode, php), cur;
            if (state.curMode == htmlMode) cur = htmlNew;
            else cur = phpNew;
            return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,
                    pending: state.pending};
          },

          token: dispatch,

          indent: function(state, textAfter, line) {
            if ((state.curMode != phpMode && /^\s*<\//.test(textAfter)) ||
                (state.curMode == phpMode && /^\?>/.test(textAfter)))
              return htmlMode.indent(state.html, textAfter, line);
            return state.curMode.indent(state.curState, textAfter, line);
          },

          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//",

          innerMode: function(state) { return {state: state.curState, mode: state.curMode}; }
        };
      }, "htmlmixed", "clike");

      CodeMirror.defineMIME("application/x-httpd-php", "php");
      CodeMirror.defineMIME("application/x-httpd-php-open", {name: "php", startOpen: true});
      CodeMirror.defineMIME("text/x-php", phpConfig);
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
     *      Pig Latin Mode for CodeMirror 2
     *      @author Prasanth Jayachandran
     *      @link   https://github.com/prasanthj/pig-codemirror-2
     *  This implementation is adapted from PL/SQL mode in CodeMirror 2.
     */
    function Pig(CodeMirror) {
    CodeMirror.defineMode("pig", function(_config, parserConfig) {
      var keywords = parserConfig.keywords,
      builtins = parserConfig.builtins,
      types = parserConfig.types,
      multiLineStrings = parserConfig.multiLineStrings;

      var isOperatorChar = /[*+\-%<>=&?:\/!|]/;

      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function tokenComment(stream, state) {
        var isEnd = false;
        var ch;
        while(ch = stream.next()) {
          if(ch == "/" && isEnd) {
            state.tokenize = tokenBase;
            break;
          }
          isEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true; break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "error";
        };
      }


      function tokenBase(stream, state) {
        var ch = stream.next();

        // is a start of string?
        if (ch == '"' || ch == "'")
          return chain(stream, state, tokenString(ch));
        // is it one of the special chars
        else if(/[\[\]{}\(\),;\.]/.test(ch))
          return null;
        // is it a number?
        else if(/\d/.test(ch)) {
          stream.eatWhile(/[\w\.]/);
          return "number";
        }
        // multi line comment or operator
        else if (ch == "/") {
          if (stream.eat("*")) {
            return chain(stream, state, tokenComment);
          }
          else {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
        }
        // single line comment or operator
        else if (ch=="-") {
          if(stream.eat("-")){
            stream.skipToEnd();
            return "comment";
          }
          else {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
        }
        // is it an operator
        else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        else {
          // get the while word
          stream.eatWhile(/[\w\$_]/);
          // is it one of the listed keywords?
          if (keywords && keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
            //keywords can be used as variables like flatten(group), group.$0 etc..
            if (!stream.eat(")") && !stream.eat("."))
              return "keyword";
          }
          // is it one of the builtin functions?
          if (builtins && builtins.propertyIsEnumerable(stream.current().toUpperCase()))
            return "variable-2";
          // is it one of the listed types?
          if (types && types.propertyIsEnumerable(stream.current().toUpperCase()))
            return "variable-3";
          // default is a 'variable'
          return "variable";
        }
      }

      // Interface
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          if(stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          return style;
        }
      };
    });

    (function() {
      function keywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      // builtin funcs taken from trunk revision 1303237
      var pBuiltins = "ABS ACOS ARITY ASIN ATAN AVG BAGSIZE BINSTORAGE BLOOM BUILDBLOOM CBRT CEIL "
        + "CONCAT COR COS COSH COUNT COUNT_STAR COV CONSTANTSIZE CUBEDIMENSIONS DIFF DISTINCT DOUBLEABS "
        + "DOUBLEAVG DOUBLEBASE DOUBLEMAX DOUBLEMIN DOUBLEROUND DOUBLESUM EXP FLOOR FLOATABS FLOATAVG "
        + "FLOATMAX FLOATMIN FLOATROUND FLOATSUM GENERICINVOKER INDEXOF INTABS INTAVG INTMAX INTMIN "
        + "INTSUM INVOKEFORDOUBLE INVOKEFORFLOAT INVOKEFORINT INVOKEFORLONG INVOKEFORSTRING INVOKER "
        + "ISEMPTY JSONLOADER JSONMETADATA JSONSTORAGE LAST_INDEX_OF LCFIRST LOG LOG10 LOWER LONGABS "
        + "LONGAVG LONGMAX LONGMIN LONGSUM MAX MIN MAPSIZE MONITOREDUDF NONDETERMINISTIC OUTPUTSCHEMA  "
        + "PIGSTORAGE PIGSTREAMING RANDOM REGEX_EXTRACT REGEX_EXTRACT_ALL REPLACE ROUND SIN SINH SIZE "
        + "SQRT STRSPLIT SUBSTRING SUM STRINGCONCAT STRINGMAX STRINGMIN STRINGSIZE TAN TANH TOBAG "
        + "TOKENIZE TOMAP TOP TOTUPLE TRIM TEXTLOADER TUPLESIZE UCFIRST UPPER UTF8STORAGECONVERTER ";

      // taken from QueryLexer.g
      var pKeywords = "VOID IMPORT RETURNS DEFINE LOAD FILTER FOREACH ORDER CUBE DISTINCT COGROUP "
        + "JOIN CROSS UNION SPLIT INTO IF OTHERWISE ALL AS BY USING INNER OUTER ONSCHEMA PARALLEL "
        + "PARTITION GROUP AND OR NOT GENERATE FLATTEN ASC DESC IS STREAM THROUGH STORE MAPREDUCE "
        + "SHIP CACHE INPUT OUTPUT STDERROR STDIN STDOUT LIMIT SAMPLE LEFT RIGHT FULL EQ GT LT GTE LTE "
        + "NEQ MATCHES TRUE FALSE DUMP";

      // data types
      var pTypes = "BOOLEAN INT LONG FLOAT DOUBLE CHARARRAY BYTEARRAY BAG TUPLE MAP ";

      CodeMirror.defineMIME("text/x-pig", {
        name: "pig",
        builtins: keywords(pBuiltins),
        keywords: keywords(pKeywords),
        types: keywords(pTypes)
      });

      CodeMirror.registerHelper("hintWords", "pig", (pBuiltins + pTypes + pKeywords).split(" "));
    }());

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function PowerShell(CodeMirror) {
    CodeMirror.defineMode('powershell', function() {
      function buildRegexp(patterns, options) {
        options = options || {};
        var prefix = options.prefix !== undefined ? options.prefix : '^';
        var suffix = options.suffix !== undefined ? options.suffix : '\\b';

        for (var i = 0; i < patterns.length; i++) {
          if (patterns[i] instanceof RegExp) {
            patterns[i] = patterns[i].source;
          }
          else {
            patterns[i] = patterns[i].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
          }
        }

        return new RegExp(prefix + '(' + patterns.join('|') + ')' + suffix, 'i');
      }

      var notCharacterOrDash = '(?=[^A-Za-z\\d\\-_]|$)';
      var varNames = /[\w\-:]/;
      var keywords = buildRegexp([
        /begin|break|catch|continue|data|default|do|dynamicparam/,
        /else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in/,
        /param|process|return|switch|throw|trap|try|until|where|while/
      ], { suffix: notCharacterOrDash });

      var punctuation = /[\[\]{},;`\.]|@[({]/;
      var wordOperators = buildRegexp([
        'f',
        /b?not/,
        /[ic]?split/, 'join',
        /is(not)?/, 'as',
        /[ic]?(eq|ne|[gl][te])/,
        /[ic]?(not)?(like|match|contains)/,
        /[ic]?replace/,
        /b?(and|or|xor)/
      ], { prefix: '-' });
      var symbolOperators = /[+\-*\/%]=|\+\+|--|\.\.|[+\-*&^%:=!|\/]|<(?!#)|(?!#)>/;
      var operators = buildRegexp([wordOperators, symbolOperators], { suffix: '' });

      var numbers = /^((0x[\da-f]+)|((\d+\.\d+|\d\.|\.\d+|\d+)(e[\+\-]?\d+)?))[ld]?([kmgtp]b)?/i;

      var identifiers = /^[A-Za-z\_][A-Za-z\-\_\d]*\b/;

      var symbolBuiltins = /[A-Z]:|%|\?/i;
      var namedBuiltins = buildRegexp([
        /Add-(Computer|Content|History|Member|PSSnapin|Type)/,
        /Checkpoint-Computer/,
        /Clear-(Content|EventLog|History|Host|Item(Property)?|Variable)/,
        /Compare-Object/,
        /Complete-Transaction/,
        /Connect-PSSession/,
        /ConvertFrom-(Csv|Json|SecureString|StringData)/,
        /Convert-Path/,
        /ConvertTo-(Csv|Html|Json|SecureString|Xml)/,
        /Copy-Item(Property)?/,
        /Debug-Process/,
        /Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
        /Disconnect-PSSession/,
        /Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
        /(Enter|Exit)-PSSession/,
        /Export-(Alias|Clixml|Console|Counter|Csv|FormatData|ModuleMember|PSSession)/,
        /ForEach-Object/,
        /Format-(Custom|List|Table|Wide)/,
        new RegExp('Get-(Acl|Alias|AuthenticodeSignature|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Counter|Credential'
          + '|Culture|Date|Event|EventLog|EventSubscriber|ExecutionPolicy|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job'
          + '|Location|Member|Module|PfxCertificate|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration'
          + '|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|Verb|WinEvent|WmiObject)'),
        /Group-Object/,
        /Import-(Alias|Clixml|Counter|Csv|LocalizedData|Module|PSSession)/,
        /ImportSystemModules/,
        /Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)/,
        /Join-Path/,
        /Limit-EventLog/,
        /Measure-(Command|Object)/,
        /Move-Item(Property)?/,
        new RegExp('New-(Alias|Event|EventLog|Item(Property)?|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile'
          + '|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy|WinEvent)'),
        /Out-(Default|File|GridView|Host|Null|Printer|String)/,
        /Pause/,
        /(Pop|Push)-Location/,
        /Read-Host/,
        /Receive-(Job|PSSession)/,
        /Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)/,
        /Remove-(Computer|Event|EventLog|Item(Property)?|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)/,
        /Rename-(Computer|Item(Property)?)/,
        /Reset-ComputerMachinePassword/,
        /Resolve-Path/,
        /Restart-(Computer|Service)/,
        /Restore-Computer/,
        /Resume-(Job|Service)/,
        /Save-Help/,
        /Select-(Object|String|Xml)/,
        /Send-MailMessage/,
        new RegExp('Set-(Acl|Alias|AuthenticodeSignature|Content|Date|ExecutionPolicy|Item(Property)?|Location|PSBreakpoint|PSDebug' +
                   '|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)'),
        /Show-(Command|ControlPanelItem|EventLog)/,
        /Sort-Object/,
        /Split-Path/,
        /Start-(Job|Process|Service|Sleep|Transaction|Transcript)/,
        /Stop-(Computer|Job|Process|Service|Transcript)/,
        /Suspend-(Job|Service)/,
        /TabExpansion2/,
        /Tee-Object/,
        /Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)/,
        /Trace-Command/,
        /Unblock-File/,
        /Undo-Transaction/,
        /Unregister-(Event|PSSessionConfiguration)/,
        /Update-(FormatData|Help|List|TypeData)/,
        /Use-Transaction/,
        /Wait-(Event|Job|Process)/,
        /Where-Object/,
        /Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning)/,
        /cd|help|mkdir|more|oss|prompt/,
        /ac|asnp|cat|cd|chdir|clc|clear|clhy|cli|clp|cls|clv|cnsn|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|dnsn|ebp/,
        /echo|epal|epcsv|epsn|erase|etsn|exsn|fc|fl|foreach|ft|fw|gal|gbp|gc|gci|gcm|gcs|gdr|ghy|gi|gjb|gl|gm|gmo|gp|gps/,
        /group|gsn|gsnp|gsv|gu|gv|gwmi|h|history|icm|iex|ihy|ii|ipal|ipcsv|ipmo|ipsn|irm|ise|iwmi|iwr|kill|lp|ls|man|md/,
        /measure|mi|mount|move|mp|mv|nal|ndr|ni|nmo|npssc|nsn|nv|ogv|oh|popd|ps|pushd|pwd|r|rbp|rcjb|rcsn|rd|rdr|ren|ri/,
        /rjb|rm|rmdir|rmo|rni|rnp|rp|rsn|rsnp|rujb|rv|rvpa|rwmi|sajb|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls/,
        /sort|sp|spjb|spps|spsv|start|sujb|sv|swmi|tee|trcm|type|where|wjb|write/
      ], { prefix: '', suffix: '' });
      var variableBuiltins = buildRegexp([
        /[$?^_]|Args|ConfirmPreference|ConsoleFileName|DebugPreference|Error|ErrorActionPreference|ErrorView|ExecutionContext/,
        /FormatEnumerationLimit|Home|Host|Input|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount/,
        /MaximumHistoryCount|MaximumVariableCount|MyInvocation|NestedPromptLevel|OutputEncoding|Pid|Profile|ProgressPreference/,
        /PSBoundParameters|PSCommandPath|PSCulture|PSDefaultParameterValues|PSEmailServer|PSHome|PSScriptRoot|PSSessionApplicationName/,
        /PSSessionConfigurationName|PSSessionOption|PSUICulture|PSVersionTable|Pwd|ShellId|StackTrace|VerbosePreference/,
        /WarningPreference|WhatIfPreference/,

        /Event|EventArgs|EventSubscriber|Sender/,
        /Matches|Ofs|ForEach|LastExitCode|PSCmdlet|PSItem|PSSenderInfo|This/,
        /true|false|null/
      ], { prefix: '\\$', suffix: '' });

      var builtins = buildRegexp([symbolBuiltins, namedBuiltins, variableBuiltins], { suffix: notCharacterOrDash });

      var grammar = {
        keyword: keywords,
        number: numbers,
        operator: operators,
        builtin: builtins,
        punctuation: punctuation,
        identifier: identifiers
      };

      // tokenizers
      function tokenBase(stream, state) {
        // Handle Comments
        //var ch = stream.peek();

        var parent = state.returnStack[state.returnStack.length - 1];
        if (parent && parent.shouldReturnFrom(state)) {
          state.tokenize = parent.tokenize;
          state.returnStack.pop();
          return state.tokenize(stream, state);
        }

        if (stream.eatSpace()) {
          return null;
        }

        if (stream.eat('(')) {
          state.bracketNesting += 1;
          return 'punctuation';
        }

        if (stream.eat(')')) {
          state.bracketNesting -= 1;
          return 'punctuation';
        }

        for (var key in grammar) {
          if (stream.match(grammar[key])) {
            return key;
          }
        }

        var ch = stream.next();

        // single-quote string
        if (ch === "'") {
          return tokenSingleQuoteString(stream, state);
        }

        if (ch === '$') {
          return tokenVariable(stream, state);
        }

        // double-quote string
        if (ch === '"') {
          return tokenDoubleQuoteString(stream, state);
        }

        if (ch === '<' && stream.eat('#')) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }

        if (ch === '#') {
          stream.skipToEnd();
          return 'comment';
        }

        if (ch === '@') {
          var quoteMatch = stream.eat(/["']/);
          if (quoteMatch && stream.eol()) {
            state.tokenize = tokenMultiString;
            state.startQuote = quoteMatch[0];
            return tokenMultiString(stream, state);
          } else if (stream.eol()) {
            return 'error';
          } else if (stream.peek().match(/[({]/)) {
            return 'punctuation';
          } else if (stream.peek().match(varNames)) {
            // splatted variable
            return tokenVariable(stream, state);
          }
        }
        return 'error';
      }

      function tokenSingleQuoteString(stream, state) {
        var ch;
        while ((ch = stream.peek()) != null) {
          stream.next();

          if (ch === "'" && !stream.eat("'")) {
            state.tokenize = tokenBase;
            return 'string';
          }
        }

        return 'error';
      }

      function tokenDoubleQuoteString(stream, state) {
        var ch;
        while ((ch = stream.peek()) != null) {
          if (ch === '$') {
            state.tokenize = tokenStringInterpolation;
            return 'string';
          }

          stream.next();
          if (ch === '`') {
            stream.next();
            continue;
          }

          if (ch === '"' && !stream.eat('"')) {
            state.tokenize = tokenBase;
            return 'string';
          }
        }

        return 'error';
      }

      function tokenStringInterpolation(stream, state) {
        return tokenInterpolation(stream, state, tokenDoubleQuoteString);
      }

      function tokenMultiStringReturn(stream, state) {
        state.tokenize = tokenMultiString;
        state.startQuote = '"';
        return tokenMultiString(stream, state);
      }

      function tokenHereStringInterpolation(stream, state) {
        return tokenInterpolation(stream, state, tokenMultiStringReturn);
      }

      function tokenInterpolation(stream, state, parentTokenize) {
        if (stream.match('$(')) {
          var savedBracketNesting = state.bracketNesting;
          state.returnStack.push({
            /*jshint loopfunc:true */
            shouldReturnFrom: function(state) {
              return state.bracketNesting === savedBracketNesting;
            },
            tokenize: parentTokenize
          });
          state.tokenize = tokenBase;
          state.bracketNesting += 1;
          return 'punctuation';
        } else {
          stream.next();
          state.returnStack.push({
            shouldReturnFrom: function() { return true; },
            tokenize: parentTokenize
          });
          state.tokenize = tokenVariable;
          return state.tokenize(stream, state);
        }
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == '>') {
              state.tokenize = tokenBase;
              break;
          }
          maybeEnd = (ch === '#');
        }
        return 'comment';
      }

      function tokenVariable(stream, state) {
        var ch = stream.peek();
        if (stream.eat('{')) {
          state.tokenize = tokenVariableWithBraces;
          return tokenVariableWithBraces(stream, state);
        } else if (ch != undefined && ch.match(varNames)) {
          stream.eatWhile(varNames);
          state.tokenize = tokenBase;
          return 'variable-2';
        } else {
          state.tokenize = tokenBase;
          return 'error';
        }
      }

      function tokenVariableWithBraces(stream, state) {
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch === '}') {
            state.tokenize = tokenBase;
            break;
          }
        }
        return 'variable-2';
      }

      function tokenMultiString(stream, state) {
        var quote = state.startQuote;
        if (stream.sol() && stream.match(new RegExp(quote + '@'))) {
          state.tokenize = tokenBase;
        }
        else if (quote === '"') {
          while (!stream.eol()) {
            var ch = stream.peek();
            if (ch === '$') {
              state.tokenize = tokenHereStringInterpolation;
              return 'string';
            }

            stream.next();
            if (ch === '`') {
              stream.next();
            }
          }
        }
        else {
          stream.skipToEnd();
        }

        return 'string';
      }

      var external = {
        startState: function() {
          return {
            returnStack: [],
            bracketNesting: 0,
            tokenize: tokenBase
          };
        },

        token: function(stream, state) {
          return state.tokenize(stream, state);
        },

        blockCommentStart: '<#',
        blockCommentEnd: '#>',
        lineComment: '#',
        fold: 'brace'
      };
      return external;
    });

    CodeMirror.defineMIME('application/x-powershell', 'powershell');
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Properties(CodeMirror) {
    CodeMirror.defineMode("properties", function() {
      return {
        token: function(stream, state) {
          var sol = stream.sol() || state.afterSection;
          var eol = stream.eol();

          state.afterSection = false;

          if (sol) {
            if (state.nextMultiline) {
              state.inMultiline = true;
              state.nextMultiline = false;
            } else {
              state.position = "def";
            }
          }

          if (eol && ! state.nextMultiline) {
            state.inMultiline = false;
            state.position = "def";
          }

          if (sol) {
            while(stream.eatSpace()) {}
          }

          var ch = stream.next();

          if (sol && (ch === "#" || ch === "!" || ch === ";")) {
            state.position = "comment";
            stream.skipToEnd();
            return "comment";
          } else if (sol && ch === "[") {
            state.afterSection = true;
            stream.skipTo("]"); stream.eat("]");
            return "header";
          } else if (ch === "=" || ch === ":") {
            state.position = "quote";
            return null;
          } else if (ch === "\\" && state.position === "quote") {
            if (stream.eol()) {  // end of line?
              // Multiline value
              state.nextMultiline = true;
            }
          }

          return state.position;
        },

        startState: function() {
          return {
            position : "def",       // Current position, "def", "quote" or "comment"
            nextMultiline : false,  // Is the next line multiline value
            inMultiline : false,    // Is the current line a multiline value
            afterSection : false    // Did we just open a section
          };
        }

      };
    });

    CodeMirror.defineMIME("text/x-properties", "properties");
    CodeMirror.defineMIME("text/x-ini", "properties");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Protobuf(CodeMirror) {
      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
      }
      var keywordArray = [
        "package", "message", "import", "syntax",
        "required", "optional", "repeated", "reserved", "default", "extensions", "packed",
        "bool", "bytes", "double", "enum", "float", "string",
        "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64",
        "option", "service", "rpc", "returns"
      ];
      var keywords = wordRegexp(keywordArray);

      CodeMirror.registerHelper("hintWords", "protobuf", keywordArray);

      var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

      function tokenBase(stream) {
        // whitespaces
        if (stream.eatSpace()) return null;

        // Handle one line Comments
        if (stream.match("//")) {
          stream.skipToEnd();
          return "comment";
        }

        // Handle Number Literals
        if (stream.match(/^[0-9\.+-]/, false)) {
          if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))
            return "number";
          if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?/))
            return "number";
          if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?/))
            return "number";
        }

        // Handle Strings
        if (stream.match(/^"([^"]|(""))*"/)) { return "string"; }
        if (stream.match(/^'([^']|(''))*'/)) { return "string"; }

        // Handle words
        if (stream.match(keywords)) { return "keyword"; }
        if (stream.match(identifiers)) { return "variable"; }
        // Handle non-detected items
        stream.next();
        return null;
      }
      CodeMirror.defineMode("protobuf", function() {
        return {token: tokenBase};
      });

      CodeMirror.defineMIME("text/x-protobuf", "protobuf");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Pug(CodeMirror) {
    CodeMirror.defineMode("pug", function (config) {
      // token types
      var KEYWORD = 'keyword';
      var DOCTYPE = 'meta';
      var ID = 'builtin';
      var CLASS = 'qualifier';

      var ATTRS_NEST = {
        '{': '}',
        '(': ')',
        '[': ']'
      };

      var jsMode = CodeMirror.getMode(config, 'javascript');

      function State() {
        this.javaScriptLine = false;
        this.javaScriptLineExcludesColon = false;

        this.javaScriptArguments = false;
        this.javaScriptArgumentsDepth = 0;

        this.isInterpolating = false;
        this.interpolationNesting = 0;

        this.jsState = CodeMirror.startState(jsMode);

        this.restOfLine = '';

        this.isIncludeFiltered = false;
        this.isEach = false;

        this.lastTag = '';
        this.scriptType = '';

        // Attributes Mode
        this.isAttrs = false;
        this.attrsNest = [];
        this.inAttributeName = true;
        this.attributeIsType = false;
        this.attrValue = '';

        // Indented Mode
        this.indentOf = Infinity;
        this.indentToken = '';

        this.innerMode = null;
        this.innerState = null;

        this.innerModeForLine = false;
      }
      /**
       * Safely copy a state
       *
       * @return {State}
       */
      State.prototype.copy = function () {
        var res = new State();
        res.javaScriptLine = this.javaScriptLine;
        res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;
        res.javaScriptArguments = this.javaScriptArguments;
        res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;
        res.isInterpolating = this.isInterpolating;
        res.interpolationNesting = this.interpolationNesting;

        res.jsState = CodeMirror.copyState(jsMode, this.jsState);

        res.innerMode = this.innerMode;
        if (this.innerMode && this.innerState) {
          res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);
        }

        res.restOfLine = this.restOfLine;

        res.isIncludeFiltered = this.isIncludeFiltered;
        res.isEach = this.isEach;
        res.lastTag = this.lastTag;
        res.scriptType = this.scriptType;
        res.isAttrs = this.isAttrs;
        res.attrsNest = this.attrsNest.slice();
        res.inAttributeName = this.inAttributeName;
        res.attributeIsType = this.attributeIsType;
        res.attrValue = this.attrValue;
        res.indentOf = this.indentOf;
        res.indentToken = this.indentToken;

        res.innerModeForLine = this.innerModeForLine;

        return res;
      };

      function javaScript(stream, state) {
        if (stream.sol()) {
          // if javaScriptLine was set at end of line, ignore it
          state.javaScriptLine = false;
          state.javaScriptLineExcludesColon = false;
        }
        if (state.javaScriptLine) {
          if (state.javaScriptLineExcludesColon && stream.peek() === ':') {
            state.javaScriptLine = false;
            state.javaScriptLineExcludesColon = false;
            return;
          }
          var tok = jsMode.token(stream, state.jsState);
          if (stream.eol()) state.javaScriptLine = false;
          return tok || true;
        }
      }
      function javaScriptArguments(stream, state) {
        if (state.javaScriptArguments) {
          if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== '(') {
            state.javaScriptArguments = false;
            return;
          }
          if (stream.peek() === '(') {
            state.javaScriptArgumentsDepth++;
          } else if (stream.peek() === ')') {
            state.javaScriptArgumentsDepth--;
          }
          if (state.javaScriptArgumentsDepth === 0) {
            state.javaScriptArguments = false;
            return;
          }

          var tok = jsMode.token(stream, state.jsState);
          return tok || true;
        }
      }

      function yieldStatement(stream) {
        if (stream.match(/^yield\b/)) {
            return 'keyword';
        }
      }

      function doctype(stream) {
        if (stream.match(/^(?:doctype) *([^\n]+)?/)) {
            return DOCTYPE;
        }
      }

      function interpolation(stream, state) {
        if (stream.match('#{')) {
          state.isInterpolating = true;
          state.interpolationNesting = 0;
          return 'punctuation';
        }
      }

      function interpolationContinued(stream, state) {
        if (state.isInterpolating) {
          if (stream.peek() === '}') {
            state.interpolationNesting--;
            if (state.interpolationNesting < 0) {
              stream.next();
              state.isInterpolating = false;
              return 'punctuation';
            }
          } else if (stream.peek() === '{') {
            state.interpolationNesting++;
          }
          return jsMode.token(stream, state.jsState) || true;
        }
      }

      function caseStatement(stream, state) {
        if (stream.match(/^case\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function when(stream, state) {
        if (stream.match(/^when\b/)) {
          state.javaScriptLine = true;
          state.javaScriptLineExcludesColon = true;
          return KEYWORD;
        }
      }

      function defaultStatement(stream) {
        if (stream.match(/^default\b/)) {
          return KEYWORD;
        }
      }

      function extendsStatement(stream, state) {
        if (stream.match(/^extends?\b/)) {
          state.restOfLine = 'string';
          return KEYWORD;
        }
      }

      function append(stream, state) {
        if (stream.match(/^append\b/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }
      function prepend(stream, state) {
        if (stream.match(/^prepend\b/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }
      function block(stream, state) {
        if (stream.match(/^block\b *(?:(prepend|append)\b)?/)) {
          state.restOfLine = 'variable';
          return KEYWORD;
        }
      }

      function include(stream, state) {
        if (stream.match(/^include\b/)) {
          state.restOfLine = 'string';
          return KEYWORD;
        }
      }

      function includeFiltered(stream, state) {
        if (stream.match(/^include:([a-zA-Z0-9\-]+)/, false) && stream.match('include')) {
          state.isIncludeFiltered = true;
          return KEYWORD;
        }
      }

      function includeFilteredContinued(stream, state) {
        if (state.isIncludeFiltered) {
          var tok = filter(stream, state);
          state.isIncludeFiltered = false;
          state.restOfLine = 'string';
          return tok;
        }
      }

      function mixin(stream, state) {
        if (stream.match(/^mixin\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function call(stream, state) {
        if (stream.match(/^\+([-\w]+)/)) {
          if (!stream.match(/^\( *[-\w]+ *=/, false)) {
            state.javaScriptArguments = true;
            state.javaScriptArgumentsDepth = 0;
          }
          return 'variable';
        }
        if (stream.match(/^\+#{/, false)) {
          stream.next();
          state.mixinCallAfter = true;
          return interpolation(stream, state);
        }
      }
      function callArguments(stream, state) {
        if (state.mixinCallAfter) {
          state.mixinCallAfter = false;
          if (!stream.match(/^\( *[-\w]+ *=/, false)) {
            state.javaScriptArguments = true;
            state.javaScriptArgumentsDepth = 0;
          }
          return true;
        }
      }

      function conditional(stream, state) {
        if (stream.match(/^(if|unless|else if|else)\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function each(stream, state) {
        if (stream.match(/^(- *)?(each|for)\b/)) {
          state.isEach = true;
          return KEYWORD;
        }
      }
      function eachContinued(stream, state) {
        if (state.isEach) {
          if (stream.match(/^ in\b/)) {
            state.javaScriptLine = true;
            state.isEach = false;
            return KEYWORD;
          } else if (stream.sol() || stream.eol()) {
            state.isEach = false;
          } else if (stream.next()) {
            while (!stream.match(/^ in\b/, false) && stream.next());
            return 'variable';
          }
        }
      }

      function whileStatement(stream, state) {
        if (stream.match(/^while\b/)) {
          state.javaScriptLine = true;
          return KEYWORD;
        }
      }

      function tag(stream, state) {
        var captures;
        if (captures = stream.match(/^(\w(?:[-:\w]*\w)?)\/?/)) {
          state.lastTag = captures[1].toLowerCase();
          if (state.lastTag === 'script') {
            state.scriptType = 'application/javascript';
          }
          return 'tag';
        }
      }

      function filter(stream, state) {
        if (stream.match(/^:([\w\-]+)/)) {
          var innerMode;
          if (config && config.innerModes) {
            innerMode = config.innerModes(stream.current().substring(1));
          }
          if (!innerMode) {
            innerMode = stream.current().substring(1);
          }
          if (typeof innerMode === 'string') {
            innerMode = CodeMirror.getMode(config, innerMode);
          }
          setInnerMode(stream, state, innerMode);
          return 'atom';
        }
      }

      function code(stream, state) {
        if (stream.match(/^(!?=|-)/)) {
          state.javaScriptLine = true;
          return 'punctuation';
        }
      }

      function id(stream) {
        if (stream.match(/^#([\w-]+)/)) {
          return ID;
        }
      }

      function className(stream) {
        if (stream.match(/^\.([\w-]+)/)) {
          return CLASS;
        }
      }

      function attrs(stream, state) {
        if (stream.peek() == '(') {
          stream.next();
          state.isAttrs = true;
          state.attrsNest = [];
          state.inAttributeName = true;
          state.attrValue = '';
          state.attributeIsType = false;
          return 'punctuation';
        }
      }

      function attrsContinued(stream, state) {
        if (state.isAttrs) {
          if (ATTRS_NEST[stream.peek()]) {
            state.attrsNest.push(ATTRS_NEST[stream.peek()]);
          }
          if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {
            state.attrsNest.pop();
          } else  if (stream.eat(')')) {
            state.isAttrs = false;
            return 'punctuation';
          }
          if (state.inAttributeName && stream.match(/^[^=,\)!]+/)) {
            if (stream.peek() === '=' || stream.peek() === '!') {
              state.inAttributeName = false;
              state.jsState = CodeMirror.startState(jsMode);
              if (state.lastTag === 'script' && stream.current().trim().toLowerCase() === 'type') {
                state.attributeIsType = true;
              } else {
                state.attributeIsType = false;
              }
            }
            return 'attribute';
          }

          var tok = jsMode.token(stream, state.jsState);
          if (state.attributeIsType && tok === 'string') {
            state.scriptType = stream.current().toString();
          }
          if (state.attrsNest.length === 0 && (tok === 'string' || tok === 'variable' || tok === 'keyword')) {
            try {
              Function('', 'var x ' + state.attrValue.replace(/,\s*$/, '').replace(/^!/, ''));
              state.inAttributeName = true;
              state.attrValue = '';
              stream.backUp(stream.current().length);
              return attrsContinued(stream, state);
            } catch (ex) {
              //not the end of an attribute
            }
          }
          state.attrValue += stream.current();
          return tok || true;
        }
      }

      function attributesBlock(stream, state) {
        if (stream.match(/^&attributes\b/)) {
          state.javaScriptArguments = true;
          state.javaScriptArgumentsDepth = 0;
          return 'keyword';
        }
      }

      function indent(stream) {
        if (stream.sol() && stream.eatSpace()) {
          return 'indent';
        }
      }

      function comment(stream, state) {
        if (stream.match(/^ *\/\/(-)?([^\n]*)/)) {
          state.indentOf = stream.indentation();
          state.indentToken = 'comment';
          return 'comment';
        }
      }

      function colon(stream) {
        if (stream.match(/^: */)) {
          return 'colon';
        }
      }

      function text(stream, state) {
        if (stream.match(/^(?:\| ?| )([^\n]+)/)) {
          return 'string';
        }
        if (stream.match(/^(<[^\n]*)/, false)) {
          // html string
          setInnerMode(stream, state, 'htmlmixed');
          state.innerModeForLine = true;
          return innerMode(stream, state, true);
        }
      }

      function dot(stream, state) {
        if (stream.eat('.')) {
          var innerMode = null;
          if (state.lastTag === 'script' && state.scriptType.toLowerCase().indexOf('javascript') != -1) {
            innerMode = state.scriptType.toLowerCase().replace(/"|'/g, '');
          } else if (state.lastTag === 'style') {
            innerMode = 'css';
          }
          setInnerMode(stream, state, innerMode);
          return 'dot';
        }
      }

      function fail(stream) {
        stream.next();
        return null;
      }


      function setInnerMode(stream, state, mode) {
        mode = CodeMirror.mimeModes[mode] || mode;
        mode = config.innerModes ? config.innerModes(mode) || mode : mode;
        mode = CodeMirror.mimeModes[mode] || mode;
        mode = CodeMirror.getMode(config, mode);
        state.indentOf = stream.indentation();

        if (mode && mode.name !== 'null') {
          state.innerMode = mode;
        } else {
          state.indentToken = 'string';
        }
      }
      function innerMode(stream, state, force) {
        if (stream.indentation() > state.indentOf || (state.innerModeForLine && !stream.sol()) || force) {
          if (state.innerMode) {
            if (!state.innerState) {
              state.innerState = state.innerMode.startState ? CodeMirror.startState(state.innerMode, stream.indentation()) : {};
            }
            return stream.hideFirstChars(state.indentOf + 2, function () {
              return state.innerMode.token(stream, state.innerState) || true;
            });
          } else {
            stream.skipToEnd();
            return state.indentToken;
          }
        } else if (stream.sol()) {
          state.indentOf = Infinity;
          state.indentToken = null;
          state.innerMode = null;
          state.innerState = null;
        }
      }
      function restOfLine(stream, state) {
        if (stream.sol()) {
          // if restOfLine was set at end of line, ignore it
          state.restOfLine = '';
        }
        if (state.restOfLine) {
          stream.skipToEnd();
          var tok = state.restOfLine;
          state.restOfLine = '';
          return tok;
        }
      }


      function startState() {
        return new State();
      }
      function copyState(state) {
        return state.copy();
      }
      /**
       * Get the next token in the stream
       *
       * @param {Stream} stream
       * @param {State} state
       */
      function nextToken(stream, state) {
        var tok = innerMode(stream, state)
          || restOfLine(stream, state)
          || interpolationContinued(stream, state)
          || includeFilteredContinued(stream, state)
          || eachContinued(stream, state)
          || attrsContinued(stream, state)
          || javaScript(stream, state)
          || javaScriptArguments(stream, state)
          || callArguments(stream, state)

          || yieldStatement(stream, state)
          || doctype(stream, state)
          || interpolation(stream, state)
          || caseStatement(stream, state)
          || when(stream, state)
          || defaultStatement(stream, state)
          || extendsStatement(stream, state)
          || append(stream, state)
          || prepend(stream, state)
          || block(stream, state)
          || include(stream, state)
          || includeFiltered(stream, state)
          || mixin(stream, state)
          || call(stream, state)
          || conditional(stream, state)
          || each(stream, state)
          || whileStatement(stream, state)
          || tag(stream, state)
          || filter(stream, state)
          || code(stream, state)
          || id(stream, state)
          || className(stream, state)
          || attrs(stream, state)
          || attributesBlock(stream, state)
          || indent(stream, state)
          || text(stream, state)
          || comment(stream, state)
          || colon(stream, state)
          || dot(stream, state)
          || fail(stream, state);

        return tok === true ? null : tok;
      }
      return {
        startState: startState,
        copyState: copyState,
        token: nextToken
      };
    }, 'javascript', 'css', 'htmlmixed');

    CodeMirror.defineMIME('text/x-pug', 'pug');
    CodeMirror.defineMIME('text/x-jade', 'pug');

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Puppet(CodeMirror) {
    CodeMirror.defineMode("puppet", function () {
      // Stores the words from the define method
      var words = {};
      // Taken, mostly, from the Puppet official variable standards regex
      var variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/;

      // Takes a string of words separated by spaces and adds them as
      // keys with the value of the first argument 'style'
      function define(style, string) {
        var split = string.split(' ');
        for (var i = 0; i < split.length; i++) {
          words[split[i]] = style;
        }
      }

      // Takes commonly known puppet types/words and classifies them to a style
      define('keyword', 'class define site node include import inherits');
      define('keyword', 'case if else in and elsif default or');
      define('atom', 'false true running present absent file directory undef');
      define('builtin', 'action augeas burst chain computer cron destination dport exec ' +
        'file filebucket group host icmp iniface interface jump k5login limit log_level ' +
        'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' +
        'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' +
        'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' +
        'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' +
        'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' +
        'resources router schedule scheduled_task selboolean selmodule service source ' +
        'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' +
        'user vlan yumrepo zfs zone zpool');

      // After finding a start of a string ('|") this function attempts to find the end;
      // If a variable is encountered along the way, we display it differently when it
      // is encapsulated in a double-quoted string.
      function tokenString(stream, state) {
        var current, prev, found_var = false;
        while (!stream.eol() && (current = stream.next()) != state.pending) {
          if (current === '$' && prev != '\\' && state.pending == '"') {
            found_var = true;
            break;
          }
          prev = current;
        }
        if (found_var) {
          stream.backUp(1);
        }
        if (current == state.pending) {
          state.continueString = false;
        } else {
          state.continueString = true;
        }
        return "string";
      }

      // Main function
      function tokenize(stream, state) {
        // Matches one whole word
        var word = stream.match(/[\w]+/, false);
        // Matches attributes (i.e. ensure => present ; 'ensure' would be matched)
        var attribute = stream.match(/(\s+)?\w+\s+=>.*/, false);
        // Matches non-builtin resource declarations
        // (i.e. "apache::vhost {" or "mycustomclasss {" would be matched)
        var resource = stream.match(/(\s+)?[\w:_]+(\s+)?{/, false);
        // Matches virtual and exported resources (i.e. @@user { ; and the like)
        var special_resource = stream.match(/(\s+)?[@]{1,2}[\w:_]+(\s+)?{/, false);

        // Finally advance the stream
        var ch = stream.next();

        // Have we found a variable?
        if (ch === '$') {
          if (stream.match(variable_regex)) {
            // If so, and its in a string, assign it a different color
            return state.continueString ? 'variable-2' : 'variable';
          }
          // Otherwise return an invalid variable
          return "error";
        }
        // Should we still be looking for the end of a string?
        if (state.continueString) {
          // If so, go through the loop again
          stream.backUp(1);
          return tokenString(stream, state);
        }
        // Are we in a definition (class, node, define)?
        if (state.inDefinition) {
          // If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)
          if (stream.match(/(\s+)?[\w:_]+(\s+)?/)) {
            return 'def';
          }
          // Match the rest it the next time around
          stream.match(/\s+{/);
          state.inDefinition = false;
        }
        // Are we in an 'include' statement?
        if (state.inInclude) {
          // Match and return the included class
          stream.match(/(\s+)?\S+(\s+)?/);
          state.inInclude = false;
          return 'def';
        }
        // Do we just have a function on our hands?
        // In 'ensure_resource("myclass")', 'ensure_resource' is matched
        if (stream.match(/(\s+)?\w+\(/)) {
          stream.backUp(1);
          return 'def';
        }
        // Have we matched the prior attribute regex?
        if (attribute) {
          stream.match(/(\s+)?\w+/);
          return 'tag';
        }
        // Do we have Puppet specific words?
        if (word && words.hasOwnProperty(word)) {
          // Negates the initial next()
          stream.backUp(1);
          // rs move the stream
          stream.match(/[\w]+/);
          // We want to process these words differently
          // do to the importance they have in Puppet
          if (stream.match(/\s+\S+\s+{/, false)) {
            state.inDefinition = true;
          }
          if (word == 'include') {
            state.inInclude = true;
          }
          // Returns their value as state in the prior define methods
          return words[word];
        }
        // Is there a match on a reference?
        if (/(^|\s+)[A-Z][\w:_]+/.test(word)) {
          // Negate the next()
          stream.backUp(1);
          // Match the full reference
          stream.match(/(^|\s+)[A-Z][\w:_]+/);
          return 'def';
        }
        // Have we matched the prior resource regex?
        if (resource) {
          stream.match(/(\s+)?[\w:_]+/);
          return 'def';
        }
        // Have we matched the prior special_resource regex?
        if (special_resource) {
          stream.match(/(\s+)?[@]{1,2}/);
          return 'special';
        }
        // Match all the comments. All of them.
        if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        // Have we found a string?
        if (ch == "'" || ch == '"') {
          // Store the type (single or double)
          state.pending = ch;
          // Perform the looping function to find the end
          return tokenString(stream, state);
        }
        // Match all the brackets
        if (ch == '{' || ch == '}') {
          return 'bracket';
        }
        // Match characters that we are going to assume
        // are trying to be regex
        if (ch == '/') {
          stream.match(/.*?\//);
          return 'variable-3';
        }
        // Match all the numbers
        if (ch.match(/[0-9]/)) {
          stream.eatWhile(/[0-9]+/);
          return 'number';
        }
        // Match the '=' and '=>' operators
        if (ch == '=') {
          if (stream.peek() == '>') {
              stream.next();
          }
          return "operator";
        }
        // Keep advancing through all the rest
        stream.eatWhile(/[\w-]/);
        // Return a blank line for everything else
        return null;
      }
      // Start it all
      return {
        startState: function () {
          var state = {};
          state.inDefinition = false;
          state.inInclude = false;
          state.continueString = false;
          state.pending = false;
          return state;
        },
        token: function (stream, state) {
          // Strip the spaces, but regex will account for them eitherway
          if (stream.eatSpace()) return null;
          // Go through the main process
          return tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME("text/x-puppet", "puppet");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Python(CodeMirror) {
      function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      var wordOperators = wordRegexp(["and", "or", "not", "is"]);
      var commonKeywords = ["as", "assert", "break", "class", "continue",
                            "def", "del", "elif", "else", "except", "finally",
                            "for", "from", "global", "if", "import",
                            "lambda", "pass", "raise", "return",
                            "try", "while", "with", "yield", "in"];
      var commonBuiltins = ["abs", "all", "any", "bin", "bool", "bytearray", "callable", "chr",
                            "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod",
                            "enumerate", "eval", "filter", "float", "format", "frozenset",
                            "getattr", "globals", "hasattr", "hash", "help", "hex", "id",
                            "input", "int", "isinstance", "issubclass", "iter", "len",
                            "list", "locals", "map", "max", "memoryview", "min", "next",
                            "object", "oct", "open", "ord", "pow", "property", "range",
                            "repr", "reversed", "round", "set", "setattr", "slice",
                            "sorted", "staticmethod", "str", "sum", "super", "tuple",
                            "type", "vars", "zip", "__import__", "NotImplemented",
                            "Ellipsis", "__debug__"];
      CodeMirror.registerHelper("hintWords", "python", commonKeywords.concat(commonBuiltins));

      function top(state) {
        return state.scopes[state.scopes.length - 1];
      }

      CodeMirror.defineMode("python", function(conf, parserConf) {
        var ERRORCLASS = "error";

        var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\(\)\[\]\{\}@,:`=;\.\\]/;
        //               (Backwards-compatiblity with old, cumbersome config system)
        var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,
                         parserConf.operators || /^([-+*/%\/&|^]=?|[<>=]+|\/\/=?|\*\*=?|!=|[~!@])/];
        for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1);

        var hangingIndent = parserConf.hangingIndent || conf.indentUnit;

        var myKeywords = commonKeywords, myBuiltins = commonBuiltins;
        if (parserConf.extra_keywords != undefined)
          myKeywords = myKeywords.concat(parserConf.extra_keywords);

        if (parserConf.extra_builtins != undefined)
          myBuiltins = myBuiltins.concat(parserConf.extra_builtins);

        var py3 = !(parserConf.version && Number(parserConf.version) < 3);
        if (py3) {
          // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator
          var identifiers = parserConf.identifiers|| /^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;
          myKeywords = myKeywords.concat(["nonlocal", "False", "True", "None", "async", "await"]);
          myBuiltins = myBuiltins.concat(["ascii", "bytes", "exec", "print"]);
          var stringPrefixes = new RegExp("^(([rbuf]|(br)|(fr))?('{3}|\"{3}|['\"]))", "i");
        } else {
          var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;
          myKeywords = myKeywords.concat(["exec", "print"]);
          myBuiltins = myBuiltins.concat(["apply", "basestring", "buffer", "cmp", "coerce", "execfile",
                                          "file", "intern", "long", "raw_input", "reduce", "reload",
                                          "unichr", "unicode", "xrange", "False", "True", "None"]);
          var stringPrefixes = new RegExp("^(([rubf]|(ur)|(br))?('{3}|\"{3}|['\"]))", "i");
        }
        var keywords = wordRegexp(myKeywords);
        var builtins = wordRegexp(myBuiltins);

        // tokenizers
        function tokenBase(stream, state) {
          var sol = stream.sol() && state.lastToken != "\\";
          if (sol) state.indent = stream.indentation();
          // Handle scope changes
          if (sol && top(state).type == "py") {
            var scopeOffset = top(state).offset;
            if (stream.eatSpace()) {
              var lineOffset = stream.indentation();
              if (lineOffset > scopeOffset)
                pushPyScope(state);
              else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != "#")
                state.errorToken = true;
              return null;
            } else {
              var style = tokenBaseInner(stream, state);
              if (scopeOffset > 0 && dedent(stream, state))
                style += " " + ERRORCLASS;
              return style;
            }
          }
          return tokenBaseInner(stream, state);
        }

        function tokenBaseInner(stream, state) {
          if (stream.eatSpace()) return null;

          // Handle Comments
          if (stream.match(/^#.*/)) return "comment";

          // Handle Number Literals
          if (stream.match(/^[0-9\.]/, false)) {
            var floatLiteral = false;
            // Floats
            if (stream.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i)) { floatLiteral = true; }
            if (stream.match(/^[\d_]+\.\d*/)) { floatLiteral = true; }
            if (stream.match(/^\.\d+/)) { floatLiteral = true; }
            if (floatLiteral) {
              // Float literals may be "imaginary"
              stream.eat(/J/i);
              return "number";
            }
            // Integers
            var intLiteral = false;
            // Hex
            if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;
            // Binary
            if (stream.match(/^0b[01_]+/i)) intLiteral = true;
            // Octal
            if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;
            // Decimal
            if (stream.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/)) {
              // Decimal literals may be "imaginary"
              stream.eat(/J/i);
              // TODO - Can you have imaginary longs?
              intLiteral = true;
            }
            // Zero by itself with no other piece of number.
            if (stream.match(/^0(?![\dx])/i)) intLiteral = true;
            if (intLiteral) {
              // Integer literals may be "long"
              stream.eat(/L/i);
              return "number";
            }
          }

          // Handle Strings
          if (stream.match(stringPrefixes)) {
            var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;
            if (!isFmtString) {
              state.tokenize = tokenStringFactory(stream.current(), state.tokenize);
              return state.tokenize(stream, state);
            } else {
              state.tokenize = formatStringFactory(stream.current(), state.tokenize);
              return state.tokenize(stream, state);
            }
          }

          for (var i = 0; i < operators.length; i++)
            if (stream.match(operators[i])) return "operator"

          if (stream.match(delimiters)) return "punctuation";

          if (state.lastToken == "." && stream.match(identifiers))
            return "property";

          if (stream.match(keywords) || stream.match(wordOperators))
            return "keyword";

          if (stream.match(builtins))
            return "builtin";

          if (stream.match(/^(self|cls)\b/))
            return "variable-2";

          if (stream.match(identifiers)) {
            if (state.lastToken == "def" || state.lastToken == "class")
              return "def";
            return "variable";
          }

          // Handle non-detected items
          stream.next();
          return ERRORCLASS;
        }

        function formatStringFactory(delimiter, tokenOuter) {
          while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
            delimiter = delimiter.substr(1);

          var singleline = delimiter.length == 1;
          var OUTCLASS = "string";

          function tokenNestedExpr(depth) {
            return function(stream, state) {
              var inner = tokenBaseInner(stream, state);
              if (inner == "punctuation") {
                if (stream.current() == "{") {
                  state.tokenize = tokenNestedExpr(depth + 1);
                } else if (stream.current() == "}") {
                  if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1);
                  else state.tokenize = tokenString;
                }
              }
              return inner
            }
          }

          function tokenString(stream, state) {
            while (!stream.eol()) {
              stream.eatWhile(/[^'"\{\}\\]/);
              if (stream.eat("\\")) {
                stream.next();
                if (singleline && stream.eol())
                  return OUTCLASS;
              } else if (stream.match(delimiter)) {
                state.tokenize = tokenOuter;
                return OUTCLASS;
              } else if (stream.match('{{')) {
                // ignore {{ in f-str
                return OUTCLASS;
              } else if (stream.match('{', false)) {
                // switch to nested mode
                state.tokenize = tokenNestedExpr(0);
                if (stream.current()) return OUTCLASS;
                else return state.tokenize(stream, state)
              } else if (stream.match('}}')) {
                return OUTCLASS;
              } else if (stream.match('}')) {
                // single } in f-string is an error
                return ERRORCLASS;
              } else {
                stream.eat(/['"]/);
              }
            }
            if (singleline) {
              if (parserConf.singleLineStringErrors)
                return ERRORCLASS;
              else
                state.tokenize = tokenOuter;
            }
            return OUTCLASS;
          }
          tokenString.isString = true;
          return tokenString;
        }

        function tokenStringFactory(delimiter, tokenOuter) {
          while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
            delimiter = delimiter.substr(1);

          var singleline = delimiter.length == 1;
          var OUTCLASS = "string";

          function tokenString(stream, state) {
            while (!stream.eol()) {
              stream.eatWhile(/[^'"\\]/);
              if (stream.eat("\\")) {
                stream.next();
                if (singleline && stream.eol())
                  return OUTCLASS;
              } else if (stream.match(delimiter)) {
                state.tokenize = tokenOuter;
                return OUTCLASS;
              } else {
                stream.eat(/['"]/);
              }
            }
            if (singleline) {
              if (parserConf.singleLineStringErrors)
                return ERRORCLASS;
              else
                state.tokenize = tokenOuter;
            }
            return OUTCLASS;
          }
          tokenString.isString = true;
          return tokenString;
        }

        function pushPyScope(state) {
          while (top(state).type != "py") state.scopes.pop();
          state.scopes.push({offset: top(state).offset + conf.indentUnit,
                             type: "py",
                             align: null});
        }

        function pushBracketScope(stream, state, type) {
          var align = stream.match(/^([\s\[\{\(]|#.*)*$/, false) ? null : stream.column() + 1;
          state.scopes.push({offset: state.indent + hangingIndent,
                             type: type,
                             align: align});
        }

        function dedent(stream, state) {
          var indented = stream.indentation();
          while (state.scopes.length > 1 && top(state).offset > indented) {
            if (top(state).type != "py") return true;
            state.scopes.pop();
          }
          return top(state).offset != indented;
        }

        function tokenLexer(stream, state) {
          if (stream.sol()) state.beginningOfLine = true;

          var style = state.tokenize(stream, state);
          var current = stream.current();

          // Handle decorators
          if (state.beginningOfLine && current == "@")
            return stream.match(identifiers, false) ? "meta" : py3 ? "operator" : ERRORCLASS;

          if (/\S/.test(current)) state.beginningOfLine = false;

          if ((style == "variable" || style == "builtin")
              && state.lastToken == "meta")
            style = "meta";

          // Handle scope changes.
          if (current == "pass" || current == "return")
            state.dedent += 1;

          if (current == "lambda") state.lambda = true;
          if (current == ":" && !state.lambda && top(state).type == "py")
            pushPyScope(state);

          if (current.length == 1 && !/string|comment/.test(style)) {
            var delimiter_index = "[({".indexOf(current);
            if (delimiter_index != -1)
              pushBracketScope(stream, state, "])}".slice(delimiter_index, delimiter_index+1));

            delimiter_index = "])}".indexOf(current);
            if (delimiter_index != -1) {
              if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent;
              else return ERRORCLASS;
            }
          }
          if (state.dedent > 0 && stream.eol() && top(state).type == "py") {
            if (state.scopes.length > 1) state.scopes.pop();
            state.dedent -= 1;
          }

          return style;
        }

        var external = {
          startState: function(basecolumn) {
            return {
              tokenize: tokenBase,
              scopes: [{offset: basecolumn || 0, type: "py", align: null}],
              indent: basecolumn || 0,
              lastToken: null,
              lambda: false,
              dedent: 0
            };
          },

          token: function(stream, state) {
            var addErr = state.errorToken;
            if (addErr) state.errorToken = false;
            var style = tokenLexer(stream, state);

            if (style && style != "comment")
              state.lastToken = (style == "keyword" || style == "punctuation") ? stream.current() : style;
            if (style == "punctuation") style = null;

            if (stream.eol() && state.lambda)
              state.lambda = false;
            return addErr ? style + " " + ERRORCLASS : style;
          },

          indent: function(state, textAfter) {
            if (state.tokenize != tokenBase)
              return state.tokenize.isString ? CodeMirror.Pass : 0;

            var scope = top(state), closing = scope.type == textAfter.charAt(0);
            if (scope.align != null)
              return scope.align - (closing ? 1 : 0)
            else
              return scope.offset - (closing ? hangingIndent : 0)
          },

          electricInput: /^\s*[\}\]\)]$/,
          closeBrackets: {triples: "'\""},
          lineComment: "#",
          fold: "indent"
        };
        return external;
      });

      CodeMirror.defineMIME("text/x-python", "python");

      var words = function(str) { return str.split(" "); };

      CodeMirror.defineMIME("text/x-cython", {
        name: "python",
        extra_keywords: words("by cdef cimport cpdef ctypedef enum except "+
                              "extern gil include nogil property public "+
                              "readonly struct union DEF IF ELIF ELSE")
      });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Q(CodeMirror) {
    CodeMirror.defineMode("q",function(config){
      var indentUnit=config.indentUnit,
          curPunc,
          keywords=buildRE(["abs","acos","aj","aj0","all","and","any","asc","asin","asof","atan","attr","avg","avgs","bin","by","ceiling","cols","cor","cos","count","cov","cross","csv","cut","delete","deltas","desc","dev","differ","distinct","div","do","each","ej","enlist","eval","except","exec","exit","exp","fby","fills","first","fkeys","flip","floor","from","get","getenv","group","gtime","hclose","hcount","hdel","hopen","hsym","iasc","idesc","if","ij","in","insert","inter","inv","key","keys","last","like","list","lj","load","log","lower","lsq","ltime","ltrim","mavg","max","maxs","mcount","md5","mdev","med","meta","min","mins","mmax","mmin","mmu","mod","msum","neg","next","not","null","or","over","parse","peach","pj","plist","prd","prds","prev","prior","rand","rank","ratios","raze","read0","read1","reciprocal","reverse","rload","rotate","rsave","rtrim","save","scan","select","set","setenv","show","signum","sin","sqrt","ss","ssr","string","sublist","sum","sums","sv","system","tables","tan","til","trim","txf","type","uj","ungroup","union","update","upper","upsert","value","var","view","views","vs","wavg","where","where","while","within","wj","wj1","wsum","xasc","xbar","xcol","xcols","xdesc","xexp","xgroup","xkey","xlog","xprev","xrank"]),
          E=/[|/&^!+:\\\-*%$=~#;@><,?_\'\"\[\(\]\)\s{}]/;
      function buildRE(w){return new RegExp("^("+w.join("|")+")$");}
      function tokenBase(stream,state){
        var sol=stream.sol(),c=stream.next();
        curPunc=null;
        if(sol)
          if(c=="/")
            return (state.tokenize=tokenLineComment)(stream,state);
          else if(c=="\\"){
            if(stream.eol()||/\s/.test(stream.peek()))
              return stream.skipToEnd(),/^\\\s*$/.test(stream.current())?(state.tokenize=tokenCommentToEOF)(stream):state.tokenize=tokenBase,"comment";
            else
              return state.tokenize=tokenBase,"builtin";
          }
        if(/\s/.test(c))
          return stream.peek()=="/"?(stream.skipToEnd(),"comment"):"whitespace";
        if(c=='"')
          return (state.tokenize=tokenString)(stream,state);
        if(c=='`')
          return stream.eatWhile(/[A-Za-z\d_:\/.]/),"symbol";
        if(("."==c&&/\d/.test(stream.peek()))||/\d/.test(c)){
          var t=null;
          stream.backUp(1);
          if(stream.match(/^\d{4}\.\d{2}(m|\.\d{2}([DT](\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)?)?)/)
          || stream.match(/^\d+D(\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)/)
          || stream.match(/^\d{2}:\d{2}(:\d{2}(\.\d{1,9})?)?/)
          || stream.match(/^\d+[ptuv]{1}/))
            t="temporal";
          else if(stream.match(/^0[NwW]{1}/)
          || stream.match(/^0x[\da-fA-F]*/)
          || stream.match(/^[01]+[b]{1}/)
          || stream.match(/^\d+[chijn]{1}/)
          || stream.match(/-?\d*(\.\d*)?(e[+\-]?\d+)?(e|f)?/))
            t="number";
          return (t&&(!(c=stream.peek())||E.test(c)))?t:(stream.next(),"error");
        }
        if(/[A-Za-z]|\./.test(c))
          return stream.eatWhile(/[A-Za-z._\d]/),keywords.test(stream.current())?"keyword":"variable";
        if(/[|/&^!+:\\\-*%$=~#;@><\.,?_\']/.test(c))
          return null;
        if(/[{}\(\[\]\)]/.test(c))
          return null;
        return "error";
      }
      function tokenLineComment(stream,state){
        return stream.skipToEnd(),/\/\s*$/.test(stream.current())?(state.tokenize=tokenBlockComment)(stream,state):(state.tokenize=tokenBase),"comment";
      }
      function tokenBlockComment(stream,state){
        var f=stream.sol()&&stream.peek()=="\\";
        stream.skipToEnd();
        if(f&&/^\\\s*$/.test(stream.current()))
          state.tokenize=tokenBase;
        return "comment";
      }
      function tokenCommentToEOF(stream){return stream.skipToEnd(),"comment";}
      function tokenString(stream,state){
        var escaped=false,next,end=false;
        while((next=stream.next())){
          if(next=="\""&&!escaped){end=true;break;}
          escaped=!escaped&&next=="\\";
        }
        if(end)state.tokenize=tokenBase;
        return "string";
      }
      function pushContext(state,type,col){state.context={prev:state.context,indent:state.indent,col:col,type:type};}
      function popContext(state){state.indent=state.context.indent;state.context=state.context.prev;}
      return {
        startState:function(){
          return {tokenize:tokenBase,
                 context:null,
                 indent:0,
                 col:0};
        },
        token:function(stream,state){
          if(stream.sol()){
            if(state.context&&state.context.align==null)
              state.context.align=false;
            state.indent=stream.indentation();
          }
          //if (stream.eatSpace()) return null;
          var style=state.tokenize(stream,state);
          if(style!="comment"&&state.context&&state.context.align==null&&state.context.type!="pattern"){
            state.context.align=true;
          }
          if(curPunc=="(")pushContext(state,")",stream.column());
          else if(curPunc=="[")pushContext(state,"]",stream.column());
          else if(curPunc=="{")pushContext(state,"}",stream.column());
          else if(/[\]\}\)]/.test(curPunc)){
            while(state.context&&state.context.type=="pattern")popContext(state);
            if(state.context&&curPunc==state.context.type)popContext(state);
          }
          else if(curPunc=="."&&state.context&&state.context.type=="pattern")popContext(state);
          else if(/atom|string|variable/.test(style)&&state.context){
            if(/[\}\]]/.test(state.context.type))
              pushContext(state,"pattern",stream.column());
            else if(state.context.type=="pattern"&&!state.context.align){
              state.context.align=true;
              state.context.col=stream.column();
            }
          }
          return style;
        },
        indent:function(state,textAfter){
          var firstChar=textAfter&&textAfter.charAt(0);
          var context=state.context;
          if(/[\]\}]/.test(firstChar))
            while (context&&context.type=="pattern")context=context.prev;
          var closing=context&&firstChar==context.type;
          if(!context)
            return 0;
          else if(context.type=="pattern")
            return context.col;
          else if(context.align)
            return context.col+(closing?0:1);
          else
            return context.indent+(closing?0:indentUnit);
        }
      };
    });
    CodeMirror.defineMIME("text/x-q","q");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function R(CodeMirror) {
    CodeMirror.registerHelper("wordChars", "r", /[\w.]/);

    CodeMirror.defineMode("r", function(config) {
      function wordObj(words) {
        var res = {};
        for (var i = 0; i < words.length; ++i) res[words[i]] = true;
        return res;
      }
      var commonAtoms = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
      var commonBuiltins = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
      var commonKeywords = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
      var commonBlockKeywords = ["if", "else", "repeat", "while", "function", "for"];

      CodeMirror.registerHelper("hintWords", "r", commonAtoms.concat(commonBuiltins, commonKeywords));

      var atoms = wordObj(commonAtoms);
      var builtins = wordObj(commonBuiltins);
      var keywords = wordObj(commonKeywords);
      var blockkeywords = wordObj(commonBlockKeywords);
      var opChars = /[+\-*\/^<>=!&|~$:]/;
      var curPunc;

      function tokenBase(stream, state) {
        curPunc = null;
        var ch = stream.next();
        if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        } else if (ch == "0" && stream.eat("x")) {
          stream.eatWhile(/[\da-f]/i);
          return "number";
        } else if (ch == "." && stream.eat(/\d/)) {
          stream.match(/\d*(?:e[+\-]?\d+)?/);
          return "number";
        } else if (/\d/.test(ch)) {
          stream.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/);
          return "number";
        } else if (ch == "'" || ch == '"') {
          state.tokenize = tokenString(ch);
          return "string";
        } else if (ch == "`") {
          stream.match(/[^`]+`/);
          return "variable-3";
        } else if (ch == "." && stream.match(/.[.\d]+/)) {
          return "keyword";
        } else if (/[\w\.]/.test(ch) && ch != "_") {
          stream.eatWhile(/[\w\.]/);
          var word = stream.current();
          if (atoms.propertyIsEnumerable(word)) return "atom";
          if (keywords.propertyIsEnumerable(word)) {
            // Block keywords start new blocks, except 'else if', which only starts
            // one new block for the 'if', no block for the 'else'.
            if (blockkeywords.propertyIsEnumerable(word) &&
                !stream.match(/\s*if(\s+|$)/, false))
              curPunc = "block";
            return "keyword";
          }
          if (builtins.propertyIsEnumerable(word)) return "builtin";
          return "variable";
        } else if (ch == "%") {
          if (stream.skipTo("%")) stream.next();
          return "operator variable-2";
        } else if (
            (ch == "<" && stream.eat("-")) ||
            (ch == "<" && stream.match("<-")) ||
            (ch == "-" && stream.match(/>>?/))
          ) {
          return "operator arrow";
        } else if (ch == "=" && state.ctx.argList) {
          return "arg-is";
        } else if (opChars.test(ch)) {
          if (ch == "$") return "operator dollar";
          stream.eatWhile(opChars);
          return "operator";
        } else if (/[\(\){}\[\];]/.test(ch)) {
          curPunc = ch;
          if (ch == ";") return "semi";
          return null;
        } else {
          return null;
        }
      }

      function tokenString(quote) {
        return function(stream, state) {
          if (stream.eat("\\")) {
            var ch = stream.next();
            if (ch == "x") stream.match(/^[a-f0-9]{2}/i);
            else if ((ch == "u" || ch == "U") && stream.eat("{") && stream.skipTo("}")) stream.next();
            else if (ch == "u") stream.match(/^[a-f0-9]{4}/i);
            else if (ch == "U") stream.match(/^[a-f0-9]{8}/i);
            else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);
            return "string-2";
          } else {
            var next;
            while ((next = stream.next()) != null) {
              if (next == quote) { state.tokenize = tokenBase; break; }
              if (next == "\\") { stream.backUp(1); break; }
            }
            return "string";
          }
        };
      }

      var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4;

      function push(state, type, stream) {
        state.ctx = {type: type,
                     indent: state.indent,
                     flags: 0,
                     column: stream.column(),
                     prev: state.ctx};
      }
      function setFlag(state, flag) {
        var ctx = state.ctx;
        state.ctx = {type: ctx.type,
                     indent: ctx.indent,
                     flags: ctx.flags | flag,
                     column: ctx.column,
                     prev: ctx.prev};
      }
      function pop(state) {
        state.indent = state.ctx.indent;
        state.ctx = state.ctx.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase,
                  ctx: {type: "top",
                        indent: -config.indentUnit,
                        flags: ALIGN_NO},
                  indent: 0,
                  afterIdent: false};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO;
            if (state.ctx.flags & BRACELESS) pop(state);
            state.indent = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (style != "comment" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES);

          if ((curPunc == ";" || curPunc == "{" || curPunc == "}") && state.ctx.type == "block") pop(state);
          if (curPunc == "{") push(state, "}", stream);
          else if (curPunc == "(") {
            push(state, ")", stream);
            if (state.afterIdent) state.ctx.argList = true;
          }
          else if (curPunc == "[") push(state, "]", stream);
          else if (curPunc == "block") push(state, "block", stream);
          else if (curPunc == state.ctx.type) pop(state);
          else if (state.ctx.type == "block" && style != "comment") setFlag(state, BRACELESS);
          state.afterIdent = style == "variable" || style == "keyword";
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,
              closing = firstChar == ctx.type;
          if (ctx.flags & BRACELESS) ctx = ctx.prev;
          if (ctx.type == "block") return ctx.indent + (firstChar == "{" ? 0 : config.indentUnit);
          else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);
          else return ctx.indent + (closing ? 0 : config.indentUnit);
        },

        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("text/x-rsrc", "r");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function RPM(CodeMirror) {
    CodeMirror.defineMode("rpm-changes", function() {
      var headerSeperator = /^-+$/;
      var headerLine = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)  ?\d{1,2} \d{2}:\d{2}(:\d{2})? [A-Z]{3,4} \d{4} - /;
      var simpleEmail = /^[\w+.-]+@[\w.-]+/;

      return {
        token: function(stream) {
          if (stream.sol()) {
            if (stream.match(headerSeperator)) { return 'tag'; }
            if (stream.match(headerLine)) { return 'tag'; }
          }
          if (stream.match(simpleEmail)) { return 'string'; }
          stream.next();
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-rpm-changes", "rpm-changes");

    // Quick and dirty spec file highlighting

    CodeMirror.defineMode("rpm-spec", function() {
      var arch = /^(i386|i586|i686|x86_64|ppc64le|ppc64|ppc|ia64|s390x|s390|sparc64|sparcv9|sparc|noarch|alphaev6|alpha|hppa|mipsel)/;

      var preamble = /^[a-zA-Z0-9()]+:/;
      var section = /^%(debug_package|package|description|prep|build|install|files|clean|changelog|preinstall|preun|postinstall|postun|pretrans|posttrans|pre|post|triggerin|triggerun|verifyscript|check|triggerpostun|triggerprein|trigger)/;
      var control_flow_complex = /^%(ifnarch|ifarch|if)/; // rpm control flow macros
      var control_flow_simple = /^%(else|endif)/; // rpm control flow macros
      var operators = /^(\!|\?|\<\=|\<|\>\=|\>|\=\=|\&\&|\|\|)/; // operators in control flow macros

      return {
        startState: function () {
            return {
              controlFlow: false,
              macroParameters: false,
              section: false
            };
        },
        token: function (stream, state) {
          var ch = stream.peek();
          if (ch == "#") { stream.skipToEnd(); return "comment"; }

          if (stream.sol()) {
            if (stream.match(preamble)) { return "header"; }
            if (stream.match(section)) { return "atom"; }
          }

          if (stream.match(/^\$\w+/)) { return "def"; } // Variables like '$RPM_BUILD_ROOT'
          if (stream.match(/^\$\{\w+\}/)) { return "def"; } // Variables like '${RPM_BUILD_ROOT}'

          if (stream.match(control_flow_simple)) { return "keyword"; }
          if (stream.match(control_flow_complex)) {
            state.controlFlow = true;
            return "keyword";
          }
          if (state.controlFlow) {
            if (stream.match(operators)) { return "operator"; }
            if (stream.match(/^(\d+)/)) { return "number"; }
            if (stream.eol()) { state.controlFlow = false; }
          }

          if (stream.match(arch)) {
            if (stream.eol()) { state.controlFlow = false; }
            return "number";
          }

          // Macros like '%make_install' or '%attr(0775,root,root)'
          if (stream.match(/^%[\w]+/)) {
            if (stream.match(/^\(/)) { state.macroParameters = true; }
            return "keyword";
          }
          if (state.macroParameters) {
            if (stream.match(/^\d+/)) { return "number";}
            if (stream.match(/^\)/)) {
              state.macroParameters = false;
              return "keyword";
            }
          }

          // Macros like '%{defined fedora}'
          if (stream.match(/^%\{\??[\w \-\:\!]+\}/)) {
            if (stream.eol()) { state.controlFlow = false; }
            return "def";
          }

          //TODO: Include bash script sub-parser (CodeMirror supports that)
          stream.next();
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-rpm-spec", "rpm-spec");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function RST(CodeMirror) {
    CodeMirror.defineMode('rst', function (config, options) {

      var rx_strong = /^\*\*[^\*\s](?:[^\*]*[^\*\s])?\*\*/;
      var rx_emphasis = /^\*[^\*\s](?:[^\*]*[^\*\s])?\*/;
      var rx_literal = /^``[^`\s](?:[^`]*[^`\s])``/;

      var rx_number = /^(?:[\d]+(?:[\.,]\d+)*)/;
      var rx_positive = /^(?:\s\+[\d]+(?:[\.,]\d+)*)/;
      var rx_negative = /^(?:\s\-[\d]+(?:[\.,]\d+)*)/;

      var rx_uri_protocol = "[Hh][Tt][Tt][Pp][Ss]?://";
      var rx_uri_domain = "(?:[\\d\\w.-]+)\\.(?:\\w{2,6})";
      var rx_uri_path = "(?:/[\\d\\w\\#\\%\\&\\-\\.\\,\\/\\:\\=\\?\\~]+)*";
      var rx_uri = new RegExp("^" + rx_uri_protocol + rx_uri_domain + rx_uri_path);

      var overlay = {
        token: function (stream) {

          if (stream.match(rx_strong) && stream.match (/\W+|$/, false))
            return 'strong';
          if (stream.match(rx_emphasis) && stream.match (/\W+|$/, false))
            return 'em';
          if (stream.match(rx_literal) && stream.match (/\W+|$/, false))
            return 'string-2';
          if (stream.match(rx_number))
            return 'number';
          if (stream.match(rx_positive))
            return 'positive';
          if (stream.match(rx_negative))
            return 'negative';
          if (stream.match(rx_uri))
            return 'link';

          while (stream.next() != null) {
            if (stream.match(rx_strong, false)) break;
            if (stream.match(rx_emphasis, false)) break;
            if (stream.match(rx_literal, false)) break;
            if (stream.match(rx_number, false)) break;
            if (stream.match(rx_positive, false)) break;
            if (stream.match(rx_negative, false)) break;
            if (stream.match(rx_uri, false)) break;
          }

          return null;
        }
      };

      var mode = CodeMirror.getMode(
        config, options.backdrop || 'rst-base'
      );

      return CodeMirror.overlayMode(mode, overlay, true); // combine
    }, 'python', 'stex');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    CodeMirror.defineMode('rst-base', function (config) {

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function format(string) {
        var args = Array.prototype.slice.call(arguments, 1);
        return string.replace(/{(\d+)}/g, function (match, n) {
          return typeof args[n] != 'undefined' ? args[n] : match;
        });
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      var mode_python = CodeMirror.getMode(config, 'python');
      var mode_stex = CodeMirror.getMode(config, 'stex');

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      var SEPA = "\\s+";
      var TAIL = "(?:\\s*|\\W|$)",
      rx_TAIL = new RegExp(format('^{0}', TAIL));

      var NAME =
        "(?:[^\\W\\d_](?:[\\w!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)",
      rx_NAME = new RegExp(format('^{0}', NAME));
      var NAME_WWS =
        "(?:[^\\W\\d_](?:[\\w\\s!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)";
      var REF_NAME = format('(?:{0}|`{1}`)', NAME, NAME_WWS);

      var TEXT1 = "(?:[^\\s\\|](?:[^\\|]*[^\\s\\|])?)";
      var TEXT2 = "(?:[^\\`]+)",
      rx_TEXT2 = new RegExp(format('^{0}', TEXT2));

      var rx_section = new RegExp(
        "^([!'#$%&\"()*+,-./:;<=>?@\\[\\\\\\]^_`{|}~])\\1{3,}\\s*$");
      var rx_explicit = new RegExp(
        format('^\\.\\.{0}', SEPA));
      var rx_link = new RegExp(
        format('^_{0}:{1}|^__:{1}', REF_NAME, TAIL));
      var rx_directive = new RegExp(
        format('^{0}::{1}', REF_NAME, TAIL));
      var rx_substitution = new RegExp(
        format('^\\|{0}\\|{1}{2}::{3}', TEXT1, SEPA, REF_NAME, TAIL));
      var rx_footnote = new RegExp(
        format('^\\[(?:\\d+|#{0}?|\\*)]{1}', REF_NAME, TAIL));
      var rx_citation = new RegExp(
        format('^\\[{0}\\]{1}', REF_NAME, TAIL));

      var rx_substitution_ref = new RegExp(
        format('^\\|{0}\\|', TEXT1));
      var rx_footnote_ref = new RegExp(
        format('^\\[(?:\\d+|#{0}?|\\*)]_', REF_NAME));
      var rx_citation_ref = new RegExp(
        format('^\\[{0}\\]_', REF_NAME));
      var rx_link_ref1 = new RegExp(
        format('^{0}__?', REF_NAME));
      var rx_link_ref2 = new RegExp(
        format('^`{0}`_', TEXT2));

      var rx_role_pre = new RegExp(
        format('^:{0}:`{1}`{2}', NAME, TEXT2, TAIL));
      var rx_role_suf = new RegExp(
        format('^`{1}`:{0}:{2}', NAME, TEXT2, TAIL));
      var rx_role = new RegExp(
        format('^:{0}:{1}', NAME, TAIL));

      var rx_directive_name = new RegExp(format('^{0}', REF_NAME));
      var rx_directive_tail = new RegExp(format('^::{0}', TAIL));
      var rx_substitution_text = new RegExp(format('^\\|{0}\\|', TEXT1));
      var rx_substitution_sepa = new RegExp(format('^{0}', SEPA));
      var rx_substitution_name = new RegExp(format('^{0}', REF_NAME));
      var rx_substitution_tail = new RegExp(format('^::{0}', TAIL));
      var rx_link_head = new RegExp("^_");
      var rx_link_name = new RegExp(format('^{0}|_', REF_NAME));
      var rx_link_tail = new RegExp(format('^:{0}', TAIL));

      var rx_verbatim = new RegExp('^::\\s*$');
      var rx_examples = new RegExp('^\\s+(?:>>>|In \\[\\d+\\]:)\\s');

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_normal(stream, state) {
        var token = null;

        if (stream.sol() && stream.match(rx_examples, false)) {
          change(state, to_mode, {
            mode: mode_python, local: CodeMirror.startState(mode_python)
          });
        } else if (stream.sol() && stream.match(rx_explicit)) {
          change(state, to_explicit);
          token = 'meta';
        } else if (stream.sol() && stream.match(rx_section)) {
          change(state, to_normal);
          token = 'header';
        } else if (phase(state) == rx_role_pre ||
                   stream.match(rx_role_pre, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role_pre, 1));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role_pre, 2));
            stream.match(rx_NAME);
            token = 'keyword';

            if (stream.current().match(/^(?:math|latex)/)) {
              state.tmp_stex = true;
            }
            break;
          case 2:
            change(state, to_normal, context(rx_role_pre, 3));
            stream.match(/^:`/);
            token = 'meta';
            break;
          case 3:
            if (state.tmp_stex) {
              state.tmp_stex = undefined; state.tmp = {
                mode: mode_stex, local: CodeMirror.startState(mode_stex)
              };
            }

            if (state.tmp) {
              if (stream.peek() == '`') {
                change(state, to_normal, context(rx_role_pre, 4));
                state.tmp = undefined;
                break;
              }

              token = state.tmp.mode.token(stream, state.tmp.local);
              break;
            }

            change(state, to_normal, context(rx_role_pre, 4));
            stream.match(rx_TEXT2);
            token = 'string';
            break;
          case 4:
            change(state, to_normal, context(rx_role_pre, 5));
            stream.match(/^`/);
            token = 'meta';
            break;
          case 5:
            change(state, to_normal, context(rx_role_pre, 6));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_role_suf ||
                   stream.match(rx_role_suf, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role_suf, 1));
            stream.match(/^`/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role_suf, 2));
            stream.match(rx_TEXT2);
            token = 'string';
            break;
          case 2:
            change(state, to_normal, context(rx_role_suf, 3));
            stream.match(/^`:/);
            token = 'meta';
            break;
          case 3:
            change(state, to_normal, context(rx_role_suf, 4));
            stream.match(rx_NAME);
            token = 'keyword';
            break;
          case 4:
            change(state, to_normal, context(rx_role_suf, 5));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 5:
            change(state, to_normal, context(rx_role_suf, 6));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_role || stream.match(rx_role, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_role, 1));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 1:
            change(state, to_normal, context(rx_role, 2));
            stream.match(rx_NAME);
            token = 'keyword';
            break;
          case 2:
            change(state, to_normal, context(rx_role, 3));
            stream.match(/^:/);
            token = 'meta';
            break;
          case 3:
            change(state, to_normal, context(rx_role, 4));
            stream.match(rx_TAIL);
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_substitution_ref ||
                   stream.match(rx_substitution_ref, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_normal, context(rx_substitution_ref, 1));
            stream.match(rx_substitution_text);
            token = 'variable-2';
            break;
          case 1:
            change(state, to_normal, context(rx_substitution_ref, 2));
            if (stream.match(/^_?_?/)) token = 'link';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_footnote_ref)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_citation_ref)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_link_ref1)) {
          change(state, to_normal);
          if (!stream.peek() || stream.peek().match(/^\W$/)) {
            token = 'link';
          }
        } else if (phase(state) == rx_link_ref2 ||
                   stream.match(rx_link_ref2, false)) {

          switch (stage(state)) {
          case 0:
            if (!stream.peek() || stream.peek().match(/^\W$/)) {
              change(state, to_normal, context(rx_link_ref2, 1));
            } else {
              stream.match(rx_link_ref2);
            }
            break;
          case 1:
            change(state, to_normal, context(rx_link_ref2, 2));
            stream.match(/^`/);
            token = 'link';
            break;
          case 2:
            change(state, to_normal, context(rx_link_ref2, 3));
            stream.match(rx_TEXT2);
            break;
          case 3:
            change(state, to_normal, context(rx_link_ref2, 4));
            stream.match(/^`_/);
            token = 'link';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_verbatim)) {
          change(state, to_verbatim);
        }

        else {
          if (stream.next()) change(state, to_normal);
        }

        return token;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_explicit(stream, state) {
        var token = null;

        if (phase(state) == rx_substitution ||
            stream.match(rx_substitution, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_substitution, 1));
            stream.match(rx_substitution_text);
            token = 'variable-2';
            break;
          case 1:
            change(state, to_explicit, context(rx_substitution, 2));
            stream.match(rx_substitution_sepa);
            break;
          case 2:
            change(state, to_explicit, context(rx_substitution, 3));
            stream.match(rx_substitution_name);
            token = 'keyword';
            break;
          case 3:
            change(state, to_explicit, context(rx_substitution, 4));
            stream.match(rx_substitution_tail);
            token = 'meta';
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_directive ||
                   stream.match(rx_directive, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_directive, 1));
            stream.match(rx_directive_name);
            token = 'keyword';

            if (stream.current().match(/^(?:math|latex)/))
              state.tmp_stex = true;
            else if (stream.current().match(/^python/))
              state.tmp_py = true;
            break;
          case 1:
            change(state, to_explicit, context(rx_directive, 2));
            stream.match(rx_directive_tail);
            token = 'meta';

            if (stream.match(/^latex\s*$/) || state.tmp_stex) {
              state.tmp_stex = undefined; change(state, to_mode, {
                mode: mode_stex, local: CodeMirror.startState(mode_stex)
              });
            }
            break;
          case 2:
            change(state, to_explicit, context(rx_directive, 3));
            if (stream.match(/^python\s*$/) || state.tmp_py) {
              state.tmp_py = undefined; change(state, to_mode, {
                mode: mode_python, local: CodeMirror.startState(mode_python)
              });
            }
            break;
          default:
            change(state, to_normal);
          }
        } else if (phase(state) == rx_link || stream.match(rx_link, false)) {

          switch (stage(state)) {
          case 0:
            change(state, to_explicit, context(rx_link, 1));
            stream.match(rx_link_head);
            stream.match(rx_link_name);
            token = 'link';
            break;
          case 1:
            change(state, to_explicit, context(rx_link, 2));
            stream.match(rx_link_tail);
            token = 'meta';
            break;
          default:
            change(state, to_normal);
          }
        } else if (stream.match(rx_footnote)) {
          change(state, to_normal);
          token = 'quote';
        } else if (stream.match(rx_citation)) {
          change(state, to_normal);
          token = 'quote';
        }

        else {
          stream.eatSpace();
          if (stream.eol()) {
            change(state, to_normal);
          } else {
            stream.skipToEnd();
            change(state, to_comment);
            token = 'comment';
          }
        }

        return token;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_comment(stream, state) {
        return as_block(stream, state, 'comment');
      }

      function to_verbatim(stream, state) {
        return as_block(stream, state, 'meta');
      }

      function as_block(stream, state, token) {
        if (stream.eol() || stream.eatSpace()) {
          stream.skipToEnd();
          return token;
        } else {
          change(state, to_normal);
          return null;
        }
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function to_mode(stream, state) {

        if (state.ctx.mode && state.ctx.local) {

          if (stream.sol()) {
            if (!stream.eatSpace()) change(state, to_normal);
            return null;
          }

          return state.ctx.mode.token(stream, state.ctx.local);
        }

        change(state, to_normal);
        return null;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      function context(phase, stage, mode, local) {
        return {phase: phase, stage: stage, mode: mode, local: local};
      }

      function change(state, tok, ctx) {
        state.tok = tok;
        state.ctx = ctx || {};
      }

      function stage(state) {
        return state.ctx.stage || 0;
      }

      function phase(state) {
        return state.ctx.phase;
      }

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////

      return {
        startState: function () {
          return {tok: to_normal, ctx: context(undefined, 0)};
        },

        copyState: function (state) {
          var ctx = state.ctx, tmp = state.tmp;
          if (ctx.local)
            ctx = {mode: ctx.mode, local: CodeMirror.copyState(ctx.mode, ctx.local)};
          if (tmp)
            tmp = {mode: tmp.mode, local: CodeMirror.copyState(tmp.mode, tmp.local)};
          return {tok: state.tok, ctx: ctx, tmp: tmp};
        },

        innerMode: function (state) {
          return state.tmp      ? {state: state.tmp.local, mode: state.tmp.mode}
          : state.ctx.mode ? {state: state.ctx.local, mode: state.ctx.mode}
          : null;
        },

        token: function (stream, state) {
          return state.tok(stream, state);
        }
      };
    }, 'python', 'stex');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    CodeMirror.defineMIME('text/x-rst', 'rst');

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Ruby(CodeMirror) {
    CodeMirror.defineMode("ruby", function(config) {
      function wordObj(words) {
        var o = {};
        for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
        return o;
      }
      var keywords = wordObj([
        "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else",
        "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or",
        "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless",
        "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc",
        "caller", "lambda", "proc", "public", "protected", "private", "require", "load",
        "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"
      ]);
      var indentWords = wordObj(["def", "class", "case", "for", "while", "until", "module", "then",
                                 "catch", "loop", "proc", "begin"]);
      var dedentWords = wordObj(["end", "until"]);
      var matching = {"[": "]", "{": "}", "(": ")"};
      var curPunc;

      function chain(newtok, stream, state) {
        state.tokenize.push(newtok);
        return newtok(stream, state);
      }

      function tokenBase(stream, state) {
        if (stream.sol() && stream.match("=begin") && stream.eol()) {
          state.tokenize.push(readBlockComment);
          return "comment";
        }
        if (stream.eatSpace()) return null;
        var ch = stream.next(), m;
        if (ch == "`" || ch == "'" || ch == '"') {
          return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
        } else if (ch == "/") {
          if (regexpAhead(stream))
            return chain(readQuoted(ch, "string-2", true), stream, state);
          else
            return "operator";
        } else if (ch == "%") {
          var style = "string", embed = true;
          if (stream.eat("s")) style = "atom";
          else if (stream.eat(/[WQ]/)) style = "string";
          else if (stream.eat(/[r]/)) style = "string-2";
          else if (stream.eat(/[wxq]/)) { style = "string"; embed = false; }
          var delim = stream.eat(/[^\w\s=]/);
          if (!delim) return "operator";
          if (matching.propertyIsEnumerable(delim)) delim = matching[delim];
          return chain(readQuoted(delim, style, embed, true), stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        } else if (ch == "<" && (m = stream.match(/^<(-)?[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
          return chain(readHereDoc(m[2], m[1]), stream, state);
        } else if (ch == "0") {
          if (stream.eat("x")) stream.eatWhile(/[\da-fA-F]/);
          else if (stream.eat("b")) stream.eatWhile(/[01]/);
          else stream.eatWhile(/[0-7]/);
          return "number";
        } else if (/\d/.test(ch)) {
          stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
          return "number";
        } else if (ch == "?") {
          while (stream.match(/^\\[CM]-/)) {}
          if (stream.eat("\\")) stream.eatWhile(/\w/);
          else stream.next();
          return "string";
        } else if (ch == ":") {
          if (stream.eat("'")) return chain(readQuoted("'", "atom", false), stream, state);
          if (stream.eat('"')) return chain(readQuoted('"', "atom", true), stream, state);

          // :> :>> :< :<< are valid symbols
          if (stream.eat(/[\<\>]/)) {
            stream.eat(/[\<\>]/);
            return "atom";
          }

          // :+ :- :/ :* :| :& :! are valid symbols
          if (stream.eat(/[\+\-\*\/\&\|\:\!]/)) {
            return "atom";
          }

          // Symbols can't start by a digit
          if (stream.eat(/[a-zA-Z$@_\xa1-\uffff]/)) {
            stream.eatWhile(/[\w$\xa1-\uffff]/);
            // Only one ? ! = is allowed and only as the last character
            stream.eat(/[\?\!\=]/);
            return "atom";
          }
          return "operator";
        } else if (ch == "@" && stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) {
          stream.eat("@");
          stream.eatWhile(/[\w\xa1-\uffff]/);
          return "variable-2";
        } else if (ch == "$") {
          if (stream.eat(/[a-zA-Z_]/)) {
            stream.eatWhile(/[\w]/);
          } else if (stream.eat(/\d/)) {
            stream.eat(/\d/);
          } else {
            stream.next(); // Must be a special global like $: or $!
          }
          return "variable-3";
        } else if (/[a-zA-Z_\xa1-\uffff]/.test(ch)) {
          stream.eatWhile(/[\w\xa1-\uffff]/);
          stream.eat(/[\?\!]/);
          if (stream.eat(":")) return "atom";
          return "ident";
        } else if (ch == "|" && (state.varList || state.lastTok == "{" || state.lastTok == "do")) {
          curPunc = "|";
          return null;
        } else if (/[\(\)\[\]{}\\;]/.test(ch)) {
          curPunc = ch;
          return null;
        } else if (ch == "-" && stream.eat(">")) {
          return "arrow";
        } else if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
          var more = stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
          if (ch == "." && !more) curPunc = ".";
          return "operator";
        } else {
          return null;
        }
      }

      function regexpAhead(stream) {
        var start = stream.pos, depth = 0, next, found = false, escaped = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if ("[{(".indexOf(next) > -1) {
              depth++;
            } else if ("]})".indexOf(next) > -1) {
              depth--;
              if (depth < 0) break
            } else if (next == "/" && depth == 0) {
              found = true;
              break
            }
            escaped = next == "\\";
          } else {
            escaped = false;
          }
        }
        stream.backUp(stream.pos - start);
        return found
      }

      function tokenBaseUntilBrace(depth) {
        if (!depth) depth = 1;
        return function(stream, state) {
          if (stream.peek() == "}") {
            if (depth == 1) {
              state.tokenize.pop();
              return state.tokenize[state.tokenize.length-1](stream, state);
            } else {
              state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);
            }
          } else if (stream.peek() == "{") {
            state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);
          }
          return tokenBase(stream, state);
        };
      }
      function tokenBaseOnce() {
        var alreadyCalled = false;
        return function(stream, state) {
          if (alreadyCalled) {
            state.tokenize.pop();
            return state.tokenize[state.tokenize.length-1](stream, state);
          }
          alreadyCalled = true;
          return tokenBase(stream, state);
        };
      }
      function readQuoted(quote, style, embed, unescaped) {
        return function(stream, state) {
          var escaped = false, ch;

          if (state.context.type === 'read-quoted-paused') {
            state.context = state.context.prev;
            stream.eat("}");
          }

          while ((ch = stream.next()) != null) {
            if (ch == quote && (unescaped || !escaped)) {
              state.tokenize.pop();
              break;
            }
            if (embed && ch == "#" && !escaped) {
              if (stream.eat("{")) {
                if (quote == "}") {
                  state.context = {prev: state.context, type: 'read-quoted-paused'};
                }
                state.tokenize.push(tokenBaseUntilBrace());
                break;
              } else if (/[@\$]/.test(stream.peek())) {
                state.tokenize.push(tokenBaseOnce());
                break;
              }
            }
            escaped = !escaped && ch == "\\";
          }
          return style;
        };
      }
      function readHereDoc(phrase, mayIndent) {
        return function(stream, state) {
          if (mayIndent) stream.eatSpace();
          if (stream.match(phrase)) state.tokenize.pop();
          else stream.skipToEnd();
          return "string";
        };
      }
      function readBlockComment(stream, state) {
        if (stream.sol() && stream.match("=end") && stream.eol())
          state.tokenize.pop();
        stream.skipToEnd();
        return "comment";
      }

      return {
        startState: function() {
          return {tokenize: [tokenBase],
                  indented: 0,
                  context: {type: "top", indented: -config.indentUnit},
                  continuedLine: false,
                  lastTok: null,
                  varList: false};
        },

        token: function(stream, state) {
          curPunc = null;
          if (stream.sol()) state.indented = stream.indentation();
          var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;
          var thisTok = curPunc;
          if (style == "ident") {
            var word = stream.current();
            style = state.lastTok == "." ? "property"
              : keywords.propertyIsEnumerable(stream.current()) ? "keyword"
              : /^[A-Z]/.test(word) ? "tag"
              : (state.lastTok == "def" || state.lastTok == "class" || state.varList) ? "def"
              : "variable";
            if (style == "keyword") {
              thisTok = word;
              if (indentWords.propertyIsEnumerable(word)) kwtype = "indent";
              else if (dedentWords.propertyIsEnumerable(word)) kwtype = "dedent";
              else if ((word == "if" || word == "unless") && stream.column() == stream.indentation())
                kwtype = "indent";
              else if (word == "do" && state.context.indented < state.indented)
                kwtype = "indent";
            }
          }
          if (curPunc || (style && style != "comment")) state.lastTok = thisTok;
          if (curPunc == "|") state.varList = !state.varList;

          if (kwtype == "indent" || /[\(\[\{]/.test(curPunc))
            state.context = {prev: state.context, type: curPunc || style, indented: state.indented};
          else if ((kwtype == "dedent" || /[\)\]\}]/.test(curPunc)) && state.context.prev)
            state.context = state.context.prev;

          if (stream.eol())
            state.continuedLine = (curPunc == "\\" || style == "operator");
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;
          var firstChar = textAfter && textAfter.charAt(0);
          var ct = state.context;
          var closing = ct.type == matching[firstChar] ||
            ct.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
          return ct.indented + (closing ? 0 : config.indentUnit) +
            (state.continuedLine ? config.indentUnit : 0);
        },

        electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
        lineComment: "#",
        fold: "indent"
      };
    });

    CodeMirror.defineMIME("text/x-ruby", "ruby");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Rust(CodeMirror) {
    CodeMirror.defineSimpleMode("rust",{
      start: [
        // string and byte string
        {regex: /b?"/, token: "string", next: "string"},
        // raw string and raw byte string
        {regex: /b?r"/, token: "string", next: "string_raw"},
        {regex: /b?r#+"/, token: "string", next: "string_raw_hash"},
        // character
        {regex: /'(?:[^'\\]|\\(?:[nrt0'"]|x[\da-fA-F]{2}|u\{[\da-fA-F]{6}\}))'/, token: "string-2"},
        // byte
        {regex: /b'(?:[^']|\\(?:['\\nrt0]|x[\da-fA-F]{2}))'/, token: "string-2"},

        {regex: /(?:(?:[0-9][0-9_]*)(?:(?:[Ee][+-]?[0-9_]+)|\.[0-9_]+(?:[Ee][+-]?[0-9_]+)?)(?:f32|f64)?)|(?:0(?:b[01_]+|(?:o[0-7_]+)|(?:x[0-9a-fA-F_]+))|(?:[0-9][0-9_]*))(?:u8|u16|u32|u64|i8|i16|i32|i64|isize|usize)?/,
         token: "number"},
        {regex: /(let(?:\s+mut)?|fn|enum|mod|struct|type)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/, token: ["keyword", null, "def"]},
        {regex: /(?:abstract|alignof|as|box|break|continue|const|crate|do|else|enum|extern|fn|for|final|if|impl|in|loop|macro|match|mod|move|offsetof|override|priv|proc|pub|pure|ref|return|self|sizeof|static|struct|super|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/, token: "keyword"},
        {regex: /\b(?:Self|isize|usize|char|bool|u8|u16|u32|u64|f16|f32|f64|i8|i16|i32|i64|str|Option)\b/, token: "atom"},
        {regex: /\b(?:true|false|Some|None|Ok|Err)\b/, token: "builtin"},
        {regex: /\b(fn)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/,
         token: ["keyword", null ,"def"]},
        {regex: /#!?\[.*\]/, token: "meta"},
        {regex: /\/\/.*/, token: "comment"},
        {regex: /\/\*/, token: "comment", next: "comment"},
        {regex: /[-+\/*=<>!]+/, token: "operator"},
        {regex: /[a-zA-Z_]\w*!/,token: "variable-3"},
        {regex: /[a-zA-Z_]\w*/, token: "variable"},
        {regex: /[\{\[\(]/, indent: true},
        {regex: /[\}\]\)]/, dedent: true}
      ],
      string: [
        {regex: /"/, token: "string", next: "start"},
        {regex: /(?:[^\\"]|\\(?:.|$))*/, token: "string"}
      ],
      string_raw: [
        {regex: /"/, token: "string", next: "start"},
        {regex: /[^"]*/, token: "string"}
      ],
      string_raw_hash: [
        {regex: /"#+/, token: "string", next: "start"},
        {regex: /(?:[^"]|"(?!#))*/, token: "string"}
      ],
      comment: [
        {regex: /.*?\*\//, token: "comment", next: "start"},
        {regex: /.*/, token: "comment"}
      ],
      meta: {
        dontIndentStates: ["comment"],
        electricInput: /^\s*\}$/,
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//",
        fold: "brace"
      }
    });


    CodeMirror.defineMIME("text/x-rustsrc", "rust");
    CodeMirror.defineMIME("text/rust", "rust");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE


    // SAS mode copyright (c) 2016 Jared Dean, SAS Institute
    // Created by Jared Dean

    // TODO
    // indent and de-indent
    // identify macro variables


    //Definitions
    //  comment -- text within * ; or /* */
    //  keyword -- SAS language variable
    //  variable -- macro variables starts with '&' or variable formats
    //  variable-2 -- DATA Step, proc, or macro names
    //  string -- text within ' ' or " "
    //  operator -- numeric operator + / - * ** le eq ge ... and so on
    //  builtin -- proc %macro data run mend
    //  atom
    //  def

    function SAS(CodeMirror) {
      CodeMirror.defineMode("sas", function () {
        var words = {};
        var isDoubleOperatorSym = {
          eq: 'operator',
          lt: 'operator',
          le: 'operator',
          gt: 'operator',
          ge: 'operator',
          "in": 'operator',
          ne: 'operator',
          or: 'operator'
        };
        var isDoubleOperatorChar = /(<=|>=|!=|<>)/;
        var isSingleOperatorChar = /[=\(:\),{}.*<>+\-\/^\[\]]/;

        // Takes a string of words separated by spaces and adds them as
        // keys with the value of the first argument 'style'
        function define(style, string, context) {
          if (context) {
            var split = string.split(' ');
            for (var i = 0; i < split.length; i++) {
              words[split[i]] = {style: style, state: context};
            }
          }
        }
        //datastep
        define('def', 'stack pgm view source debug nesting nolist', ['inDataStep']);
        define('def', 'if while until for do do; end end; then else cancel', ['inDataStep']);
        define('def', 'label format _n_ _error_', ['inDataStep']);
        define('def', 'ALTER BUFNO BUFSIZE CNTLLEV COMPRESS DLDMGACTION ENCRYPT ENCRYPTKEY EXTENDOBSCOUNTER GENMAX GENNUM INDEX LABEL OBSBUF OUTREP PW PWREQ READ REPEMPTY REPLACE REUSE ROLE SORTEDBY SPILL TOBSNO TYPE WRITE FILECLOSE FIRSTOBS IN OBS POINTOBS WHERE WHEREUP IDXNAME IDXWHERE DROP KEEP RENAME', ['inDataStep']);
        define('def', 'filevar finfo finv fipname fipnamel fipstate first firstobs floor', ['inDataStep']);
        define('def', 'varfmt varinfmt varlabel varlen varname varnum varray varrayx vartype verify vformat vformatd vformatdx vformatn vformatnx vformatw vformatwx vformatx vinarray vinarrayx vinformat vinformatd vinformatdx vinformatn vinformatnx vinformatw vinformatwx vinformatx vlabel vlabelx vlength vlengthx vname vnamex vnferr vtype vtypex weekday', ['inDataStep']);
        define('def', 'zipfips zipname zipnamel zipstate', ['inDataStep']);
        define('def', 'put putc putn', ['inDataStep']);
        define('builtin', 'data run', ['inDataStep']);


        //proc
        define('def', 'data', ['inProc']);

        // flow control for macros
        define('def', '%if %end %end; %else %else; %do %do; %then', ['inMacro']);

        //everywhere
        define('builtin', 'proc run; quit; libname filename %macro %mend option options', ['ALL']);

        define('def', 'footnote title libname ods', ['ALL']);
        define('def', '%let %put %global %sysfunc %eval ', ['ALL']);
        // automatic macro variables http://support.sas.com/documentation/cdl/en/mcrolref/61885/HTML/default/viewer.htm#a003167023.htm
        define('variable', '&sysbuffr &syscc &syscharwidth &syscmd &sysdate &sysdate9 &sysday &sysdevic &sysdmg &sysdsn &sysencoding &sysenv &syserr &syserrortext &sysfilrc &syshostname &sysindex &sysinfo &sysjobid &syslast &syslckrc &syslibrc &syslogapplname &sysmacroname &sysmenv &sysmsg &sysncpu &sysodspath &sysparm &syspbuff &sysprocessid &sysprocessname &sysprocname &sysrc &sysscp &sysscpl &sysscpl &syssite &sysstartid &sysstartname &systcpiphostname &systime &sysuserid &sysver &sysvlong &sysvlong4 &syswarningtext', ['ALL']);

        //footnote[1-9]? title[1-9]?

        //options statement
        define('def', 'source2 nosource2 page pageno pagesize', ['ALL']);

        //proc and datastep
        define('def', '_all_ _character_ _cmd_ _freq_ _i_ _infile_ _last_ _msg_ _null_ _numeric_ _temporary_ _type_ abort abs addr adjrsq airy alpha alter altlog altprint and arcos array arsin as atan attrc attrib attrn authserver autoexec awscontrol awsdef awsmenu awsmenumerge awstitle backward band base betainv between blocksize blshift bnot bor brshift bufno bufsize bxor by byerr byline byte calculated call cards cards4 catcache cbufno cdf ceil center cexist change chisq cinv class cleanup close cnonct cntllev coalesce codegen col collate collin column comamid comaux1 comaux2 comdef compbl compound compress config continue convert cos cosh cpuid create cross crosstab css curobs cv daccdb daccdbsl daccsl daccsyd dacctab dairy datalines datalines4 datejul datepart datetime day dbcslang dbcstype dclose ddm delete delimiter depdb depdbsl depsl depsyd deptab dequote descending descript design= device dflang dhms dif digamma dim dinfo display distinct dkricond dkrocond dlm dnum do dopen doptname doptnum dread drop dropnote dsname dsnferr echo else emaildlg emailid emailpw emailserver emailsys encrypt end endsas engine eof eov erf erfc error errorcheck errors exist exp fappend fclose fcol fdelete feedback fetch fetchobs fexist fget file fileclose fileexist filefmt filename fileref  fmterr fmtsearch fnonct fnote font fontalias  fopen foptname foptnum force formatted formchar formdelim formdlim forward fpoint fpos fput fread frewind frlen from fsep fuzz fwrite gaminv gamma getoption getvarc getvarn go goto group gwindow hbar hbound helpenv helploc hms honorappearance hosthelp hostprint hour hpct html hvar ibessel ibr id if index indexc indexw initcmd initstmt inner input inputc inputn inr insert int intck intnx into intrr invaliddata irr is jbessel join juldate keep kentb kurtosis label lag last lbound leave left length levels lgamma lib  library libref line linesize link list log log10 log2 logpdf logpmf logsdf lostcard lowcase lrecl ls macro macrogen maps mautosource max maxdec maxr mdy mean measures median memtype merge merror min minute missing missover mlogic mod mode model modify month mopen mort mprint mrecall msglevel msymtabmax mvarsize myy n nest netpv new news nmiss no nobatch nobs nocaps nocardimage nocenter nocharcode nocmdmac nocol nocum nodate nodbcs nodetails nodmr nodms nodmsbatch nodup nodupkey noduplicates noechoauto noequals noerrorabend noexitwindows nofullstimer noicon noimplmac noint nolist noloadlist nomiss nomlogic nomprint nomrecall nomsgcase nomstored nomultenvappl nonotes nonumber noobs noovp nopad nopercent noprint noprintinit normal norow norsasuser nosetinit  nosplash nosymbolgen note notes notitle notitles notsorted noverbose noxsync noxwait npv null number numkeys nummousekeys nway obs  on open     order ordinal otherwise out outer outp= output over ovp p(1 5 10 25 50 75 90 95 99) pad pad2  paired parm parmcards path pathdll pathname pdf peek peekc pfkey pmf point poisson poke position printer probbeta probbnml probchi probf probgam probhypr probit probnegb probnorm probsig probt procleave prt ps  pw pwreq qtr quote r ranbin rancau ranexp rangam range ranks rannor ranpoi rantbl rantri ranuni read recfm register regr remote remove rename repeat replace resolve retain return reuse reverse rewind right round rsquare rtf rtrace rtraceloc s s2 samploc sasautos sascontrol sasfrscr sasmsg sasmstore sasscript sasuser saving scan sdf second select selection separated seq serror set setcomm setot sign simple sin sinh siteinfo skewness skip sle sls sortedby sortpgm sortseq sortsize soundex  spedis splashlocation split spool sqrt start std stderr stdin stfips stimer stname stnamel stop stopover subgroup subpopn substr sum sumwgt symbol symbolgen symget symput sysget sysin sysleave sysmsg sysparm sysprint sysprintfont sysprod sysrc system t table tables tan tanh tapeclose tbufsize terminal test then timepart tinv  tnonct to today tol tooldef totper transformout translate trantab tranwrd trigamma trim trimn trunc truncover type unformatted uniform union until upcase update user usericon uss validate value var  weight when where while wincharset window work workinit workterm write wsum xsync xwait yearcutoff yes yyq  min max', ['inDataStep', 'inProc']);
        define('operator', 'and not ', ['inDataStep', 'inProc']);

        // Main function
        function tokenize(stream, state) {
          // Finally advance the stream
          var ch = stream.next();

          // BLOCKCOMMENT
          if (ch === '/' && stream.eat('*')) {
            state.continueComment = true;
            return "comment";
          } else if (state.continueComment === true) { // in comment block
            //comment ends at the beginning of the line
            if (ch === '*' && stream.peek() === '/') {
              stream.next();
              state.continueComment = false;
            } else if (stream.skipTo('*')) { //comment is potentially later in line
              stream.skipTo('*');
              stream.next();
              if (stream.eat('/'))
                state.continueComment = false;
            } else {
              stream.skipToEnd();
            }
            return "comment";
          }

          if (ch == "*" && stream.column() == stream.indentation()) {
            stream.skipToEnd();
            return "comment"
          }

          // DoubleOperator match
          var doubleOperator = ch + stream.peek();

          if ((ch === '"' || ch === "'") && !state.continueString) {
            state.continueString = ch;
            return "string"
          } else if (state.continueString) {
            if (state.continueString == ch) {
              state.continueString = null;
            } else if (stream.skipTo(state.continueString)) {
              // quote found on this line
              stream.next();
              state.continueString = null;
            } else {
              stream.skipToEnd();
            }
            return "string";
          } else if (state.continueString !== null && stream.eol()) {
            stream.skipTo(state.continueString) || stream.skipToEnd();
            return "string";
          } else if (/[\d\.]/.test(ch)) { //find numbers
            if (ch === ".")
              stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
            else if (ch === "0")
              stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
            else
              stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
            return "number";
          } else if (isDoubleOperatorChar.test(ch + stream.peek())) { // TWO SYMBOL TOKENS
            stream.next();
            return "operator";
          } else if (isDoubleOperatorSym.hasOwnProperty(doubleOperator)) {
            stream.next();
            if (stream.peek() === ' ')
              return isDoubleOperatorSym[doubleOperator.toLowerCase()];
          } else if (isSingleOperatorChar.test(ch)) { // SINGLE SYMBOL TOKENS
            return "operator";
          }

          // Matches one whole word -- even if the word is a character
          var word;
          if (stream.match(/[%&;\w]+/, false) != null) {
            word = ch + stream.match(/[%&;\w]+/, true);
            if (/&/.test(word)) return 'variable'
          } else {
            word = ch;
          }
          // the word after DATA PROC or MACRO
          if (state.nextword) {
            stream.match(/[\w]+/);
            // match memname.libname
            if (stream.peek() === '.') stream.skipTo(' ');
            state.nextword = false;
            return 'variable-2';
          }

          word = word.toLowerCase();
          // Are we in a DATA Step?
          if (state.inDataStep) {
            if (word === 'run;' || stream.match(/run\s;/)) {
              state.inDataStep = false;
              return 'builtin';
            }
            // variable formats
            if ((word) && stream.next() === '.') {
              //either a format or libname.memname
              if (/\w/.test(stream.peek())) return 'variable-2';
              else return 'variable';
            }
            // do we have a DATA Step keyword
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inDataStep") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              //backup to the start of the word
              if (stream.start < stream.pos)
                stream.backUp(stream.pos - stream.start);
              //advance the length of the word and return
              for (var i = 0; i < word.length; ++i) stream.next();
              return words[word].style;
            }
          }
          // Are we in an Proc statement?
          if (state.inProc) {
            if (word === 'run;' || word === 'quit;') {
              state.inProc = false;
              return 'builtin';
            }
            // do we have a proc keyword
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inProc") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              stream.match(/[\w]+/);
              return words[word].style;
            }
          }
          // Are we in a Macro statement?
          if (state.inMacro) {
            if (word === '%mend') {
              if (stream.peek() === ';') stream.next();
              state.inMacro = false;
              return 'builtin';
            }
            if (word && words.hasOwnProperty(word) &&
                (words[word].state.indexOf("inMacro") !== -1 ||
                 words[word].state.indexOf("ALL") !== -1)) {
              stream.match(/[\w]+/);
              return words[word].style;
            }

            return 'atom';
          }
          // Do we have Keywords specific words?
          if (word && words.hasOwnProperty(word)) {
            // Negates the initial next()
            stream.backUp(1);
            // Actually move the stream
            stream.match(/[\w]+/);
            if (word === 'data' && /=/.test(stream.peek()) === false) {
              state.inDataStep = true;
              state.nextword = true;
              return 'builtin';
            }
            if (word === 'proc') {
              state.inProc = true;
              state.nextword = true;
              return 'builtin';
            }
            if (word === '%macro') {
              state.inMacro = true;
              state.nextword = true;
              return 'builtin';
            }
            if (/title[1-9]/.test(word)) return 'def';

            if (word === 'footnote') {
              stream.eat(/[1-9]/);
              return 'def';
            }

            // Returns their value as state in the prior define methods
            if (state.inDataStep === true && words[word].state.indexOf("inDataStep") !== -1)
              return words[word].style;
            if (state.inProc === true && words[word].state.indexOf("inProc") !== -1)
              return words[word].style;
            if (state.inMacro === true && words[word].state.indexOf("inMacro") !== -1)
              return words[word].style;
            if (words[word].state.indexOf("ALL") !== -1)
              return words[word].style;
            return null;
          }
          // Unrecognized syntax
          return null;
        }

        return {
          startState: function () {
            return {
              inDataStep: false,
              inProc: false,
              inMacro: false,
              nextword: false,
              continueString: null,
              continueComment: false
            };
          },
          token: function (stream, state) {
            // Strip the spaces, but regex will account for them either way
            if (stream.eatSpace()) return null;
            // Go through the main process
            return tokenize(stream, state);
          },

          blockCommentStart: "/*",
          blockCommentEnd: "*/"
        };

      });

      CodeMirror.defineMIME("text/x-sas", "sas");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Author: Koh Zi Han, based on implementation by Koh Zi Chun
     */

    function Scheme(CodeMirror) {
    CodeMirror.defineMode("scheme", function () {
        var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
            ATOM = "atom", NUMBER = "number", BRACKET = "bracket";
        var INDENT_WORD_SKIP = 2;

        function makeKeywords(str) {
            var obj = {}, words = str.split(" ");
            for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
            return obj;
        }

        var keywords = makeKeywords("λ case-lambda call/cc class define-class exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?");
        var indentKeys = makeKeywords("define let letrec let* lambda");

        function stateStack(indent, type, prev) { // represents a state stack object
            this.indent = indent;
            this.type = type;
            this.prev = prev;
        }

        function pushStack(state, indent, type) {
            state.indentStack = new stateStack(indent, type, state.indentStack);
        }

        function popStack(state) {
            state.indentStack = state.indentStack.prev;
        }

        var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\/[01]+#*)?i|[-+]?[01]+#*(?:\/[01]+#*)?@[-+]?[01]+#*(?:\/[01]+#*)?|[-+]?[01]+#*(?:\/[01]+#*)?[-+](?:[01]+#*(?:\/[01]+#*)?)?i|[-+]?[01]+#*(?:\/[01]+#*)?)(?=[()\s;"]|$)/i);
        var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?)(?=[()\s;"]|$)/i);
        var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\da-f]+#*(?:\/[\da-f]+#*)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?@[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?[-+](?:[\da-f]+#*(?:\/[\da-f]+#*)?)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?)(?=[()\s;"]|$)/i);
        var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)i|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)@[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)?i|(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*))(?=[()\s;"]|$)/i);

        function isBinaryNumber (stream) {
            return stream.match(binaryMatcher);
        }

        function isOctalNumber (stream) {
            return stream.match(octalMatcher);
        }

        function isDecimalNumber (stream, backup) {
            if (backup === true) {
                stream.backUp(1);
            }
            return stream.match(decimalMatcher);
        }

        function isHexNumber (stream) {
            return stream.match(hexMatcher);
        }

        return {
            startState: function () {
                return {
                    indentStack: null,
                    indentation: 0,
                    mode: false,
                    sExprComment: false,
                    sExprQuote: false
                };
            },

            token: function (stream, state) {
                if (state.indentStack == null && stream.sol()) {
                    // update indentation, but only if indentStack is empty
                    state.indentation = stream.indentation();
                }

                // skip spaces
                if (stream.eatSpace()) {
                    return null;
                }
                var returnType = null;

                switch(state.mode){
                    case "string": // multi-line string parsing mode
                        var next, escaped = false;
                        while ((next = stream.next()) != null) {
                            if (next == "\"" && !escaped) {

                                state.mode = false;
                                break;
                            }
                            escaped = !escaped && next == "\\";
                        }
                        returnType = STRING; // continue on in scheme-string mode
                        break;
                    case "comment": // comment parsing mode
                        var next, maybeEnd = false;
                        while ((next = stream.next()) != null) {
                            if (next == "#" && maybeEnd) {

                                state.mode = false;
                                break;
                            }
                            maybeEnd = (next == "|");
                        }
                        returnType = COMMENT;
                        break;
                    case "s-expr-comment": // s-expr commenting mode
                        state.mode = false;
                        if(stream.peek() == "(" || stream.peek() == "["){
                            // actually start scheme s-expr commenting mode
                            state.sExprComment = 0;
                        }else{
                            // if not we just comment the entire of the next token
                            stream.eatWhile(/[^\s\(\)\[\]]/); // eat symbol atom
                            returnType = COMMENT;
                            break;
                        }
                    default: // default parsing mode
                        var ch = stream.next();

                        if (ch == "\"") {
                            state.mode = "string";
                            returnType = STRING;

                        } else if (ch == "'") {
                            if (stream.peek() == "(" || stream.peek() == "["){
                                if (typeof state.sExprQuote != "number") {
                                    state.sExprQuote = 0;
                                } // else already in a quoted expression
                                returnType = ATOM;
                            } else {
                                stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);
                                returnType = ATOM;
                            }
                        } else if (ch == '#') {
                            if (stream.eat("|")) {                    // Multi-line comment
                                state.mode = "comment"; // toggle to comment mode
                                returnType = COMMENT;
                            } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)
                                returnType = ATOM;
                            } else if (stream.eat(';')) {                // S-Expr comment
                                state.mode = "s-expr-comment";
                                returnType = COMMENT;
                            } else {
                                var numTest = null, hasExactness = false, hasRadix = true;
                                if (stream.eat(/[ei]/i)) {
                                    hasExactness = true;
                                } else {
                                    stream.backUp(1);       // must be radix specifier
                                }
                                if (stream.match(/^#b/i)) {
                                    numTest = isBinaryNumber;
                                } else if (stream.match(/^#o/i)) {
                                    numTest = isOctalNumber;
                                } else if (stream.match(/^#x/i)) {
                                    numTest = isHexNumber;
                                } else if (stream.match(/^#d/i)) {
                                    numTest = isDecimalNumber;
                                } else if (stream.match(/^[-+0-9.]/, false)) {
                                    hasRadix = false;
                                    numTest = isDecimalNumber;
                                // re-consume the intial # if all matches failed
                                } else if (!hasExactness) {
                                    stream.eat('#');
                                }
                                if (numTest != null) {
                                    if (hasRadix && !hasExactness) {
                                        // consume optional exactness after radix
                                        stream.match(/^#[ei]/i);
                                    }
                                    if (numTest(stream))
                                        returnType = NUMBER;
                                }
                            }
                        } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal
                            returnType = NUMBER;
                        } else if (ch == ";") { // comment
                            stream.skipToEnd(); // rest of the line is a comment
                            returnType = COMMENT;
                        } else if (ch == "(" || ch == "[") {
                          var keyWord = ''; var indentTemp = stream.column(), letter;
                            /**
                            Either
                            (indent-word ..
                            (non-indent-word ..
                            (;something else, bracket, etc.
                            */

                            while ((letter = stream.eat(/[^\s\(\[\;\)\]]/)) != null) {
                                keyWord += letter;
                            }

                            if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word

                                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);
                            } else { // non-indent word
                                // we continue eating the spaces
                                stream.eatSpace();
                                if (stream.eol() || stream.peek() == ";") {
                                    // nothing significant after
                                    // we restart indentation 1 space after
                                    pushStack(state, indentTemp + 1, ch);
                                } else {
                                    pushStack(state, indentTemp + stream.current().length, ch); // else we match
                                }
                            }
                            stream.backUp(stream.current().length - 1); // undo all the eating

                            if(typeof state.sExprComment == "number") state.sExprComment++;
                            if(typeof state.sExprQuote == "number") state.sExprQuote++;

                            returnType = BRACKET;
                        } else if (ch == ")" || ch == "]") {
                            returnType = BRACKET;
                            if (state.indentStack != null && state.indentStack.type == (ch == ")" ? "(" : "[")) {
                                popStack(state);

                                if(typeof state.sExprComment == "number"){
                                    if(--state.sExprComment == 0){
                                        returnType = COMMENT; // final closing bracket
                                        state.sExprComment = false; // turn off s-expr commenting mode
                                    }
                                }
                                if(typeof state.sExprQuote == "number"){
                                    if(--state.sExprQuote == 0){
                                        returnType = ATOM; // final closing bracket
                                        state.sExprQuote = false; // turn off s-expr quote mode
                                    }
                                }
                            }
                        } else {
                            stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);

                            if (keywords && keywords.propertyIsEnumerable(stream.current())) {
                                returnType = BUILTIN;
                            } else returnType = "variable";
                        }
                }
                return (typeof state.sExprComment == "number") ? COMMENT : ((typeof state.sExprQuote == "number") ? ATOM : returnType);
            },

            indent: function (state) {
                if (state.indentStack == null) return state.indentation;
                return state.indentStack.indent;
            },

            closeBrackets: {pairs: "()[]{}\"\""},
            lineComment: ";;"
        };
    });

    CodeMirror.defineMIME("text/x-scheme", "scheme");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Shell(CodeMirror) {
    CodeMirror.defineMode('shell', function() {

      var words = {};
      function define(style, dict) {
        for(var i = 0; i < dict.length; i++) {
          words[dict[i]] = style;
        }
      }
      var commonAtoms = ["true", "false"];
      var commonKeywords = ["if", "then", "do", "else", "elif", "while", "until", "for", "in", "esac", "fi",
        "fin", "fil", "done", "exit", "set", "unset", "export", "function"];
      var commonCommands = ["ab", "awk", "bash", "beep", "cat", "cc", "cd", "chown", "chmod", "chroot", "clear",
        "cp", "curl", "cut", "diff", "echo", "find", "gawk", "gcc", "get", "git", "grep", "hg", "kill", "killall",
        "ln", "ls", "make", "mkdir", "openssl", "mv", "nc", "nl", "node", "npm", "ping", "ps", "restart", "rm",
        "rmdir", "sed", "service", "sh", "shopt", "shred", "source", "sort", "sleep", "ssh", "start", "stop",
        "su", "sudo", "svn", "tee", "telnet", "top", "touch", "vi", "vim", "wall", "wc", "wget", "who", "write",
        "yes", "zsh"];

      CodeMirror.registerHelper("hintWords", "shell", commonAtoms.concat(commonKeywords, commonCommands));

      define('atom', commonAtoms);
      define('keyword', commonKeywords);
      define('builtin', commonCommands);

      function tokenBase(stream, state) {
        if (stream.eatSpace()) return null;

        var sol = stream.sol();
        var ch = stream.next();

        if (ch === '\\') {
          stream.next();
          return null;
        }
        if (ch === '\'' || ch === '"' || ch === '`') {
          state.tokens.unshift(tokenString(ch, ch === "`" ? "quote" : "string"));
          return tokenize(stream, state);
        }
        if (ch === '#') {
          if (sol && stream.eat('!')) {
            stream.skipToEnd();
            return 'meta'; // 'comment'?
          }
          stream.skipToEnd();
          return 'comment';
        }
        if (ch === '$') {
          state.tokens.unshift(tokenDollar);
          return tokenize(stream, state);
        }
        if (ch === '+' || ch === '=') {
          return 'operator';
        }
        if (ch === '-') {
          stream.eat('-');
          stream.eatWhile(/\w/);
          return 'attribute';
        }
        if (/\d/.test(ch)) {
          stream.eatWhile(/\d/);
          if(stream.eol() || !/\w/.test(stream.peek())) {
            return 'number';
          }
        }
        stream.eatWhile(/[\w-]/);
        var cur = stream.current();
        if (stream.peek() === '=' && /\w+/.test(cur)) return 'def';
        return words.hasOwnProperty(cur) ? words[cur] : null;
      }

      function tokenString(quote, style) {
        var close = quote == "(" ? ")" : quote == "{" ? "}" : quote;
        return function(stream, state) {
          var next, escaped = false;
          while ((next = stream.next()) != null) {
            if (next === close && !escaped) {
              state.tokens.shift();
              break;
            } else if (next === '$' && !escaped && quote !== "'" && stream.peek() != close) {
              escaped = true;
              stream.backUp(1);
              state.tokens.unshift(tokenDollar);
              break;
            } else if (!escaped && quote !== close && next === quote) {
              state.tokens.unshift(tokenString(quote, style));
              return tokenize(stream, state)
            } else if (!escaped && /['"]/.test(next) && !/['"]/.test(quote)) {
              state.tokens.unshift(tokenStringStart(next, "string"));
              stream.backUp(1);
              break;
            }
            escaped = !escaped && next === '\\';
          }
          return style;
        };
      }
      function tokenStringStart(quote, style) {
        return function(stream, state) {
          state.tokens[0] = tokenString(quote, style);
          stream.next();
          return tokenize(stream, state)
        }
      }

      var tokenDollar = function(stream, state) {
        if (state.tokens.length > 1) stream.eat('$');
        var ch = stream.next();
        if (/['"({]/.test(ch)) {
          state.tokens[0] = tokenString(ch, ch == "(" ? "quote" : ch == "{" ? "def" : "string");
          return tokenize(stream, state);
        }
        if (!/\d/.test(ch)) stream.eatWhile(/\w/);
        state.tokens.shift();
        return 'def';
      };

      function tokenize(stream, state) {
        return (state.tokens[0] || tokenBase) (stream, state);
      }
      return {
        startState: function() {return {tokens:[]};},
        token: function(stream, state) {
          return tokenize(stream, state);
        },
        closeBrackets: "()[]{}''\"\"``",
        lineComment: '#',
        fold: "brace"
      };
    });

    CodeMirror.defineMIME('text/x-sh', 'shell');
    // Apache uses a slightly different Media Type for Shell scripts
    // http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
    CodeMirror.defineMIME('application/x-sh', 'shell');

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Shieve(CodeMirror) {

    CodeMirror.defineMode("sieve", function(config) {
      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var keywords = words("if elsif else stop require");
      var atoms = words("true false not");
      var indentUnit = config.indentUnit;

      function tokenBase(stream, state) {

        var ch = stream.next();
        if (ch == "/" && stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        }

        if (ch === '#') {
          stream.skipToEnd();
          return "comment";
        }

        if (ch == "\"") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }

        if (ch == "(") {
          state._indent.push("(");
          // add virtual angel wings so that editor behaves...
          // ...more sane incase of broken brackets
          state._indent.push("{");
          return null;
        }

        if (ch === "{") {
          state._indent.push("{");
          return null;
        }

        if (ch == ")")  {
          state._indent.pop();
          state._indent.pop();
        }

        if (ch === "}") {
          state._indent.pop();
          return null;
        }

        if (ch == ",")
          return null;

        if (ch == ";")
          return null;


        if (/[{}\(\),;]/.test(ch))
          return null;

        // 1*DIGIT "K" / "M" / "G"
        if (/\d/.test(ch)) {
          stream.eatWhile(/[\d]/);
          stream.eat(/[KkMmGg]/);
          return "number";
        }

        // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
        if (ch == ":") {
          stream.eatWhile(/[a-zA-Z_]/);
          stream.eatWhile(/[a-zA-Z0-9_]/);

          return "operator";
        }

        stream.eatWhile(/\w/);
        var cur = stream.current();

        // "text:" *(SP / HTAB) (hash-comment / CRLF)
        // *(multiline-literal / multiline-dotstart)
        // "." CRLF
        if ((cur == "text") && stream.eat(":"))
        {
          state.tokenize = tokenMultiLineString;
          return "string";
        }

        if (keywords.propertyIsEnumerable(cur))
          return "keyword";

        if (atoms.propertyIsEnumerable(cur))
          return "atom";

        return null;
      }

      function tokenMultiLineString(stream, state)
      {
        state._multiLineString = true;
        // the first line is special it may contain a comment
        if (!stream.sol()) {
          stream.eatSpace();

          if (stream.peek() == "#") {
            stream.skipToEnd();
            return "comment";
          }

          stream.skipToEnd();
          return "string";
        }

        if ((stream.next() == ".")  && (stream.eol()))
        {
          state._multiLineString = false;
          state.tokenize = tokenBase;
        }

        return "string";
      }

      function tokenCComment(stream, state) {
        var maybeEnd = false, ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped)
              break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) state.tokenize = tokenBase;
          return "string";
        };
      }

      return {
        startState: function(base) {
          return {tokenize: tokenBase,
                  baseIndent: base || 0,
                  _indent: []};
        },

        token: function(stream, state) {
          if (stream.eatSpace())
            return null;

          return (state.tokenize || tokenBase)(stream, state);
        },

        indent: function(state, _textAfter) {
          var length = state._indent.length;
          if (_textAfter && (_textAfter[0] == "}"))
            length--;

          if (length <0)
            length = 0;

          return length * indentUnit;
        },

        electricChars: "}"
      };
    });

    CodeMirror.defineMIME("application/sieve", "sieve");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh

    function Slim(CodeMirror) {
      CodeMirror.defineMode("slim", function(config) {
        var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
        var rubyMode = CodeMirror.getMode(config, "ruby");
        var modes = { html: htmlMode, ruby: rubyMode };
        var embedded = {
          ruby: "ruby",
          javascript: "javascript",
          css: "text/css",
          sass: "text/x-sass",
          scss: "text/x-scss",
          less: "text/x-less",
          styl: "text/x-styl", // no highlighting so far
          coffee: "coffeescript",
          asciidoc: "text/x-asciidoc",
          markdown: "text/x-markdown",
          textile: "text/x-textile", // no highlighting so far
          creole: "text/x-creole", // no highlighting so far
          wiki: "text/x-wiki", // no highlighting so far
          mediawiki: "text/x-mediawiki", // no highlighting so far
          rdoc: "text/x-rdoc", // no highlighting so far
          builder: "text/x-builder", // no highlighting so far
          nokogiri: "text/x-nokogiri", // no highlighting so far
          erb: "application/x-erb"
        };
        var embeddedRegexp = function(map){
          var arr = [];
          for(var key in map) arr.push(key);
          return new RegExp("^("+arr.join('|')+"):");
        }(embedded);

        var styleMap = {
          "commentLine": "comment",
          "slimSwitch": "operator special",
          "slimTag": "tag",
          "slimId": "attribute def",
          "slimClass": "attribute qualifier",
          "slimAttribute": "attribute",
          "slimSubmode": "keyword special",
          "closeAttributeTag": null,
          "slimDoctype": null,
          "lineContinuation": null
        };
        var closing = {
          "{": "}",
          "[": "]",
          "(": ")"
        };

        var nameStartChar = "_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
        var nameChar = nameStartChar + "\\-0-9\xB7\u0300-\u036F\u203F-\u2040";
        var nameRegexp = new RegExp("^[:"+nameStartChar+"](?::["+nameChar+"]|["+nameChar+"]*)");
        var attributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*(?=\\s*=)");
        var wrappedAttributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*");
        var classNameRegexp = /^\.-?[_a-zA-Z]+[\w\-]*/;
        var classIdRegexp = /^#[_a-zA-Z]+[\w\-]*/;

        function backup(pos, tokenize, style) {
          var restore = function(stream, state) {
            state.tokenize = tokenize;
            if (stream.pos < pos) {
              stream.pos = pos;
              return style;
            }
            return state.tokenize(stream, state);
          };
          return function(stream, state) {
            state.tokenize = restore;
            return tokenize(stream, state);
          };
        }

        function maybeBackup(stream, state, pat, offset, style) {
          var cur = stream.current();
          var idx = cur.search(pat);
          if (idx > -1) {
            state.tokenize = backup(stream.pos, state.tokenize, style);
            stream.backUp(cur.length - idx - offset);
          }
          return style;
        }

        function continueLine(state, column) {
          state.stack = {
            parent: state.stack,
            style: "continuation",
            indented: column,
            tokenize: state.line
          };
          state.line = state.tokenize;
        }
        function finishContinue(state) {
          if (state.line == state.tokenize) {
            state.line = state.stack.tokenize;
            state.stack = state.stack.parent;
          }
        }

        function lineContinuable(column, tokenize) {
          return function(stream, state) {
            finishContinue(state);
            if (stream.match(/^\\$/)) {
              continueLine(state, column);
              return "lineContinuation";
            }
            var style = tokenize(stream, state);
            if (stream.eol() && stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/)) {
              stream.backUp(1);
            }
            return style;
          };
        }
        function commaContinuable(column, tokenize) {
          return function(stream, state) {
            finishContinue(state);
            var style = tokenize(stream, state);
            if (stream.eol() && stream.current().match(/,$/)) {
              continueLine(state, column);
            }
            return style;
          };
        }

        function rubyInQuote(endQuote, tokenize) {
          // TODO: add multi line support
          return function(stream, state) {
            var ch = stream.peek();
            if (ch == endQuote && state.rubyState.tokenize.length == 1) {
              // step out of ruby context as it seems to complete processing all the braces
              stream.next();
              state.tokenize = tokenize;
              return "closeAttributeTag";
            } else {
              return ruby(stream, state);
            }
          };
        }
        function startRubySplat(tokenize) {
          var rubyState;
          var runSplat = function(stream, state) {
            if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {
              stream.backUp(1);
              if (stream.eatSpace()) {
                state.rubyState = rubyState;
                state.tokenize = tokenize;
                return tokenize(stream, state);
              }
              stream.next();
            }
            return ruby(stream, state);
          };
          return function(stream, state) {
            rubyState = state.rubyState;
            state.rubyState = CodeMirror.startState(rubyMode);
            state.tokenize = runSplat;
            return ruby(stream, state);
          };
        }

        function ruby(stream, state) {
          return rubyMode.token(stream, state.rubyState);
        }

        function htmlLine(stream, state) {
          if (stream.match(/^\\$/)) {
            return "lineContinuation";
          }
          return html(stream, state);
        }
        function html(stream, state) {
          if (stream.match(/^#\{/)) {
            state.tokenize = rubyInQuote("}", state.tokenize);
            return null;
          }
          return maybeBackup(stream, state, /[^\\]#\{/, 1, htmlMode.token(stream, state.htmlState));
        }

        function startHtmlLine(lastTokenize) {
          return function(stream, state) {
            var style = htmlLine(stream, state);
            if (stream.eol()) state.tokenize = lastTokenize;
            return style;
          };
        }

        function startHtmlMode(stream, state, offset) {
          state.stack = {
            parent: state.stack,
            style: "html",
            indented: stream.column() + offset, // pipe + space
            tokenize: state.line
          };
          state.line = state.tokenize = html;
          return null;
        }

        function comment(stream, state) {
          stream.skipToEnd();
          return state.stack.style;
        }

        function commentMode(stream, state) {
          state.stack = {
            parent: state.stack,
            style: "comment",
            indented: state.indented + 1,
            tokenize: state.line
          };
          state.line = comment;
          return comment(stream, state);
        }

        function attributeWrapper(stream, state) {
          if (stream.eat(state.stack.endQuote)) {
            state.line = state.stack.line;
            state.tokenize = state.stack.tokenize;
            state.stack = state.stack.parent;
            return null;
          }
          if (stream.match(wrappedAttributeNameRegexp)) {
            state.tokenize = attributeWrapperAssign;
            return "slimAttribute";
          }
          stream.next();
          return null;
        }
        function attributeWrapperAssign(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = attributeWrapperValue;
            return null;
          }
          return attributeWrapper(stream, state);
        }
        function attributeWrapperValue(stream, state) {
          var ch = stream.peek();
          if (ch == '"' || ch == "\'") {
            state.tokenize = readQuoted(ch, "string", true, false, attributeWrapper);
            stream.next();
            return state.tokenize(stream, state);
          }
          if (ch == '[') {
            return startRubySplat(attributeWrapper)(stream, state);
          }
          if (stream.match(/^(true|false|nil)\b/)) {
            state.tokenize = attributeWrapper;
            return "keyword";
          }
          return startRubySplat(attributeWrapper)(stream, state);
        }

        function startAttributeWrapperMode(state, endQuote, tokenize) {
          state.stack = {
            parent: state.stack,
            style: "wrapper",
            indented: state.indented + 1,
            tokenize: tokenize,
            line: state.line,
            endQuote: endQuote
          };
          state.line = state.tokenize = attributeWrapper;
          return null;
        }

        function sub(stream, state) {
          if (stream.match(/^#\{/)) {
            state.tokenize = rubyInQuote("}", state.tokenize);
            return null;
          }
          var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);
          subStream.pos = stream.pos - state.stack.indented;
          subStream.start = stream.start - state.stack.indented;
          subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;
          subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;
          var style = state.subMode.token(subStream, state.subState);
          stream.pos = subStream.pos + state.stack.indented;
          return style;
        }
        function firstSub(stream, state) {
          state.stack.indented = stream.column();
          state.line = state.tokenize = sub;
          return state.tokenize(stream, state);
        }

        function createMode(mode) {
          var query = embedded[mode];
          var spec = CodeMirror.mimeModes[query];
          if (spec) {
            return CodeMirror.getMode(config, spec);
          }
          var factory = CodeMirror.modes[query];
          if (factory) {
            return factory(config, {name: query});
          }
          return CodeMirror.getMode(config, "null");
        }

        function getMode(mode) {
          if (!modes.hasOwnProperty(mode)) {
            return modes[mode] = createMode(mode);
          }
          return modes[mode];
        }

        function startSubMode(mode, state) {
          var subMode = getMode(mode);
          var subState = CodeMirror.startState(subMode);

          state.subMode = subMode;
          state.subState = subState;

          state.stack = {
            parent: state.stack,
            style: "sub",
            indented: state.indented + 1,
            tokenize: state.line
          };
          state.line = state.tokenize = firstSub;
          return "slimSubmode";
        }

        function doctypeLine(stream, _state) {
          stream.skipToEnd();
          return "slimDoctype";
        }

        function startLine(stream, state) {
          var ch = stream.peek();
          if (ch == '<') {
            return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);
          }
          if (stream.match(/^[|']/)) {
            return startHtmlMode(stream, state, 1);
          }
          if (stream.match(/^\/(!|\[\w+])?/)) {
            return commentMode(stream, state);
          }
          if (stream.match(/^(-|==?[<>]?)/)) {
            state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));
            return "slimSwitch";
          }
          if (stream.match(/^doctype\b/)) {
            state.tokenize = doctypeLine;
            return "keyword";
          }

          var m = stream.match(embeddedRegexp);
          if (m) {
            return startSubMode(m[1], state);
          }

          return slimTag(stream, state);
        }

        function slim(stream, state) {
          if (state.startOfLine) {
            return startLine(stream, state);
          }
          return slimTag(stream, state);
        }

        function slimTag(stream, state) {
          if (stream.eat('*')) {
            state.tokenize = startRubySplat(slimTagExtras);
            return null;
          }
          if (stream.match(nameRegexp)) {
            state.tokenize = slimTagExtras;
            return "slimTag";
          }
          return slimClass(stream, state);
        }
        function slimTagExtras(stream, state) {
          if (stream.match(/^(<>?|><?)/)) {
            state.tokenize = slimClass;
            return null;
          }
          return slimClass(stream, state);
        }
        function slimClass(stream, state) {
          if (stream.match(classIdRegexp)) {
            state.tokenize = slimClass;
            return "slimId";
          }
          if (stream.match(classNameRegexp)) {
            state.tokenize = slimClass;
            return "slimClass";
          }
          return slimAttribute(stream, state);
        }
        function slimAttribute(stream, state) {
          if (stream.match(/^([\[\{\(])/)) {
            return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);
          }
          if (stream.match(attributeNameRegexp)) {
            state.tokenize = slimAttributeAssign;
            return "slimAttribute";
          }
          if (stream.peek() == '*') {
            stream.next();
            state.tokenize = startRubySplat(slimContent);
            return null;
          }
          return slimContent(stream, state);
        }
        function slimAttributeAssign(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = slimAttributeValue;
            return null;
          }
          // should never happen, because of forward lookup
          return slimAttribute(stream, state);
        }

        function slimAttributeValue(stream, state) {
          var ch = stream.peek();
          if (ch == '"' || ch == "\'") {
            state.tokenize = readQuoted(ch, "string", true, false, slimAttribute);
            stream.next();
            return state.tokenize(stream, state);
          }
          if (ch == '[') {
            return startRubySplat(slimAttribute)(stream, state);
          }
          if (ch == ':') {
            return startRubySplat(slimAttributeSymbols)(stream, state);
          }
          if (stream.match(/^(true|false|nil)\b/)) {
            state.tokenize = slimAttribute;
            return "keyword";
          }
          return startRubySplat(slimAttribute)(stream, state);
        }
        function slimAttributeSymbols(stream, state) {
          stream.backUp(1);
          if (stream.match(/^[^\s],(?=:)/)) {
            state.tokenize = startRubySplat(slimAttributeSymbols);
            return null;
          }
          stream.next();
          return slimAttribute(stream, state);
        }
        function readQuoted(quote, style, embed, unescaped, nextTokenize) {
          return function(stream, state) {
            finishContinue(state);
            var fresh = stream.current().length == 0;
            if (stream.match(/^\\$/, fresh)) {
              if (!fresh) return style;
              continueLine(state, state.indented);
              return "lineContinuation";
            }
            if (stream.match(/^#\{/, fresh)) {
              if (!fresh) return style;
              state.tokenize = rubyInQuote("}", state.tokenize);
              return null;
            }
            var escaped = false, ch;
            while ((ch = stream.next()) != null) {
              if (ch == quote && (unescaped || !escaped)) {
                state.tokenize = nextTokenize;
                break;
              }
              if (embed && ch == "#" && !escaped) {
                if (stream.eat("{")) {
                  stream.backUp(2);
                  break;
                }
              }
              escaped = !escaped && ch == "\\";
            }
            if (stream.eol() && escaped) {
              stream.backUp(1);
            }
            return style;
          };
        }
        function slimContent(stream, state) {
          if (stream.match(/^==?/)) {
            state.tokenize = ruby;
            return "slimSwitch";
          }
          if (stream.match(/^\/$/)) { // tag close hint
            state.tokenize = slim;
            return null;
          }
          if (stream.match(/^:/)) { // inline tag
            state.tokenize = slimTag;
            return "slimSwitch";
          }
          startHtmlMode(stream, state, 0);
          return state.tokenize(stream, state);
        }

        var mode = {
          // default to html mode
          startState: function() {
            var htmlState = CodeMirror.startState(htmlMode);
            var rubyState = CodeMirror.startState(rubyMode);
            return {
              htmlState: htmlState,
              rubyState: rubyState,
              stack: null,
              last: null,
              tokenize: slim,
              line: slim,
              indented: 0
            };
          },

          copyState: function(state) {
            return {
              htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
              rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
              subMode: state.subMode,
              subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),
              stack: state.stack,
              last: state.last,
              tokenize: state.tokenize,
              line: state.line
            };
          },

          token: function(stream, state) {
            if (stream.sol()) {
              state.indented = stream.indentation();
              state.startOfLine = true;
              state.tokenize = state.line;
              while (state.stack && state.stack.indented > state.indented && state.last != "slimSubmode") {
                state.line = state.tokenize = state.stack.tokenize;
                state.stack = state.stack.parent;
                state.subMode = null;
                state.subState = null;
              }
            }
            if (stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            state.startOfLine = false;
            if (style) state.last = style;
            return styleMap.hasOwnProperty(style) ? styleMap[style] : style;
          },

          blankLine: function(state) {
            if (state.subMode && state.subMode.blankLine) {
              return state.subMode.blankLine(state.subState);
            }
          },

          innerMode: function(state) {
            if (state.subMode) return {state: state.subState, mode: state.subMode};
            return {state: state, mode: mode};
          }

          //indent: function(state) {
          //  return state.indented;
          //}
        };
        return mode;
      }, "htmlmixed", "ruby");

      CodeMirror.defineMIME("text/x-slim", "slim");
      CodeMirror.defineMIME("application/x-slim", "slim");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function SmallTalk(CodeMirror) {
    CodeMirror.defineMode('smalltalk', function(config) {

      var specialChars = /[+\-\/\\*~<>=@%|&?!.,:;^]/;
      var keywords = /true|false|nil|self|super|thisContext/;

      var Context = function(tokenizer, parent) {
        this.next = tokenizer;
        this.parent = parent;
      };

      var Token = function(name, context, eos) {
        this.name = name;
        this.context = context;
        this.eos = eos;
      };

      var State = function() {
        this.context = new Context(next, null);
        this.expectVariable = true;
        this.indentation = 0;
        this.userIndentationDelta = 0;
      };

      State.prototype.userIndent = function(indentation) {
        this.userIndentationDelta = indentation > 0 ? (indentation / config.indentUnit - this.indentation) : 0;
      };

      var next = function(stream, context, state) {
        var token = new Token(null, context, false);
        var aChar = stream.next();

        if (aChar === '"') {
          token = nextComment(stream, new Context(nextComment, context));

        } else if (aChar === '\'') {
          token = nextString(stream, new Context(nextString, context));

        } else if (aChar === '#') {
          if (stream.peek() === '\'') {
            stream.next();
            token = nextSymbol(stream, new Context(nextSymbol, context));
          } else {
            if (stream.eatWhile(/[^\s.{}\[\]()]/))
              token.name = 'string-2';
            else
              token.name = 'meta';
          }

        } else if (aChar === '$') {
          if (stream.next() === '<') {
            stream.eatWhile(/[^\s>]/);
            stream.next();
          }
          token.name = 'string-2';

        } else if (aChar === '|' && state.expectVariable) {
          token.context = new Context(nextTemporaries, context);

        } else if (/[\[\]{}()]/.test(aChar)) {
          token.name = 'bracket';
          token.eos = /[\[{(]/.test(aChar);

          if (aChar === '[') {
            state.indentation++;
          } else if (aChar === ']') {
            state.indentation = Math.max(0, state.indentation - 1);
          }

        } else if (specialChars.test(aChar)) {
          stream.eatWhile(specialChars);
          token.name = 'operator';
          token.eos = aChar !== ';'; // ; cascaded message expression

        } else if (/\d/.test(aChar)) {
          stream.eatWhile(/[\w\d]/);
          token.name = 'number';

        } else if (/[\w_]/.test(aChar)) {
          stream.eatWhile(/[\w\d_]/);
          token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;

        } else {
          token.eos = state.expectVariable;
        }

        return token;
      };

      var nextComment = function(stream, context) {
        stream.eatWhile(/[^"]/);
        return new Token('comment', stream.eat('"') ? context.parent : context, true);
      };

      var nextString = function(stream, context) {
        stream.eatWhile(/[^']/);
        return new Token('string', stream.eat('\'') ? context.parent : context, false);
      };

      var nextSymbol = function(stream, context) {
        stream.eatWhile(/[^']/);
        return new Token('string-2', stream.eat('\'') ? context.parent : context, false);
      };

      var nextTemporaries = function(stream, context) {
        var token = new Token(null, context, false);
        var aChar = stream.next();

        if (aChar === '|') {
          token.context = context.parent;
          token.eos = true;

        } else {
          stream.eatWhile(/[^|]/);
          token.name = 'variable';
        }

        return token;
      };

      return {
        startState: function() {
          return new State;
        },

        token: function(stream, state) {
          state.userIndent(stream.indentation());

          if (stream.eatSpace()) {
            return null;
          }

          var token = state.context.next(stream, state.context, state);
          state.context = token.context;
          state.expectVariable = token.eos;

          return token.name;
        },

        blankLine: function(state) {
          state.userIndent(0);
        },

        indent: function(state, textAfter) {
          var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;
          return (state.indentation + i) * config.indentUnit;
        },

        electricChars: ']'
      };

    });

    CodeMirror.defineMIME('text/x-stsrc', {name: 'smalltalk'});

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /**
     * Smarty 2 and 3 mode.
     */

    function Smarty(CodeMirror) {
      CodeMirror.defineMode("smarty", function(config, parserConf) {
        var rightDelimiter = parserConf.rightDelimiter || "}";
        var leftDelimiter = parserConf.leftDelimiter || "{";
        var version = parserConf.version || 2;
        var baseMode = CodeMirror.getMode(config, parserConf.baseMode || "null");

        var keyFunctions = ["debug", "extends", "function", "include", "literal"];
        var regs = {
          operatorChars: /[+\-*&%=<>!?]/,
          validIdentifier: /[a-zA-Z0-9_]/,
          stringChar: /['"]/
        };

        var last;
        function cont(style, lastType) {
          last = lastType;
          return style;
        }

        function chain(stream, state, parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode
        function doesNotCount(stream, pos) {
          if (pos == null) pos = stream.pos;
          return version === 3 && leftDelimiter == "{" &&
            (pos == stream.string.length || /\s/.test(stream.string.charAt(pos)));
        }

        function tokenTop(stream, state) {
          var string = stream.string;
          for (var scan = stream.pos;;) {
            var nextMatch = string.indexOf(leftDelimiter, scan);
            scan = nextMatch + leftDelimiter.length;
            if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;
          }
          if (nextMatch == stream.pos) {
            stream.match(leftDelimiter);
            if (stream.eat("*")) {
              return chain(stream, state, tokenBlock("comment", "*" + rightDelimiter));
            } else {
              state.depth++;
              state.tokenize = tokenSmarty;
              last = "startTag";
              return "tag";
            }
          }

          if (nextMatch > -1) stream.string = string.slice(0, nextMatch);
          var token = baseMode.token(stream, state.base);
          if (nextMatch > -1) stream.string = string;
          return token;
        }

        // parsing Smarty content
        function tokenSmarty(stream, state) {
          if (stream.match(rightDelimiter, true)) {
            if (version === 3) {
              state.depth--;
              if (state.depth <= 0) {
                state.tokenize = tokenTop;
              }
            } else {
              state.tokenize = tokenTop;
            }
            return cont("tag", null);
          }

          if (stream.match(leftDelimiter, true)) {
            state.depth++;
            return cont("tag", "startTag");
          }

          var ch = stream.next();
          if (ch == "$") {
            stream.eatWhile(regs.validIdentifier);
            return cont("variable-2", "variable");
          } else if (ch == "|") {
            return cont("operator", "pipe");
          } else if (ch == ".") {
            return cont("operator", "property");
          } else if (regs.stringChar.test(ch)) {
            state.tokenize = tokenAttribute(ch);
            return cont("string", "string");
          } else if (regs.operatorChars.test(ch)) {
            stream.eatWhile(regs.operatorChars);
            return cont("operator", "operator");
          } else if (ch == "[" || ch == "]") {
            return cont("bracket", "bracket");
          } else if (ch == "(" || ch == ")") {
            return cont("bracket", "operator");
          } else if (/\d/.test(ch)) {
            stream.eatWhile(/\d/);
            return cont("number", "number");
          } else {

            if (state.last == "variable") {
              if (ch == "@") {
                stream.eatWhile(regs.validIdentifier);
                return cont("property", "property");
              } else if (ch == "|") {
                stream.eatWhile(regs.validIdentifier);
                return cont("qualifier", "modifier");
              }
            } else if (state.last == "pipe") {
              stream.eatWhile(regs.validIdentifier);
              return cont("qualifier", "modifier");
            } else if (state.last == "whitespace") {
              stream.eatWhile(regs.validIdentifier);
              return cont("attribute", "modifier");
            } if (state.last == "property") {
              stream.eatWhile(regs.validIdentifier);
              return cont("property", null);
            } else if (/\s/.test(ch)) {
              last = "whitespace";
              return null;
            }

            var str = "";
            if (ch != "/") {
              str += ch;
            }
            var c = null;
            while (c = stream.eat(regs.validIdentifier)) {
              str += c;
            }
            for (var i=0, j=keyFunctions.length; i<j; i++) {
              if (keyFunctions[i] == str) {
                return cont("keyword", "keyword");
              }
            }
            if (/\s/.test(ch)) {
              return null;
            }
            return cont("tag", "tag");
          }
        }

        function tokenAttribute(quote) {
          return function(stream, state) {
            var prevChar = null;
            var currChar = null;
            while (!stream.eol()) {
              currChar = stream.peek();
              if (stream.next() == quote && prevChar !== '\\') {
                state.tokenize = tokenSmarty;
                break;
              }
              prevChar = currChar;
            }
            return "string";
          };
        }

        function tokenBlock(style, terminator) {
          return function(stream, state) {
            while (!stream.eol()) {
              if (stream.match(terminator)) {
                state.tokenize = tokenTop;
                break;
              }
              stream.next();
            }
            return style;
          };
        }

        return {
          startState: function() {
            return {
              base: CodeMirror.startState(baseMode),
              tokenize: tokenTop,
              last: null,
              depth: 0
            };
          },
          copyState: function(state) {
            return {
              base: CodeMirror.copyState(baseMode, state.base),
              tokenize: state.tokenize,
              last: state.last,
              depth: state.depth
            };
          },
          innerMode: function(state) {
            if (state.tokenize == tokenTop)
              return {mode: baseMode, state: state.base};
          },
          token: function(stream, state) {
            var style = state.tokenize(stream, state);
            state.last = last;
            return style;
          },
          indent: function(state, text, line) {
            if (state.tokenize == tokenTop && baseMode.indent)
              return baseMode.indent(state.base, text, line);
            else
              return CodeMirror.Pass;
          },
          blockCommentStart: leftDelimiter + "*",
          blockCommentEnd: "*" + rightDelimiter
        };
      });

      CodeMirror.defineMIME("text/x-smarty", "smarty");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Solr(CodeMirror) {
    CodeMirror.defineMode("solr", function() {
      var isStringChar = /[^\s\|\!\+\-\*\?\~\^\&\:\(\)\[\]\{\}\"\\]/;
      var isOperatorChar = /[\|\!\+\-\*\?\~\^\&]/;
      var isOperatorString = /^(OR|AND|NOT|TO)$/i;

      function isNumber(word) {
        return parseFloat(word).toString() === word;
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) break;
            escaped = !escaped && next == "\\";
          }

          if (!escaped) state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenOperator(operator) {
        return function(stream, state) {
          var style = "operator";
          if (operator == "+")
            style += " positive";
          else if (operator == "-")
            style += " negative";
          else if (operator == "|")
            stream.eat(/\|/);
          else if (operator == "&")
            stream.eat(/\&/);
          else if (operator == "^")
            style += " boost";

          state.tokenize = tokenBase;
          return style;
        };
      }

      function tokenWord(ch) {
        return function(stream, state) {
          var word = ch;
          while ((ch = stream.peek()) && ch.match(isStringChar) != null) {
            word += stream.next();
          }

          state.tokenize = tokenBase;
          if (isOperatorString.test(word))
            return "operator";
          else if (isNumber(word))
            return "number";
          else if (stream.peek() == ":")
            return "field";
          else
            return "string";
        };
      }

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"')
          state.tokenize = tokenString(ch);
        else if (isOperatorChar.test(ch))
          state.tokenize = tokenOperator(ch);
        else if (isStringChar.test(ch))
          state.tokenize = tokenWord(ch);

        return (state.tokenize != tokenBase) ? state.tokenize(stream, state) : null;
      }

      return {
        startState: function() {
          return {
            tokenize: tokenBase
          };
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME("text/x-solr", "solr");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Soy(CodeMirror) {
      var indentingTags = ["template", "literal", "msg", "fallbackmsg", "let", "if", "elseif",
                           "else", "switch", "case", "default", "foreach", "ifempty", "for",
                           "call", "param", "deltemplate", "delcall", "log", "element"];

      CodeMirror.defineMode("soy", function(config) {
        var textMode = CodeMirror.getMode(config, "text/plain");
        var modes = {
          html: CodeMirror.getMode(config, {name: "text/html", multilineTagIndentFactor: 2, multilineTagIndentPastTag: false}),
          attributes: textMode,
          text: textMode,
          uri: textMode,
          trusted_resource_uri: textMode,
          css: CodeMirror.getMode(config, "text/css"),
          js: CodeMirror.getMode(config, {name: "text/javascript", statementIndent: 2 * config.indentUnit})
        };

        function last(array) {
          return array[array.length - 1];
        }

        function tokenUntil(stream, state, untilRegExp) {
          if (stream.sol()) {
            for (var indent = 0; indent < state.indent; indent++) {
              if (!stream.eat(/\s/)) break;
            }
            if (indent) return null;
          }
          var oldString = stream.string;
          var match = untilRegExp.exec(oldString.substr(stream.pos));
          if (match) {
            // We don't use backUp because it backs up just the position, not the state.
            // This uses an undocumented API.
            stream.string = oldString.substr(0, stream.pos + match.index);
          }
          var result = stream.hideFirstChars(state.indent, function() {
            var localState = last(state.localStates);
            return localState.mode.token(stream, localState.state);
          });
          stream.string = oldString;
          return result;
        }

        function contains(list, element) {
          while (list) {
            if (list.element === element) return true;
            list = list.next;
          }
          return false;
        }

        function prepend(list, element) {
          return {
            element: element,
            next: list
          };
        }

        // Reference a variable `name` in `list`.
        // Let `loose` be truthy to ignore missing identifiers.
        function ref(list, name, loose) {
          return contains(list, name) ? "variable-2" : (loose ? "variable" : "variable-2 error");
        }

        function popscope(state) {
          if (state.scopes) {
            state.variables = state.scopes.element;
            state.scopes = state.scopes.next;
          }
        }

        return {
          startState: function() {
            return {
              kind: [],
              kindTag: [],
              soyState: [],
              templates: null,
              variables: prepend(null, 'ij'),
              scopes: null,
              indent: 0,
              quoteKind: null,
              localStates: [{
                mode: modes.html,
                state: CodeMirror.startState(modes.html)
              }]
            };
          },

          copyState: function(state) {
            return {
              tag: state.tag, // Last seen Soy tag.
              kind: state.kind.concat([]), // Values of kind="" attributes.
              kindTag: state.kindTag.concat([]), // Opened tags with kind="" attributes.
              soyState: state.soyState.concat([]),
              templates: state.templates,
              variables: state.variables,
              scopes: state.scopes,
              indent: state.indent, // Indentation of the following line.
              quoteKind: state.quoteKind,
              localStates: state.localStates.map(function(localState) {
                return {
                  mode: localState.mode,
                  state: CodeMirror.copyState(localState.mode, localState.state)
                };
              })
            };
          },

          token: function(stream, state) {
            var match;

            switch (last(state.soyState)) {
              case "comment":
                if (stream.match(/^.*?\*\//)) {
                  state.soyState.pop();
                } else {
                  stream.skipToEnd();
                }
                if (!state.scopes) {
                  var paramRe = /@param\??\s+(\S+)/g;
                  var current = stream.current();
                  for (var match; (match = paramRe.exec(current)); ) {
                    state.variables = prepend(state.variables, match[1]);
                  }
                }
                return "comment";

              case "string":
                var match = stream.match(/^.*?(["']|\\[\s\S])/);
                if (!match) {
                  stream.skipToEnd();
                } else if (match[1] == state.quoteKind) {
                  state.quoteKind = null;
                  state.soyState.pop();
                }
                return "string";
            }

            if (!state.soyState.length || last(state.soyState) != "literal") {
              if (stream.match(/^\/\*/)) {
                state.soyState.push("comment");
                return "comment";
              } else if (stream.match(stream.sol() ? /^\s*\/\/.*/ : /^\s+\/\/.*/)) {
                return "comment";
              }
            }

            switch (last(state.soyState)) {
              case "templ-def":
                if (match = stream.match(/^\.?([\w]+(?!\.[\w]+)*)/)) {
                  state.templates = prepend(state.templates, match[1]);
                  state.scopes = prepend(state.scopes, state.variables);
                  state.soyState.pop();
                  return "def";
                }
                stream.next();
                return null;

              case "templ-ref":
                if (match = stream.match(/(\.?[a-zA-Z_][a-zA-Z_0-9]+)+/)) {
                  state.soyState.pop();
                  // If the first character is '.', it can only be a local template.
                  if (match[0][0] == '.') {
                    return "variable-2"
                  }
                  // Otherwise
                  return "variable";
                }
                stream.next();
                return null;

              case "namespace-def":
                if (match = stream.match(/^\.?([\w\.]+)/)) {
                  state.soyState.pop();
                  return "variable";
                }
                stream.next();
                return null;

              case "param-def":
                if (match = stream.match(/^\w+/)) {
                  state.variables = prepend(state.variables, match[0]);
                  state.soyState.pop();
                  state.soyState.push("param-type");
                  return "def";
                }
                stream.next();
                return null;

              case "param-ref":
                if (match = stream.match(/^\w+/)) {
                  state.soyState.pop();
                  return "property";
                }
                stream.next();
                return null;

              case "param-type":
                if (stream.peek() == "}") {
                  state.soyState.pop();
                  return null;
                }
                if (stream.eatWhile(/^([\w]+|[?])/)) {
                  return "type";
                }
                stream.next();
                return null;

              case "var-def":
                if (match = stream.match(/^\$([\w]+)/)) {
                  state.variables = prepend(state.variables, match[1]);
                  state.soyState.pop();
                  return "def";
                }
                stream.next();
                return null;

              case "tag":
                if (stream.match(/^\/?}/)) {
                  if (state.tag == "/template" || state.tag == "/deltemplate") {
                    popscope(state);
                    state.variables = prepend(null, 'ij');
                    state.indent = 0;
                  } else {
                    if (state.tag == "/for" || state.tag == "/foreach") {
                      popscope(state);
                    }
                    state.indent -= config.indentUnit *
                        (stream.current() == "/}" || indentingTags.indexOf(state.tag) == -1 ? 2 : 1);
                  }
                  state.soyState.pop();
                  return "keyword";
                } else if (stream.match(/^([\w?]+)(?==)/)) {
                  if (stream.current() == "kind" && (match = stream.match(/^="([^"]+)/, false))) {
                    var kind = match[1];
                    state.kind.push(kind);
                    state.kindTag.push(state.tag);
                    var mode = modes[kind] || modes.html;
                    var localState = last(state.localStates);
                    if (localState.mode.indent) {
                      state.indent += localState.mode.indent(localState.state, "", "");
                    }
                    state.localStates.push({
                      mode: mode,
                      state: CodeMirror.startState(mode)
                    });
                  }
                  return "attribute";
                } else if (match = stream.match(/([\w]+)(?=\()/)) {
                  return "variable callee";
                } else if (match = stream.match(/^["']/)) {
                  state.soyState.push("string");
                  state.quoteKind = match;
                  return "string";
                }
                if (stream.match(/(null|true|false)(?!\w)/) ||
                  stream.match(/0x([0-9a-fA-F]{2,})/) ||
                  stream.match(/-?([0-9]*[.])?[0-9]+(e[0-9]*)?/)) {
                  return "atom";
                }
                if (stream.match(/(\||[+\-*\/%]|[=!]=|\?:|[<>]=?)/)) {
                  // Tokenize filter, binary, null propagator, and equality operators.
                  return "operator";
                }
                if (match = stream.match(/^\$([\w]+)/)) {
                  return ref(state.variables, match[1]);
                }
                if (match = stream.match(/^\w+/)) {
                  return /^(?:as|and|or|not|in)$/.test(match[0]) ? "keyword" : null;
                }
                stream.next();
                return null;

              case "literal":
                if (stream.match(/^(?=\{\/literal})/)) {
                  state.indent -= config.indentUnit;
                  state.soyState.pop();
                  return this.token(stream, state);
                }
                return tokenUntil(stream, state, /\{\/literal}/);
            }

            if (stream.match(/^\{literal}/)) {
              state.indent += config.indentUnit;
              state.soyState.push("literal");
              return "keyword";

            // A tag-keyword must be followed by whitespace, comment or a closing tag.
            } else if (match = stream.match(/^\{([/@\\]?\w+\??)(?=$|[\s}]|\/[/*])/)) {
              if (match[1] != "/switch")
                state.indent += (/^(\/|(else|elseif|ifempty|case|fallbackmsg|default)$)/.test(match[1]) && state.tag != "switch" ? 1 : 2) * config.indentUnit;
              state.tag = match[1];
              if (state.tag == "/" + last(state.kindTag)) {
                // We found the tag that opened the current kind="".
                state.kind.pop();
                state.kindTag.pop();
                state.localStates.pop();
                var localState = last(state.localStates);
                if (localState.mode.indent) {
                  state.indent -= localState.mode.indent(localState.state, "", "");
                }
              }
              state.soyState.push("tag");
              if (state.tag == "template" || state.tag == "deltemplate") {
                state.soyState.push("templ-def");
              } else if (state.tag == "call" || state.tag == "delcall") {
                state.soyState.push("templ-ref");
              } else if (state.tag == "let") {
                state.soyState.push("var-def");
              } else if (state.tag == "for" || state.tag == "foreach") {
                state.scopes = prepend(state.scopes, state.variables);
                state.soyState.push("var-def");
              } else if (state.tag == "namespace") {
                state.soyState.push("namespace-def");
                if (!state.scopes) {
                  state.variables = prepend(null, 'ij');
                }
              } else if (state.tag.match(/^@(?:param\??|inject|state)/)) {
                state.soyState.push("param-def");
              } else if (state.tag.match(/^(?:param)/)) {
                state.soyState.push("param-ref");
              }
              return "keyword";

            // Not a tag-keyword; it's an implicit print tag.
            } else if (stream.eat('{')) {
              state.tag = "print";
              state.indent += 2 * config.indentUnit;
              state.soyState.push("tag");
              return "keyword";
            }

            return tokenUntil(stream, state, /\{|\s+\/\/|\/\*/);
          },

          indent: function(state, textAfter, line) {
            var indent = state.indent, top = last(state.soyState);
            if (top == "comment") return CodeMirror.Pass;

            if (top == "literal") {
              if (/^\{\/literal}/.test(textAfter)) indent -= config.indentUnit;
            } else {
              if (/^\s*\{\/(template|deltemplate)\b/.test(textAfter)) return 0;
              if (/^\{(\/|(fallbackmsg|elseif|else|ifempty)\b)/.test(textAfter)) indent -= config.indentUnit;
              if (state.tag != "switch" && /^\{(case|default)\b/.test(textAfter)) indent -= config.indentUnit;
              if (/^\{\/switch\b/.test(textAfter)) indent -= config.indentUnit;
            }
            var localState = last(state.localStates);
            if (indent && localState.mode.indent) {
              indent += localState.mode.indent(localState.state, textAfter, line);
            }
            return indent;
          },

          innerMode: function(state) {
            if (state.soyState.length && last(state.soyState) != "literal") return null;
            else return last(state.localStates);
          },

          electricInput: /^\s*\{(\/|\/template|\/deltemplate|\/switch|fallbackmsg|elseif|else|case|default|ifempty|\/literal\})$/,
          lineComment: "//",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          blockCommentContinue: " * ",
          useInnerComments: false,
          fold: "indent"
        };
      }, "htmlmixed");

      CodeMirror.registerHelper("wordChars", "soy", /[\w$]/);

      CodeMirror.registerHelper("hintWords", "soy", indentingTags.concat(
          ["delpackage", "namespace", "alias", "print", "css", "debugger"]));

      CodeMirror.defineMIME("text/x-soy", "soy");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Sparql(CodeMirror) {
    CodeMirror.defineMode("sparql", function(config) {
      var indentUnit = config.indentUnit;
      var curPunc;

      function wordRegexp(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      }
      var ops = wordRegexp(["str", "lang", "langmatches", "datatype", "bound", "sameterm", "isiri", "isuri",
                            "iri", "uri", "bnode", "count", "sum", "min", "max", "avg", "sample",
                            "group_concat", "rand", "abs", "ceil", "floor", "round", "concat", "substr", "strlen",
                            "replace", "ucase", "lcase", "encode_for_uri", "contains", "strstarts", "strends",
                            "strbefore", "strafter", "year", "month", "day", "hours", "minutes", "seconds",
                            "timezone", "tz", "now", "uuid", "struuid", "md5", "sha1", "sha256", "sha384",
                            "sha512", "coalesce", "if", "strlang", "strdt", "isnumeric", "regex", "exists",
                            "isblank", "isliteral", "a", "bind"]);
      var keywords = wordRegexp(["base", "prefix", "select", "distinct", "reduced", "construct", "describe",
                                 "ask", "from", "named", "where", "order", "limit", "offset", "filter", "optional",
                                 "graph", "by", "asc", "desc", "as", "having", "undef", "values", "group",
                                 "minus", "in", "not", "service", "silent", "using", "insert", "delete", "union",
                                 "true", "false", "with",
                                 "data", "copy", "to", "move", "add", "create", "drop", "clear", "load"]);
      var operatorChars = /[*+\-<>=&|\^\/!\?]/;

      function tokenBase(stream, state) {
        var ch = stream.next();
        curPunc = null;
        if (ch == "$" || ch == "?") {
          if(ch == "?" && stream.match(/\s/, false)){
            return "operator";
          }
          stream.match(/^[\w\d]*/);
          return "variable-2";
        }
        else if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
          stream.match(/^[^\s\u00a0>]*>?/);
          return "atom";
        }
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        }
        else if (/[{}\(\),\.;\[\]]/.test(ch)) {
          curPunc = ch;
          return "bracket";
        }
        else if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        else if (operatorChars.test(ch)) {
          stream.eatWhile(operatorChars);
          return "operator";
        }
        else if (ch == ":") {
          stream.eatWhile(/[\w\d\._\-]/);
          return "atom";
        }
        else if (ch == "@") {
          stream.eatWhile(/[a-z\d\-]/i);
          return "meta";
        }
        else {
          stream.eatWhile(/[_\w\d]/);
          if (stream.eat(":")) {
            stream.eatWhile(/[\w\d_\-]/);
            return "atom";
          }
          var word = stream.current();
          if (ops.test(word))
            return "builtin";
          else if (keywords.test(word))
            return "keyword";
          else
            return "variable";
        }
      }

      function tokenLiteral(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return "string";
        };
      }

      function pushContext(state, type, col) {
        state.context = {prev: state.context, indent: state.indent, col: col, type: type};
      }
      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase,
                  context: null,
                  indent: 0,
                  col: 0};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null) state.context.align = false;
            state.indent = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);

          if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
            state.context.align = true;
          }

          if (curPunc == "(") pushContext(state, ")", stream.column());
          else if (curPunc == "[") pushContext(state, "]", stream.column());
          else if (curPunc == "{") pushContext(state, "}", stream.column());
          else if (/[\]\}\)]/.test(curPunc)) {
            while (state.context && state.context.type == "pattern") popContext(state);
            if (state.context && curPunc == state.context.type) {
              popContext(state);
              if (curPunc == "}" && state.context && state.context.type == "pattern")
                popContext(state);
            }
          }
          else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
          else if (/atom|string|variable/.test(style) && state.context) {
            if (/[\}\]]/.test(state.context.type))
              pushContext(state, "pattern", stream.column());
            else if (state.context.type == "pattern" && !state.context.align) {
              state.context.align = true;
              state.context.col = stream.column();
            }
          }

          return style;
        },

        indent: function(state, textAfter) {
          var firstChar = textAfter && textAfter.charAt(0);
          var context = state.context;
          if (/[\]\}]/.test(firstChar))
            while (context && context.type == "pattern") context = context.prev;

          var closing = context && firstChar == context.type;
          if (!context)
            return 0;
          else if (context.type == "pattern")
            return context.col;
          else if (context.align)
            return context.col + (closing ? 0 : 1);
          else
            return context.indent + (closing ? 0 : indentUnit);
        },

        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("application/sparql-query", "sparql");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function SpreadSheet(CodeMirror) {
      CodeMirror.defineMode("spreadsheet", function () {
        return {
          startState: function () {
            return {
              stringType: null,
              stack: []
            };
          },
          token: function (stream, state) {
            if (!stream) return;

            //check for state changes
            if (state.stack.length === 0) {
              //strings
              if ((stream.peek() == '"') || (stream.peek() == "'")) {
                state.stringType = stream.peek();
                stream.next(); // Skip quote
                state.stack.unshift("string");
              }
            }

            //return state
            //stack has
            switch (state.stack[0]) {
            case "string":
              while (state.stack[0] === "string" && !stream.eol()) {
                if (stream.peek() === state.stringType) {
                  stream.next(); // Skip quote
                  state.stack.shift(); // Clear flag
                } else if (stream.peek() === "\\") {
                  stream.next();
                  stream.next();
                } else {
                  stream.match(/^.[^\\\"\']*/);
                }
              }
              return "string";

            case "characterClass":
              while (state.stack[0] === "characterClass" && !stream.eol()) {
                if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./)))
                  state.stack.shift();
              }
              return "operator";
            }

            var peek = stream.peek();

            //no stack
            switch (peek) {
            case "[":
              stream.next();
              state.stack.unshift("characterClass");
              return "bracket";
            case ":":
              stream.next();
              return "operator";
            case "\\":
              if (stream.match(/\\[a-z]+/)) return "string-2";
              else {
                stream.next();
                return "atom";
              }
            case ".":
            case ",":
            case ";":
            case "*":
            case "-":
            case "+":
            case "^":
            case "<":
            case "/":
            case "=":
              stream.next();
              return "atom";
            case "$":
              stream.next();
              return "builtin";
            }

            if (stream.match(/\d+/)) {
              if (stream.match(/^\w+/)) return "error";
              return "number";
            } else if (stream.match(/^[a-zA-Z_]\w*/)) {
              if (stream.match(/(?=[\(.])/, false)) return "keyword";
              return "variable-2";
            } else if (["[", "]", "(", ")", "{", "}"].indexOf(peek) != -1) {
              stream.next();
              return "bracket";
            } else if (!stream.eatSpace()) {
              stream.next();
            }
            return null;
          }
        };
      });

      CodeMirror.defineMIME("text/x-spreadsheet", "spreadsheet");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function SQL(CodeMirror) {
    CodeMirror.defineMode("sql", function(config, parserConfig) {
      var client         = parserConfig.client || {},
          atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},
          builtin        = parserConfig.builtin || set(defaultBuiltin),
          keywords       = parserConfig.keywords || set(sqlKeywords),
          operatorChars  = parserConfig.operatorChars || /^[*+\-%<>!=&|~^\/]/,
          support        = parserConfig.support || {},
          hooks          = parserConfig.hooks || {},
          dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true},
          backslashStringEscapes = parserConfig.backslashStringEscapes !== false,
          brackets       = parserConfig.brackets || /^[\{}\(\)\[\]]/,
          punctuation    = parserConfig.punctuation || /^[;.,:]/;

      function tokenBase(stream, state) {
        var ch = stream.next();

        // call hooks from the mime type
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }

        if (support.hexNumber &&
          ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))
          || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
          // hex
          // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
          return "number";
        } else if (support.binaryNumber &&
          (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))
          || (ch == "0" && stream.match(/^b[01]+/)))) {
          // bitstring
          // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
          return "number";
        } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
          // numbers
          // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
          stream.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/);
          support.decimallessFloat && stream.match(/^\.(?!\.)/);
          return "number";
        } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
          // placeholders
          return "variable-3";
        } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {
          // strings
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        } else if ((((support.nCharCast && (ch == "n" || ch == "N"))
            || (support.charsetCast && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))
            && (stream.peek() == "'" || stream.peek() == '"'))) {
          // charset casting: _utf8'str', N'str', n'str'
          // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
          return "keyword";
        } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
          // 1-line comment
          stream.skipToEnd();
          return "comment";
        } else if ((support.commentHash && ch == "#")
            || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {
          // 1-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          stream.skipToEnd();
          return "comment";
        } else if (ch == "/" && stream.eat("*")) {
          // multi-line comments
          // ref: https://kb.askmonty.org/en/comment-syntax/
          state.tokenize = tokenComment(1);
          return state.tokenize(stream, state);
        } else if (ch == ".") {
          // .1 for 0.1
          if (support.zerolessFloat && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i))
            return "number";
          if (stream.match(/^\.+/))
            return null
          // .table_name (ODBC)
          // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
          if (support.ODBCdotTable && stream.match(/^[\w\d_]+/))
            return "variable-2";
        } else if (operatorChars.test(ch)) {
          // operators
          stream.eatWhile(operatorChars);
          return "operator";
        } else if (brackets.test(ch)) {
          // brackets
          return "bracket";
        } else if (punctuation.test(ch)) {
          // punctuation
          stream.eatWhile(punctuation);
          return "punctuation";
        } else if (ch == '{' &&
            (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
          // dates (weird ODBC syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          return "number";
        } else {
          stream.eatWhile(/^[_\w\d]/);
          var word = stream.current().toLowerCase();
          // dates (standard SQL syntax)
          // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
          if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))
            return "number";
          if (atoms.hasOwnProperty(word)) return "atom";
          if (builtin.hasOwnProperty(word)) return "builtin";
          if (keywords.hasOwnProperty(word)) return "keyword";
          if (client.hasOwnProperty(word)) return "string-2";
          return null;
        }
      }

      // 'string', with char specified in quote escaped by '\'
      function tokenLiteral(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = backslashStringEscapes && !escaped && ch == "\\";
          }
          return "string";
        };
      }
      function tokenComment(depth) {
        return function(stream, state) {
          var m = stream.match(/^.*?(\/\*|\*\/)/);
          if (!m) stream.skipToEnd();
          else if (m[1] == "/*") state.tokenize = tokenComment(depth + 1);
          else if (depth > 1) state.tokenize = tokenComment(depth - 1);
          else state.tokenize = tokenBase;
          return "comment"
        }
      }

      function pushContext(stream, state, type) {
        state.context = {
          prev: state.context,
          indent: stream.indentation(),
          col: stream.column(),
          type: type
        };
      }

      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase, context: null};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null)
              state.context.align = false;
          }
          if (state.tokenize == tokenBase && stream.eatSpace()) return null;

          var style = state.tokenize(stream, state);
          if (style == "comment") return style;

          if (state.context && state.context.align == null)
            state.context.align = true;

          var tok = stream.current();
          if (tok == "(")
            pushContext(stream, state, ")");
          else if (tok == "[")
            pushContext(stream, state, "]");
          else if (state.context && state.context.type == tok)
            popContext(state);
          return style;
        },

        indent: function(state, textAfter) {
          var cx = state.context;
          if (!cx) return CodeMirror.Pass;
          var closing = textAfter.charAt(0) == cx.type;
          if (cx.align) return cx.col + (closing ? 0 : 1);
          else return cx.indent + (closing ? 0 : config.indentUnit);
        },

        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--",
        closeBrackets: "()[]{}''\"\"``"
      };
    });

      // `identifier`
      function hookIdentifier(stream) {
        // MySQL/MariaDB identifiers
        // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "`" && !stream.eat("`")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
      }

      // "identifier"
      function hookIdentifierDoublequote(stream) {
        // Standard SQL /SQLite identifiers
        // ref: http://web.archive.org/web/20160813185132/http://savage.net.au/SQL/sql-99.bnf.html#delimited%20identifier
        // ref: http://sqlite.org/lang_keywords.html
        var ch;
        while ((ch = stream.next()) != null) {
          if (ch == "\"" && !stream.eat("\"")) return "variable-2";
        }
        stream.backUp(stream.current().length - 1);
        return stream.eatWhile(/\w/) ? "variable-2" : null;
      }

      // variable token
      function hookVar(stream) {
        // variables
        // @@prefix.varName @varName
        // varName can be quoted with ` or ' or "
        // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html
        if (stream.eat("@")) {
          stream.match(/^session\./);
          stream.match(/^local\./);
          stream.match(/^global\./);
        }

        if (stream.eat("'")) {
          stream.match(/^.*'/);
          return "variable-2";
        } else if (stream.eat('"')) {
          stream.match(/^.*"/);
          return "variable-2";
        } else if (stream.eat("`")) {
          stream.match(/^.*`/);
          return "variable-2";
        } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
          return "variable-2";
        }
        return null;
      }
      // short client keyword token
      function hookClient(stream) {
        // \N means NULL
        // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html
        if (stream.eat("N")) {
            return "atom";
        }
        // \g, etc
        // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html
        return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
      }

      // these keywords are used by all SQL dialects (however, a mode can still overwrite it)
      var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";

      // turn a space-separated list into an array
      function set(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var defaultBuiltin = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric";

      // A generic SQL Mode. It's not a standard, it just try to support what is generally supported
      CodeMirror.defineMIME("text/x-sql", {
        name: "sql",
        keywords: set(sqlKeywords + "begin"),
        builtin: set(defaultBuiltin),
        atoms: set("false true null unknown"),
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
      });

      CodeMirror.defineMIME("text/x-mssql", {
        name: "sql",
        client: set("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
        keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
        builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
        atoms: set("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
        operatorChars: /^[*+\-%<>!=^\&|\/]/,
        brackets: /^[\{}\(\)]/,
        punctuation: /^[;.,:/]/,
        backslashStringEscapes: false,
        dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),
        hooks: {
          "@":   hookVar
        }
      });

      CodeMirror.defineMIME("text/x-mysql", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@":   hookVar,
          "`":   hookIdentifier,
          "\\":  hookClient
        }
      });

      CodeMirror.defineMIME("text/x-mariadb", {
        name: "sql",
        client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@":   hookVar,
          "`":   hookIdentifier,
          "\\":  hookClient
        }
      });

      // provided by the phpLiteAdmin project - phpliteadmin.org
      CodeMirror.defineMIME("text/x-sqlite", {
        name: "sql",
        // commands of the official SQLite client, ref: https://www.sqlite.org/cli.html#dotcmd
        client: set("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
        // ref: http://sqlite.org/lang_keywords.html
        keywords: set(sqlKeywords + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
        // ref: http://sqlite.org/syntax/literal-value.html
        atoms: set("null current_date current_time current_timestamp"),
        // ref: http://sqlite.org/lang_expr.html#binaryops
        operatorChars: /^[*+\-%<>!=&|/~]/,
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        dateSQL: set("date time timestamp datetime"),
        support: set("decimallessFloat zerolessFloat"),
        identifierQuote: "\"",  //ref: http://sqlite.org/lang_keywords.html
        hooks: {
          // bind-parameters ref:http://sqlite.org/lang_expr.html#varparam
          "@":   hookVar,
          ":":   hookVar,
          "?":   hookVar,
          "$":   hookVar,
          // The preferred way to escape Identifiers is using double quotes, ref: http://sqlite.org/lang_keywords.html
          "\"":   hookIdentifierDoublequote,
          // there is also support for backtics, ref: http://sqlite.org/lang_keywords.html
          "`":   hookIdentifier
        }
      });

      // the query language used by Apache Cassandra is called CQL, but this mime type
      // is called Cassandra to avoid confusion with Contextual Query Language
      CodeMirror.defineMIME("text/x-cassandra", {
        name: "sql",
        client: { },
        keywords: set("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
        builtin: set("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
        atoms: set("false true infinity NaN"),
        operatorChars: /^[<>=]/,
        dateSQL: { },
        support: set("commentSlashSlash decimallessFloat"),
        hooks: { }
      });

      // this is based on Peter Raganitsch's 'plsql' mode
      CodeMirror.defineMIME("text/x-plsql", {
        name:       "sql",
        client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
        keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
        builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
        operatorChars: /^[*\/+\-%<>!=~]/,
        dateSQL:    set("date time timestamp"),
        support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
      });

      // Created to support specific hive keywords
      CodeMirror.defineMIME("text/x-hive", {
        name: "sql",
        keywords: set("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
        builtin: set("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=]/,
        dateSQL: set("date timestamp"),
        support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
      });

      CodeMirror.defineMIME("text/x-pgsql", {
        name: "sql",
        client: set("source"),
        // For PostgreSQL - https://www.postgresql.org/docs/11/sql-keywords-appendix.html
        // For pl/pgsql lang - https://github.com/postgres/postgres/blob/REL_11_2/src/pl/plpgsql/src/pl_scanner.c
        keywords: set(sqlKeywords + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
        // https://www.postgresql.org/docs/11/datatype.html
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
      });

      // Google's SQL-like query language, GQL
      CodeMirror.defineMIME("text/x-gql", {
        name: "sql",
        keywords: set("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
        atoms: set("false true"),
        builtin: set("blob datetime first key __key__ string integer double boolean null"),
        operatorChars: /^[*+\-%<>!=]/
      });

      // Greenplum
      CodeMirror.defineMIME("text/x-gpsql", {
        name: "sql",
        client: set("source"),
        //https://github.com/greenplum-db/gpdb/blob/master/src/include/parser/kwlist.h
        keywords: set("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
        builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: set("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
      });

      // Spark SQL
      CodeMirror.defineMIME("text/x-sparksql", {
        name: "sql",
        keywords: set("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases datata dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
        builtin: set("tinyint smallint int bigint boolean float double string binary timestamp decimal array map struct uniontype delimited serde sequencefile textfile rcfile inputformat outputformat"),
        atoms: set("false true null"),
        operatorChars: /^[*\/+\-%<>!=~&|^]/,
        dateSQL: set("date time timestamp"),
        support: set("ODBCdotTable doubleQuote zerolessFloat")
      });

      // Esper
      CodeMirror.defineMIME("text/x-esper", {
        name: "sql",
        client: set("source"),
        // http://www.espertech.com/esper/release-5.5.0/esper-reference/html/appendix_keywords.html
        keywords: set("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
        builtin: {},
        atoms: set("false true null"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: set("time"),
        support: set("decimallessFloat zerolessFloat binaryNumber hexNumber")
      });
    }
    /*
      How Properties of Mime Types are used by SQL Mode
      =================================================

      keywords:
        A list of keywords you want to be highlighted.
      builtin:
        A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").
      operatorChars:
        All characters that must be handled as operators.
      client:
        Commands parsed and executed by the client (not the server).
      support:
        A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.
        * ODBCdotTable: .tableName
        * zerolessFloat: .1
        * doubleQuote
        * nCharCast: N'string'
        * charsetCast: _utf8'string'
        * commentHash: use # char for comments
        * commentSlashSlash: use // for comments
        * commentSpaceRequired: require a space after -- for comments
      atoms:
        Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:
        UNKNOWN, INFINITY, UNDERFLOW, NaN...
      dateSQL:
        Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.
    */

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
     * Author: Constantin Jucovschi (c.jucovschi@jacobs-university.de)
     * Licence: MIT
     */

    function Stext(CodeMirror) {
      CodeMirror.defineMode("stex", function(_config, parserConfig) {

        function pushCommand(state, command) {
          state.cmdState.push(command);
        }

        function peekCommand(state) {
          if (state.cmdState.length > 0) {
            return state.cmdState[state.cmdState.length - 1];
          } else {
            return null;
          }
        }

        function popCommand(state) {
          var plug = state.cmdState.pop();
          if (plug) {
            plug.closeBracket();
          }
        }

        // returns the non-default plugin closest to the end of the list
        function getMostPowerful(state) {
          var context = state.cmdState;
          for (var i = context.length - 1; i >= 0; i--) {
            var plug = context[i];
            if (plug.name == "DEFAULT") {
              continue;
            }
            return plug;
          }
          return { styleIdentifier: function() { return null; } };
        }

        function addPluginPattern(pluginName, cmdStyle, styles) {
          return function () {
            this.name = pluginName;
            this.bracketNo = 0;
            this.style = cmdStyle;
            this.styles = styles;
            this.argument = null;   // \begin and \end have arguments that follow. These are stored in the plugin

            this.styleIdentifier = function() {
              return this.styles[this.bracketNo - 1] || null;
            };
            this.openBracket = function() {
              this.bracketNo++;
              return "bracket";
            };
            this.closeBracket = function() {};
          };
        }

        var plugins = {};

        plugins["importmodule"] = addPluginPattern("importmodule", "tag", ["string", "builtin"]);
        plugins["documentclass"] = addPluginPattern("documentclass", "tag", ["", "atom"]);
        plugins["usepackage"] = addPluginPattern("usepackage", "tag", ["atom"]);
        plugins["begin"] = addPluginPattern("begin", "tag", ["atom"]);
        plugins["end"] = addPluginPattern("end", "tag", ["atom"]);

        plugins["label"    ] = addPluginPattern("label"    , "tag", ["atom"]);
        plugins["ref"      ] = addPluginPattern("ref"      , "tag", ["atom"]);
        plugins["eqref"    ] = addPluginPattern("eqref"    , "tag", ["atom"]);
        plugins["cite"     ] = addPluginPattern("cite"     , "tag", ["atom"]);
        plugins["bibitem"  ] = addPluginPattern("bibitem"  , "tag", ["atom"]);
        plugins["Bibitem"  ] = addPluginPattern("Bibitem"  , "tag", ["atom"]);
        plugins["RBibitem" ] = addPluginPattern("RBibitem" , "tag", ["atom"]);

        plugins["DEFAULT"] = function () {
          this.name = "DEFAULT";
          this.style = "tag";

          this.styleIdentifier = this.openBracket = this.closeBracket = function() {};
        };

        function setState(state, f) {
          state.f = f;
        }

        // called when in a normal (no environment) context
        function normal(source, state) {
          var plug;
          // Do we look like '\command' ?  If so, attempt to apply the plugin 'command'
          if (source.match(/^\\[a-zA-Z@]+/)) {
            var cmdName = source.current().slice(1);
            plug = plugins[cmdName] || plugins["DEFAULT"];
            plug = new plug();
            pushCommand(state, plug);
            setState(state, beginParams);
            return plug.style;
          }

          // escape characters
          if (source.match(/^\\[$&%#{}_]/)) {
            return "tag";
          }

          // white space control characters
          if (source.match(/^\\[,;!\/\\]/)) {
            return "tag";
          }

          // find if we're starting various math modes
          if (source.match("\\[")) {
            setState(state, function(source, state){ return inMathMode(source, state, "\\]"); });
            return "keyword";
          }
          if (source.match("\\(")) {
            setState(state, function(source, state){ return inMathMode(source, state, "\\)"); });
            return "keyword";
          }
          if (source.match("$$")) {
            setState(state, function(source, state){ return inMathMode(source, state, "$$"); });
            return "keyword";
          }
          if (source.match("$")) {
            setState(state, function(source, state){ return inMathMode(source, state, "$"); });
            return "keyword";
          }

          var ch = source.next();
          if (ch == "%") {
            source.skipToEnd();
            return "comment";
          } else if (ch == '}' || ch == ']') {
            plug = peekCommand(state);
            if (plug) {
              plug.closeBracket(ch);
              setState(state, beginParams);
            } else {
              return "error";
            }
            return "bracket";
          } else if (ch == '{' || ch == '[') {
            plug = plugins["DEFAULT"];
            plug = new plug();
            pushCommand(state, plug);
            return "bracket";
          } else if (/\d/.test(ch)) {
            source.eatWhile(/[\w.%]/);
            return "atom";
          } else {
            source.eatWhile(/[\w\-_]/);
            plug = getMostPowerful(state);
            if (plug.name == 'begin') {
              plug.argument = source.current();
            }
            return plug.styleIdentifier();
          }
        }

        function inMathMode(source, state, endModeSeq) {
          if (source.eatSpace()) {
            return null;
          }
          if (endModeSeq && source.match(endModeSeq)) {
            setState(state, normal);
            return "keyword";
          }
          if (source.match(/^\\[a-zA-Z@]+/)) {
            return "tag";
          }
          if (source.match(/^[a-zA-Z]+/)) {
            return "variable-2";
          }
          // escape characters
          if (source.match(/^\\[$&%#{}_]/)) {
            return "tag";
          }
          // white space control characters
          if (source.match(/^\\[,;!\/]/)) {
            return "tag";
          }
          // special math-mode characters
          if (source.match(/^[\^_&]/)) {
            return "tag";
          }
          // non-special characters
          if (source.match(/^[+\-<>|=,\/@!*:;'"`~#?]/)) {
            return null;
          }
          if (source.match(/^(\d+\.\d*|\d*\.\d+|\d+)/)) {
            return "number";
          }
          var ch = source.next();
          if (ch == "{" || ch == "}" || ch == "[" || ch == "]" || ch == "(" || ch == ")") {
            return "bracket";
          }

          if (ch == "%") {
            source.skipToEnd();
            return "comment";
          }
          return "error";
        }

        function beginParams(source, state) {
          var ch = source.peek(), lastPlug;
          if (ch == '{' || ch == '[') {
            lastPlug = peekCommand(state);
            lastPlug.openBracket(ch);
            source.eat(ch);
            setState(state, normal);
            return "bracket";
          }
          if (/[ \t\r]/.test(ch)) {
            source.eat(ch);
            return null;
          }
          setState(state, normal);
          popCommand(state);

          return normal(source, state);
        }

        return {
          startState: function() {
            var f = parserConfig.inMathMode ? function(source, state){ return inMathMode(source, state); } : normal;
            return {
              cmdState: [],
              f: f
            };
          },
          copyState: function(s) {
            return {
              cmdState: s.cmdState.slice(),
              f: s.f
            };
          },
          token: function(stream, state) {
            return state.f(stream, state);
          },
          blankLine: function(state) {
            state.f = normal;
            state.cmdState.length = 0;
          },
          lineComment: "%"
        };
      });

      CodeMirror.defineMIME("text/x-stex", "stex");
      CodeMirror.defineMIME("text/x-latex", "stex");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Stylus mode created by Dmitry Kiselyov http://git.io/AaRB

    function Stylus(CodeMirror) {
      CodeMirror.defineMode("stylus", function(config) {
        var indentUnit = config.indentUnit,
            indentUnitString = '',
            tagKeywords = keySet(tagKeywords_),
            tagVariablesRegexp = /^(a|b|i|s|col|em)$/i,
            propertyKeywords = keySet(propertyKeywords_),
            nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),
            valueKeywords = keySet(valueKeywords_),
            colorKeywords = keySet(colorKeywords_),
            documentTypes = keySet(documentTypes_),
            documentTypesRegexp = wordRegexp(documentTypes_),
            mediaFeatures = keySet(mediaFeatures_),
            mediaTypes = keySet(mediaTypes_),
            fontProperties = keySet(fontProperties_),
            operatorsRegexp = /^\s*([.]{2,3}|&&|\|\||\*\*|[?!=:]?=|[-+*\/%<>]=?|\?:|\~)/,
            wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_),
            blockKeywords = keySet(blockKeywords_),
            vendorPrefixesRegexp = new RegExp(/^\-(moz|ms|o|webkit)-/i),
            commonAtoms = keySet(commonAtoms_),
            firstWordMatch = "",
            states = {},
            ch,
            style,
            type,
            override;

        while (indentUnitString.length < indentUnit) indentUnitString += ' ';

        /**
         * Tokenizers
         */
        function tokenBase(stream, state) {
          firstWordMatch = stream.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&|\[|\d|\+|::?|\{|\>|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/);
          state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\s*/, "") : "";
          state.context.line.indent = stream.indentation();
          ch = stream.peek();

          // Line comment
          if (stream.match("//")) {
            stream.skipToEnd();
            return ["comment", "comment"];
          }
          // Block comment
          if (stream.match("/*")) {
            state.tokenize = tokenCComment;
            return tokenCComment(stream, state);
          }
          // String
          if (ch == "\"" || ch == "'") {
            stream.next();
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          // Def
          if (ch == "@") {
            stream.next();
            stream.eatWhile(/[\w\\-]/);
            return ["def", stream.current()];
          }
          // ID selector or Hex color
          if (ch == "#") {
            stream.next();
            // Hex color
            if (stream.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\b/i)) {
              return ["atom", "atom"];
            }
            // ID selector
            if (stream.match(/^[a-z][\w-]*/i)) {
              return ["builtin", "hash"];
            }
          }
          // Vendor prefixes
          if (stream.match(vendorPrefixesRegexp)) {
            return ["meta", "vendor-prefixes"];
          }
          // Numbers
          if (stream.match(/^-?[0-9]?\.?[0-9]/)) {
            stream.eatWhile(/[a-z%]/i);
            return ["number", "unit"];
          }
          // !important|optional
          if (ch == "!") {
            stream.next();
            return [stream.match(/^(important|optional)/i) ? "keyword": "operator", "important"];
          }
          // Class
          if (ch == "." && stream.match(/^\.[a-z][\w-]*/i)) {
            return ["qualifier", "qualifier"];
          }
          // url url-prefix domain regexp
          if (stream.match(documentTypesRegexp)) {
            if (stream.peek() == "(") state.tokenize = tokenParenthesized;
            return ["property", "word"];
          }
          // Mixins / Functions
          if (stream.match(/^[a-z][\w-]*\(/i)) {
            stream.backUp(1);
            return ["keyword", "mixin"];
          }
          // Block mixins
          if (stream.match(/^(\+|-)[a-z][\w-]*\(/i)) {
            stream.backUp(1);
            return ["keyword", "block-mixin"];
          }
          // Parent Reference BEM naming
          if (stream.string.match(/^\s*&/) && stream.match(/^[-_]+[a-z][\w-]*/)) {
            return ["qualifier", "qualifier"];
          }
          // / Root Reference & Parent Reference
          if (stream.match(/^(\/|&)(-|_|:|\.|#|[a-z])/)) {
            stream.backUp(1);
            return ["variable-3", "reference"];
          }
          if (stream.match(/^&{1}\s*$/)) {
            return ["variable-3", "reference"];
          }
          // Word operator
          if (stream.match(wordOperatorKeywordsRegexp)) {
            return ["operator", "operator"];
          }
          // Word
          if (stream.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i)) {
            // Variable
            if (stream.match(/^(\.|\[)[\w-\'\"\]]+/i, false)) {
              if (!wordIsTag(stream.current())) {
                stream.match(/\./);
                return ["variable-2", "variable-name"];
              }
            }
            return ["variable-2", "word"];
          }
          // Operators
          if (stream.match(operatorsRegexp)) {
            return ["operator", stream.current()];
          }
          // Delimiters
          if (/[:;,{}\[\]\(\)]/.test(ch)) {
            stream.next();
            return [null, ch];
          }
          // Non-detected items
          stream.next();
          return [null, null];
        }

        /**
         * Token comment
         */
        function tokenCComment(stream, state) {
          var maybeEnd = false, ch;
          while ((ch = stream.next()) != null) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return ["comment", "comment"];
        }

        /**
         * Token string
         */
        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, ch;
            while ((ch = stream.next()) != null) {
              if (ch == quote && !escaped) {
                if (quote == ")") stream.backUp(1);
                break;
              }
              escaped = !escaped && ch == "\\";
            }
            if (ch == quote || !escaped && quote != ")") state.tokenize = null;
            return ["string", "string"];
          };
        }

        /**
         * Token parenthesized
         */
        function tokenParenthesized(stream, state) {
          stream.next(); // Must be "("
          if (!stream.match(/\s*[\"\')]/, false))
            state.tokenize = tokenString(")");
          else
            state.tokenize = null;
          return [null, "("];
        }

        /**
         * Context management
         */
        function Context(type, indent, prev, line) {
          this.type = type;
          this.indent = indent;
          this.prev = prev;
          this.line = line || {firstWord: "", indent: 0};
        }

        function pushContext(state, stream, type, indent) {
          indent = indent >= 0 ? indent : indentUnit;
          state.context = new Context(type, stream.indentation() + indent, state.context);
          return type;
        }

        function popContext(state, currentIndent) {
          var contextIndent = state.context.indent - indentUnit;
          currentIndent = currentIndent || false;
          state.context = state.context.prev;
          if (currentIndent) state.context.indent = contextIndent;
          return state.context.type;
        }

        function pass(type, stream, state) {
          return states[state.context.type](type, stream, state);
        }

        function popAndPass(type, stream, state, n) {
          for (var i = n || 1; i > 0; i--)
            state.context = state.context.prev;
          return pass(type, stream, state);
        }


        /**
         * Parser
         */
        function wordIsTag(word) {
          return word.toLowerCase() in tagKeywords;
        }

        function wordIsProperty(word) {
          word = word.toLowerCase();
          return word in propertyKeywords || word in fontProperties;
        }

        function wordIsBlock(word) {
          return word.toLowerCase() in blockKeywords;
        }

        function wordIsVendorPrefix(word) {
          return word.toLowerCase().match(vendorPrefixesRegexp);
        }

        function wordAsValue(word) {
          var wordLC = word.toLowerCase();
          var override = "variable-2";
          if (wordIsTag(word)) override = "tag";
          else if (wordIsBlock(word)) override = "block-keyword";
          else if (wordIsProperty(word)) override = "property";
          else if (wordLC in valueKeywords || wordLC in commonAtoms) override = "atom";
          else if (wordLC == "return" || wordLC in colorKeywords) override = "keyword";

          // Font family
          else if (word.match(/^[A-Z]/)) override = "string";
          return override;
        }

        function typeIsBlock(type, stream) {
          return ((endOfLine(stream) && (type == "{" || type == "]" || type == "hash" || type == "qualifier")) || type == "block-mixin");
        }

        function typeIsInterpolation(type, stream) {
          return type == "{" && stream.match(/^\s*\$?[\w-]+/i, false);
        }

        function typeIsPseudo(type, stream) {
          return type == ":" && stream.match(/^[a-z-]+/, false);
        }

        function startOfLine(stream) {
          return stream.sol() || stream.string.match(new RegExp("^\\s*" + escapeRegExp(stream.current())));
        }

        function endOfLine(stream) {
          return stream.eol() || stream.match(/^\s*$/, false);
        }

        function firstWordOfLine(line) {
          var re = /^\s*[-_]*[a-z0-9]+[\w-]*/i;
          var result = typeof line == "string" ? line.match(re) : line.string.match(re);
          return result ? result[0].replace(/^\s*/, "") : "";
        }


        /**
         * Block
         */
        states.block = function(type, stream, state) {
          if ((type == "comment" && startOfLine(stream)) ||
              (type == "," && endOfLine(stream)) ||
              type == "mixin") {
            return pushContext(state, stream, "block", 0);
          }
          if (typeIsInterpolation(type, stream)) {
            return pushContext(state, stream, "interpolation");
          }
          if (endOfLine(stream) && type == "]") {
            if (!/^\s*(\.|#|:|\[|\*|&)/.test(stream.string) && !wordIsTag(firstWordOfLine(stream))) {
              return pushContext(state, stream, "block", 0);
            }
          }
          if (typeIsBlock(type, stream)) {
            return pushContext(state, stream, "block");
          }
          if (type == "}" && endOfLine(stream)) {
            return pushContext(state, stream, "block", 0);
          }
          if (type == "variable-name") {
            if (stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/) || wordIsBlock(firstWordOfLine(stream))) {
              return pushContext(state, stream, "variableName");
            }
            else {
              return pushContext(state, stream, "variableName", 0);
            }
          }
          if (type == "=") {
            if (!endOfLine(stream) && !wordIsBlock(firstWordOfLine(stream))) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "*") {
            if (endOfLine(stream) || stream.match(/\s*(,|\.|#|\[|:|{)/,false)) {
              override = "tag";
              return pushContext(state, stream, "block");
            }
          }
          if (typeIsPseudo(type, stream)) {
            return pushContext(state, stream, "pseudo");
          }
          if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
            return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
          }
          if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
            return pushContext(state, stream, "keyframes");
          }
          if (/@extends?/.test(type)) {
            return pushContext(state, stream, "extend", 0);
          }
          if (type && type.charAt(0) == "@") {

            // Property Lookup
            if (stream.indentation() > 0 && wordIsProperty(stream.current().slice(1))) {
              override = "variable-2";
              return "block";
            }
            if (/(@import|@require|@charset)/.test(type)) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "reference" && endOfLine(stream)) {
            return pushContext(state, stream, "block");
          }
          if (type == "(") {
            return pushContext(state, stream, "parens");
          }

          if (type == "vendor-prefixes") {
            return pushContext(state, stream, "vendorPrefixes");
          }
          if (type == "word") {
            var word = stream.current();
            override = wordAsValue(word);

            if (override == "property") {
              if (startOfLine(stream)) {
                return pushContext(state, stream, "block", 0);
              } else {
                override = "atom";
                return "block";
              }
            }

            if (override == "tag") {

              // tag is a css value
              if (/embed|menu|pre|progress|sub|table/.test(word)) {
                if (wordIsProperty(firstWordOfLine(stream))) {
                  override = "atom";
                  return "block";
                }
              }

              // tag is an attribute
              if (stream.string.match(new RegExp("\\[\\s*" + word + "|" + word +"\\s*\\]"))) {
                override = "atom";
                return "block";
              }

              // tag is a variable
              if (tagVariablesRegexp.test(word)) {
                if ((startOfLine(stream) && stream.string.match(/=/)) ||
                    (!startOfLine(stream) &&
                     !stream.string.match(/^(\s*\.|#|\&|\[|\/|>|\*)/) &&
                     !wordIsTag(firstWordOfLine(stream)))) {
                  override = "variable-2";
                  if (wordIsBlock(firstWordOfLine(stream)))  return "block";
                  return pushContext(state, stream, "block", 0);
                }
              }

              if (endOfLine(stream)) return pushContext(state, stream, "block");
            }
            if (override == "block-keyword") {
              override = "keyword";

              // Postfix conditionals
              if (stream.current(/(if|unless)/) && !startOfLine(stream)) {
                return "block";
              }
              return pushContext(state, stream, "block");
            }
            if (word == "return") return pushContext(state, stream, "block", 0);

            // Placeholder selector
            if (override == "variable-2" && stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/)) {
              return pushContext(state, stream, "block");
            }
          }
          return state.context.type;
        };


        /**
         * Parens
         */
        states.parens = function(type, stream, state) {
          if (type == "(") return pushContext(state, stream, "parens");
          if (type == ")") {
            if (state.context.prev.type == "parens") {
              return popContext(state);
            }
            if ((stream.string.match(/^[a-z][\w-]*\(/i) && endOfLine(stream)) ||
                wordIsBlock(firstWordOfLine(stream)) ||
                /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(firstWordOfLine(stream)) ||
                (!stream.string.match(/^-?[a-z][\w-\.\[\]\'\"]*\s*=/) &&
                 wordIsTag(firstWordOfLine(stream)))) {
              return pushContext(state, stream, "block");
            }
            if (stream.string.match(/^[\$-]?[a-z][\w-\.\[\]\'\"]*\s*=/) ||
                stream.string.match(/^\s*(\(|\)|[0-9])/) ||
                stream.string.match(/^\s+[a-z][\w-]*\(/i) ||
                stream.string.match(/^\s+[\$-]?[a-z]/i)) {
              return pushContext(state, stream, "block", 0);
            }
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            else return pushContext(state, stream, "block", 0);
          }
          if (type && type.charAt(0) == "@" && wordIsProperty(stream.current().slice(1))) {
            override = "variable-2";
          }
          if (type == "word") {
            var word = stream.current();
            override = wordAsValue(word);
            if (override == "tag" && tagVariablesRegexp.test(word)) {
              override = "variable-2";
            }
            if (override == "property" || word == "to") override = "atom";
          }
          if (type == "variable-name") {
            return pushContext(state, stream, "variableName");
          }
          if (typeIsPseudo(type, stream)) {
            return pushContext(state, stream, "pseudo");
          }
          return state.context.type;
        };


        /**
         * Vendor prefixes
         */
        states.vendorPrefixes = function(type, stream, state) {
          if (type == "word") {
            override = "property";
            return pushContext(state, stream, "block", 0);
          }
          return popContext(state);
        };


        /**
         * Pseudo
         */
        states.pseudo = function(type, stream, state) {
          if (!wordIsProperty(firstWordOfLine(stream.string))) {
            stream.match(/^[a-z-]+/);
            override = "variable-3";
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            return popContext(state);
          }
          return popAndPass(type, stream, state);
        };


        /**
         * atBlock
         */
        states.atBlock = function(type, stream, state) {
          if (type == "(") return pushContext(state, stream, "atBlock_parens");
          if (typeIsBlock(type, stream)) {
            return pushContext(state, stream, "block");
          }
          if (typeIsInterpolation(type, stream)) {
            return pushContext(state, stream, "interpolation");
          }
          if (type == "word") {
            var word = stream.current().toLowerCase();
            if (/^(only|not|and|or)$/.test(word))
              override = "keyword";
            else if (documentTypes.hasOwnProperty(word))
              override = "tag";
            else if (mediaTypes.hasOwnProperty(word))
              override = "attribute";
            else if (mediaFeatures.hasOwnProperty(word))
              override = "property";
            else if (nonStandardPropertyKeywords.hasOwnProperty(word))
              override = "string-2";
            else override = wordAsValue(stream.current());
            if (override == "tag" && endOfLine(stream)) {
              return pushContext(state, stream, "block");
            }
          }
          if (type == "operator" && /^(not|and|or)$/.test(stream.current())) {
            override = "keyword";
          }
          return state.context.type;
        };

        states.atBlock_parens = function(type, stream, state) {
          if (type == "{" || type == "}") return state.context.type;
          if (type == ")") {
            if (endOfLine(stream)) return pushContext(state, stream, "block");
            else return pushContext(state, stream, "atBlock");
          }
          if (type == "word") {
            var word = stream.current().toLowerCase();
            override = wordAsValue(word);
            if (/^(max|min)/.test(word)) override = "property";
            if (override == "tag") {
              tagVariablesRegexp.test(word) ? override = "variable-2" : override = "atom";
            }
            return state.context.type;
          }
          return states.atBlock(type, stream, state);
        };


        /**
         * Keyframes
         */
        states.keyframes = function(type, stream, state) {
          if (stream.indentation() == "0" && ((type == "}" && startOfLine(stream)) || type == "]" || type == "hash"
                                              || type == "qualifier" || wordIsTag(stream.current()))) {
            return popAndPass(type, stream, state);
          }
          if (type == "{") return pushContext(state, stream, "keyframes");
          if (type == "}") {
            if (startOfLine(stream)) return popContext(state, true);
            else return pushContext(state, stream, "keyframes");
          }
          if (type == "unit" && /^[0-9]+\%$/.test(stream.current())) {
            return pushContext(state, stream, "keyframes");
          }
          if (type == "word") {
            override = wordAsValue(stream.current());
            if (override == "block-keyword") {
              override = "keyword";
              return pushContext(state, stream, "keyframes");
            }
          }
          if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
            return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
          }
          if (type == "mixin") {
            return pushContext(state, stream, "block", 0);
          }
          return state.context.type;
        };


        /**
         * Interpolation
         */
        states.interpolation = function(type, stream, state) {
          if (type == "{") popContext(state) && pushContext(state, stream, "block");
          if (type == "}") {
            if (stream.string.match(/^\s*(\.|#|:|\[|\*|&|>|~|\+|\/)/i) ||
                (stream.string.match(/^\s*[a-z]/i) && wordIsTag(firstWordOfLine(stream)))) {
              return pushContext(state, stream, "block");
            }
            if (!stream.string.match(/^(\{|\s*\&)/) ||
                stream.match(/\s*[\w-]/,false)) {
              return pushContext(state, stream, "block", 0);
            }
            return pushContext(state, stream, "block");
          }
          if (type == "variable-name") {
            return pushContext(state, stream, "variableName", 0);
          }
          if (type == "word") {
            override = wordAsValue(stream.current());
            if (override == "tag") override = "atom";
          }
          return state.context.type;
        };


        /**
         * Extend/s
         */
        states.extend = function(type, stream, state) {
          if (type == "[" || type == "=") return "extend";
          if (type == "]") return popContext(state);
          if (type == "word") {
            override = wordAsValue(stream.current());
            return "extend";
          }
          return popContext(state);
        };


        /**
         * Variable name
         */
        states.variableName = function(type, stream, state) {
          if (type == "string" || type == "[" || type == "]" || stream.current().match(/^(\.|\$)/)) {
            if (stream.current().match(/^\.[\w-]+/i)) override = "variable-2";
            return "variableName";
          }
          return popAndPass(type, stream, state);
        };


        return {
          startState: function(base) {
            return {
              tokenize: null,
              state: "block",
              context: new Context("block", base || 0, null)
            };
          },
          token: function(stream, state) {
            if (!state.tokenize && stream.eatSpace()) return null;
            style = (state.tokenize || tokenBase)(stream, state);
            if (style && typeof style == "object") {
              type = style[1];
              style = style[0];
            }
            override = style;
            state.state = states[state.state](type, stream, state);
            return override;
          },
          indent: function(state, textAfter, line) {

            var cx = state.context,
                ch = textAfter && textAfter.charAt(0),
                indent = cx.indent,
                lineFirstWord = firstWordOfLine(textAfter),
                lineIndent = line.match(/^\s*/)[0].replace(/\t/g, indentUnitString).length,
                prevLineFirstWord = state.context.prev ? state.context.prev.line.firstWord : "",
                prevLineIndent = state.context.prev ? state.context.prev.line.indent : lineIndent;

            if (cx.prev &&
                (ch == "}" && (cx.type == "block" || cx.type == "atBlock" || cx.type == "keyframes") ||
                 ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
                 ch == "{" && (cx.type == "at"))) {
              indent = cx.indent - indentUnit;
            } else if (!(/(\})/.test(ch))) {
              if (/@|\$|\d/.test(ch) ||
                  /^\{/.test(textAfter) ||
    /^\s*\/(\/|\*)/.test(textAfter) ||
                  /^\s*\/\*/.test(prevLineFirstWord) ||
                  /^\s*[\w-\.\[\]\'\"]+\s*(\?|:|\+)?=/i.test(textAfter) ||
    /^(\+|-)?[a-z][\w-]*\(/i.test(textAfter) ||
    /^return/.test(textAfter) ||
                  wordIsBlock(lineFirstWord)) {
                indent = lineIndent;
              } else if (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(ch) || wordIsTag(lineFirstWord)) {
                if (/\,\s*$/.test(prevLineFirstWord)) {
                  indent = prevLineIndent;
                } else if (/^\s+/.test(line) && (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord))) {
                  indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                } else {
                  indent = lineIndent;
                }
              } else if (!/,\s*$/.test(line) && (wordIsVendorPrefix(lineFirstWord) || wordIsProperty(lineFirstWord))) {
                if (wordIsBlock(prevLineFirstWord)) {
                  indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                } else if (/^\{/.test(prevLineFirstWord)) {
                  indent = lineIndent <= prevLineIndent ? lineIndent : prevLineIndent + indentUnit;
                } else if (wordIsVendorPrefix(prevLineFirstWord) || wordIsProperty(prevLineFirstWord)) {
                  indent = lineIndent >= prevLineIndent ? prevLineIndent : lineIndent;
                } else if (/^(\.|#|:|\[|\*|&|@|\+|\-|>|~|\/)/.test(prevLineFirstWord) ||
                          /=\s*$/.test(prevLineFirstWord) ||
                          wordIsTag(prevLineFirstWord) ||
                          /^\$[\w-\.\[\]\'\"]/.test(prevLineFirstWord)) {
                  indent = prevLineIndent + indentUnit;
                } else {
                  indent = lineIndent;
                }
              }
            }
            return indent;
          },
          electricChars: "}",
          lineComment: "//",
          fold: "indent"
        };
      });

      // developer.mozilla.org/en-US/docs/Web/HTML/Element
      var tagKeywords_ = ["a","abbr","address","area","article","aside","audio", "b", "base","bdi", "bdo","bgsound","blockquote","body","br","button","canvas","caption","cite", "code","col","colgroup","data","datalist","dd","del","details","dfn","div", "dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1", "h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe", "img","input","ins","kbd","keygen","label","legend","li","link","main","map", "mark","marquee","menu","menuitem","meta","meter","nav","nobr","noframes", "noscript","object","ol","optgroup","option","output","p","param","pre", "progress","q","rp","rt","ruby","s","samp","script","section","select", "small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track", "u","ul","var","video"];

      // github.com/codemirror/CodeMirror/blob/master/mode/css/css.js
      var documentTypes_ = ["domain", "regexp", "url", "url-prefix"];
      var mediaTypes_ = ["all","aural","braille","handheld","print","projection","screen","tty","tv","embossed"];
      var mediaFeatures_ = ["width","min-width","max-width","height","min-height","max-height","device-width","min-device-width","max-device-width","device-height","min-device-height","max-device-height","aspect-ratio","min-aspect-ratio","max-aspect-ratio","device-aspect-ratio","min-device-aspect-ratio","max-device-aspect-ratio","color","min-color","max-color","color-index","min-color-index","max-color-index","monochrome","min-monochrome","max-monochrome","resolution","min-resolution","max-resolution","scan","grid"];
      var propertyKeywords_ = ["align-content","align-items","align-self","alignment-adjust","alignment-baseline","anchor-point","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","appearance","azimuth","backface-visibility","background","background-attachment","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","baseline-shift","binding","bleed","bookmark-label","bookmark-level","bookmark-state","bookmark-target","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","clear","clip","color","color-profile","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","crop","cue","cue-after","cue-before","cursor","direction","display","dominant-baseline","drop-initial-after-adjust","drop-initial-after-align","drop-initial-before-adjust","drop-initial-before-align","drop-initial-size","drop-initial-value","elevation","empty-cells","fit","fit-position","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","float-offset","flow-from","flow-into","font","font-feature-settings","font-family","font-kerning","font-language-override","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-position","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","inline-box-align","justify-content","left","letter-spacing","line-break","line-height","line-stacking","line-stacking-ruby","line-stacking-shift","line-stacking-strategy","list-style","list-style-image","list-style-position","list-style-type","margin","margin-bottom","margin-left","margin-right","margin-top","marker-offset","marks","marquee-direction","marquee-loop","marquee-play-count","marquee-speed","marquee-style","max-height","max-width","min-height","min-width","move-to","nav-down","nav-index","nav-left","nav-right","nav-up","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-style","overflow-wrap","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page","page-break-after","page-break-before","page-break-inside","page-policy","pause","pause-after","pause-before","perspective","perspective-origin","pitch","pitch-range","play-during","position","presentation-level","punctuation-trim","quotes","region-break-after","region-break-before","region-break-inside","region-fragment","rendering-intent","resize","rest","rest-after","rest-before","richness","right","rotation","rotation-point","ruby-align","ruby-overhang","ruby-position","ruby-span","shape-image-threshold","shape-inside","shape-margin","shape-outside","size","speak","speak-as","speak-header","speak-numeral","speak-punctuation","speech-rate","stress","string-set","tab-size","table-layout","target","target-name","target-new","target-position","text-align","text-align-last","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-height","text-indent","text-justify","text-outline","text-overflow","text-shadow","text-size-adjust","text-space-collapse","text-transform","text-underline-position","text-wrap","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","z-index","clip-path","clip-rule","mask","enable-background","filter","flood-color","flood-opacity","lighting-color","stop-color","stop-opacity","pointer-events","color-interpolation","color-interpolation-filters","color-rendering","fill","fill-opacity","fill-rule","image-rendering","marker","marker-end","marker-mid","marker-start","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-rendering","baseline-shift","dominant-baseline","glyph-orientation-horizontal","glyph-orientation-vertical","text-anchor","writing-mode","font-smoothing","osx-font-smoothing"];
      var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color","scrollbar-base-color","scrollbar-dark-shadow-color","scrollbar-face-color","scrollbar-highlight-color","scrollbar-shadow-color","scrollbar-3d-light-color","scrollbar-track-color","shape-inside","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","zoom"];
      var fontProperties_ = ["font-family","src","unicode-range","font-variant","font-feature-settings","font-stretch","font-weight","font-style"];
      var colorKeywords_ = ["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"];
      var valueKeywords_ = ["above","absolute","activeborder","additive","activecaption","afar","after-white-space","ahead","alias","all","all-scroll","alphabetic","alternate","always","amharic","amharic-abegede","antialiased","appworkspace","arabic-indic","armenian","asterisks","attr","auto","avoid","avoid-column","avoid-page","avoid-region","background","backwards","baseline","below","bidi-override","binary","bengali","blink","block","block-axis","bold","bolder","border","border-box","both","bottom","break","break-all","break-word","bullets","button","button-bevel","buttonface","buttonhighlight","buttonshadow","buttontext","calc","cambodian","capitalize","caps-lock-indicator","caption","captiontext","caret","cell","center","checkbox","circle","cjk-decimal","cjk-earthly-branch","cjk-heavenly-stem","cjk-ideographic","clear","clip","close-quote","col-resize","collapse","column","compact","condensed","contain","content","contents","content-box","context-menu","continuous","copy","counter","counters","cover","crop","cross","crosshair","currentcolor","cursive","cyclic","dashed","decimal","decimal-leading-zero","default","default-button","destination-atop","destination-in","destination-out","destination-over","devanagari","disc","discard","disclosure-closed","disclosure-open","document","dot-dash","dot-dot-dash","dotted","double","down","e-resize","ease","ease-in","ease-in-out","ease-out","element","ellipse","ellipsis","embed","end","ethiopic","ethiopic-abegede","ethiopic-abegede-am-et","ethiopic-abegede-gez","ethiopic-abegede-ti-er","ethiopic-abegede-ti-et","ethiopic-halehame-aa-er","ethiopic-halehame-aa-et","ethiopic-halehame-am-et","ethiopic-halehame-gez","ethiopic-halehame-om-et","ethiopic-halehame-sid-et","ethiopic-halehame-so-et","ethiopic-halehame-ti-er","ethiopic-halehame-ti-et","ethiopic-halehame-tig","ethiopic-numeric","ew-resize","expanded","extends","extra-condensed","extra-expanded","fantasy","fast","fill","fixed","flat","flex","footnotes","forwards","from","geometricPrecision","georgian","graytext","groove","gujarati","gurmukhi","hand","hangul","hangul-consonant","hebrew","help","hidden","hide","higher","highlight","highlighttext","hiragana","hiragana-iroha","horizontal","hsl","hsla","icon","ignore","inactiveborder","inactivecaption","inactivecaptiontext","infinite","infobackground","infotext","inherit","initial","inline","inline-axis","inline-block","inline-flex","inline-table","inset","inside","intrinsic","invert","italic","japanese-formal","japanese-informal","justify","kannada","katakana","katakana-iroha","keep-all","khmer","korean-hangul-formal","korean-hanja-formal","korean-hanja-informal","landscape","lao","large","larger","left","level","lighter","line-through","linear","linear-gradient","lines","list-item","listbox","listitem","local","logical","loud","lower","lower-alpha","lower-armenian","lower-greek","lower-hexadecimal","lower-latin","lower-norwegian","lower-roman","lowercase","ltr","malayalam","match","matrix","matrix3d","media-controls-background","media-current-time-display","media-fullscreen-button","media-mute-button","media-play-button","media-return-to-realtime-button","media-rewind-button","media-seek-back-button","media-seek-forward-button","media-slider","media-sliderthumb","media-time-remaining-display","media-volume-slider","media-volume-slider-container","media-volume-sliderthumb","medium","menu","menulist","menulist-button","menulist-text","menulist-textfield","menutext","message-box","middle","min-intrinsic","mix","mongolian","monospace","move","multiple","myanmar","n-resize","narrower","ne-resize","nesw-resize","no-close-quote","no-drop","no-open-quote","no-repeat","none","normal","not-allowed","nowrap","ns-resize","numbers","numeric","nw-resize","nwse-resize","oblique","octal","open-quote","optimizeLegibility","optimizeSpeed","oriya","oromo","outset","outside","outside-shape","overlay","overline","padding","padding-box","painted","page","paused","persian","perspective","plus-darker","plus-lighter","pointer","polygon","portrait","pre","pre-line","pre-wrap","preserve-3d","progress","push-button","radial-gradient","radio","read-only","read-write","read-write-plaintext-only","rectangle","region","relative","repeat","repeating-linear-gradient","repeating-radial-gradient","repeat-x","repeat-y","reset","reverse","rgb","rgba","ridge","right","rotate","rotate3d","rotateX","rotateY","rotateZ","round","row-resize","rtl","run-in","running","s-resize","sans-serif","scale","scale3d","scaleX","scaleY","scaleZ","scroll","scrollbar","scroll-position","se-resize","searchfield","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","semi-condensed","semi-expanded","separate","serif","show","sidama","simp-chinese-formal","simp-chinese-informal","single","skew","skewX","skewY","skip-white-space","slide","slider-horizontal","slider-vertical","sliderthumb-horizontal","sliderthumb-vertical","slow","small","small-caps","small-caption","smaller","solid","somali","source-atop","source-in","source-out","source-over","space","spell-out","square","square-button","start","static","status-bar","stretch","stroke","sub","subpixel-antialiased","super","sw-resize","symbolic","symbols","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tamil","telugu","text","text-bottom","text-top","textarea","textfield","thai","thick","thin","threeddarkshadow","threedface","threedhighlight","threedlightshadow","threedshadow","tibetan","tigre","tigrinya-er","tigrinya-er-abegede","tigrinya-et","tigrinya-et-abegede","to","top","trad-chinese-formal","trad-chinese-informal","translate","translate3d","translateX","translateY","translateZ","transparent","ultra-condensed","ultra-expanded","underline","up","upper-alpha","upper-armenian","upper-greek","upper-hexadecimal","upper-latin","upper-norwegian","upper-roman","uppercase","urdu","url","var","vertical","vertical-text","visible","visibleFill","visiblePainted","visibleStroke","visual","w-resize","wait","wave","wider","window","windowframe","windowtext","words","x-large","x-small","xor","xx-large","xx-small","bicubic","optimizespeed","grayscale","row","row-reverse","wrap","wrap-reverse","column-reverse","flex-start","flex-end","space-between","space-around", "unset"];

      var wordOperatorKeywords_ = ["in","and","or","not","is not","is a","is","isnt","defined","if unless"],
          blockKeywords_ = ["for","if","else","unless", "from", "to"],
          commonAtoms_ = ["null","true","false","href","title","type","not-allowed","readonly","disabled"],
          commonDef_ = ["@font-face", "@keyframes", "@media", "@viewport", "@page", "@host", "@supports", "@block", "@css"];

      var hintWords = tagKeywords_.concat(documentTypes_,mediaTypes_,mediaFeatures_,
                                          propertyKeywords_,nonStandardPropertyKeywords_,
                                          colorKeywords_,valueKeywords_,fontProperties_,
                                          wordOperatorKeywords_,blockKeywords_,
                                          commonAtoms_,commonDef_);

      function wordRegexp(words) {
        words = words.sort(function(a,b){return b > a;});
        return new RegExp("^((" + words.join(")|(") + "))\\b");
      }

      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) keys[array[i]] = true;
        return keys;
      }

      function escapeRegExp(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      CodeMirror.registerHelper("hintWords", "stylus", hintWords);
      CodeMirror.defineMIME("text/x-styl", "stylus");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Swift mode created by Michael Kaminsky https://github.com/mkaminsky11
    function Swift(CodeMirror) {
      function wordSet(words) {
        var set = {};
        for (var i = 0; i < words.length; i++) set[words[i]] = true;
        return set
      }

      var keywords = wordSet(["_","var","let","class","enum","extension","import","protocol","struct","func","typealias","associatedtype",
                              "open","public","internal","fileprivate","private","deinit","init","new","override","self","subscript","super",
                              "convenience","dynamic","final","indirect","lazy","required","static","unowned","unowned(safe)","unowned(unsafe)","weak","as","is",
                              "break","case","continue","default","else","fallthrough","for","guard","if","in","repeat","switch","where","while",
                              "defer","return","inout","mutating","nonmutating","catch","do","rethrows","throw","throws","try","didSet","get","set","willSet",
                              "assignment","associativity","infix","left","none","operator","postfix","precedence","precedencegroup","prefix","right",
                              "Any","AnyObject","Type","dynamicType","Self","Protocol","__COLUMN__","__FILE__","__FUNCTION__","__LINE__"]);
      var definingKeywords = wordSet(["var","let","class","enum","extension","import","protocol","struct","func","typealias","associatedtype","for"]);
      var atoms = wordSet(["true","false","nil","self","super","_"]);
      var types = wordSet(["Array","Bool","Character","Dictionary","Double","Float","Int","Int8","Int16","Int32","Int64","Never","Optional","Set","String",
                           "UInt8","UInt16","UInt32","UInt64","Void"]);
      var operators = "+-/*%=|&<>~^?!";
      var punc = ":;,.(){}[]";
      var binary = /^\-?0b[01][01_]*/;
      var octal = /^\-?0o[0-7][0-7_]*/;
      var hexadecimal = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/;
      var decimal = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/;
      var identifier = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/;
      var property = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
      var instruction = /^\#[A-Za-z]+/;
      var attribute = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
      //var regexp = /^\/(?!\s)(?:\/\/)?(?:\\.|[^\/])+\//

      function tokenBase(stream, state, prev) {
        if (stream.sol()) state.indented = stream.indentation();
        if (stream.eatSpace()) return null

        var ch = stream.peek();
        if (ch == "/") {
          if (stream.match("//")) {
            stream.skipToEnd();
            return "comment"
          }
          if (stream.match("/*")) {
            state.tokenize.push(tokenComment);
            return tokenComment(stream, state)
          }
        }
        if (stream.match(instruction)) return "builtin"
        if (stream.match(attribute)) return "attribute"
        if (stream.match(binary)) return "number"
        if (stream.match(octal)) return "number"
        if (stream.match(hexadecimal)) return "number"
        if (stream.match(decimal)) return "number"
        if (stream.match(property)) return "property"
        if (operators.indexOf(ch) > -1) {
          stream.next();
          return "operator"
        }
        if (punc.indexOf(ch) > -1) {
          stream.next();
          stream.match("..");
          return "punctuation"
        }
        if (ch = stream.match(/("{3}|"|')/)) {
          var tokenize = tokenString(ch[0]);
          state.tokenize.push(tokenize);
          return tokenize(stream, state)
        }

        if (stream.match(identifier)) {
          var ident = stream.current();
          if (types.hasOwnProperty(ident)) return "variable-2"
          if (atoms.hasOwnProperty(ident)) return "atom"
          if (keywords.hasOwnProperty(ident)) {
            if (definingKeywords.hasOwnProperty(ident))
              state.prev = "define";
            return "keyword"
          }
          if (prev == "define") return "def"
          return "variable"
        }

        stream.next();
        return null
      }

      function tokenUntilClosingParen() {
        var depth = 0;
        return function(stream, state, prev) {
          var inner = tokenBase(stream, state, prev);
          if (inner == "punctuation") {
            if (stream.current() == "(") ++depth;
            else if (stream.current() == ")") {
              if (depth == 0) {
                stream.backUp(1);
                state.tokenize.pop();
                return state.tokenize[state.tokenize.length - 1](stream, state)
              }
              else --depth;
            }
          }
          return inner
        }
      }

      function tokenString(quote) {
        var singleLine = quote.length == 1;
        return function(stream, state) {
          var ch, escaped = false;
          while (ch = stream.next()) {
            if (escaped) {
              if (ch == "(") {
                state.tokenize.push(tokenUntilClosingParen());
                return "string"
              }
              escaped = false;
            } else if (stream.match(quote)) {
              state.tokenize.pop();
              return "string"
            } else {
              escaped = ch == "\\";
            }
          }
          if (singleLine) {
            state.tokenize.pop();
          }
          return "string"
        }
      }

      function tokenComment(stream, state) {
        var ch;
        while (true) {
          stream.match(/^[^/*]+/, true);
          ch = stream.next();
          if (!ch) break
          if (ch === "/" && stream.eat("*")) {
            state.tokenize.push(tokenComment);
          } else if (ch === "*" && stream.eat("/")) {
            state.tokenize.pop();
          }
        }
        return "comment"
      }

      function Context(prev, align, indented) {
        this.prev = prev;
        this.align = align;
        this.indented = indented;
      }

      function pushContext(state, stream) {
        var align = stream.match(/^\s*($|\/[\/\*])/, false) ? null : stream.column() + 1;
        state.context = new Context(state.context, align, state.indented);
      }

      function popContext(state) {
        if (state.context) {
          state.indented = state.context.indented;
          state.context = state.context.prev;
        }
      }

      CodeMirror.defineMode("swift", function(config) {
        return {
          startState: function() {
            return {
              prev: null,
              context: null,
              indented: 0,
              tokenize: []
            }
          },

          token: function(stream, state) {
            var prev = state.prev;
            state.prev = null;
            var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase;
            var style = tokenize(stream, state, prev);
            if (!style || style == "comment") state.prev = prev;
            else if (!state.prev) state.prev = style;

            if (style == "punctuation") {
              var bracket = /[\(\[\{]|([\]\)\}])/.exec(stream.current());
              if (bracket) (bracket[1] ? popContext : pushContext)(state, stream);
            }

            return style
          },

          indent: function(state, textAfter) {
            var cx = state.context;
            if (!cx) return 0
            var closing = /^[\]\}\)]/.test(textAfter);
            if (cx.align != null) return cx.align - (closing ? 1 : 0)
            return cx.indented + (closing ? 0 : config.indentUnit)
          },

          electricInput: /^\s*[\)\}\]]$/,

          lineComment: "//",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``"
        }
      });

      CodeMirror.defineMIME("text/x-swift","swift");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    //tcl mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

    function TCL(CodeMirror) {
    CodeMirror.defineMode("tcl", function() {
      function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }
      var keywords = parseWords("Tcl safe after append array auto_execok auto_import auto_load " +
            "auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror " +
            "binary break catch cd close concat continue dde eof encoding error " +
            "eval exec exit expr fblocked fconfigure fcopy file fileevent filename " +
            "filename flush for foreach format gets glob global history http if " +
            "incr info interp join lappend lindex linsert list llength load lrange " +
            "lreplace lsearch lset lsort memory msgcat namespace open package parray " +
            "pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp " +
            "registry regsub rename resource return scan seek set socket source split " +
            "string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord " +
            "tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest " +
            "tclvars tell time trace unknown unset update uplevel upvar variable " +
        "vwait");
        var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
        var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
        function chain(stream, state, f) {
          state.tokenize = f;
          return f(stream, state);
        }
        function tokenBase(stream, state) {
          var beforeParams = state.beforeParams;
          state.beforeParams = false;
          var ch = stream.next();
          if ((ch == '"' || ch == "'") && state.inParams) {
            return chain(stream, state, tokenString(ch));
          } else if (/[\[\]{}\(\),;\.]/.test(ch)) {
            if (ch == "(" && beforeParams) state.inParams = true;
            else if (ch == ")") state.inParams = false;
              return null;
          } else if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          } else if (ch == "#") {
            if (stream.eat("*"))
              return chain(stream, state, tokenComment);
            if (ch == "#" && stream.match(/ *\[ *\[/))
              return chain(stream, state, tokenUnparsed);
            stream.skipToEnd();
            return "comment";
          } else if (ch == '"') {
            stream.skipTo(/"/);
            return "comment";
          } else if (ch == "$") {
            stream.eatWhile(/[$_a-z0-9A-Z\.{:]/);
            stream.eatWhile(/}/);
            state.beforeParams = true;
            return "builtin";
          } else if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "comment";
          } else {
            stream.eatWhile(/[\w\$_{}\xa1-\uffff]/);
            var word = stream.current().toLowerCase();
            if (keywords && keywords.propertyIsEnumerable(word))
              return "keyword";
            if (functions && functions.propertyIsEnumerable(word)) {
              state.beforeParams = true;
              return "keyword";
            }
            return null;
          }
        }
        function tokenString(quote) {
          return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {
              end = true;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          if (end) state.tokenize = tokenBase;
            return "string";
          };
        }
        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "#" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }
        function tokenUnparsed(stream, state) {
          var maybeEnd = 0, ch;
          while (ch = stream.next()) {
            if (ch == "#" && maybeEnd == 2) {
              state.tokenize = tokenBase;
              break;
            }
            if (ch == "]")
              maybeEnd++;
            else if (ch != " ")
              maybeEnd = 0;
          }
          return "meta";
        }
        return {
          startState: function() {
            return {
              tokenize: tokenBase,
              beforeParams: false,
              inParams: false
            };
          },
          token: function(stream, state) {
            if (stream.eatSpace()) return null;
            return state.tokenize(stream, state);
          }
        };
    });
    CodeMirror.defineMIME("text/x-tcl", "tcl");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Textile(CodeMirror) {
      var TOKEN_STYLES = {
        addition: "positive",
        attributes: "attribute",
        bold: "strong",
        cite: "keyword",
        code: "atom",
        definitionList: "number",
        deletion: "negative",
        div: "punctuation",
        em: "em",
        footnote: "variable",
        footCite: "qualifier",
        header: "header",
        html: "comment",
        image: "string",
        italic: "em",
        link: "link",
        linkDefinition: "link",
        list1: "variable-2",
        list2: "variable-3",
        list3: "keyword",
        notextile: "string-2",
        pre: "operator",
        p: "property",
        quote: "bracket",
        span: "quote",
        specialChar: "tag",
        strong: "strong",
        sub: "builtin",
        sup: "builtin",
        table: "variable-3",
        tableHeading: "operator"
      };

      function startNewLine(stream, state) {
        state.mode = Modes.newLayout;
        state.tableHeading = false;

        if (state.layoutType === "definitionList" && state.spanningLayout &&
            stream.match(RE("definitionListEnd"), false))
          state.spanningLayout = false;
      }

      function handlePhraseModifier(stream, state, ch) {
        if (ch === "_") {
          if (stream.eat("_"))
            return togglePhraseModifier(stream, state, "italic", /__/, 2);
          else
            return togglePhraseModifier(stream, state, "em", /_/, 1);
        }

        if (ch === "*") {
          if (stream.eat("*")) {
            return togglePhraseModifier(stream, state, "bold", /\*\*/, 2);
          }
          return togglePhraseModifier(stream, state, "strong", /\*/, 1);
        }

        if (ch === "[") {
          if (stream.match(/\d+\]/)) state.footCite = true;
          return tokenStyles(state);
        }

        if (ch === "(") {
          var spec = stream.match(/^(r|tm|c)\)/);
          if (spec)
            return tokenStylesWith(state, TOKEN_STYLES.specialChar);
        }

        if (ch === "<" && stream.match(/(\w+)[^>]+>[^<]+<\/\1>/))
          return tokenStylesWith(state, TOKEN_STYLES.html);

        if (ch === "?" && stream.eat("?"))
          return togglePhraseModifier(stream, state, "cite", /\?\?/, 2);

        if (ch === "=" && stream.eat("="))
          return togglePhraseModifier(stream, state, "notextile", /==/, 2);

        if (ch === "-" && !stream.eat("-"))
          return togglePhraseModifier(stream, state, "deletion", /-/, 1);

        if (ch === "+")
          return togglePhraseModifier(stream, state, "addition", /\+/, 1);

        if (ch === "~")
          return togglePhraseModifier(stream, state, "sub", /~/, 1);

        if (ch === "^")
          return togglePhraseModifier(stream, state, "sup", /\^/, 1);

        if (ch === "%")
          return togglePhraseModifier(stream, state, "span", /%/, 1);

        if (ch === "@")
          return togglePhraseModifier(stream, state, "code", /@/, 1);

        if (ch === "!") {
          var type = togglePhraseModifier(stream, state, "image", /(?:\([^\)]+\))?!/, 1);
          stream.match(/^:\S+/); // optional Url portion
          return type;
        }
        return tokenStyles(state);
      }

      function togglePhraseModifier(stream, state, phraseModifier, closeRE, openSize) {
        var charBefore = stream.pos > openSize ? stream.string.charAt(stream.pos - openSize - 1) : null;
        var charAfter = stream.peek();
        if (state[phraseModifier]) {
          if ((!charAfter || /\W/.test(charAfter)) && charBefore && /\S/.test(charBefore)) {
            var type = tokenStyles(state);
            state[phraseModifier] = false;
            return type;
          }
        } else if ((!charBefore || /\W/.test(charBefore)) && charAfter && /\S/.test(charAfter) &&
                   stream.match(new RegExp("^.*\\S" + closeRE.source + "(?:\\W|$)"), false)) {
          state[phraseModifier] = true;
          state.mode = Modes.attributes;
        }
        return tokenStyles(state);
      }
      function tokenStyles(state) {
        var disabled = textileDisabled(state);
        if (disabled) return disabled;

        var styles = [];
        if (state.layoutType) styles.push(TOKEN_STYLES[state.layoutType]);

        styles = styles.concat(activeStyles(
          state, "addition", "bold", "cite", "code", "deletion", "em", "footCite",
          "image", "italic", "link", "span", "strong", "sub", "sup", "table", "tableHeading"));

        if (state.layoutType === "header")
          styles.push(TOKEN_STYLES.header + "-" + state.header);

        return styles.length ? styles.join(" ") : null;
      }

      function textileDisabled(state) {
        var type = state.layoutType;

        switch(type) {
        case "notextile":
        case "code":
        case "pre":
          return TOKEN_STYLES[type];
        default:
          if (state.notextile)
            return TOKEN_STYLES.notextile + (type ? (" " + TOKEN_STYLES[type]) : "");
          return null;
        }
      }

      function tokenStylesWith(state, extraStyles) {
        var disabled = textileDisabled(state);
        if (disabled) return disabled;

        var type = tokenStyles(state);
        if (extraStyles)
          return type ? (type + " " + extraStyles) : extraStyles;
        else
          return type;
      }

      function activeStyles(state) {
        var styles = [];
        for (var i = 1; i < arguments.length; ++i) {
          if (state[arguments[i]])
            styles.push(TOKEN_STYLES[arguments[i]]);
        }
        return styles;
      }

      function blankLine(state) {
        var spanningLayout = state.spanningLayout, type = state.layoutType;

        for (var key in state) if (state.hasOwnProperty(key))
          delete state[key];

        state.mode = Modes.newLayout;
        if (spanningLayout) {
          state.layoutType = type;
          state.spanningLayout = true;
        }
      }

      var REs = {
        cache: {},
        single: {
          bc: "bc",
          bq: "bq",
          definitionList: /- .*?:=+/,
          definitionListEnd: /.*=:\s*$/,
          div: "div",
          drawTable: /\|.*\|/,
          foot: /fn\d+/,
          header: /h[1-6]/,
          html: /\s*<(?:\/)?(\w+)(?:[^>]+)?>(?:[^<]+<\/\1>)?/,
          link: /[^"]+":\S/,
          linkDefinition: /\[[^\s\]]+\]\S+/,
          list: /(?:#+|\*+)/,
          notextile: "notextile",
          para: "p",
          pre: "pre",
          table: "table",
          tableCellAttributes: /[\/\\]\d+/,
          tableHeading: /\|_\./,
          tableText: /[^"_\*\[\(\?\+~\^%@|-]+/,
          text: /[^!"_=\*\[\(<\?\+~\^%@-]+/
        },
        attributes: {
          align: /(?:<>|<|>|=)/,
          selector: /\([^\(][^\)]+\)/,
          lang: /\[[^\[\]]+\]/,
          pad: /(?:\(+|\)+){1,2}/,
          css: /\{[^\}]+\}/
        },
        createRe: function(name) {
          switch (name) {
          case "drawTable":
            return REs.makeRe("^", REs.single.drawTable, "$");
          case "html":
            return REs.makeRe("^", REs.single.html, "(?:", REs.single.html, ")*", "$");
          case "linkDefinition":
            return REs.makeRe("^", REs.single.linkDefinition, "$");
          case "listLayout":
            return REs.makeRe("^", REs.single.list, RE("allAttributes"), "*\\s+");
          case "tableCellAttributes":
            return REs.makeRe("^", REs.choiceRe(REs.single.tableCellAttributes,
                                                RE("allAttributes")), "+\\.");
          case "type":
            return REs.makeRe("^", RE("allTypes"));
          case "typeLayout":
            return REs.makeRe("^", RE("allTypes"), RE("allAttributes"),
                              "*\\.\\.?", "(\\s+|$)");
          case "attributes":
            return REs.makeRe("^", RE("allAttributes"), "+");

          case "allTypes":
            return REs.choiceRe(REs.single.div, REs.single.foot,
                                REs.single.header, REs.single.bc, REs.single.bq,
                                REs.single.notextile, REs.single.pre, REs.single.table,
                                REs.single.para);

          case "allAttributes":
            return REs.choiceRe(REs.attributes.selector, REs.attributes.css,
                                REs.attributes.lang, REs.attributes.align, REs.attributes.pad);

          default:
            return REs.makeRe("^", REs.single[name]);
          }
        },
        makeRe: function() {
          var pattern = "";
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            pattern += (typeof arg === "string") ? arg : arg.source;
          }
          return new RegExp(pattern);
        },
        choiceRe: function() {
          var parts = [arguments[0]];
          for (var i = 1; i < arguments.length; ++i) {
            parts[i * 2 - 1] = "|";
            parts[i * 2] = arguments[i];
          }

          parts.unshift("(?:");
          parts.push(")");
          return REs.makeRe.apply(null, parts);
        }
      };

      function RE(name) {
        return (REs.cache[name] || (REs.cache[name] = REs.createRe(name)));
      }

      var Modes = {
        newLayout: function(stream, state) {
          if (stream.match(RE("typeLayout"), false)) {
            state.spanningLayout = false;
            return (state.mode = Modes.blockType)(stream, state);
          }
          var newMode;
          if (!textileDisabled(state)) {
            if (stream.match(RE("listLayout"), false))
              newMode = Modes.list;
            else if (stream.match(RE("drawTable"), false))
              newMode = Modes.table;
            else if (stream.match(RE("linkDefinition"), false))
              newMode = Modes.linkDefinition;
            else if (stream.match(RE("definitionList")))
              newMode = Modes.definitionList;
            else if (stream.match(RE("html"), false))
              newMode = Modes.html;
          }
          return (state.mode = (newMode || Modes.text))(stream, state);
        },

        blockType: function(stream, state) {
          var match, type;
          state.layoutType = null;

          if (match = stream.match(RE("type")))
            type = match[0];
          else
            return (state.mode = Modes.text)(stream, state);

          if (match = type.match(RE("header"))) {
            state.layoutType = "header";
            state.header = parseInt(match[0][1]);
          } else if (type.match(RE("bq"))) {
            state.layoutType = "quote";
          } else if (type.match(RE("bc"))) {
            state.layoutType = "code";
          } else if (type.match(RE("foot"))) {
            state.layoutType = "footnote";
          } else if (type.match(RE("notextile"))) {
            state.layoutType = "notextile";
          } else if (type.match(RE("pre"))) {
            state.layoutType = "pre";
          } else if (type.match(RE("div"))) {
            state.layoutType = "div";
          } else if (type.match(RE("table"))) {
            state.layoutType = "table";
          }

          state.mode = Modes.attributes;
          return tokenStyles(state);
        },

        text: function(stream, state) {
          if (stream.match(RE("text"))) return tokenStyles(state);

          var ch = stream.next();
          if (ch === '"')
            return (state.mode = Modes.link)(stream, state);
          return handlePhraseModifier(stream, state, ch);
        },

        attributes: function(stream, state) {
          state.mode = Modes.layoutLength;

          if (stream.match(RE("attributes")))
            return tokenStylesWith(state, TOKEN_STYLES.attributes);
          else
            return tokenStyles(state);
        },

        layoutLength: function(stream, state) {
          if (stream.eat(".") && stream.eat("."))
            state.spanningLayout = true;

          state.mode = Modes.text;
          return tokenStyles(state);
        },

        list: function(stream, state) {
          var match = stream.match(RE("list"));
          state.listDepth = match[0].length;
          var listMod = (state.listDepth - 1) % 3;
          if (!listMod)
            state.layoutType = "list1";
          else if (listMod === 1)
            state.layoutType = "list2";
          else
            state.layoutType = "list3";

          state.mode = Modes.attributes;
          return tokenStyles(state);
        },

        link: function(stream, state) {
          state.mode = Modes.text;
          if (stream.match(RE("link"))) {
            stream.match(/\S+/);
            return tokenStylesWith(state, TOKEN_STYLES.link);
          }
          return tokenStyles(state);
        },

        linkDefinition: function(stream, state) {
          stream.skipToEnd();
          return tokenStylesWith(state, TOKEN_STYLES.linkDefinition);
        },

        definitionList: function(stream, state) {
          stream.match(RE("definitionList"));

          state.layoutType = "definitionList";

          if (stream.match(/\s*$/))
            state.spanningLayout = true;
          else
            state.mode = Modes.attributes;

          return tokenStyles(state);
        },

        html: function(stream, state) {
          stream.skipToEnd();
          return tokenStylesWith(state, TOKEN_STYLES.html);
        },

        table: function(stream, state) {
          state.layoutType = "table";
          return (state.mode = Modes.tableCell)(stream, state);
        },

        tableCell: function(stream, state) {
          if (stream.match(RE("tableHeading")))
            state.tableHeading = true;
          else
            stream.eat("|");

          state.mode = Modes.tableCellAttributes;
          return tokenStyles(state);
        },

        tableCellAttributes: function(stream, state) {
          state.mode = Modes.tableText;

          if (stream.match(RE("tableCellAttributes")))
            return tokenStylesWith(state, TOKEN_STYLES.attributes);
          else
            return tokenStyles(state);
        },

        tableText: function(stream, state) {
          if (stream.match(RE("tableText")))
            return tokenStyles(state);

          if (stream.peek() === "|") { // end of cell
            state.mode = Modes.tableCell;
            return tokenStyles(state);
          }
          return handlePhraseModifier(stream, state, stream.next());
        }
      };

      CodeMirror.defineMode("textile", function() {
        return {
          startState: function() {
            return { mode: Modes.newLayout };
          },
          token: function(stream, state) {
            if (stream.sol()) startNewLine(stream, state);
            return state.mode(stream, state);
          },
          blankLine: blankLine
        };
      });

      CodeMirror.defineMIME("text/x-textile", "textile");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /***
        |''Name''|tiddlywiki.js|
        |''Description''|Enables TiddlyWikiy syntax highlighting using CodeMirror|
        |''Author''|PMario|
        |''Version''|0.1.7|
        |''Status''|''stable''|
        |''Source''|[[GitHub|https://github.com/pmario/CodeMirror2/blob/tw-syntax/mode/tiddlywiki]]|
        |''Documentation''|https://codemirror.tiddlyspace.com/|
        |''License''|[[MIT License|http://www.opensource.org/licenses/mit-license.php]]|
        |''CoreVersion''|2.5.0|
        |''Requires''|codemirror.js|
        |''Keywords''|syntax highlighting color code mirror codemirror|
        ! Info
        CoreVersion parameter is needed for TiddlyWiki only!
    ***/

    function TiddlyWiki(CodeMirror) {
    CodeMirror.defineMode("tiddlywiki", function () {
      // Tokenizer
      var textwords = {};

      var keywords = {
        "allTags": true, "closeAll": true, "list": true,
        "newJournal": true, "newTiddler": true,
        "permaview": true, "saveChanges": true,
        "search": true, "slider": true, "tabs": true,
        "tag": true, "tagging": true, "tags": true,
        "tiddler": true, "timeline": true,
        "today": true, "version": true, "option": true,
        "with": true, "filter": true
      };

      var isSpaceName = /[\w_\-]/i,
          reHR = /^\-\-\-\-+$/,                                 // <hr>
          reWikiCommentStart = /^\/\*\*\*$/,            // /***
          reWikiCommentStop = /^\*\*\*\/$/,             // ***/
          reBlockQuote = /^<<<$/,

          reJsCodeStart = /^\/\/\{\{\{$/,                       // //{{{ js block start
          reJsCodeStop = /^\/\/\}\}\}$/,                        // //}}} js stop
          reXmlCodeStart = /^<!--\{\{\{-->$/,           // xml block start
          reXmlCodeStop = /^<!--\}\}\}-->$/,            // xml stop

          reCodeBlockStart = /^\{\{\{$/,                        // {{{ TW text div block start
          reCodeBlockStop = /^\}\}\}$/,                 // }}} TW text stop

          reUntilCodeStop = /.*?\}\}\}/;

      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      function tokenBase(stream, state) {
        var sol = stream.sol(), ch = stream.peek();

        state.block = false;        // indicates the start of a code block.

        // check start of  blocks
        if (sol && /[<\/\*{}\-]/.test(ch)) {
          if (stream.match(reCodeBlockStart)) {
            state.block = true;
            return chain(stream, state, twTokenCode);
          }
          if (stream.match(reBlockQuote))
            return 'quote';
          if (stream.match(reWikiCommentStart) || stream.match(reWikiCommentStop))
            return 'comment';
          if (stream.match(reJsCodeStart) || stream.match(reJsCodeStop) || stream.match(reXmlCodeStart) || stream.match(reXmlCodeStop))
            return 'comment';
          if (stream.match(reHR))
            return 'hr';
        }

        stream.next();
        if (sol && /[\/\*!#;:>|]/.test(ch)) {
          if (ch == "!") { // tw header
            stream.skipToEnd();
            return "header";
          }
          if (ch == "*") { // tw list
            stream.eatWhile('*');
            return "comment";
          }
          if (ch == "#") { // tw numbered list
            stream.eatWhile('#');
            return "comment";
          }
          if (ch == ";") { // definition list, term
            stream.eatWhile(';');
            return "comment";
          }
          if (ch == ":") { // definition list, description
            stream.eatWhile(':');
            return "comment";
          }
          if (ch == ">") { // single line quote
            stream.eatWhile(">");
            return "quote";
          }
          if (ch == '|')
            return 'header';
        }

        if (ch == '{' && stream.match(/\{\{/))
          return chain(stream, state, twTokenCode);

        // rudimentary html:// file:// link matching. TW knows much more ...
        if (/[hf]/i.test(ch) &&
            /[ti]/i.test(stream.peek()) &&
            stream.match(/\b(ttps?|tp|ile):\/\/[\-A-Z0-9+&@#\/%?=~_|$!:,.;]*[A-Z0-9+&@#\/%=~_|$]/i))
          return "link";

        // just a little string indicator, don't want to have the whole string covered
        if (ch == '"')
          return 'string';

        if (ch == '~')    // _no_ CamelCase indicator should be bold
          return 'brace';

        if (/[\[\]]/.test(ch) && stream.match(ch)) // check for [[..]]
          return 'brace';

        if (ch == "@") {    // check for space link. TODO fix @@...@@ highlighting
          stream.eatWhile(isSpaceName);
          return "link";
        }

        if (/\d/.test(ch)) {        // numbers
          stream.eatWhile(/\d/);
          return "number";
        }

        if (ch == "/") { // tw invisible comment
          if (stream.eat("%")) {
            return chain(stream, state, twTokenComment);
          } else if (stream.eat("/")) { //
            return chain(stream, state, twTokenEm);
          }
        }

        if (ch == "_" && stream.eat("_")) // tw underline
            return chain(stream, state, twTokenUnderline);

        // strikethrough and mdash handling
        if (ch == "-" && stream.eat("-")) {
          // if strikethrough looks ugly, change CSS.
          if (stream.peek() != ' ')
            return chain(stream, state, twTokenStrike);
          // mdash
          if (stream.peek() == ' ')
            return 'brace';
        }

        if (ch == "'" && stream.eat("'")) // tw bold
          return chain(stream, state, twTokenStrong);

        if (ch == "<" && stream.eat("<")) // tw macro
          return chain(stream, state, twTokenMacro);

        // core macro handling
        stream.eatWhile(/[\w\$_]/);
        return textwords.propertyIsEnumerable(stream.current()) ? "keyword" : null
      }

      // tw invisible comment
      function twTokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "%");
        }
        return "comment";
      }

      // tw strong / bold
      function twTokenStrong(stream, state) {
        var maybeEnd = false,
        ch;
        while (ch = stream.next()) {
          if (ch == "'" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "'");
        }
        return "strong";
      }

      // tw code
      function twTokenCode(stream, state) {
        var sb = state.block;

        if (sb && stream.current()) {
          return "comment";
        }

        if (!sb && stream.match(reUntilCodeStop)) {
          state.tokenize = tokenBase;
          return "comment";
        }

        if (sb && stream.sol() && stream.match(reCodeBlockStop)) {
          state.tokenize = tokenBase;
          return "comment";
        }

        stream.next();
        return "comment";
      }

      // tw em / italic
      function twTokenEm(stream, state) {
        var maybeEnd = false,
        ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "/");
        }
        return "em";
      }

      // tw underlined text
      function twTokenUnderline(stream, state) {
        var maybeEnd = false,
        ch;
        while (ch = stream.next()) {
          if (ch == "_" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "_");
        }
        return "underlined";
      }

      // tw strike through text looks ugly
      // change CSS if needed
      function twTokenStrike(stream, state) {
        var maybeEnd = false, ch;

        while (ch = stream.next()) {
          if (ch == "-" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "-");
        }
        return "strikethrough";
      }

      // macro
      function twTokenMacro(stream, state) {
        if (stream.current() == '<<') {
          return 'macro';
        }

        var ch = stream.next();
        if (!ch) {
          state.tokenize = tokenBase;
          return null;
        }
        if (ch == ">") {
          if (stream.peek() == '>') {
            stream.next();
            state.tokenize = tokenBase;
            return "macro";
          }
        }

        stream.eatWhile(/[\w\$_]/);
        return keywords.propertyIsEnumerable(stream.current()) ? "keyword" : null
      }

      // Interface
      return {
        startState: function () {
          return {tokenize: tokenBase};
        },

        token: function (stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          return style;
        }
      };
    });

    CodeMirror.defineMIME("text/x-tiddlywiki", "tiddlywiki");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Tiki(CodeMirror) {
    CodeMirror.defineMode('tiki', function(config) {
      function inBlock(style, terminator, returnTokenizer) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }

          if (returnTokenizer) state.tokenize = returnTokenizer;

          return style;
        };
      }

      function inLine(style) {
        return function(stream, state) {
          while(!stream.eol()) {
            stream.next();
          }
          state.tokenize = inText;
          return style;
        };
      }

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var sol = stream.sol();
        var ch = stream.next();

        //non start of line
        switch (ch) { //switch is generally much faster than if, so it is used here
        case "{": //plugin
          stream.eat("/");
          stream.eatSpace();
          stream.eatWhile(/[^\s\u00a0=\"\'\/?(}]/);
          state.tokenize = inPlugin;
          return "tag";
        case "_": //bold
          if (stream.eat("_"))
            return chain(inBlock("strong", "__", inText));
          break;
        case "'": //italics
          if (stream.eat("'"))
            return chain(inBlock("em", "''", inText));
          break;
        case "(":// Wiki Link
          if (stream.eat("("))
            return chain(inBlock("variable-2", "))", inText));
          break;
        case "[":// Weblink
          return chain(inBlock("variable-3", "]", inText));
          break;
        case "|": //table
          if (stream.eat("|"))
            return chain(inBlock("comment", "||"));
          break;
        case "-":
          if (stream.eat("=")) {//titleBar
            return chain(inBlock("header string", "=-", inText));
          } else if (stream.eat("-")) {//deleted
            return chain(inBlock("error tw-deleted", "--", inText));
          }
          break;
        case "=": //underline
          if (stream.match("=="))
            return chain(inBlock("tw-underline", "===", inText));
          break;
        case ":":
          if (stream.eat(":"))
            return chain(inBlock("comment", "::"));
          break;
        case "^": //box
          return chain(inBlock("tw-box", "^"));
          break;
        case "~": //np
          if (stream.match("np~"))
            return chain(inBlock("meta", "~/np~"));
          break;
        }

        //start of line types
        if (sol) {
          switch (ch) {
          case "!": //header at start of line
            if (stream.match('!!!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!!')) {
              return chain(inLine("header string"));
            } else if (stream.match('!!')) {
              return chain(inLine("header string"));
            } else {
              return chain(inLine("header string"));
            }
            break;
          case "*": //unordered list line item, or <li /> at start of line
          case "#": //ordered list line item, or <li /> at start of line
          case "+": //ordered list line item, or <li /> at start of line
            return chain(inLine("tw-listitem bracket"));
            break;
          }
        }

        //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki
        return null;
      }

      var indentUnit = config.indentUnit;

      // Return variables for tokenizers
      var pluginName, type;
      function inPlugin(stream, state) {
        var ch = stream.next();
        var peek = stream.peek();

        if (ch == "}") {
          state.tokenize = inText;
          //type = ch == ")" ? "endPlugin" : "selfclosePlugin"; inPlugin
          return "tag";
        } else if (ch == "(" || ch == ")") {
          return "bracket";
        } else if (ch == "=") {
          type = "equals";

          if (peek == ">") {
            stream.next();
            peek = stream.peek();
          }

          //here we detect values directly after equal character with no quotes
          if (!/[\'\"]/.test(peek)) {
            state.tokenize = inAttributeNoQuote();
          }
          //end detect values

          return "operator";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          return state.tokenize(stream, state);
        } else {
          stream.eatWhile(/[^\s\u00a0=\"\'\/?]/);
          return "keyword";
        }
      }

      function inAttribute(quote) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inPlugin;
              break;
            }
          }
          return "string";
        };
      }

      function inAttributeNoQuote() {
        return function(stream, state) {
          while (!stream.eol()) {
            var ch = stream.next();
            var peek = stream.peek();
            if (ch == " " || ch == "," || /[ )}]/.test(peek)) {
          state.tokenize = inPlugin;
          break;
        }
      }
      return "string";
    };
                         }

    var curState, setStyle;
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
    }

    function cont() {
      pass.apply(null, arguments);
      return true;
    }

    function pushContext(pluginName, startOfLine) {
      var noIndent = curState.context && curState.context.noIndent;
      curState.context = {
        prev: curState.context,
        pluginName: pluginName,
        indent: curState.indented,
        startOfLine: startOfLine,
        noIndent: noIndent
      };
    }

    function popContext() {
      if (curState.context) curState.context = curState.context.prev;
    }

    function element(type) {
      if (type == "openPlugin") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}
      else if (type == "closePlugin") {
        var err = false;
        if (curState.context) {
          err = curState.context.pluginName != pluginName;
          popContext();
        } else {
          err = true;
        }
        if (err) setStyle = "error";
        return cont(endcloseplugin(err));
      }
      else if (type == "string") {
        if (!curState.context || curState.context.name != "!cdata") pushContext("!cdata");
        if (curState.tokenize == inText) popContext();
        return cont();
      }
      else return cont();
    }

    function endplugin(startOfLine) {
      return function(type) {
        if (
          type == "selfclosePlugin" ||
            type == "endPlugin"
        )
          return cont();
        if (type == "endPlugin") {pushContext(curState.pluginName, startOfLine); return cont();}
        return cont();
      };
    }

    function endcloseplugin(err) {
      return function(type) {
        if (err) setStyle = "error";
        if (type == "endPlugin") return cont();
        return pass();
      };
    }

    function attributes(type) {
      if (type == "keyword") {setStyle = "attribute"; return cont(attributes);}
      if (type == "equals") return cont(attvalue, attributes);
      return pass();
    }
    function attvalue(type) {
      if (type == "keyword") {setStyle = "string"; return cont();}
      if (type == "string") return cont(attvaluemaybe);
      return pass();
    }
    function attvaluemaybe(type) {
      if (type == "string") return cont(attvaluemaybe);
      else return pass();
    }
    return {
      startState: function() {
        return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};
      },
      token: function(stream, state) {
        if (stream.sol()) {
          state.startOfLine = true;
          state.indented = stream.indentation();
        }
        if (stream.eatSpace()) return null;

        setStyle = type = pluginName = null;
        var style = state.tokenize(stream, state);
        if ((style || type) && style != "comment") {
          curState = state;
          while (true) {
            var comb = state.cc.pop() || element;
            if (comb(type || style)) break;
          }
        }
        state.startOfLine = false;
        return setStyle || style;
      },
      indent: function(state, textAfter) {
        var context = state.context;
        if (context && context.noIndent) return 0;
        if (context && /^{\//.test(textAfter))
            context = context.prev;
        while (context && !context.startOfLine)
            context = context.prev;
        if (context) return context.indent + indentUnit;
        else return 0;
      },
      electricChars: "/"
    };
    });

    CodeMirror.defineMIME("text/tiki", "tiki");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Toml(CodeMirror) {
    CodeMirror.defineMode("toml", function () {
      return {
        startState: function () {
          return {
            inString: false,
            stringType: "",
            lhs: true,
            inArray: 0
          };
        },
        token: function (stream, state) {
          //check for state changes
          if (!state.inString && ((stream.peek() == '"') || (stream.peek() == "'"))) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.inString = true; // Update state
          }
          if (stream.sol() && state.inArray === 0) {
            state.lhs = true;
          }
          //return state
          if (state.inString) {
            while (state.inString && !stream.eol()) {
              if (stream.peek() === state.stringType) {
                stream.next(); // Skip quote
                state.inString = false; // Clear flag
              } else if (stream.peek() === '\\') {
                stream.next();
                stream.next();
              } else {
                stream.match(/^.[^\\\"\']*/);
              }
            }
            return state.lhs ? "property string" : "string"; // Token style
          } else if (state.inArray && stream.peek() === ']') {
            stream.next();
            state.inArray--;
            return 'bracket';
          } else if (state.lhs && stream.peek() === '[' && stream.skipTo(']')) {
            stream.next();//skip closing ]
            // array of objects has an extra open & close []
            if (stream.peek() === ']') stream.next();
            return "atom";
          } else if (stream.peek() === "#") {
            stream.skipToEnd();
            return "comment";
          } else if (stream.eatSpace()) {
            return null;
          } else if (state.lhs && stream.eatWhile(function (c) { return c != '=' && c != ' '; })) {
            return "property";
          } else if (state.lhs && stream.peek() === "=") {
            stream.next();
            state.lhs = false;
            return null;
          } else if (!state.lhs && stream.match(/^\d\d\d\d[\d\-\:\.T]*Z/)) {
            return 'atom'; //date
          } else if (!state.lhs && (stream.match('true') || stream.match('false'))) {
            return 'atom';
          } else if (!state.lhs && stream.peek() === '[') {
            state.inArray++;
            stream.next();
            return 'bracket';
          } else if (!state.lhs && stream.match(/^\-?\d+(?:\.\d+)?/)) {
            return 'number';
          } else if (!stream.eatSpace()) {
            stream.next();
          }
          return null;
        }
      };
    });

    CodeMirror.defineMIME('text/x-toml', 'toml');

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Tornado(CodeMirror) {
      CodeMirror.defineMode("tornado:inner", function() {
        var keywords = ["and","as","assert","autoescape","block","break","class","comment","context",
                        "continue","datetime","def","del","elif","else","end","escape","except",
                        "exec","extends","false","finally","for","from","global","if","import","in",
                        "include","is","json_encode","lambda","length","linkify","load","module",
                        "none","not","or","pass","print","put","raise","raw","return","self","set",
                        "squeeze","super","true","try","url_escape","while","with","without","xhtml_escape","yield"];
        keywords = new RegExp("^((" + keywords.join(")|(") + "))\\b");

        function tokenBase (stream, state) {
          stream.eatWhile(/[^\{]/);
          var ch = stream.next();
          if (ch == "{") {
            if (ch = stream.eat(/\{|%|#/)) {
              state.tokenize = inTag(ch);
              return "tag";
            }
          }
        }
        function inTag (close) {
          if (close == "{") {
            close = "}";
          }
          return function (stream, state) {
            var ch = stream.next();
            if ((ch == close) && stream.eat("}")) {
              state.tokenize = tokenBase;
              return "tag";
            }
            if (stream.match(keywords)) {
              return "keyword";
            }
            return close == "#" ? "comment" : "string";
          };
        }
        return {
          startState: function () {
            return {tokenize: tokenBase};
          },
          token: function (stream, state) {
            return state.tokenize(stream, state);
          }
        };
      });

      CodeMirror.defineMode("tornado", function(config) {
        var htmlBase = CodeMirror.getMode(config, "text/html");
        var tornadoInner = CodeMirror.getMode(config, "tornado:inner");
        return CodeMirror.overlayMode(htmlBase, tornadoInner);
      });

      CodeMirror.defineMIME("text/x-tornado", "tornado");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Troff(CodeMirror) {
    CodeMirror.defineMode('troff', function() {

      var words = {};

      function tokenBase(stream) {
        if (stream.eatSpace()) return null;

        var sol = stream.sol();
        var ch = stream.next();

        if (ch === '\\') {
          if (stream.match('fB') || stream.match('fR') || stream.match('fI') ||
              stream.match('u')  || stream.match('d')  ||
              stream.match('%')  || stream.match('&')) {
            return 'string';
          }
          if (stream.match('m[')) {
            stream.skipTo(']');
            stream.next();
            return 'string';
          }
          if (stream.match('s+') || stream.match('s-')) {
            stream.eatWhile(/[\d-]/);
            return 'string';
          }
          if (stream.match('\(') || stream.match('*\(')) {
            stream.eatWhile(/[\w-]/);
            return 'string';
          }
          return 'string';
        }
        if (sol && (ch === '.' || ch === '\'')) {
          if (stream.eat('\\') && stream.eat('\"')) {
            stream.skipToEnd();
            return 'comment';
          }
        }
        if (sol && ch === '.') {
          if (stream.match('B ') || stream.match('I ') || stream.match('R ')) {
            return 'attribute';
          }
          if (stream.match('TH ') || stream.match('SH ') || stream.match('SS ') || stream.match('HP ')) {
            stream.skipToEnd();
            return 'quote';
          }
          if ((stream.match(/[A-Z]/) && stream.match(/[A-Z]/)) || (stream.match(/[a-z]/) && stream.match(/[a-z]/))) {
            return 'attribute';
          }
        }
        stream.eatWhile(/[\w-]/);
        var cur = stream.current();
        return words.hasOwnProperty(cur) ? words[cur] : null;
      }

      function tokenize(stream, state) {
        return (state.tokens[0] || tokenBase) (stream, state);
      }
      return {
        startState: function() {return {tokens:[]};},
        token: function(stream, state) {
          return tokenize(stream, state);
        }
      };
    });

    CodeMirror.defineMIME('text/troff', 'troff');
    CodeMirror.defineMIME('text/x-troff', 'troff');
    CodeMirror.defineMIME('application/x-troff', 'troff');

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function TTCN(CodeMirror) {

      CodeMirror.defineMode("ttcn", function(config, parserConfig) {
        var indentUnit = config.indentUnit,
            keywords = parserConfig.keywords || {},
            builtin = parserConfig.builtin || {},
            timerOps = parserConfig.timerOps || {},
            portOps  = parserConfig.portOps || {},
            configOps = parserConfig.configOps || {},
            verdictOps = parserConfig.verdictOps || {},
            sutOps = parserConfig.sutOps || {},
            functionOps = parserConfig.functionOps || {},

            verdictConsts = parserConfig.verdictConsts || {},
            booleanConsts = parserConfig.booleanConsts || {},
            otherConsts   = parserConfig.otherConsts || {},

            types = parserConfig.types || {},
            visibilityModifiers = parserConfig.visibilityModifiers || {},
            templateMatch = parserConfig.templateMatch || {},
            multiLineStrings = parserConfig.multiLineStrings,
            indentStatements = parserConfig.indentStatements !== false;
        var isOperatorChar = /[+\-*&@=<>!\/]/;
        var curPunc;

        function tokenBase(stream, state) {
          var ch = stream.next();

          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          if (/[\[\]{}\(\),;\\:\?\.]/.test(ch)) {
            curPunc = ch;
            return "punctuation";
          }
          if (ch == "#"){
            stream.skipToEnd();
            return "atom preprocessor";
          }
          if (ch == "%"){
            stream.eatWhile(/\b/);
            return "atom ttcn3Macros";
          }
          if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return tokenComment(stream, state);
            }
            if (stream.eat("/")) {
              stream.skipToEnd();
              return "comment";
            }
          }
          if (isOperatorChar.test(ch)) {
            if(ch == "@"){
              if(stream.match("try") || stream.match("catch")
                  || stream.match("lazy")){
                return "keyword";
              }
            }
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
          stream.eatWhile(/[\w\$_\xa1-\uffff]/);
          var cur = stream.current();

          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          if (builtin.propertyIsEnumerable(cur)) return "builtin";

          if (timerOps.propertyIsEnumerable(cur)) return "def timerOps";
          if (configOps.propertyIsEnumerable(cur)) return "def configOps";
          if (verdictOps.propertyIsEnumerable(cur)) return "def verdictOps";
          if (portOps.propertyIsEnumerable(cur)) return "def portOps";
          if (sutOps.propertyIsEnumerable(cur)) return "def sutOps";
          if (functionOps.propertyIsEnumerable(cur)) return "def functionOps";

          if (verdictConsts.propertyIsEnumerable(cur)) return "string verdictConsts";
          if (booleanConsts.propertyIsEnumerable(cur)) return "string booleanConsts";
          if (otherConsts.propertyIsEnumerable(cur)) return "string otherConsts";

          if (types.propertyIsEnumerable(cur)) return "builtin types";
          if (visibilityModifiers.propertyIsEnumerable(cur))
            return "builtin visibilityModifiers";
          if (templateMatch.propertyIsEnumerable(cur)) return "atom templateMatch";

          return "variable";
        }

        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped){
                var afterQuote = stream.peek();
                //look if the character after the quote is like the B in '10100010'B
                if (afterQuote){
                  afterQuote = afterQuote.toLowerCase();
                  if(afterQuote == "b" || afterQuote == "h" || afterQuote == "o")
                    stream.next();
                }
                end = true; break;
              }
              escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
              state.tokenize = null;
            return "string";
          };
        }

        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
              state.tokenize = null;
              break;
            }
            maybeEnd = (ch == "*");
          }
          return "comment";
        }

        function Context(indented, column, type, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.align = align;
          this.prev = prev;
        }

        function pushContext(state, col, type) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement")
            indent = state.context.indented;
          return state.context = new Context(indent, col, type, null, state.context);
        }

        function popContext(state) {
          var t = state.context.type;
          if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }

        //Interface
        return {
          startState: function(basecolumn) {
            return {
              tokenize: null,
              context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
              indented: 0,
              startOfLine: true
            };
          },

          token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
              if (ctx.align == null) ctx.align = false;
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
                && ctx.type == "statement"){
              popContext(state);
            }
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
              while (ctx.type == "statement") ctx = popContext(state);
              if (ctx.type == "}") ctx = popContext(state);
              while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (indentStatements &&
                (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
                (ctx.type == "statement" && curPunc == "newstatement")))
              pushContext(state, stream.column(), "statement");

            state.startOfLine = false;

            return style;
          },

          electricChars: "{}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//",
          fold: "brace"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      function def(mimes, mode) {
        if (typeof mimes == "string") mimes = [mimes];
        var words = [];
        function add(obj) {
          if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
            words.push(prop);
        }

        add(mode.keywords);
        add(mode.builtin);
        add(mode.timerOps);
        add(mode.portOps);

        if (words.length) {
          mode.helperType = mimes[0];
          CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i = 0; i < mimes.length; ++i)
          CodeMirror.defineMIME(mimes[i], mode);
      }

      def(["text/x-ttcn", "text/x-ttcn3", "text/x-ttcnpp"], {
        name: "ttcn",
        keywords: words("activate address alive all alt altstep and and4b any" +
        " break case component const continue control deactivate" +
        " display do else encode enumerated except exception" +
        " execute extends extension external for from function" +
        " goto group if import in infinity inout interleave" +
        " label language length log match message mixed mod" +
        " modifies module modulepar mtc noblock not not4b nowait" +
        " of on optional or or4b out override param pattern port" +
        " procedure record recursive rem repeat return runs select" +
        " self sender set signature system template testcase to" +
        " type union value valueof var variant while with xor xor4b"),
        builtin: words("bit2hex bit2int bit2oct bit2str char2int char2oct encvalue" +
        " decomp decvalue float2int float2str hex2bit hex2int" +
        " hex2oct hex2str int2bit int2char int2float int2hex" +
        " int2oct int2str int2unichar isbound ischosen ispresent" +
        " isvalue lengthof log2str oct2bit oct2char oct2hex oct2int" +
        " oct2str regexp replace rnd sizeof str2bit str2float" +
        " str2hex str2int str2oct substr unichar2int unichar2char" +
        " enum2int"),
        types: words("anytype bitstring boolean char charstring default float" +
        " hexstring integer objid octetstring universal verdicttype timer"),
        timerOps: words("read running start stop timeout"),
        portOps: words("call catch check clear getcall getreply halt raise receive" +
        " reply send trigger"),
        configOps: words("create connect disconnect done kill killed map unmap"),
        verdictOps: words("getverdict setverdict"),
        sutOps: words("action"),
        functionOps: words("apply derefers refers"),

        verdictConsts: words("error fail inconc none pass"),
        booleanConsts: words("true false"),
        otherConsts: words("null NULL omit"),

        visibilityModifiers: words("private public friend"),
        templateMatch: words("complement ifpresent subset superset permutation"),
        multiLineStrings: true
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function TTCN_cfg(CodeMirror) {
      CodeMirror.defineMode("ttcn-cfg", function(config, parserConfig) {
        var indentUnit = config.indentUnit,
            keywords = parserConfig.keywords || {},
            fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions || {},
            externalCommands = parserConfig.externalCommands || {},
            multiLineStrings = parserConfig.multiLineStrings,
            indentStatements = parserConfig.indentStatements !== false;
        var isOperatorChar = /[\|]/;
        var curPunc;

        function tokenBase(stream, state) {
          var ch = stream.next();
          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          }
          if (/[:=]/.test(ch)) {
            curPunc = ch;
            return "punctuation";
          }
          if (ch == "#"){
            stream.skipToEnd();
            return "comment";
          }
          if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
          }
          if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "operator";
          }
          if (ch == "["){
            stream.eatWhile(/[\w_\]]/);
            return "number sectionTitle";
          }

          stream.eatWhile(/[\w\$_]/);
          var cur = stream.current();
          if (keywords.propertyIsEnumerable(cur)) return "keyword";
          if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))
            return "negative fileNCtrlMaskOptions";
          if (externalCommands.propertyIsEnumerable(cur)) return "negative externalCommands";

          return "variable";
        }

        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped){
                var afterNext = stream.peek();
                //look if the character if the quote is like the B in '10100010'B
                if (afterNext){
                  afterNext = afterNext.toLowerCase();
                  if(afterNext == "b" || afterNext == "h" || afterNext == "o")
                    stream.next();
                }
                end = true; break;
              }
              escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
              state.tokenize = null;
            return "string";
          };
        }

        function Context(indented, column, type, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.align = align;
          this.prev = prev;
        }
        function pushContext(state, col, type) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement")
            indent = state.context.indented;
          return state.context = new Context(indent, col, type, null, state.context);
        }
        function popContext(state) {
          var t = state.context.type;
          if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }

        //Interface
        return {
          startState: function(basecolumn) {
            return {
              tokenize: null,
              context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
              indented: 0,
              startOfLine: true
            };
          },

          token: function(stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
              if (ctx.align == null) ctx.align = false;
              state.indented = stream.indentation();
              state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
                && ctx.type == "statement"){
              popContext(state);
            }
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
              while (ctx.type == "statement") ctx = popContext(state);
              if (ctx.type == "}") ctx = popContext(state);
              while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")
                && curPunc != ';') || (ctx.type == "statement"
                && curPunc == "newstatement")))
              pushContext(state, stream.column(), "statement");
            state.startOfLine = false;
            return style;
          },

          electricChars: "{}",
          lineComment: "#",
          fold: "brace"
        };
      });

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i)
          obj[words[i]] = true;
        return obj;
      }

      CodeMirror.defineMIME("text/x-ttcn-cfg", {
        name: "ttcn-cfg",
        keywords: words("Yes No LogFile FileMask ConsoleMask AppendFile" +
        " TimeStampFormat LogEventTypes SourceInfoFormat" +
        " LogEntityName LogSourceInfo DiskFullAction" +
        " LogFileNumber LogFileSize MatchingHints Detailed" +
        " Compact SubCategories Stack Single None Seconds" +
        " DateTime Time Stop Error Retry Delete TCPPort KillTimer" +
        " NumHCs UnixSocketsEnabled LocalAddress"),
        fileNCtrlMaskOptions: words("TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING" +
        " TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP" +
        " TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION" +
        " TTCN_USER TTCN_FUNCTION TTCN_STATISTICS" +
        " TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG" +
        " EXECUTOR ERROR WARNING PORTEVENT TIMEROP" +
        " VERDICTOP DEFAULTOP TESTCASE ACTION USER" +
        " FUNCTION STATISTICS PARALLEL MATCHING DEBUG" +
        " LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED" +
        " DEBUG_ENCDEC DEBUG_TESTPORT" +
        " DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE" +
        " DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT" +
        " DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED" +
        " EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA" +
        " EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS" +
        " EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED" +
        " FUNCTION_RND FUNCTION_UNQUALIFIED" +
        " MATCHING_DONE MATCHING_MCSUCCESS" +
        " MATCHING_MCUNSUCC MATCHING_MMSUCCESS" +
        " MATCHING_MMUNSUCC MATCHING_PCSUCCESS" +
        " MATCHING_PCUNSUCC MATCHING_PMSUCCESS" +
        " MATCHING_PMUNSUCC MATCHING_PROBLEM" +
        " MATCHING_TIMEOUT MATCHING_UNQUALIFIED" +
        " PARALLEL_PORTCONN PARALLEL_PORTMAP" +
        " PARALLEL_PTC PARALLEL_UNQUALIFIED" +
        " PORTEVENT_DUALRECV PORTEVENT_DUALSEND" +
        " PORTEVENT_MCRECV PORTEVENT_MCSEND" +
        " PORTEVENT_MMRECV PORTEVENT_MMSEND" +
        " PORTEVENT_MQUEUE PORTEVENT_PCIN" +
        " PORTEVENT_PCOUT PORTEVENT_PMIN" +
        " PORTEVENT_PMOUT PORTEVENT_PQUEUE" +
        " PORTEVENT_STATE PORTEVENT_UNQUALIFIED" +
        " STATISTICS_UNQUALIFIED STATISTICS_VERDICT" +
        " TESTCASE_FINISH TESTCASE_START" +
        " TESTCASE_UNQUALIFIED TIMEROP_GUARD" +
        " TIMEROP_READ TIMEROP_START TIMEROP_STOP" +
        " TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED" +
        " USER_UNQUALIFIED VERDICTOP_FINAL" +
        " VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT" +
        " VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED"),
        externalCommands: words("BeginControlPart EndControlPart BeginTestCase" +
        " EndTestCase"),
        multiLineStrings: true
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Turtle(CodeMirror) {
    CodeMirror.defineMode("turtle", function(config) {
      var indentUnit = config.indentUnit;
      var curPunc;

      function wordRegexp(words) {
        return new RegExp("^(?:" + words.join("|") + ")$", "i");
      }
      var ops = wordRegexp([]);
      var keywords = wordRegexp(["@prefix", "@base", "a"]);
      var operatorChars = /[*+\-<>=&|]/;

      function tokenBase(stream, state) {
        var ch = stream.next();
        curPunc = null;
        if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
          stream.match(/^[^\s\u00a0>]*>?/);
          return "atom";
        }
        else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenLiteral(ch);
          return state.tokenize(stream, state);
        }
        else if (/[{}\(\),\.;\[\]]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        else if (ch == "#") {
          stream.skipToEnd();
          return "comment";
        }
        else if (operatorChars.test(ch)) {
          stream.eatWhile(operatorChars);
          return null;
        }
        else if (ch == ":") {
              return "operator";
            } else {
          stream.eatWhile(/[_\w\d]/);
          if(stream.peek() == ":") {
            return "variable-3";
          } else {
                 var word = stream.current();

                 if(keywords.test(word)) {
                            return "meta";
                 }

                 if(ch >= "A" && ch <= "Z") {
                        return "comment";
                     } else {
                            return "keyword";
                     }
          }
          var word = stream.current();
          if (ops.test(word))
            return null;
          else if (keywords.test(word))
            return "meta";
          else
            return "variable";
        }
      }

      function tokenLiteral(quote) {
        return function(stream, state) {
          var escaped = false, ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && ch == "\\";
          }
          return "string";
        };
      }

      function pushContext(state, type, col) {
        state.context = {prev: state.context, indent: state.indent, col: col, type: type};
      }
      function popContext(state) {
        state.indent = state.context.indent;
        state.context = state.context.prev;
      }

      return {
        startState: function() {
          return {tokenize: tokenBase,
                  context: null,
                  indent: 0,
                  col: 0};
        },

        token: function(stream, state) {
          if (stream.sol()) {
            if (state.context && state.context.align == null) state.context.align = false;
            state.indent = stream.indentation();
          }
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);

          if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
            state.context.align = true;
          }

          if (curPunc == "(") pushContext(state, ")", stream.column());
          else if (curPunc == "[") pushContext(state, "]", stream.column());
          else if (curPunc == "{") pushContext(state, "}", stream.column());
          else if (/[\]\}\)]/.test(curPunc)) {
            while (state.context && state.context.type == "pattern") popContext(state);
            if (state.context && curPunc == state.context.type) popContext(state);
          }
          else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
          else if (/atom|string|variable/.test(style) && state.context) {
            if (/[\}\]]/.test(state.context.type))
              pushContext(state, "pattern", stream.column());
            else if (state.context.type == "pattern" && !state.context.align) {
              state.context.align = true;
              state.context.col = stream.column();
            }
          }

          return style;
        },

        indent: function(state, textAfter) {
          var firstChar = textAfter && textAfter.charAt(0);
          var context = state.context;
          if (/[\]\}]/.test(firstChar))
            while (context && context.type == "pattern") context = context.prev;

          var closing = context && firstChar == context.type;
          if (!context)
            return 0;
          else if (context.type == "pattern")
            return context.col;
          else if (context.align)
            return context.col + (closing ? 0 : 1);
          else
            return context.indent + (closing ? 0 : indentUnit);
        },

        lineComment: "#"
      };
    });

    CodeMirror.defineMIME("text/turtle", "turtle");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Twig(CodeMirror) {
      CodeMirror.defineMode("twig:inner", function() {
        var keywords = ["and", "as", "autoescape", "endautoescape", "block", "do", "endblock", "else", "elseif", "extends", "for", "endfor", "embed", "endembed", "filter", "endfilter", "flush", "from", "if", "endif", "in", "is", "include", "import", "not", "or", "set", "spaceless", "endspaceless", "with", "endwith", "trans", "endtrans", "blocktrans", "endblocktrans", "macro", "endmacro", "use", "verbatim", "endverbatim"],
            operator = /^[+\-*&%=<>!?|~^]/,
            sign = /^[:\[\(\{]/,
            atom = ["true", "false", "null", "empty", "defined", "divisibleby", "divisible by", "even", "odd", "iterable", "sameas", "same as"],
            number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

        keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
        atom = new RegExp("((" + atom.join(")|(") + "))\\b");

        function tokenBase (stream, state) {
          var ch = stream.peek();

          //Comment
          if (state.incomment) {
            if (!stream.skipTo("#}")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\#|}/);
              state.incomment = false;
            }
            return "comment";
          //Tag
          } else if (state.intag) {
            //After operator
            if (state.operator) {
              state.operator = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }
            //After sign
            if (state.sign) {
              state.sign = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }

            if (state.instring) {
              if (ch == state.instring) {
                state.instring = false;
              }
              stream.next();
              return "string";
            } else if (ch == "'" || ch == '"') {
              state.instring = ch;
              stream.next();
              return "string";
            } else if (stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
              state.intag = false;
              return "tag";
            } else if (stream.match(operator)) {
              state.operator = true;
              return "operator";
            } else if (stream.match(sign)) {
              state.sign = true;
            } else {
              if (stream.eat(" ") || stream.sol()) {
                if (stream.match(keywords)) {
                  return "keyword";
                }
                if (stream.match(atom)) {
                  return "atom";
                }
                if (stream.match(number)) {
                  return "number";
                }
                if (stream.sol()) {
                  stream.next();
                }
              } else {
                stream.next();
              }

            }
            return "variable";
          } else if (stream.eat("{")) {
            if (stream.eat("#")) {
              state.incomment = true;
              if (!stream.skipTo("#}")) {
                stream.skipToEnd();
              } else {
                stream.eatWhile(/\#|}/);
                state.incomment = false;
              }
              return "comment";
            //Open tag
            } else if (ch = stream.eat(/\{|%/)) {
              //Cache close tag
              state.intag = ch;
              if (ch == "{") {
                state.intag = "}";
              }
              stream.eat("-");
              return "tag";
            }
          }
          stream.next();
        }
        return {
          startState: function () {
            return {};
          },
          token: function (stream, state) {
            return tokenBase(stream, state);
          }
        };
      });

      CodeMirror.defineMode("twig", function(config, parserConfig) {
        var twigInner = CodeMirror.getMode(config, "twig:inner");
        if (!parserConfig || !parserConfig.base) return twigInner;
        return CodeMirror.multiplexingMode(
          CodeMirror.getMode(config, parserConfig.base), {
            open: /\{[{#%]/, close: /[}#%]\}/, mode: twigInner, parseDelimiters: true
          }
        );
      });
      CodeMirror.defineMIME("text/x-twig", "twig");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function VB(CodeMirror) {
    CodeMirror.defineMode("vb", function(conf, parserConf) {
        var ERRORCLASS = 'error';

        function wordRegexp(words) {
            return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/%&\\\\|\\^~<>!]");
        var singleDelimiters = new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
        var doubleOperators = new RegExp("^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))");
        var doubleDelimiters = new RegExp("^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))");
        var tripleDelimiters = new RegExp("^((//=)|(>>=)|(<<=)|(\\*\\*=))");
        var identifiers = new RegExp("^[_A-Za-z][_A-Za-z0-9]*");

        var openingKeywords = ['class','module', 'sub','enum','select','while','if','function',  'get','set','property', 'try'];
        var middleKeywords = ['else','elseif','case', 'catch'];
        var endKeywords = ['next','loop'];

        var operatorKeywords = ['and', 'or', 'not', 'xor', 'in'];
        var wordOperators = wordRegexp(operatorKeywords);
        var commonKeywords = ['as', 'dim', 'break',  'continue','optional', 'then',  'until',
                              'goto', 'byval','byref','new','handles','property', 'return',
                              'const','private', 'protected', 'friend', 'public', 'shared', 'static', 'true','false'];
        var commontypes = ['integer','string','double','decimal','boolean','short','char', 'float','single'];

        var keywords = wordRegexp(commonKeywords);
        var types = wordRegexp(commontypes);
        var stringPrefixes = '"';

        var opening = wordRegexp(openingKeywords);
        var middle = wordRegexp(middleKeywords);
        var closing = wordRegexp(endKeywords);
        var doubleClosing = wordRegexp(['end']);
        var doOpening = wordRegexp(['do']);

        CodeMirror.registerHelper("hintWords", "vb", openingKeywords.concat(middleKeywords).concat(endKeywords)
                                    .concat(operatorKeywords).concat(commonKeywords).concat(commontypes));

        function indent(_stream, state) {
          state.currentIndent++;
        }

        function dedent(_stream, state) {
          state.currentIndent--;
        }
        // tokenizers
        function tokenBase(stream, state) {
            if (stream.eatSpace()) {
                return null;
            }

            var ch = stream.peek();

            // Handle Comments
            if (ch === "'") {
                stream.skipToEnd();
                return 'comment';
            }


            // Handle Number Literals
            if (stream.match(/^((&H)|(&O))?[0-9\.a-f]/i, false)) {
                var floatLiteral = false;
                // Floats
                if (stream.match(/^\d*\.\d+F?/i)) { floatLiteral = true; }
                else if (stream.match(/^\d+\.\d*F?/)) { floatLiteral = true; }
                else if (stream.match(/^\.\d+F?/)) { floatLiteral = true; }

                if (floatLiteral) {
                    // Float literals may be "imaginary"
                    stream.eat(/J/i);
                    return 'number';
                }
                // Integers
                var intLiteral = false;
                // Hex
                if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
                // Octal
                else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
                // Decimal
                else if (stream.match(/^[1-9]\d*F?/)) {
                    // Decimal literals may be "imaginary"
                    stream.eat(/J/i);
                    // TODO - Can you have imaginary longs?
                    intLiteral = true;
                }
                // Zero by itself with no other piece of number.
                else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
                if (intLiteral) {
                    // Integer literals may be "long"
                    stream.eat(/L/i);
                    return 'number';
                }
            }

            // Handle Strings
            if (stream.match(stringPrefixes)) {
                state.tokenize = tokenStringFactory(stream.current());
                return state.tokenize(stream, state);
            }

            // Handle operators and Delimiters
            if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
                return null;
            }
            if (stream.match(doubleOperators)
                || stream.match(singleOperators)
                || stream.match(wordOperators)) {
                return 'operator';
            }
            if (stream.match(singleDelimiters)) {
                return null;
            }
            if (stream.match(doOpening)) {
                indent(stream,state);
                state.doInCurrentLine = true;
                return 'keyword';
            }
            if (stream.match(opening)) {
                if (! state.doInCurrentLine)
                  indent(stream,state);
                else
                  state.doInCurrentLine = false;
                return 'keyword';
            }
            if (stream.match(middle)) {
                return 'keyword';
            }

            if (stream.match(doubleClosing)) {
                dedent(stream,state);
                dedent(stream,state);
                return 'keyword';
            }
            if (stream.match(closing)) {
                dedent(stream,state);
                return 'keyword';
            }

            if (stream.match(types)) {
                return 'keyword';
            }

            if (stream.match(keywords)) {
                return 'keyword';
            }

            if (stream.match(identifiers)) {
                return 'variable';
            }

            // Handle non-detected items
            stream.next();
            return ERRORCLASS;
        }

        function tokenStringFactory(delimiter) {
            var singleline = delimiter.length == 1;
            var OUTCLASS = 'string';

            return function(stream, state) {
                while (!stream.eol()) {
                    stream.eatWhile(/[^'"]/);
                    if (stream.match(delimiter)) {
                        state.tokenize = tokenBase;
                        return OUTCLASS;
                    } else {
                        stream.eat(/['"]/);
                    }
                }
                if (singleline) {
                    if (parserConf.singleLineStringErrors) {
                        return ERRORCLASS;
                    } else {
                        state.tokenize = tokenBase;
                    }
                }
                return OUTCLASS;
            };
        }


        function tokenLexer(stream, state) {
            var style = state.tokenize(stream, state);
            var current = stream.current();

            // Handle '.' connected identifiers
            if (current === '.') {
                style = state.tokenize(stream, state);
                if (style === 'variable') {
                    return 'variable';
                } else {
                    return ERRORCLASS;
                }
            }


            var delimiter_index = '[({'.indexOf(current);
            if (delimiter_index !== -1) {
                indent(stream, state );
            }
            delimiter_index = '])}'.indexOf(current);
            if (delimiter_index !== -1) {
                if (dedent(stream, state)) {
                    return ERRORCLASS;
                }
            }

            return style;
        }

        var external = {
            electricChars:"dDpPtTfFeE ",
            startState: function() {
                return {
                  tokenize: tokenBase,
                  lastToken: null,
                  currentIndent: 0,
                  nextLineIndent: 0,
                  doInCurrentLine: false


              };
            },

            token: function(stream, state) {
                if (stream.sol()) {
                  state.currentIndent += state.nextLineIndent;
                  state.nextLineIndent = 0;
                  state.doInCurrentLine = 0;
                }
                var style = tokenLexer(stream, state);

                state.lastToken = {style:style, content: stream.current()};



                return style;
            },

            indent: function(state, textAfter) {
                var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
                if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
                if(state.currentIndent < 0) return 0;
                return state.currentIndent * conf.indentUnit;
            },

            lineComment: "'"
        };
        return external;
    });

    CodeMirror.defineMIME("text/x-vb", "vb");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    /*
    For extra ASP classic objects, initialize CodeMirror instance with this option:
        isASP: true

    E.G.:
        var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
            lineNumbers: true,
            isASP: true
          });
    */

    function VbScript(CodeMirror) {
    CodeMirror.defineMode("vbscript", function(conf, parserConf) {
        var ERRORCLASS = 'error';

        function wordRegexp(words) {
            return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
        }

        var singleOperators = new RegExp("^[\\+\\-\\*/&\\\\\\^<>=]");
        var doubleOperators = new RegExp("^((<>)|(<=)|(>=))");
        var singleDelimiters = new RegExp('^[\\.,]');
        var brakets = new RegExp('^[\\(\\)]');
        var identifiers = new RegExp("^[A-Za-z][_A-Za-z0-9]*");

        var openingKeywords = ['class','sub','select','while','if','function', 'property', 'with', 'for'];
        var middleKeywords = ['else','elseif','case'];
        var endKeywords = ['next','loop','wend'];

        var wordOperators = wordRegexp(['and', 'or', 'not', 'xor', 'is', 'mod', 'eqv', 'imp']);
        var commonkeywords = ['dim', 'redim', 'then',  'until', 'randomize',
                              'byval','byref','new','property', 'exit', 'in',
                              'const','private', 'public',
                              'get','set','let', 'stop', 'on error resume next', 'on error goto 0', 'option explicit', 'call', 'me'];

        //This list was from: http://msdn.microsoft.com/en-us/library/f8tbc79x(v=vs.84).aspx
        var atomWords = ['true', 'false', 'nothing', 'empty', 'null'];
        //This list was from: http://msdn.microsoft.com/en-us/library/3ca8tfek(v=vs.84).aspx
        var builtinFuncsWords = ['abs', 'array', 'asc', 'atn', 'cbool', 'cbyte', 'ccur', 'cdate', 'cdbl', 'chr', 'cint', 'clng', 'cos', 'csng', 'cstr', 'date', 'dateadd', 'datediff', 'datepart',
                            'dateserial', 'datevalue', 'day', 'escape', 'eval', 'execute', 'exp', 'filter', 'formatcurrency', 'formatdatetime', 'formatnumber', 'formatpercent', 'getlocale', 'getobject',
                            'getref', 'hex', 'hour', 'inputbox', 'instr', 'instrrev', 'int', 'fix', 'isarray', 'isdate', 'isempty', 'isnull', 'isnumeric', 'isobject', 'join', 'lbound', 'lcase', 'left',
                            'len', 'loadpicture', 'log', 'ltrim', 'rtrim', 'trim', 'maths', 'mid', 'minute', 'month', 'monthname', 'msgbox', 'now', 'oct', 'replace', 'rgb', 'right', 'rnd', 'round',
                            'scriptengine', 'scriptenginebuildversion', 'scriptenginemajorversion', 'scriptengineminorversion', 'second', 'setlocale', 'sgn', 'sin', 'space', 'split', 'sqr', 'strcomp',
                            'string', 'strreverse', 'tan', 'time', 'timer', 'timeserial', 'timevalue', 'typename', 'ubound', 'ucase', 'unescape', 'vartype', 'weekday', 'weekdayname', 'year'];

        //This list was from: http://msdn.microsoft.com/en-us/library/ydz4cfk3(v=vs.84).aspx
        var builtinConsts = ['vbBlack', 'vbRed', 'vbGreen', 'vbYellow', 'vbBlue', 'vbMagenta', 'vbCyan', 'vbWhite', 'vbBinaryCompare', 'vbTextCompare',
                             'vbSunday', 'vbMonday', 'vbTuesday', 'vbWednesday', 'vbThursday', 'vbFriday', 'vbSaturday', 'vbUseSystemDayOfWeek', 'vbFirstJan1', 'vbFirstFourDays', 'vbFirstFullWeek',
                             'vbGeneralDate', 'vbLongDate', 'vbShortDate', 'vbLongTime', 'vbShortTime', 'vbObjectError',
                             'vbOKOnly', 'vbOKCancel', 'vbAbortRetryIgnore', 'vbYesNoCancel', 'vbYesNo', 'vbRetryCancel', 'vbCritical', 'vbQuestion', 'vbExclamation', 'vbInformation', 'vbDefaultButton1', 'vbDefaultButton2',
                             'vbDefaultButton3', 'vbDefaultButton4', 'vbApplicationModal', 'vbSystemModal', 'vbOK', 'vbCancel', 'vbAbort', 'vbRetry', 'vbIgnore', 'vbYes', 'vbNo',
                             'vbCr', 'VbCrLf', 'vbFormFeed', 'vbLf', 'vbNewLine', 'vbNullChar', 'vbNullString', 'vbTab', 'vbVerticalTab', 'vbUseDefault', 'vbTrue', 'vbFalse',
                             'vbEmpty', 'vbNull', 'vbInteger', 'vbLong', 'vbSingle', 'vbDouble', 'vbCurrency', 'vbDate', 'vbString', 'vbObject', 'vbError', 'vbBoolean', 'vbVariant', 'vbDataObject', 'vbDecimal', 'vbByte', 'vbArray'];
        //This list was from: http://msdn.microsoft.com/en-us/library/hkc375ea(v=vs.84).aspx
        var builtinObjsWords = ['WScript', 'err', 'debug', 'RegExp'];
        var knownProperties = ['description', 'firstindex', 'global', 'helpcontext', 'helpfile', 'ignorecase', 'length', 'number', 'pattern', 'source', 'value', 'count'];
        var knownMethods = ['clear', 'execute', 'raise', 'replace', 'test', 'write', 'writeline', 'close', 'open', 'state', 'eof', 'update', 'addnew', 'end', 'createobject', 'quit'];

        var aspBuiltinObjsWords = ['server', 'response', 'request', 'session', 'application'];
        var aspKnownProperties = ['buffer', 'cachecontrol', 'charset', 'contenttype', 'expires', 'expiresabsolute', 'isclientconnected', 'pics', 'status', //response
                                  'clientcertificate', 'cookies', 'form', 'querystring', 'servervariables', 'totalbytes', //request
                                  'contents', 'staticobjects', //application
                                  'codepage', 'lcid', 'sessionid', 'timeout', //session
                                  'scripttimeout']; //server
        var aspKnownMethods = ['addheader', 'appendtolog', 'binarywrite', 'end', 'flush', 'redirect', //response
                               'binaryread', //request
                               'remove', 'removeall', 'lock', 'unlock', //application
                               'abandon', //session
                               'getlasterror', 'htmlencode', 'mappath', 'transfer', 'urlencode']; //server

        var knownWords = knownMethods.concat(knownProperties);

        builtinObjsWords = builtinObjsWords.concat(builtinConsts);

        if (conf.isASP){
            builtinObjsWords = builtinObjsWords.concat(aspBuiltinObjsWords);
            knownWords = knownWords.concat(aspKnownMethods, aspKnownProperties);
        }
        var keywords = wordRegexp(commonkeywords);
        var atoms = wordRegexp(atomWords);
        var builtinFuncs = wordRegexp(builtinFuncsWords);
        var builtinObjs = wordRegexp(builtinObjsWords);
        var known = wordRegexp(knownWords);
        var stringPrefixes = '"';

        var opening = wordRegexp(openingKeywords);
        var middle = wordRegexp(middleKeywords);
        var closing = wordRegexp(endKeywords);
        var doubleClosing = wordRegexp(['end']);
        var doOpening = wordRegexp(['do']);
        var noIndentWords = wordRegexp(['on error resume next', 'exit']);
        var comment = wordRegexp(['rem']);


        function indent(_stream, state) {
          state.currentIndent++;
        }

        function dedent(_stream, state) {
          state.currentIndent--;
        }
        // tokenizers
        function tokenBase(stream, state) {
            if (stream.eatSpace()) {
                return 'space';
                //return null;
            }

            var ch = stream.peek();

            // Handle Comments
            if (ch === "'") {
                stream.skipToEnd();
                return 'comment';
            }
            if (stream.match(comment)){
                stream.skipToEnd();
                return 'comment';
            }


            // Handle Number Literals
            if (stream.match(/^((&H)|(&O))?[0-9\.]/i, false) && !stream.match(/^((&H)|(&O))?[0-9\.]+[a-z_]/i, false)) {
                var floatLiteral = false;
                // Floats
                if (stream.match(/^\d*\.\d+/i)) { floatLiteral = true; }
                else if (stream.match(/^\d+\.\d*/)) { floatLiteral = true; }
                else if (stream.match(/^\.\d+/)) { floatLiteral = true; }

                if (floatLiteral) {
                    // Float literals may be "imaginary"
                    stream.eat(/J/i);
                    return 'number';
                }
                // Integers
                var intLiteral = false;
                // Hex
                if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
                // Octal
                else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
                // Decimal
                else if (stream.match(/^[1-9]\d*F?/)) {
                    // Decimal literals may be "imaginary"
                    stream.eat(/J/i);
                    // TODO - Can you have imaginary longs?
                    intLiteral = true;
                }
                // Zero by itself with no other piece of number.
                else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
                if (intLiteral) {
                    // Integer literals may be "long"
                    stream.eat(/L/i);
                    return 'number';
                }
            }

            // Handle Strings
            if (stream.match(stringPrefixes)) {
                state.tokenize = tokenStringFactory(stream.current());
                return state.tokenize(stream, state);
            }

            // Handle operators and Delimiters
            if (stream.match(doubleOperators)
                || stream.match(singleOperators)
                || stream.match(wordOperators)) {
                return 'operator';
            }
            if (stream.match(singleDelimiters)) {
                return null;
            }

            if (stream.match(brakets)) {
                return "bracket";
            }

            if (stream.match(noIndentWords)) {
                state.doInCurrentLine = true;

                return 'keyword';
            }

            if (stream.match(doOpening)) {
                indent(stream,state);
                state.doInCurrentLine = true;

                return 'keyword';
            }
            if (stream.match(opening)) {
                if (! state.doInCurrentLine)
                  indent(stream,state);
                else
                  state.doInCurrentLine = false;

                return 'keyword';
            }
            if (stream.match(middle)) {
                return 'keyword';
            }


            if (stream.match(doubleClosing)) {
                dedent(stream,state);
                dedent(stream,state);

                return 'keyword';
            }
            if (stream.match(closing)) {
                if (! state.doInCurrentLine)
                  dedent(stream,state);
                else
                  state.doInCurrentLine = false;

                return 'keyword';
            }

            if (stream.match(keywords)) {
                return 'keyword';
            }

            if (stream.match(atoms)) {
                return 'atom';
            }

            if (stream.match(known)) {
                return 'variable-2';
            }

            if (stream.match(builtinFuncs)) {
                return 'builtin';
            }

            if (stream.match(builtinObjs)){
                return 'variable-2';
            }

            if (stream.match(identifiers)) {
                return 'variable';
            }

            // Handle non-detected items
            stream.next();
            return ERRORCLASS;
        }

        function tokenStringFactory(delimiter) {
            var singleline = delimiter.length == 1;
            var OUTCLASS = 'string';

            return function(stream, state) {
                while (!stream.eol()) {
                    stream.eatWhile(/[^'"]/);
                    if (stream.match(delimiter)) {
                        state.tokenize = tokenBase;
                        return OUTCLASS;
                    } else {
                        stream.eat(/['"]/);
                    }
                }
                if (singleline) {
                    if (parserConf.singleLineStringErrors) {
                        return ERRORCLASS;
                    } else {
                        state.tokenize = tokenBase;
                    }
                }
                return OUTCLASS;
            };
        }


        function tokenLexer(stream, state) {
            var style = state.tokenize(stream, state);
            var current = stream.current();

            // Handle '.' connected identifiers
            if (current === '.') {
                style = state.tokenize(stream, state);

                current = stream.current();
                if (style && (style.substr(0, 8) === 'variable' || style==='builtin' || style==='keyword')){//|| knownWords.indexOf(current.substring(1)) > -1) {
                    if (style === 'builtin' || style === 'keyword') style='variable';
                    if (knownWords.indexOf(current.substr(1)) > -1) style='variable-2';

                    return style;
                } else {
                    return ERRORCLASS;
                }
            }

            return style;
        }

        var external = {
            electricChars:"dDpPtTfFeE ",
            startState: function() {
                return {
                  tokenize: tokenBase,
                  lastToken: null,
                  currentIndent: 0,
                  nextLineIndent: 0,
                  doInCurrentLine: false,
                  ignoreKeyword: false


              };
            },

            token: function(stream, state) {
                if (stream.sol()) {
                  state.currentIndent += state.nextLineIndent;
                  state.nextLineIndent = 0;
                  state.doInCurrentLine = 0;
                }
                var style = tokenLexer(stream, state);

                state.lastToken = {style:style, content: stream.current()};

                if (style==='space') style=null;

                return style;
            },

            indent: function(state, textAfter) {
                var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
                if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
                if(state.currentIndent < 0) return 0;
                return state.currentIndent * conf.indentUnit;
            }

        };
        return external;
    });

    CodeMirror.defineMIME("text/vbscript", "vbscript");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Velocity(CodeMirror) {
    CodeMirror.defineMode("velocity", function() {
        function parseWords(str) {
            var obj = {}, words = str.split(" ");
            for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
            return obj;
        }

        var keywords = parseWords("#end #else #break #stop #[[ #]] " +
                                  "#{end} #{else} #{break} #{stop}");
        var functions = parseWords("#if #elseif #foreach #set #include #parse #macro #define #evaluate " +
                                   "#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}");
        var specials = parseWords("$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent");
        var isOperatorChar = /[+\-*&%=<>!?:\/|]/;

        function chain(stream, state, f) {
            state.tokenize = f;
            return f(stream, state);
        }
        function tokenBase(stream, state) {
            var beforeParams = state.beforeParams;
            state.beforeParams = false;
            var ch = stream.next();
            // start of unparsed string?
            if ((ch == "'") && !state.inString && state.inParams) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenString(ch));
            }
            // start of parsed string?
            else if ((ch == '"')) {
                state.lastTokenWasBuiltin = false;
                if (state.inString) {
                    state.inString = false;
                    return "string";
                }
                else if (state.inParams)
                    return chain(stream, state, tokenString(ch));
            }
            // is it one of the special signs []{}().,;? Seperator?
            else if (/[\[\]{}\(\),;\.]/.test(ch)) {
                if (ch == "(" && beforeParams)
                    state.inParams = true;
                else if (ch == ")") {
                    state.inParams = false;
                    state.lastTokenWasBuiltin = true;
                }
                return null;
            }
            // start of a number value?
            else if (/\d/.test(ch)) {
                state.lastTokenWasBuiltin = false;
                stream.eatWhile(/[\w\.]/);
                return "number";
            }
            // multi line comment?
            else if (ch == "#" && stream.eat("*")) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenComment);
            }
            // unparsed content?
            else if (ch == "#" && stream.match(/ *\[ *\[/)) {
                state.lastTokenWasBuiltin = false;
                return chain(stream, state, tokenUnparsed);
            }
            // single line comment?
            else if (ch == "#" && stream.eat("#")) {
                state.lastTokenWasBuiltin = false;
                stream.skipToEnd();
                return "comment";
            }
            // variable?
            else if (ch == "$") {
                stream.eatWhile(/[\w\d\$_\.{}-]/);
                // is it one of the specials?
                if (specials && specials.propertyIsEnumerable(stream.current())) {
                    return "keyword";
                }
                else {
                    state.lastTokenWasBuiltin = true;
                    state.beforeParams = true;
                    return "builtin";
                }
            }
            // is it a operator?
            else if (isOperatorChar.test(ch)) {
                state.lastTokenWasBuiltin = false;
                stream.eatWhile(isOperatorChar);
                return "operator";
            }
            else {
                // get the whole word
                stream.eatWhile(/[\w\$_{}@]/);
                var word = stream.current();
                // is it one of the listed keywords?
                if (keywords && keywords.propertyIsEnumerable(word))
                    return "keyword";
                // is it one of the listed functions?
                if (functions && functions.propertyIsEnumerable(word) ||
                        (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()=="(") &&
                         !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {
                    state.beforeParams = true;
                    state.lastTokenWasBuiltin = false;
                    return "keyword";
                }
                if (state.inString) {
                    state.lastTokenWasBuiltin = false;
                    return "string";
                }
                if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)=="." && state.lastTokenWasBuiltin)
                    return "builtin";
                // default: just a "word"
                state.lastTokenWasBuiltin = false;
                return null;
            }
        }

        function tokenString(quote) {
            return function(stream, state) {
                var escaped = false, next, end = false;
                while ((next = stream.next()) != null) {
                    if ((next == quote) && !escaped) {
                        end = true;
                        break;
                    }
                    if (quote=='"' && stream.peek() == '$' && !escaped) {
                        state.inString = true;
                        end = true;
                        break;
                    }
                    escaped = !escaped && next == "\\";
                }
                if (end) state.tokenize = tokenBase;
                return "string";
            };
        }

        function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
                if (ch == "#" && maybeEnd) {
                    state.tokenize = tokenBase;
                    break;
                }
                maybeEnd = (ch == "*");
            }
            return "comment";
        }

        function tokenUnparsed(stream, state) {
            var maybeEnd = 0, ch;
            while (ch = stream.next()) {
                if (ch == "#" && maybeEnd == 2) {
                    state.tokenize = tokenBase;
                    break;
                }
                if (ch == "]")
                    maybeEnd++;
                else if (ch != " ")
                    maybeEnd = 0;
            }
            return "meta";
        }
        // Interface

        return {
            startState: function() {
                return {
                    tokenize: tokenBase,
                    beforeParams: false,
                    inParams: false,
                    inString: false,
                    lastTokenWasBuiltin: false
                };
            },

            token: function(stream, state) {
                if (stream.eatSpace()) return null;
                return state.tokenize(stream, state);
            },
            blockCommentStart: "#*",
            blockCommentEnd: "*#",
            lineComment: "##",
            fold: "velocity"
        };
    });

    CodeMirror.defineMIME("text/velocity", "velocity");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Verilog(CodeMirror) {
    CodeMirror.defineMode("verilog", function(config, parserConfig) {

      var indentUnit = config.indentUnit,
          statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
          dontAlignCalls = parserConfig.dontAlignCalls,
          noIndentKeywords = parserConfig.noIndentKeywords || [],
          multiLineStrings = parserConfig.multiLineStrings,
          hooks = parserConfig.hooks || {};

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      /**
       * Keywords from IEEE 1800-2012
       */
      var keywords = words(
        "accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind " +
        "bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config " +
        "const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable " +
        "dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup " +
        "endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask " +
        "enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin " +
        "function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import " +
        "incdir include initial inout input inside instance int integer interconnect interface intersect join join_any " +
        "join_none large let liblist library local localparam logic longint macromodule matches medium modport module " +
        "nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed " +
        "parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup " +
        "pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg " +
        "reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime " +
        "s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify " +
        "specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on " +
        "table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior " +
        "trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void " +
        "wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor");

      /** Operators from IEEE 1800-2012
         unary_operator ::=
           + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
         binary_operator ::=
           + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **
           | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<
           | -> | <->
         inc_or_dec_operator ::= ++ | --
         unary_module_path_operator ::=
           ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
         binary_module_path_operator ::=
           == | != | && | || | & | | | ^ | ^~ | ~^
      */
      var isOperatorChar = /[\+\-\*\/!~&|^%=?:]/;
      var isBracketChar = /[\[\]{}()]/;

      var unsignedNumber = /\d[0-9_]*/;
      var decimalLiteral = /\d*\s*'s?d\s*\d[0-9_]*/i;
      var binaryLiteral = /\d*\s*'s?b\s*[xz01][xz01_]*/i;
      var octLiteral = /\d*\s*'s?o\s*[xz0-7][xz0-7_]*/i;
      var hexLiteral = /\d*\s*'s?h\s*[0-9a-fxz?][0-9a-fxz?_]*/i;
      var realLiteral = /(\d[\d_]*(\.\d[\d_]*)?E-?[\d_]+)|(\d[\d_]*\.\d[\d_]*)/i;

      var closingBracketOrWord = /^((\w+)|[)}\]])/;
      var closingBracket = /[)}\]]/;

      var curPunc;
      var curKeyword;

      // Block openings which are closed by a matching keyword in the form of ("end" + keyword)
      // E.g. "task" => "endtask"
      var blockKeywords = words(
        "case checker class clocking config function generate interface module package " +
        "primitive program property specify sequence table task"
      );

      // Opening/closing pairs
      var openClose = {};
      for (var keyword in blockKeywords) {
        openClose[keyword] = "end" + keyword;
      }
      openClose["begin"] = "end";
      openClose["casex"] = "endcase";
      openClose["casez"] = "endcase";
      openClose["do"   ] = "while";
      openClose["fork" ] = "join;join_any;join_none";
      openClose["covergroup"] = "endgroup";

      for (var i in noIndentKeywords) {
        var keyword = noIndentKeywords[i];
        if (openClose[keyword]) {
          openClose[keyword] = undefined;
        }
      }

      // Keywords which open statements that are ended with a semi-colon
      var statementKeywords = words("always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while");

      function tokenBase(stream, state) {
        var ch = stream.peek(), style;
        if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;
        if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)
          return style;

        if (/[,;:\.]/.test(ch)) {
          curPunc = stream.next();
          return null;
        }
        if (isBracketChar.test(ch)) {
          curPunc = stream.next();
          return "bracket";
        }
        // Macros (tick-defines)
        if (ch == '`') {
          stream.next();
          if (stream.eatWhile(/[\w\$_]/)) {
            return "def";
          } else {
            return null;
          }
        }
        // System calls
        if (ch == '$') {
          stream.next();
          if (stream.eatWhile(/[\w\$_]/)) {
            return "meta";
          } else {
            return null;
          }
        }
        // Time literals
        if (ch == '#') {
          stream.next();
          stream.eatWhile(/[\d_.]/);
          return "def";
        }
        // Strings
        if (ch == '"') {
          stream.next();
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        // Comments
        if (ch == "/") {
          stream.next();
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
          stream.backUp(1);
        }

        // Numeric literals
        if (stream.match(realLiteral) ||
            stream.match(decimalLiteral) ||
            stream.match(binaryLiteral) ||
            stream.match(octLiteral) ||
            stream.match(hexLiteral) ||
            stream.match(unsignedNumber) ||
            stream.match(realLiteral)) {
          return "number";
        }

        // Operators
        if (stream.eatWhile(isOperatorChar)) {
          return "meta";
        }

        // Keywords / plain variables
        if (stream.eatWhile(/[\w\$_]/)) {
          var cur = stream.current();
          if (keywords[cur]) {
            if (openClose[cur]) {
              curPunc = "newblock";
            }
            if (statementKeywords[cur]) {
              curPunc = "newstatement";
            }
            curKeyword = cur;
            return "keyword";
          }
          return "variable";
        }

        stream.next();
        return null;
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "\\";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string";
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = (ch == "*");
        }
        return "comment";
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        var indent = state.indented;
        var c = new Context(indent, col, type, null, state.context);
        return state.context = c;
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}") {
          state.indented = state.context.indented;
        }
        return state.context = state.context.prev;
      }

      function isClosing(text, contextClosing) {
        if (text == contextClosing) {
          return true;
        } else {
          // contextClosing may be multiple keywords separated by ;
          var closingKeywords = contextClosing.split(";");
          for (var i in closingKeywords) {
            if (text == closingKeywords[i]) {
              return true;
            }
          }
          return false;
        }
      }

      function buildElectricInputRegEx() {
        // Reindentation should occur on any bracket char: {}()[]
        // or on a match of any of the block closing keywords, at
        // the end of a line
        var allClosings = [];
        for (var i in openClose) {
          if (openClose[i]) {
            var closings = openClose[i].split(";");
            for (var j in closings) {
              allClosings.push(closings[j]);
            }
          }
        }
        var re = new RegExp("[{}()\\[\\]]|(" + allClosings.join("|") + ")$");
        return re;
      }

      // Interface
      return {

        // Regex to force current line to reindent
        electricInput: buildElectricInputRegEx(),

        startState: function(basecolumn) {
          var state = {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
          if (hooks.startState) hooks.startState(state);
          return state;
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (hooks.token) {
            // Call hook, with an optional return value of a style to override verilog styling.
            var style = hooks.token(stream, state);
            if (style !== undefined) {
              return style;
            }
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          curKeyword = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta" || style == "variable") return style;
          if (ctx.align == null) ctx.align = true;

          if (curPunc == ctx.type) {
            popContext(state);
          } else if ((curPunc == ";" && ctx.type == "statement") ||
                   (ctx.type && isClosing(curKeyword, ctx.type))) {
            ctx = popContext(state);
            while (ctx && ctx.type == "statement") ctx = popContext(state);
          } else if (curPunc == "{") {
            pushContext(state, stream.column(), "}");
          } else if (curPunc == "[") {
            pushContext(state, stream.column(), "]");
          } else if (curPunc == "(") {
            pushContext(state, stream.column(), ")");
          } else if (ctx && ctx.type == "endcase" && curPunc == ":") {
            pushContext(state, stream.column(), "statement");
          } else if (curPunc == "newstatement") {
            pushContext(state, stream.column(), "statement");
          } else if (curPunc == "newblock") {
            if (curKeyword == "function" && ctx && (ctx.type == "statement" || ctx.type == "endgroup")) ; else if (curKeyword == "task" && ctx && ctx.type == "statement") ; else {
              var close = openClose[curKeyword];
              pushContext(state, stream.column(), close);
            }
          }

          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
          if (hooks.indent) {
            var fromHook = hooks.indent(state);
            if (fromHook >= 0) return fromHook;
          }
          var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
          if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
          var closing = false;
          var possibleClosing = textAfter.match(closingBracketOrWord);
          if (possibleClosing)
            closing = isClosing(possibleClosing[0], ctx.type);
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
          else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);
          else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

      CodeMirror.defineMIME("text/x-verilog", {
        name: "verilog"
      });

      CodeMirror.defineMIME("text/x-systemverilog", {
        name: "verilog"
      });



      // TL-Verilog mode.
      // See tl-x.org for language spec.
      // See the mode in action at makerchip.com.
      // Contact: steve.hoover@redwoodeda.com

      // TLV Identifier prefixes.
      // Note that sign is not treated separately, so "+/-" versions of numeric identifiers
      // are included.
      var tlvIdentifierStyle = {
        "|": "link",
        ">": "property",  // Should condition this off for > TLV 1c.
        "$": "variable",
        "$$": "variable",
        "?$": "qualifier",
        "?*": "qualifier",
        "-": "hr",
        "/": "property",
        "/-": "property",
        "@": "variable-3",
        "@-": "variable-3",
        "@++": "variable-3",
        "@+=": "variable-3",
        "@+=-": "variable-3",
        "@--": "variable-3",
        "@-=": "variable-3",
        "%+": "tag",
        "%-": "tag",
        "%": "tag",
        ">>": "tag",
        "<<": "tag",
        "<>": "tag",
        "#": "tag",  // Need to choose a style for this.
        "^": "attribute",
        "^^": "attribute",
        "^!": "attribute",
        "*": "variable-2",
        "**": "variable-2",
        "\\": "keyword",
        "\"": "comment"
      };

      // Lines starting with these characters define scope (result in indentation).
      var tlvScopePrefixChars = {
        "/": "beh-hier",
        ">": "beh-hier",
        "-": "phys-hier",
        "|": "pipe",
        "?": "when",
        "@": "stage",
        "\\": "keyword"
      };
      var tlvIndentUnit = 3;
      var tlvIdentMatch = /^([~!@#\$%\^&\*-\+=\?\/\\\|'"<>]+)([\d\w_]*)/;  // Matches an identifiere.
      // Note that ':' is excluded, because of it's use in [:].
      var tlvFirstLevelIndentMatch = /^[! ]  /;
      var tlvLineIndentationMatch = /^[! ] */;
      var tlvCommentMatch = /^\/[\/\*]/;


      // Returns a style specific to the scope at the given indentation column.
      // Type is one of: "indent", "scope-ident", "before-scope-ident".
      function tlvScopeStyle(state, indentation, type) {
        // Begin scope.
        var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.
        return "tlv-" + state.tlvIndentationStyle[depth] + "-" + type;
      }

      // Return true if the next thing in the stream is an identifier with a mnemonic.
      function tlvIdentNext(stream) {
        var match;
        return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;
      }

      CodeMirror.defineMIME("text/x-tlv", {
        name: "verilog",

        hooks: {

          electricInput: false,


          // Return undefined for verilog tokenizing, or style for TLV token (null not used).
          // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting
          // can be enabled with the definition of cm-tlv-* styles, including highlighting for:
          //   - M4 tokens
          //   - TLV scope indentation
          //   - Statement delimitation (enabled by tlvTrackStatements)
          token: function(stream, state) {
            var style = undefined;
            var match;  // Return value of pattern matches.

            // Set highlighting mode based on code region (TLV or SV).
            if (stream.sol() && ! state.tlvInBlockComment) {
              // Process region.
              if (stream.peek() == '\\') {
                style = "def";
                stream.skipToEnd();
                if (stream.string.match(/\\SV/)) {
                  state.tlvCodeActive = false;
                } else if (stream.string.match(/\\TLV/)){
                  state.tlvCodeActive = true;
                }
              }
              // Correct indentation in the face of a line prefix char.
              if (state.tlvCodeActive && stream.pos == 0 &&
                  (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {
                state.indented = match[0].length;
              }

              // Compute indentation state:
              //   o Auto indentation on next line
              //   o Indentation scope styles
              var indented = state.indented;
              var depth = indented / tlvIndentUnit;
              if (depth <= state.tlvIndentationStyle.length) {
                // not deeper than current scope

                var blankline = stream.string.length == indented;
                var chPos = depth * tlvIndentUnit;
                if (chPos < stream.string.length) {
                  var bodyString = stream.string.slice(chPos);
                  var ch = bodyString[0];
                  if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&
                      tlvIdentifierStyle[match[1]])) {
                    // This line begins scope.
                    // Next line gets indented one level.
                    indented += tlvIndentUnit;
                    // Style the next level of indentation (except non-region keyword identifiers,
                    //   which are statements themselves)
                    if (!(ch == "\\" && chPos > 0)) {
                      state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];
                      depth++;
                    }
                  }
                }
                // Clear out deeper indentation levels unless line is blank.
                if (!blankline) {
                  while (state.tlvIndentationStyle.length > depth) {
                    state.tlvIndentationStyle.pop();
                  }
                }
              }
              // Set next level of indentation.
              state.tlvNextIndent = indented;
            }

            if (state.tlvCodeActive) {
              // Highlight as TLV.

              var beginStatement = false;

              var match;
              if (style !== undefined) {
                // Region line.
                style += " " + tlvScopeStyle(state, 0, "scope-ident");
              } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&
                         (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {
                // Indentation
                style = // make this style distinct from the previous one to prevent
                        // codemirror from combining spans
                        "tlv-indent-" + (((stream.pos % 2) == 0) ? "even" : "odd") +
                        // and style it
                        " " + tlvScopeStyle(state, stream.pos - tlvIndentUnit, "indent");
                // Style the line prefix character.
                if (match[0].charAt(0) == "!") {
                  style += " tlv-alert-line-prefix";
                }
                // Place a class before a scope identifier.
                if (tlvIdentNext(stream)) {
                  style += " " + tlvScopeStyle(state, stream.pos, "before-scope-ident");
                }
              } else if (state.tlvInBlockComment) {
                // In a block comment.
                if (stream.match(/^.*?\*\//)) {
                  // Exit block comment.
                  state.tlvInBlockComment = false;
                } else {
                  stream.skipToEnd();
                }
                style = "comment";
              } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {
                // Start comment.
                if (match[0] == "//") {
                  // Line comment.
                  stream.skipToEnd();
                } else {
                  // Block comment.
                  state.tlvInBlockComment = true;
                }
                style = "comment";
              } else if (match = stream.match(tlvIdentMatch)) {
                // looks like an identifier (or identifier prefix)
                var prefix = match[1];
                var mnemonic = match[2];
                if (// is identifier prefix
                    tlvIdentifierStyle.hasOwnProperty(prefix) &&
                    // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)
                    (mnemonic.length > 0 || stream.eol())) {
                  style = tlvIdentifierStyle[prefix];
                  if (stream.column() == state.indented) {
                    // Begin scope.
                    style += " " + tlvScopeStyle(state, stream.column(), "scope-ident");
                  }
                } else {
                  // Just swallow one character and try again.
                  // This enables subsequent identifier match with preceding symbol character, which
                  //   is legal within a statement.  (Eg, !$reset).  It also enables detection of
                  //   comment start with preceding symbols.
                  stream.backUp(stream.current().length - 1);
                  style = "tlv-default";
                }
              } else if (stream.match(/^\t+/)) {
                // Highlight tabs, which are illegal.
                style = "tlv-tab";
              } else if (stream.match(/^[\[\]{}\(\);\:]+/)) {
                // [:], (), {}, ;.
                style = "meta";
              } else if (match = stream.match(/^[mM]4([\+_])?[\w\d_]*/)) {
                // m4 pre proc
                style = (match[1] == "+") ? "tlv-m4-plus" : "tlv-m4";
              } else if (stream.match(/^ +/)){
                // Skip over spaces.
                if (stream.eol()) {
                  // Trailing spaces.
                  style = "error";
                } else {
                  // Non-trailing spaces.
                  style = "tlv-default";
                }
              } else if (stream.match(/^[\w\d_]+/)) {
                // alpha-numeric token.
                style = "number";
              } else {
                // Eat the next char w/ no formatting.
                stream.next();
                style = "tlv-default";
              }
              if (beginStatement) {
                style += " tlv-statement";
              }
            } else {
              if (stream.match(/^[mM]4([\w\d_]*)/)) {
                // m4 pre proc
                style = "tlv-m4";
              }
            }
            return style;
          },

          indent: function(state) {
            return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;
          },

          startState: function(state) {
            state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.
            state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).
            state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.
            state.tlvInBlockComment = false;  // True inside /**/ comment.
          }

        }
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Originally written by Alf Nielsen, re-written by Michael Zhou
    function VHDL(CodeMirror) {
    function words(str) {
      var obj = {}, words = str.split(",");
      for (var i = 0; i < words.length; ++i) {
        var allCaps = words[i].toUpperCase();
        var firstCap = words[i].charAt(0).toUpperCase() + words[i].slice(1);
        obj[words[i]] = true;
        obj[allCaps] = true;
        obj[firstCap] = true;
      }
      return obj;
    }

    function metaHook(stream) {
      stream.eatWhile(/[\w\$_]/);
      return "meta";
    }

    CodeMirror.defineMode("vhdl", function(config, parserConfig) {
      var indentUnit = config.indentUnit,
          atoms = parserConfig.atoms || words("null"),
          hooks = parserConfig.hooks || {"`": metaHook, "$": metaHook},
          multiLineStrings = parserConfig.multiLineStrings;

      var keywords = words("abs,access,after,alias,all,and,architecture,array,assert,attribute,begin,block," +
          "body,buffer,bus,case,component,configuration,constant,disconnect,downto,else,elsif,end,end block,end case," +
          "end component,end for,end generate,end if,end loop,end process,end record,end units,entity,exit,file,for," +
          "function,generate,generic,generic map,group,guarded,if,impure,in,inertial,inout,is,label,library,linkage," +
          "literal,loop,map,mod,nand,new,next,nor,null,of,on,open,or,others,out,package,package body,port,port map," +
          "postponed,procedure,process,pure,range,record,register,reject,rem,report,return,rol,ror,select,severity,signal," +
          "sla,sll,sra,srl,subtype,then,to,transport,type,unaffected,units,until,use,variable,wait,when,while,with,xnor,xor");

      var blockKeywords = words("architecture,entity,begin,case,port,else,elsif,end,for,function,if");

      var isOperatorChar = /[&|~><!\)\(*#%@+\/=?\:;}{,\.\^\-\[\]]/;
      var curPunc;

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == '"') {
          state.tokenize = tokenString2(ch);
          return state.tokenize(stream, state);
        }
        if (ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          curPunc = ch;
          return null;
        }
        if (/[\d']/.test(ch)) {
          stream.eatWhile(/[\w\.']/);
          return "number";
        }
        if (ch == "-") {
          if (stream.eat("-")) {
            stream.skipToEnd();
            return "comment";
          }
        }
        if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur.toLowerCase())) {
          if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
          return "keyword";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
      }

      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "--";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string";
        };
      }
      function tokenString2(quote) {
        return function(stream, state) {
          var escaped = false, next, end = false;
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped) {end = true; break;}
            escaped = !escaped && next == "--";
          }
          if (end || !(escaped || multiLineStrings))
            state.tokenize = tokenBase;
          return "string-2";
        };
      }

      function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
      }
      function pushContext(state, col, type) {
        return state.context = new Context(state.indented, col, type, null, state.context);
      }
      function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
          state.indented = state.context.indented;
        return state.context = state.context.prev;
      }

      // Interface
      return {
        startState: function(basecolumn) {
          return {
            tokenize: null,
            context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
            indented: 0,
            startOfLine: true
          };
        },

        token: function(stream, state) {
          var ctx = state.context;
          if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
          }
          if (stream.eatSpace()) return null;
          curPunc = null;
          var style = (state.tokenize || tokenBase)(stream, state);
          if (style == "comment" || style == "meta") return style;
          if (ctx.align == null) ctx.align = true;

          if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
          else if (curPunc == "{") pushContext(state, stream.column(), "}");
          else if (curPunc == "[") pushContext(state, stream.column(), "]");
          else if (curPunc == "(") pushContext(state, stream.column(), ")");
          else if (curPunc == "}") {
            while (ctx.type == "statement") ctx = popContext(state);
            if (ctx.type == "}") ctx = popContext(state);
            while (ctx.type == "statement") ctx = popContext(state);
          }
          else if (curPunc == ctx.type) popContext(state);
          else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
            pushContext(state, stream.column(), "statement");
          state.startOfLine = false;
          return style;
        },

        indent: function(state, textAfter) {
          if (state.tokenize != tokenBase && state.tokenize != null) return 0;
          var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
          if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
          else if (ctx.align) return ctx.column + (closing ? 0 : 1);
          else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}"
      };
    });

    CodeMirror.defineMIME("text/x-vhdl", "vhdl");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Vue(CodeMirror) {
      var tagLanguages = {
        script: [
          ["lang", /coffee(script)?/, "coffeescript"],
          ["type", /^(?:text|application)\/(?:x-)?coffee(?:script)?$/, "coffeescript"],
          ["lang", /^babel$/, "javascript"],
          ["type", /^text\/babel$/, "javascript"],
          ["type", /^text\/ecmascript-\d+$/, "javascript"]
        ],
        style: [
          ["lang", /^stylus$/i, "stylus"],
          ["lang", /^sass$/i, "sass"],
          ["lang", /^less$/i, "text/x-less"],
          ["lang", /^scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?styl(us)?$/i, "stylus"],
          ["type", /^text\/sass/i, "sass"],
          ["type", /^(text\/)?(x-)?scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?less$/i, "text/x-less"]
        ],
        template: [
          ["lang", /^vue-template$/i, "vue"],
          ["lang", /^pug$/i, "pug"],
          ["lang", /^handlebars$/i, "handlebars"],
          ["type", /^(text\/)?(x-)?pug$/i, "pug"],
          ["type", /^text\/x-handlebars-template$/i, "handlebars"],
          [null, null, "vue-template"]
        ]
      };

      CodeMirror.defineMode("vue-template", function (config, parserConfig) {
        var mustacheOverlay = {
          token: function (stream) {
            if (stream.match(/^\{\{.*?\}\}/)) return "meta mustache";
            while (stream.next() && !stream.match("{{", false)) {}
            return null;
          }
        };
        return CodeMirror.overlayMode(CodeMirror.getMode(config, parserConfig.backdrop || "text/html"), mustacheOverlay);
      });

      CodeMirror.defineMode("vue", function (config) {
        return CodeMirror.getMode(config, {name: "htmlmixed", tags: tagLanguages});
      }, "htmlmixed", "xml", "javascript", "coffeescript", "css", "sass", "stylus", "pug", "handlebars");

      CodeMirror.defineMIME("script/x-vue", "vue");
      CodeMirror.defineMIME("text/x-vue", "vue");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Webidl(CodeMirror) {
    function wordRegexp(words) {
      return new RegExp("^((" + words.join(")|(") + "))\\b");
    }
    var builtinArray = [
      "Clamp",
      "Constructor",
      "EnforceRange",
      "Exposed",
      "ImplicitThis",
      "Global", "PrimaryGlobal",
      "LegacyArrayClass",
      "LegacyUnenumerableNamedProperties",
      "LenientThis",
      "NamedConstructor",
      "NewObject",
      "NoInterfaceObject",
      "OverrideBuiltins",
      "PutForwards",
      "Replaceable",
      "SameObject",
      "TreatNonObjectAsNull",
      "TreatNullAs",
        "EmptyString",
      "Unforgeable",
      "Unscopeable"
    ];
    var builtins = wordRegexp(builtinArray);

    var typeArray = [
      "unsigned", "short", "long",                  // UnsignedIntegerType
      "unrestricted", "float", "double",            // UnrestrictedFloatType
      "boolean", "byte", "octet",                   // Rest of PrimitiveType
      "Promise",                                    // PromiseType
      "ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array",
      "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray",
      "Float32Array", "Float64Array",               // BufferRelatedType
      "ByteString", "DOMString", "USVString", "sequence", "object", "RegExp",
      "Error", "DOMException", "FrozenArray",       // Rest of NonAnyType
      "any",                                        // Rest of SingleType
      "void"                                        // Rest of ReturnType
    ];
    var types = wordRegexp(typeArray);

    var keywordArray = [
      "attribute", "callback", "const", "deleter", "dictionary", "enum", "getter",
      "implements", "inherit", "interface", "iterable", "legacycaller", "maplike",
      "partial", "required", "serializer", "setlike", "setter", "static",
      "stringifier", "typedef",                     // ArgumentNameKeyword except
                                                    // "unrestricted"
      "optional", "readonly", "or"
    ];
    var keywords = wordRegexp(keywordArray);

    var atomArray = [
      "true", "false",                              // BooleanLiteral
      "Infinity", "NaN",                            // FloatLiteral
      "null"                                        // Rest of ConstValue
    ];
    var atoms = wordRegexp(atomArray);

    CodeMirror.registerHelper("hintWords", "webidl",
        builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray));

    var startDefArray = ["callback", "dictionary", "enum", "interface"];
    var startDefs = wordRegexp(startDefArray);

    var endDefArray = ["typedef"];
    var endDefs = wordRegexp(endDefArray);

    var singleOperators = /^[:<=>?]/;
    var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;
    var floats = /^-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;
    var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;
    var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\s*;)/;
    var strings = /^"[^"]*"/;
    var multilineComments = /^\/\*.*?\*\//;
    var multilineCommentsStart = /^\/\*.*/;
    var multilineCommentsEnd = /^.*?\*\//;

    function readToken(stream, state) {
      // whitespace
      if (stream.eatSpace()) return null;

      // comment
      if (state.inComment) {
        if (stream.match(multilineCommentsEnd)) {
          state.inComment = false;
          return "comment";
        }
        stream.skipToEnd();
        return "comment";
      }
      if (stream.match("//")) {
        stream.skipToEnd();
        return "comment";
      }
      if (stream.match(multilineComments)) return "comment";
      if (stream.match(multilineCommentsStart)) {
        state.inComment = true;
        return "comment";
      }

      // integer and float
      if (stream.match(/^-?[0-9\.]/, false)) {
        if (stream.match(integers) || stream.match(floats)) return "number";
      }

      // string
      if (stream.match(strings)) return "string";

      // identifier
      if (state.startDef && stream.match(identifiers)) return "def";

      if (state.endDef && stream.match(identifiersEnd)) {
        state.endDef = false;
        return "def";
      }

      if (stream.match(keywords)) return "keyword";

      if (stream.match(types)) {
        var lastToken = state.lastToken;
        var nextToken = (stream.match(/^\s*(.+?)\b/, false) || [])[1];

        if (lastToken === ":" || lastToken === "implements" ||
            nextToken === "implements" || nextToken === "=") {
          // Used as identifier
          return "builtin";
        } else {
          // Used as type
          return "variable-3";
        }
      }

      if (stream.match(builtins)) return "builtin";
      if (stream.match(atoms)) return "atom";
      if (stream.match(identifiers)) return "variable";

      // other
      if (stream.match(singleOperators)) return "operator";

      // unrecognized
      stream.next();
      return null;
    }
    CodeMirror.defineMode("webidl", function() {
      return {
        startState: function() {
          return {
            // Is in multiline comment
            inComment: false,
            // Last non-whitespace, matched token
            lastToken: "",
            // Next token is a definition
            startDef: false,
            // Last token of the statement is a definition
            endDef: false
          };
        },
        token: function(stream, state) {
          var style = readToken(stream, state);

          if (style) {
            var cur = stream.current();
            state.lastToken = cur;
            if (style === "keyword") {
              state.startDef = startDefs.test(cur);
              state.endDef = state.endDef || endDefs.test(cur);
            } else {
              state.startDef = false;
            }
          }

          return style;
        }
      };
    });

    CodeMirror.defineMIME("text/x-webidl", "webidl");
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function XML(CodeMirror) {

    var htmlConfig = {
      autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                        'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                        'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                        'track': true, 'wbr': true, 'menuitem': true},
      implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                         'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                         'th': true, 'tr': true},
      contextGrabbers: {
        'dd': {'dd': true, 'dt': true},
        'dt': {'dd': true, 'dt': true},
        'li': {'li': true},
        'option': {'option': true, 'optgroup': true},
        'optgroup': {'optgroup': true},
        'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
              'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
              'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
              'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
              'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
        'rp': {'rp': true, 'rt': true},
        'rt': {'rp': true, 'rt': true},
        'tbody': {'tbody': true, 'tfoot': true},
        'td': {'td': true, 'th': true},
        'tfoot': {'tbody': true},
        'th': {'td': true, 'th': true},
        'thead': {'tbody': true, 'tfoot': true},
        'tr': {'tr': true}
      },
      doNotIndent: {"pre": true},
      allowUnquoted: true,
      allowMissing: true,
      caseFold: true
    };

    var xmlConfig = {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false,
      allowMissingTagName: false,
      caseFold: false
    };

    CodeMirror.defineMode("xml", function(editorConf, config_) {
      var indentUnit = editorConf.indentUnit;
      var config = {};
      var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
      for (var prop in defaults) config[prop] = defaults[prop];
      for (var prop in config_) config[prop] = config_[prop];

      // Return variables for tokenizers
      var type, setStyle;

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
              else return null;
            } else if (stream.match("--")) {
              return chain(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            type = stream.eat("/") ? "closeTag" : "openTag";
            state.tokenize = inTag;
            return "tag bracket";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }
      inText.isInText = true;

      function inTag(stream, state) {
        var ch = stream.next();
        if (ch == ">" || (ch == "/" && stream.eat(">"))) {
          state.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag bracket";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state.tokenize = inText;
          state.state = baseState;
          state.tagName = state.tagStart = null;
          var next = state.tokenize(stream, state);
          return next ? next + " tag error" : "tag error";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          state.stringStartCol = stream.column();
          return state.tokenize(stream, state);
        } else {
          stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
          return "word";
        }
      }

      function inAttribute(quote) {
        var closure = function(stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }

      function inBlock(style, terminator) {
        return function(stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style;
        }
      }

      function doctype(depth) {
        return function(stream, state) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state.tokenize = doctype(depth + 1);
              return state.tokenize(stream, state);
            } else if (ch == ">") {
              if (depth == 1) {
                state.tokenize = inText;
                break;
              } else {
                state.tokenize = doctype(depth - 1);
                return state.tokenize(stream, state);
              }
            }
          }
          return "meta";
        };
      }

      function Context(state, tagName, startOfLine) {
        this.prev = state.context;
        this.tagName = tagName;
        this.indent = state.indented;
        this.startOfLine = startOfLine;
        if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
          this.noIndent = true;
      }
      function popContext(state) {
        if (state.context) state.context = state.context.prev;
      }
      function maybePopContext(state, nextTagName) {
        var parentTagName;
        while (true) {
          if (!state.context) {
            return;
          }
          parentTagName = state.context.tagName;
          if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
              !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
            return;
          }
          popContext(state);
        }
      }

      function baseState(type, stream, state) {
        if (type == "openTag") {
          state.tagStart = stream.column();
          return tagNameState;
        } else if (type == "closeTag") {
          return closeTagNameState;
        } else {
          return baseState;
        }
      }
      function tagNameState(type, stream, state) {
        if (type == "word") {
          state.tagName = stream.current();
          setStyle = "tag";
          return attrState;
        } else if (config.allowMissingTagName && type == "endTag") {
          setStyle = "tag bracket";
          return attrState(type, stream, state);
        } else {
          setStyle = "error";
          return tagNameState;
        }
      }
      function closeTagNameState(type, stream, state) {
        if (type == "word") {
          var tagName = stream.current();
          if (state.context && state.context.tagName != tagName &&
              config.implicitlyClosed.hasOwnProperty(state.context.tagName))
            popContext(state);
          if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
            setStyle = "tag";
            return closeState;
          } else {
            setStyle = "tag error";
            return closeStateErr;
          }
        } else if (config.allowMissingTagName && type == "endTag") {
          setStyle = "tag bracket";
          return closeState(type, stream, state);
        } else {
          setStyle = "error";
          return closeStateErr;
        }
      }

      function closeState(type, _stream, state) {
        if (type != "endTag") {
          setStyle = "error";
          return closeState;
        }
        popContext(state);
        return baseState;
      }
      function closeStateErr(type, stream, state) {
        setStyle = "error";
        return closeState(type, stream, state);
      }

      function attrState(type, _stream, state) {
        if (type == "word") {
          setStyle = "attribute";
          return attrEqState;
        } else if (type == "endTag" || type == "selfcloseTag") {
          var tagName = state.tagName, tagStart = state.tagStart;
          state.tagName = state.tagStart = null;
          if (type == "selfcloseTag" ||
              config.autoSelfClosers.hasOwnProperty(tagName)) {
            maybePopContext(state, tagName);
          } else {
            maybePopContext(state, tagName);
            state.context = new Context(state, tagName, tagStart == state.indented);
          }
          return baseState;
        }
        setStyle = "error";
        return attrState;
      }
      function attrEqState(type, stream, state) {
        if (type == "equals") return attrValueState;
        if (!config.allowMissing) setStyle = "error";
        return attrState(type, stream, state);
      }
      function attrValueState(type, stream, state) {
        if (type == "string") return attrContinuedState;
        if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
        setStyle = "error";
        return attrState(type, stream, state);
      }
      function attrContinuedState(type, stream, state) {
        if (type == "string") return attrContinuedState;
        return attrState(type, stream, state);
      }

      return {
        startState: function(baseIndent) {
          var state = {tokenize: inText,
                       state: baseState,
                       indented: baseIndent || 0,
                       tagName: null, tagStart: null,
                       context: null};
          if (baseIndent != null) state.baseIndent = baseIndent;
          return state
        },

        token: function(stream, state) {
          if (!state.tagName && stream.sol())
            state.indented = stream.indentation();

          if (stream.eatSpace()) return null;
          type = null;
          var style = state.tokenize(stream, state);
          if ((style || type) && style != "comment") {
            setStyle = null;
            state.state = state.state(type || style, stream, state);
            if (setStyle)
              style = setStyle == "error" ? style + " error" : setStyle;
          }
          return style;
        },

        indent: function(state, textAfter, fullLine) {
          var context = state.context;
          // Indent multi-line strings (e.g. css).
          if (state.tokenize.isInAttribute) {
            if (state.tagStart == state.indented)
              return state.stringStartCol + 1;
            else
              return state.indented + indentUnit;
          }
          if (context && context.noIndent) return CodeMirror.Pass;
          if (state.tokenize != inTag && state.tokenize != inText)
            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          // Indent the starts of attribute names.
          if (state.tagName) {
            if (config.multilineTagIndentPastTag !== false)
              return state.tagStart + state.tagName.length + 2;
            else
              return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
          }
          if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
          var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
          if (tagAfter && tagAfter[1]) { // Closing tag spotted
            while (context) {
              if (context.tagName == tagAfter[2]) {
                context = context.prev;
                break;
              } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                context = context.prev;
              } else {
                break;
              }
            }
          } else if (tagAfter) { // Opening tag spotted
            while (context) {
              var grabbers = config.contextGrabbers[context.tagName];
              if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
                context = context.prev;
              else
                break;
            }
          }
          while (context && context.prev && !context.startOfLine)
            context = context.prev;
          if (context) return context.indent + indentUnit;
          else return state.baseIndent || 0;
        },

        electricInput: /<\/[\s\w:]+>$/,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",

        configuration: config.htmlMode ? "html" : "xml",
        helperType: config.htmlMode ? "html" : "xml",

        skipAttribute: function(state) {
          if (state.state == attrValueState)
            state.state = attrState;
        }
      };
    });

    CodeMirror.defineMIME("text/xml", "xml");
    CodeMirror.defineMIME("application/xml", "xml");
    if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
      CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Xquery(CodeMirror) {
    CodeMirror.defineMode("xquery", function() {

      // The keywords object is set to the result of this self executing
      // function. Each keyword is a property of the keywords object whose
      // value is {type: atype, style: astyle}
      var keywords = function(){
        // convenience functions used to build keywords object
        function kw(type) {return {type: type, style: "keyword"};}
        var operator = kw("operator")
          , atom = {type: "atom", style: "atom"}
          , punctuation = {type: "punctuation", style: null}
          , qualifier = {type: "axis_specifier", style: "qualifier"};

        // kwObj is what is return from this function at the end
        var kwObj = {
          ',': punctuation
        };

        // a list of 'basic' keywords. For each add a property to kwObj with the value of
        // {type: basic[i], style: "keyword"} e.g. 'after' --> {type: "after", style: "keyword"}
        var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',
        'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',
        'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',
        'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',
        'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',
        'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',
        'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',
        'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',
        'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',
        'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',
        'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',
        'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',
        'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',
        'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',
        'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',
        'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',
        'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',
        'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',
        'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',
        'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];
        for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);}
        // a list of types. For each add a property to kwObj with the value of
        // {type: "atom", style: "atom"}
        var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',
        'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',
        'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',
        'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',
        'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',
        'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',
        'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',
        'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',
        'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',
        'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];
        for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;}
        // each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
        var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];
        for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;}
        // each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
        var axis_specifiers = ["self::", "attribute::", "child::", "descendant::", "descendant-or-self::", "parent::",
        "ancestor::", "ancestor-or-self::", "following::", "preceding::", "following-sibling::", "preceding-sibling::"];
        for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; }
        return kwObj;
      }();

      function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
      }

      // the primary mode tokenizer
      function tokenBase(stream, state) {
        var ch = stream.next(),
            mightBeFunction = false,
            isEQName = isEQNameAhead(stream);

        // an XML tag (if not in some sub, chained tokenizer)
        if (ch == "<") {
          if(stream.match("!--", true))
            return chain(stream, state, tokenXMLComment);

          if(stream.match("![CDATA", false)) {
            state.tokenize = tokenCDATA;
            return "tag";
          }

          if(stream.match("?", false)) {
            return chain(stream, state, tokenPreProcessing);
          }

          var isclose = stream.eat("/");
          stream.eatSpace();
          var tagName = "", c;
          while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;

          return chain(stream, state, tokenTag(tagName, isclose));
        }
        // start code block
        else if(ch == "{") {
          pushStateStack(state, { type: "codeblock"});
          return null;
        }
        // end code block
        else if(ch == "}") {
          popStateStack(state);
          return null;
        }
        // if we're in an XML block
        else if(isInXmlBlock(state)) {
          if(ch == ">")
            return "tag";
          else if(ch == "/" && stream.eat(">")) {
            popStateStack(state);
            return "tag";
          }
          else
            return "variable";
        }
        // if a number
        else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
          return "atom";
        }
        // comment start
        else if (ch === "(" && stream.eat(":")) {
          pushStateStack(state, { type: "comment"});
          return chain(stream, state, tokenComment);
        }
        // quoted string
        else if (!isEQName && (ch === '"' || ch === "'"))
          return chain(stream, state, tokenString(ch));
        // variable
        else if(ch === "$") {
          return chain(stream, state, tokenVariable);
        }
        // assignment
        else if(ch ===":" && stream.eat("=")) {
          return "keyword";
        }
        // open paren
        else if(ch === "(") {
          pushStateStack(state, { type: "paren"});
          return null;
        }
        // close paren
        else if(ch === ")") {
          popStateStack(state);
          return null;
        }
        // open paren
        else if(ch === "[") {
          pushStateStack(state, { type: "bracket"});
          return null;
        }
        // close paren
        else if(ch === "]") {
          popStateStack(state);
          return null;
        }
        else {
          var known = keywords.propertyIsEnumerable(ch) && keywords[ch];

          // if there's a EQName ahead, consume the rest of the string portion, it's likely a function
          if(isEQName && ch === '\"') while(stream.next() !== '"'){}
          if(isEQName && ch === '\'') while(stream.next() !== '\''){}

          // gobble up a word if the character is not known
          if(!known) stream.eatWhile(/[\w\$_-]/);

          // gobble a colon in the case that is a lib func type call fn:doc
          var foundColon = stream.eat(":");

          // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
          // which should get matched as a keyword
          if(!stream.eat(":") && foundColon) {
            stream.eatWhile(/[\w\$_-]/);
          }
          // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
          if(stream.match(/^[ \t]*\(/, false)) {
            mightBeFunction = true;
          }
          // is the word a keyword?
          var word = stream.current();
          known = keywords.propertyIsEnumerable(word) && keywords[word];

          // if we think it's a function call but not yet known,
          // set style to variable for now for lack of something better
          if(mightBeFunction && !known) known = {type: "function_call", style: "variable def"};

          // if the previous word was element, attribute, axis specifier, this word should be the name of that
          if(isInXmlConstructor(state)) {
            popStateStack(state);
            return "variable";
          }
          // as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
          // push the stack so we know to look for it on the next word
          if(word == "element" || word == "attribute" || known.type == "axis_specifier") pushStateStack(state, {type: "xmlconstructor"});

          // if the word is known, return the details of that else just call this a generic 'word'
          return known ? known.style : "variable";
        }
      }

      // handle comments, including nested
      function tokenComment(stream, state) {
        var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
        while (ch = stream.next()) {
          if (ch == ")" && maybeEnd) {
            if(nestedCount > 0)
              nestedCount--;
            else {
              popStateStack(state);
              break;
            }
          }
          else if(ch == ":" && maybeNested) {
            nestedCount++;
          }
          maybeEnd = (ch == ":");
          maybeNested = (ch == "(");
        }

        return "comment";
      }

      // tokenizer for string literals
      // optionally pass a tokenizer function to set state.tokenize back to when finished
      function tokenString(quote, f) {
        return function(stream, state) {
          var ch;

          if(isInString(state) && stream.current() == quote) {
            popStateStack(state);
            if(f) state.tokenize = f;
            return "string";
          }

          pushStateStack(state, { type: "string", name: quote, tokenize: tokenString(quote, f) });

          // if we're in a string and in an XML block, allow an embedded code block
          if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
            state.tokenize = tokenBase;
            return "string";
          }


          while (ch = stream.next()) {
            if (ch ==  quote) {
              popStateStack(state);
              if(f) state.tokenize = f;
              break;
            }
            else {
              // if we're in a string and in an XML block, allow an embedded code block in an attribute
              if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
                state.tokenize = tokenBase;
                return "string";
              }

            }
          }

          return "string";
        };
      }

      // tokenizer for variables
      function tokenVariable(stream, state) {
        var isVariableChar = /[\w\$_-]/;

        // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
        if(stream.eat("\"")) {
          while(stream.next() !== '\"'){}      stream.eat(":");
        } else {
          stream.eatWhile(isVariableChar);
          if(!stream.match(":=", false)) stream.eat(":");
        }
        stream.eatWhile(isVariableChar);
        state.tokenize = tokenBase;
        return "variable";
      }

      // tokenizer for XML tags
      function tokenTag(name, isclose) {
        return function(stream, state) {
          stream.eatSpace();
          if(isclose && stream.eat(">")) {
            popStateStack(state);
            state.tokenize = tokenBase;
            return "tag";
          }
          // self closing tag without attributes?
          if(!stream.eat("/"))
            pushStateStack(state, { type: "tag", name: name, tokenize: tokenBase});
          if(!stream.eat(">")) {
            state.tokenize = tokenAttribute;
            return "tag";
          }
          else {
            state.tokenize = tokenBase;
          }
          return "tag";
        };
      }

      // tokenizer for XML attributes
      function tokenAttribute(stream, state) {
        var ch = stream.next();

        if(ch == "/" && stream.eat(">")) {
          if(isInXmlAttributeBlock(state)) popStateStack(state);
          if(isInXmlBlock(state)) popStateStack(state);
          return "tag";
        }
        if(ch == ">") {
          if(isInXmlAttributeBlock(state)) popStateStack(state);
          return "tag";
        }
        if(ch == "=")
          return null;
        // quoted string
        if (ch == '"' || ch == "'")
          return chain(stream, state, tokenString(ch, tokenAttribute));

        if(!isInXmlAttributeBlock(state))
          pushStateStack(state, { type: "attribute", tokenize: tokenAttribute});

        stream.eat(/[a-zA-Z_:]/);
        stream.eatWhile(/[-a-zA-Z0-9_:.]/);
        stream.eatSpace();

        // the case where the attribute has not value and the tag was closed
        if(stream.match(">", false) || stream.match("/", false)) {
          popStateStack(state);
          state.tokenize = tokenBase;
        }

        return "attribute";
      }

      // handle comments, including nested
      function tokenXMLComment(stream, state) {
        var ch;
        while (ch = stream.next()) {
          if (ch == "-" && stream.match("->", true)) {
            state.tokenize = tokenBase;
            return "comment";
          }
        }
      }


      // handle CDATA
      function tokenCDATA(stream, state) {
        var ch;
        while (ch = stream.next()) {
          if (ch == "]" && stream.match("]", true)) {
            state.tokenize = tokenBase;
            return "comment";
          }
        }
      }

      // handle preprocessing instructions
      function tokenPreProcessing(stream, state) {
        var ch;
        while (ch = stream.next()) {
          if (ch == "?" && stream.match(">", true)) {
            state.tokenize = tokenBase;
            return "comment meta";
          }
        }
      }


      // functions to test the current context of the state
      function isInXmlBlock(state) { return isIn(state, "tag"); }
      function isInXmlAttributeBlock(state) { return isIn(state, "attribute"); }
      function isInXmlConstructor(state) { return isIn(state, "xmlconstructor"); }
      function isInString(state) { return isIn(state, "string"); }

      function isEQNameAhead(stream) {
        // assume we've already eaten a quote (")
        if(stream.current() === '"')
          return stream.match(/^[^\"]+\"\:/, false);
        else if(stream.current() === '\'')
          return stream.match(/^[^\"]+\'\:/, false);
        else
          return false;
      }

      function isIn(state, type) {
        return (state.stack.length && state.stack[state.stack.length - 1].type == type);
      }

      function pushStateStack(state, newState) {
        state.stack.push(newState);
      }

      function popStateStack(state) {
        state.stack.pop();
        var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;
        state.tokenize = reinstateTokenize || tokenBase;
      }

      // the interface for the mode API
      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            cc: [],
            stack: []
          };
        },

        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          return style;
        },

        blockCommentStart: "(:",
        blockCommentEnd: ":)"

      };

    });

    CodeMirror.defineMIME("application/xquery", "xquery");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    // Yacas mode copyright (c) 2015 by Grzegorz Mazur
    // Loosely based on mathematica mode by Calin Barbat

    function Yacas(CodeMirror) {
    CodeMirror.defineMode('yacas', function(_config, _parserConfig) {

      function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
      }

      var bodiedOps = words("Assert BackQuote D Defun Deriv For ForEach FromFile " +
                            "FromString Function Integrate InverseTaylor Limit " +
                            "LocalSymbols Macro MacroRule MacroRulePattern " +
                            "NIntegrate Rule RulePattern Subst TD TExplicitSum " +
                            "TSum Taylor Taylor1 Taylor2 Taylor3 ToFile " +
                            "ToStdout ToString TraceRule Until While");

      // patterns
      var pFloatForm  = "(?:(?:\\.\\d+|\\d+\\.\\d*|\\d+)(?:[eE][+-]?\\d+)?)";
      var pIdentifier = "(?:[a-zA-Z\\$'][a-zA-Z0-9\\$']*)";

      // regular expressions
      var reFloatForm    = new RegExp(pFloatForm);
      var reIdentifier   = new RegExp(pIdentifier);
      var rePattern      = new RegExp(pIdentifier + "?_" + pIdentifier);
      var reFunctionLike = new RegExp(pIdentifier + "\\s*\\(");

      function tokenBase(stream, state) {
        var ch;

        // get next character
        ch = stream.next();

        // string
        if (ch === '"') {
          state.tokenize = tokenString;
          return state.tokenize(stream, state);
        }

        // comment
        if (ch === '/') {
          if (stream.eat('*')) {
            state.tokenize = tokenComment;
            return state.tokenize(stream, state);
          }
          if (stream.eat("/")) {
            stream.skipToEnd();
            return "comment";
          }
        }

        // go back one character
        stream.backUp(1);

        // update scope info
        var m = stream.match(/^(\w+)\s*\(/, false);
        if (m !== null && bodiedOps.hasOwnProperty(m[1]))
          state.scopes.push('bodied');

        var scope = currentScope(state);

        if (scope === 'bodied' && ch === '[')
          state.scopes.pop();

        if (ch === '[' || ch === '{' || ch === '(')
          state.scopes.push(ch);

        scope = currentScope(state);

        if (scope === '[' && ch === ']' ||
            scope === '{' && ch === '}' ||
            scope === '(' && ch === ')')
          state.scopes.pop();

        if (ch === ';') {
          while (scope === 'bodied') {
            state.scopes.pop();
            scope = currentScope(state);
          }
        }

        // look for ordered rules
        if (stream.match(/\d+ *#/, true, false)) {
          return 'qualifier';
        }

        // look for numbers
        if (stream.match(reFloatForm, true, false)) {
          return 'number';
        }

        // look for placeholders
        if (stream.match(rePattern, true, false)) {
          return 'variable-3';
        }

        // match all braces separately
        if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
          return 'bracket';
        }

        // literals looking like function calls
        if (stream.match(reFunctionLike, true, false)) {
          stream.backUp(1);
          return 'variable';
        }

        // all other identifiers
        if (stream.match(reIdentifier, true, false)) {
          return 'variable-2';
        }

        // operators; note that operators like @@ or /; are matched separately for each symbol.
        if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%|#)/, true, false)) {
          return 'operator';
        }

        // everything else is an error
        return 'error';
      }

      function tokenString(stream, state) {
        var next, end = false, escaped = false;
        while ((next = stream.next()) != null) {
          if (next === '"' && !escaped) {
            end = true;
            break;
          }
          escaped = !escaped && next === '\\';
        }
        if (end && !escaped) {
          state.tokenize = tokenBase;
        }
        return 'string';
      }
      function tokenComment(stream, state) {
        var prev, next;
        while((next = stream.next()) != null) {
          if (prev === '*' && next === '/') {
            state.tokenize = tokenBase;
            break;
          }
          prev = next;
        }
        return 'comment';
      }

      function currentScope(state) {
        var scope = null;
        if (state.scopes.length > 0)
          scope = state.scopes[state.scopes.length - 1];
        return scope;
      }

      return {
        startState: function() {
          return {
            tokenize: tokenBase,
            scopes: []
          };
        },
        token: function(stream, state) {
          if (stream.eatSpace()) return null;
          return state.tokenize(stream, state);
        },
        indent: function(state, textAfter) {
          if (state.tokenize !== tokenBase && state.tokenize !== null)
            return CodeMirror.Pass;

          var delta = 0;
          if (textAfter === ']' || textAfter === '];' ||
              textAfter === '}' || textAfter === '};' ||
              textAfter === ');')
            delta = -1;

          return (state.scopes.length + delta) * _config.indentUnit;
        },
        electricChars: "{}[]();",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//"
      };
    });

    CodeMirror.defineMIME('text/x-yacas', {
      name: 'yacas'
    });

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Yaml(CodeMirror) {
    CodeMirror.defineMode("yaml", function() {

      var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];
      var keywordRegex = new RegExp("\\b(("+cons.join(")|(")+"))$", 'i');

      return {
        token: function(stream, state) {
          var ch = stream.peek();
          var esc = state.escaped;
          state.escaped = false;
          /* comments */
          if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
            stream.skipToEnd();
            return "comment";
          }

          if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
            return "string";

          if (state.literal && stream.indentation() > state.keyCol) {
            stream.skipToEnd(); return "string";
          } else if (state.literal) { state.literal = false; }
          if (stream.sol()) {
            state.keyCol = 0;
            state.pair = false;
            state.pairStart = false;
            /* document start */
            if(stream.match(/---/)) { return "def"; }
            /* document end */
            if (stream.match(/\.\.\./)) { return "def"; }
            /* array list item */
            if (stream.match(/\s*-\s+/)) { return 'meta'; }
          }
          /* inline pairs/lists */
          if (stream.match(/^(\{|\}|\[|\])/)) {
            if (ch == '{')
              state.inlinePairs++;
            else if (ch == '}')
              state.inlinePairs--;
            else if (ch == '[')
              state.inlineList++;
            else
              state.inlineList--;
            return 'meta';
          }

          /* list seperator */
          if (state.inlineList > 0 && !esc && ch == ',') {
            stream.next();
            return 'meta';
          }
          /* pairs seperator */
          if (state.inlinePairs > 0 && !esc && ch == ',') {
            state.keyCol = 0;
            state.pair = false;
            state.pairStart = false;
            stream.next();
            return 'meta';
          }

          /* start of value of a pair */
          if (state.pairStart) {
            /* block literals */
            if (stream.match(/^\s*(\||\>)\s*/)) { state.literal = true; return 'meta'; }        /* references */
            if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) { return 'variable-2'; }
            /* numbers */
            if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) { return 'number'; }
            if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) { return 'number'; }
            /* keywords */
            if (stream.match(keywordRegex)) { return 'keyword'; }
          }

          /* pairs (associative arrays) -> key */
          if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
            state.pair = true;
            state.keyCol = stream.indentation();
            return "atom";
          }
          if (state.pair && stream.match(/^:\s*/)) { state.pairStart = true; return 'meta'; }

          /* nothing found, continue */
          state.pairStart = false;
          state.escaped = (ch == '\\');
          stream.next();
          return null;
        },
        startState: function() {
          return {
            pair: false,
            pairStart: false,
            keyCol: 0,
            inlinePairs: 0,
            inlineList: 0,
            literal: false,
            escaped: false
          };
        },
        lineComment: "#",
        fold: "indent"
      };
    });

    CodeMirror.defineMIME("text/x-yaml", "yaml");
    CodeMirror.defineMIME("text/yaml", "yaml");

    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Yaml_formatter(CodeMirror) {

      var START = 0, FRONTMATTER = 1, BODY = 2;

      // a mixed mode for Markdown text with an optional YAML front matter
      CodeMirror.defineMode("yaml-frontmatter", function (config, parserConfig) {
        var yamlMode = CodeMirror.getMode(config, "yaml");
        var innerMode = CodeMirror.getMode(config, parserConfig && parserConfig.base || "gfm");

        function curMode(state) {
          return state.state == BODY ? innerMode : yamlMode
        }

        return {
          startState: function () {
            return {
              state: START,
              inner: CodeMirror.startState(yamlMode)
            }
          },
          copyState: function (state) {
            return {
              state: state.state,
              inner: CodeMirror.copyState(curMode(state), state.inner)
            }
          },
          token: function (stream, state) {
            if (state.state == START) {
              if (stream.match(/---/, false)) {
                state.state = FRONTMATTER;
                return yamlMode.token(stream, state.inner)
              } else {
                state.state = BODY;
                state.inner = CodeMirror.startState(innerMode);
                return innerMode.token(stream, state.inner)
              }
            } else if (state.state == FRONTMATTER) {
              var end = stream.sol() && stream.match(/---/, false);
              var style = yamlMode.token(stream, state.inner);
              if (end) {
                state.state = BODY;
                state.inner = CodeMirror.startState(innerMode);
              }
              return style
            } else {
              return innerMode.token(stream, state.inner)
            }
          },
          innerMode: function (state) {
            return {mode: curMode(state), state: state.inner}
          },
          blankLine: function (state) {
            var mode = curMode(state);
            if (mode.blankLine) return mode.blankLine(state.inner)
          }
        }
      });
    }

    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE

    function Z80(CodeMirror) {
    CodeMirror.defineMode('z80', function(_config, parserConfig) {
      var ez80 = parserConfig.ez80;
      var keywords1, keywords2;
      if (ez80) {
        keywords1 = /^(exx?|(ld|cp)([di]r?)?|[lp]ea|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|[de]i|halt|im|in([di]mr?|ir?|irx|2r?)|ot(dmr?|[id]rx|imr?)|out(0?|[di]r?|[di]2r?)|tst(io)?|slp)(\.([sl]?i)?[sl])?\b/i;
        keywords2 = /^(((call|j[pr]|rst|ret[in]?)(\.([sl]?i)?[sl])?)|(rs|st)mix)\b/i;
      } else {
        keywords1 = /^(exx?|(ld|cp|in)([di]r?)?|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|rst|[de]i|halt|im|ot[di]r|out[di]?)\b/i;
        keywords2 = /^(call|j[pr]|ret[in]?|b_?(call|jump))\b/i;
      }

      var variables1 = /^(af?|bc?|c|de?|e|hl?|l|i[xy]?|r|sp)\b/i;
      var variables2 = /^(n?[zc]|p[oe]?|m)\b/i;
      var errors = /^([hl][xy]|i[xy][hl]|slia|sll)\b/i;
      var numbers = /^([\da-f]+h|[0-7]+o|[01]+b|\d+d?)\b/i;

      return {
        startState: function() {
          return {
            context: 0
          };
        },
        token: function(stream, state) {
          if (!stream.column())
            state.context = 0;

          if (stream.eatSpace())
            return null;

          var w;

          if (stream.eatWhile(/\w/)) {
            if (ez80 && stream.eat('.')) {
              stream.eatWhile(/\w/);
            }
            w = stream.current();

            if (stream.indentation()) {
              if ((state.context == 1 || state.context == 4) && variables1.test(w)) {
                state.context = 4;
                return 'var2';
              }

              if (state.context == 2 && variables2.test(w)) {
                state.context = 4;
                return 'var3';
              }

              if (keywords1.test(w)) {
                state.context = 1;
                return 'keyword';
              } else if (keywords2.test(w)) {
                state.context = 2;
                return 'keyword';
              } else if (state.context == 4 && numbers.test(w)) {
                return 'number';
              }

              if (errors.test(w))
                return 'error';
            } else if (stream.match(numbers)) {
              return 'number';
            } else {
              return null;
            }
          } else if (stream.eat(';')) {
            stream.skipToEnd();
            return 'comment';
          } else if (stream.eat('"')) {
            while (w = stream.next()) {
              if (w == '"')
                break;

              if (w == '\\')
                stream.next();
            }
            return 'string';
          } else if (stream.eat('\'')) {
            if (stream.match(/\\?.'/))
              return 'number';
          } else if (stream.eat('.') || stream.sol() && stream.eat('#')) {
            state.context = 5;

            if (stream.eatWhile(/\w/))
              return 'def';
          } else if (stream.eat('$')) {
            if (stream.eatWhile(/[\da-f]/i))
              return 'number';
          } else if (stream.eat('%')) {
            if (stream.eatWhile(/[01]/))
              return 'number';
          } else {
            stream.next();
          }
          return null;
        }
      };
    });

    CodeMirror.defineMIME("text/x-z80", "z80");
    CodeMirror.defineMIME("text/x-ez80", { name: "z80", ez80: true });

    }



    var mode = /*#__PURE__*/Object.freeze({
        APL: APL,
        Asciiarmor: Asciiarmor,
        Asn1: Asn1,
        Asterisk: Asterisk,
        Brainfuck: Brainfuck,
        Clike: Clike,
        Clojure: Clojure,
        Cmake: Cmake,
        Cobol: Cobol,
        Coffeescript: Coffeescript,
        Commonlisp: Commonlisp,
        Crystal: Crystal,
        CSS: CSS,
        Cypher: Cypher,
        D: D,
        Dart: Dart,
        Diff: Diff,
        Django: Django,
        Dockerfile: Dockerfile,
        DTD: DTD,
        Dylan: Dylan,
        EBNF: EBNF,
        ECL: ECL,
        Eiffel: Eiffel,
        Elm: Elm,
        Erlang: Erlang,
        Factor: Factor,
        FCL: FCL,
        Forth: Forth,
        Fortran: Fortran,
        Gas: Gas,
        GFM: GFM,
        Gherkin: Gherkin,
        Go: Go,
        Groovy: Groovy,
        Haml: Haml,
        Handlebars: Handlebars,
        Haskell: Haskell,
        Haskell_literate: Haskell_literate,
        Haxe: Haxe,
        HTMLembedded: HTMLembedded,
        HTMLMixed: HTMLMixed,
        HTTP: HTTP,
        IDL: IDL,
        Javascript: Javascript,
        Jinja2: Jinja2,
        JSX: JSX,
        Julia: Julia,
        LiveScript: LiveScript,
        Lua: Lua,
        Markdown: Markdown,
        Mathematica: Mathematica,
        Mbox: Mbox,
        Mirc: Mirc,
        Mllike: Mllike,
        Modelica: Modelica,
        MscGen: MscGen,
        Mumps: Mumps,
        Nginx: Nginx,
        Nsis: Nsis,
        Ntriples: Ntriples,
        Octave: Octave,
        Oz: Oz,
        Pascal: Pascal,
        Pegjs: Pegjs,
        Perl: Perl,
        PHP: PHP,
        Pig: Pig,
        PowerShell: PowerShell,
        Properties: Properties,
        Protobuf: Protobuf,
        Pug: Pug,
        Puppet: Puppet,
        Python: Python,
        Q: Q,
        R: R,
        RPM: RPM,
        RST: RST,
        Ruby: Ruby,
        Rust: Rust,
        SAS: SAS,
        Scheme: Scheme,
        Shell: Shell,
        Shieve: Shieve,
        Slim: Slim,
        SmallTalk: SmallTalk,
        Smarty: Smarty,
        Solr: Solr,
        Soy: Soy,
        Sparql: Sparql,
        SpreadSheet: SpreadSheet,
        SQL: SQL,
        Stext: Stext,
        Stylus: Stylus,
        Swift: Swift,
        TCL: TCL,
        Textile: Textile,
        TiddlyWiki: TiddlyWiki,
        Tiki: Tiki,
        Toml: Toml,
        Tornado: Tornado,
        Troff: Troff,
        TTCN: TTCN,
        TTCN_cfg: TTCN_cfg,
        Turtle: Turtle,
        Twig: Twig,
        VB: VB,
        VbScript: VbScript,
        Velocity: Velocity,
        Verilog: Verilog,
        VHDL: VHDL,
        Vue: Vue,
        Webidl: Webidl,
        XML: XML,
        Xquery: Xquery,
        Yacas: Yacas,
        Yaml: Yaml,
        Yaml_formatter: Yaml_formatter,
        Z80: Z80
    });

    // CodeMirror, copyright (c) by Marijn Haverbeke and others

    let CodeMirror=codemirror();

    for(let k in addon){
      addon[k](CodeMirror);
    }

    for(let k in mode){
      mode[k](CodeMirror);
    }

    function codemirror() {
      // Kludges for bugs and behavior differences that can't be feature
      // detected are enabled based on userAgent etc sniffing.
      var userAgent = navigator.userAgent;
      var platform = navigator.platform;

      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);

      var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
      var android = /Android/.test(userAgent);
      // This is woefully incomplete. Suggestions for alternative methods welcome.
      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);

      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version) { presto_version = Number(presto_version[1]); }
      if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
      // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || (ie && ie_version >= 9);

      function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

      var rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };

      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
          { e.removeChild(e.firstChild); }
        return e
      }

      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e)
      }

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) { e.className = className; }
        if (style) { e.style.cssText = style; }
        if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
        else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
        return e
      }
      // wrapper for elt, which removes the elt from the accessibility tree
      function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e
      }

      var range;
      if (document.createRange) { range = function(node, start, end, endNode) {
        var r = document.createRange();
        r.setEnd(endNode || node, end);
        r.setStart(node, start);
        return r
      }; }
      else { range = function(node, start, end) {
        var r = document.body.createTextRange();
        try { r.moveToElementText(node.parentNode); }
        catch(e) { return r }
        r.collapse(true);
        r.moveEnd("character", end);
        r.moveStart("character", start);
        return r
      }; }

      function contains(parent, child) {
        if (child.nodeType == 3) // Android browser always returns false when child is a textnode
          { child = child.parentNode; }
        if (parent.contains)
          { return parent.contains(child) }
        do {
          if (child.nodeType == 11) { child = child.host; }
          if (child == parent) { return true }
        } while (child = child.parentNode)
      }

      function activeElt() {
        // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
        // IE < 10 will throw when accessed while the page is loading or in an iframe.
        // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
        var activeElement;
        try {
          activeElement = document.activeElement;
        } catch(e) {
          activeElement = document.body || null;
        }
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
          { activeElement = activeElement.shadowRoot.activeElement; }
        return activeElement
      }

      function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
      }
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i = 0; i < as.length; i++)
          { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
        return b
      }

      var selectInput = function(node) { node.select(); };
      if (ios) // Mobile Safari apparently has a bug where select() is broken.
        { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
      else if (ie) // Suppress mysterious IE10 errors
        { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function(){return f.apply(null, args)}
      }

      function copyObj(obj, target, overwrite) {
        if (!target) { target = {}; }
        for (var prop in obj)
          { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
            { target[prop] = obj[prop]; } }
        return target
      }

      // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) { end = string.length; }
        }
        for (var i = startIndex || 0, n = startValue || 0;;) {
          var nextTab = string.indexOf("\t", i);
          if (nextTab < 0 || nextTab >= end)
            { return n + (end - i) }
          n += nextTab - i;
          n += tabSize - (n % tabSize);
          i = nextTab + 1;
        }
      }

      var Delayed = function() {this.id = null;};
      Delayed.prototype.set = function (ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
      };

      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
          { if (array[i] == elt) { return i } }
        return -1
      }

      // Number of pixels added to scroller and sizer to hide scrollbar
      var scrollerGap = 30;

      // Returned or thrown by various protocols to signal 'I'm not
      // handling this'.
      var Pass = {toString: function(){return "CodeMirror.Pass"}};

      // Reused option objects for setSelection & friends
      var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

      // The inverse of countColumn -- find the offset that corresponds to
      // a particular column.
      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
          var nextTab = string.indexOf("\t", pos);
          if (nextTab == -1) { nextTab = string.length; }
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal)
            { return pos + Math.min(skipped, goal - col) }
          col += nextTab - pos;
          col += tabSize - (col % tabSize);
          pos = nextTab + 1;
          if (col >= goal) { return pos }
        }
      }

      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n)
          { spaceStrs.push(lst(spaceStrs) + " "); }
        return spaceStrs[n]
      }

      function lst(arr) { return arr[arr.length-1] }

      function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
        return out
      }

      function insertSorted(array, value, score) {
        var pos = 0, priority = score(value);
        while (pos < array.length && score(array[pos]) <= priority) { pos++; }
        array.splice(pos, 0, value);
      }

      function nothing() {}

      function createObj(base, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }
        if (props) { copyObj(props, inst); }
        return inst
      }

      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "\x80" &&
          (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
      }
      function isWordChar(ch, helper) {
        if (!helper) { return isWordCharBasic(ch) }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
        return helper.test(ch)
      }

      function isEmpty(obj) {
        for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
        return true
      }

      // Extending unicode characters. A series of a non-extending char +
      // any number of extending chars is treated as a single unit as far
      // as editing and measuring is concerned. This is not fully correct,
      // since some scripts/fonts/browsers also treat other configurations
      // of code points as a group.
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

      // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
      function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
        return pos
      }

      // Returns the value from the range [`from`; `to`] that satisfies
      // `pred` and is closest to `from`. Assumes that at least `to`
      // satisfies `pred`. Supports `from` being greater than `to`.
      function findFirst(pred, from, to) {
        // At any point we are certain `to` satisfies `pred`, don't know
        // whether `from` does.
        var dir = from > to ? -1 : 1;
        for (;;) {
          if (from == to) { return from }
          var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
          if (mid == from) { return pred(mid) ? from : to }
          if (pred(mid)) { to = mid; }
          else { from = mid + dir; }
        }
      }

      // BIDI HELPERS

      function iterateBidiSections(order, from, to, f) {
        if (!order) { return f(from, to, "ltr", 0) }
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
            found = true;
          }
        }
        if (!found) { f(from, to, "ltr"); }
      }

      var bidiOther = null;
      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for (var i = 0; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < ch && cur.to > ch) { return i }
          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") { found = i; }
            else { bidiOther = i; }
          }
          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") { found = i; }
            else { bidiOther = i; }
          }
        }
        return found != null ? found : bidiOther
      }

      // Bidirectional ordering algorithm
      // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
      // that this (partially) implements.

      // One-char codes used for character types:
      // L (L):   Left-to-Right
      // R (R):   Right-to-Left
      // r (AL):  Right-to-Left Arabic
      // 1 (EN):  European Number
      // + (ES):  European Number Separator
      // % (ET):  European Number Terminator
      // n (AN):  Arabic Number
      // , (CS):  Common Number Separator
      // m (NSM): Non-Spacing Mark
      // b (BN):  Boundary Neutral
      // s (B):   Paragraph Separator
      // t (S):   Segment Separator
      // w (WS):  Whitespace
      // N (ON):  Other Neutrals

      // Returns null if characters are ordered as they appear
      // (left-to-right), or an array of sections ({from, to, level}
      // objects) in the order in which they occur visually.
      var bidiOrdering = (function() {
        // Character types for codepoints 0 to 0xff
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        // Character types for codepoints 0x600 to 0x6f9
        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function charType(code) {
          if (code <= 0xf7) { return lowTypes.charAt(code) }
          else if (0x590 <= code && code <= 0x5f4) { return "R" }
          else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
          else if (0x6ee <= code && code <= 0x8ac) { return "r" }
          else if (0x2000 <= code && code <= 0x200b) { return "w" }
          else if (code == 0x200c) { return "b" }
          else { return "L" }
        }

        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from; this.to = to;
        }

        return function(str, direction) {
          var outerType = direction == "ltr" ? "L" : "R";

          if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
          var len = str.length, types = [];
          for (var i = 0; i < len; ++i)
            { types.push(charType(str.charCodeAt(i))); }

          // W1. Examine each non-spacing mark (NSM) in the level run, and
          // change the type of the NSM to the type of the previous
          // character. If the NSM is at the start of the level run, it will
          // get the type of sor.
          for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
            var type = types[i$1];
            if (type == "m") { types[i$1] = prev; }
            else { prev = type; }
          }

          // W2. Search backwards from each instance of a European number
          // until the first strong type (R, L, AL, or sor) is found. If an
          // AL is found, change the type of the European number to Arabic
          // number.
          // W3. Change all ALs to R.
          for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
            var type$1 = types[i$2];
            if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
            else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
          }

          // W4. A single European separator between two European numbers
          // changes to a European number. A single common separator between
          // two numbers of the same type changes to that type.
          for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];
            if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
            else if (type$2 == "," && prev$1 == types[i$3+1] &&
                     (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
            prev$1 = type$2;
          }

          // W5. A sequence of European terminators adjacent to European
          // numbers changes to all European numbers.
          // W6. Otherwise, separators and terminators change to Other
          // Neutral.
          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];
            if (type$3 == ",") { types[i$4] = "N"; }
            else if (type$3 == "%") {
              var end = (void 0);
              for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
              var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
              for (var j = i$4; j < end; ++j) { types[j] = replace; }
              i$4 = end - 1;
            }
          }

          // W7. Search backwards from each instance of a European number
          // until the first strong type (R, L, or sor) is found. If an L is
          // found, then change the type of the European number to L.
          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];
            if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
            else if (isStrong.test(type$4)) { cur$1 = type$4; }
          }

          // N1. A sequence of neutrals takes the direction of the
          // surrounding strong text if the text on both sides has the same
          // direction. European and Arabic numbers act as if they were R in
          // terms of their influence on neutrals. Start-of-level-run (sor)
          // and end-of-level-run (eor) are used at level run boundaries.
          // N2. Any remaining neutrals take the embedding direction.
          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = (void 0);
              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
              var before = (i$6 ? types[i$6-1] : outerType) == "L";
              var after = (end$1 < len ? types[end$1] : outerType) == "L";
              var replace$1 = before == after ? (before ? "L" : "R") : outerType;
              for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
              i$6 = end$1 - 1;
            }
          }

          // Here we depart from the documented algorithm, in order to avoid
          // building up an actual levels array. Since there are only three
          // levels (0, 1, 2) in an implementation that doesn't take
          // explicit embedding into account, we can build up the order on
          // the fly, without following the level-based algorithm.
          var order = [], m;
          for (var i$7 = 0; i$7 < len;) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;
              for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7, at = order.length;
              for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
              for (var j$2 = pos; j$2 < i$7;) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
                  var nstart = j$2;
                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  pos = j$2;
                } else { ++j$2; }
              }
              if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
            }
          }
          if (direction == "ltr") {
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
              order[0].from = m[0].length;
              order.unshift(new BidiSpan(0, 0, m[0].length));
            }
            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
              lst(order).to -= m[0].length;
              order.push(new BidiSpan(0, len - m[0].length, len));
            }
          }

          return direction == "rtl" ? order.reverse() : order
        }
      })();

      // Get the bidi ordering for the given line (and cache it). Returns
      // false for lines that are fully left-to-right, and an array of
      // BidiSpan objects otherwise.
      function getOrder(line, direction) {
        var order = line.order;
        if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
        return order
      }

      // EVENT HANDLING

      // Lightweight event framework. on/off also work on DOM nodes,
      // registering native DOM handlers.

      var noHandlers = [];

      var on = function(emitter, type, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type, f);
        } else {
          var map$$1 = emitter._handlers || (emitter._handlers = {});
          map$$1[type] = (map$$1[type] || noHandlers).concat(f);
        }
      };

      function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers
      }

      function off(emitter, type, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type, f);
        } else {
          var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
          if (arr) {
            var index = indexOf(arr, f);
            if (index > -1)
              { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
          }
        }
      }

      function signal(emitter, type /*, values...*/) {
        var handlers = getHandlers(emitter, type);
        if (!handlers.length) { return }
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
      }

      // The DOM events that CodeMirror handles can be overridden by
      // registering a (non-DOM) handler on the editor for the event name,
      // and preventDefault-ing the event in that handler.
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string")
          { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore
      }

      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) { return }
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
          { set.push(arr[i]); } }
      }

      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0
      }

      // Add on and off methods to a constructor's prototype, to make
      // registering events on such objects more convenient.
      function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {on(this, type, f);};
        ctor.prototype.off = function(type, f) {off(this, type, f);};
      }

      // Due to the fact that we still support jurassic IE versions, some
      // compatibility wrappers are needed.

      function e_preventDefault(e) {
        if (e.preventDefault) { e.preventDefault(); }
        else { e.returnValue = false; }
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) { e.stopPropagation(); }
        else { e.cancelBubble = true; }
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
      }
      function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

      function e_target(e) {return e.target || e.srcElement}
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) { b = 1; }
          else if (e.button & 2) { b = 3; }
          else if (e.button & 4) { b = 2; }
        }
        if (mac && e.ctrlKey && b == 1) { b = 3; }
        return b
      }

      // Detect drag-and-drop
      var dragAndDrop = function() {
        // There is *some* kind of drag-and-drop support in IE6-8, but I
        // couldn't get it to work yet.
        if (ie && ie_version < 9) { return false }
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div
      }();

      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0)
            { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
        }
        var node = zwspSupported ? elt("span", "\u200b") :
          elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node
      }

      // Feature-detect IE's crummy client rect reporting for bidi text
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null) { return badBidiRects }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);
        if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
        return badBidiRects = (r1.right - r0.right < 3)
      }

      // See if "".split is the broken IE version, if so, provide an
      // alternative way to split lines.
      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0, result = [], l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) { nl = string.length; }
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result
      } : function (string) { return string.split(/\r\n?|\n/); };

      var hasSelection = window.getSelection ? function (te) {
        try { return te.selectionStart != te.selectionEnd }
        catch(e) { return false }
      } : function (te) {
        var range$$1;
        try {range$$1 = te.ownerDocument.selection.createRange();}
        catch(e) {}
        if (!range$$1 || range$$1.parentElement() != te) { return false }
        return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
      };

      var hasCopyEvent = (function () {
        var e = elt("div");
        if ("oncopy" in e) { return true }
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function"
      })();

      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) { return badZoomedRects }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
      }

      // Known modes, by name and by MIME
      var modes = {}, mimeModes = {};

      // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)
      function defineMode(name, mode) {
        if (arguments.length > 2)
          { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
        modes[name] = mode;
      }

      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }

      // Given a MIME type, a {name, ...options} config object, or a name
      // string, return a mode config object.
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") { found = {name: found}; }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml")
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json")
        }
        if (typeof spec == "string") { return {name: spec} }
        else { return spec || {name: "null"} }
      }

      // Given a mode spec (anything that resolveMode accepts), find and
      // initialize an actual mode object.
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) { return getMode(options, "text/plain") }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) { continue }
            if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) { modeObj.helperType = spec.helperType; }
        if (spec.modeProps) { for (var prop$1 in spec.modeProps)
          { modeObj[prop$1] = spec.modeProps[prop$1]; } }

        return modeObj
      }

      // This can be used to attach properties to mode objects from
      // outside the actual mode definition.
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
        copyObj(properties, exts);
      }

      function copyState(mode, state) {
        if (state === true) { return state }
        if (mode.copyState) { return mode.copyState(state) }
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) { val = val.concat([]); }
          nstate[n] = val;
        }
        return nstate
      }

      // Given a mode and a state (for that mode), find the inner mode and
      // state at the position that the state refers to.
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) { break }
          state = info.state;
          mode = info.mode;
        }
        return info || {mode: mode, state: state}
      }

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true
      }

      // STRING STREAM

      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.

      var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };

      StringStream.prototype.eol = function () {return this.pos >= this.string.length};
      StringStream.prototype.sol = function () {return this.pos == this.lineStart};
      StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
      StringStream.prototype.next = function () {
        if (this.pos < this.string.length)
          { return this.string.charAt(this.pos++) }
      };
      StringStream.prototype.eat = function (match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") { ok = ch == match; }
        else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
        if (ok) {++this.pos; return ch}
      };
      StringStream.prototype.eatWhile = function (match) {
        var start = this.pos;
        while (this.eat(match)){}
        return this.pos > start
      };
      StringStream.prototype.eatSpace = function () {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
        return this.pos > start
      };
      StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
      StringStream.prototype.skipTo = function (ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {this.pos = found; return true}
      };
      StringStream.prototype.backUp = function (n) {this.pos -= n;};
      StringStream.prototype.column = function () {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
      };
      StringStream.prototype.indentation = function () {
        return countColumn(this.string, null, this.tabSize) -
          (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
      };
      StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) { this.pos += pattern.length; }
            return true
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) { return null }
          if (match && consume !== false) { this.pos += match[0].length; }
          return match
        }
      };
      StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
      StringStream.prototype.hideFirstChars = function (n, inner) {
        this.lineStart += n;
        try { return inner() }
        finally { this.lineStart -= n; }
      };
      StringStream.prototype.lookAhead = function (n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n)
      };
      StringStream.prototype.baseToken = function () {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos)
      };

      // Find the line object corresponding to the given line number.
      function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
        var chunk = doc;
        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i], sz = child.chunkSize();
            if (n < sz) { chunk = child; break }
            n -= sz;
          }
        }
        return chunk.lines[n]
      }

      // Get the part of a document between two positions, as an array of
      // strings.
      function getBetween(doc, start, end) {
        var out = [], n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;
          if (n == end.line) { text = text.slice(0, end.ch); }
          if (n == start.line) { text = text.slice(start.ch); }
          out.push(text);
          ++n;
        });
        return out
      }
      // Get the lines between from and to, as array of strings.
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
        return out
      }

      // Update the height of a line, propagating the height change
      // upwards to parent nodes.
      function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
      }

      // Given a line object, find its line number by walking up through
      // its parent links.
      function lineNo(line) {
        if (line.parent == null) { return null }
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) { break }
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first
      }

      // Find the line at the given vertical position, using the height
      // information in the document tree.
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
            var child = chunk.children[i$1], ch = child.height;
            if (h < ch) { chunk = child; continue outer }
            h -= ch;
            n += child.chunkSize();
          }
          return n
        } while (!chunk.lines)
        var i = 0;
        for (; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i], lh = line.height;
          if (h < lh) { break }
          h -= lh;
        }
        return n + i
      }

      function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber))
      }

      // A Pos instance represents a position within the text.
      function Pos(line, ch, sticky) {
        if ( sticky === void 0 ) sticky = null;

        if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      }

      // Compare two positions, return 0 if they are the same, a negative
      // number when a is less, and a positive number otherwise.
      function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

      function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

      function copyPos(x) {return Pos(x.line, x.ch)}
      function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
      function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

      // Most of the external API clips given positions to make sure they
      // actually exist within the document.
      function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
      function clipPos(doc, pos) {
        if (pos.line < doc.first) { return Pos(doc.first, 0) }
        var last = doc.first + doc.size - 1;
        if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
        return clipToLen(pos, getLine(doc, pos.line).text.length)
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
        else if (ch < 0) { return Pos(pos.line, 0) }
        else { return pos }
      }
      function clipPosArray(doc, array) {
        var out = [];
        for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
        return out
      }

      var SavedContext = function(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };

      var Context = function(doc, state, line, lookAhead) {
        this.state = state;
        this.doc = doc;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };

      Context.prototype.lookAhead = function (n) {
        var line = this.doc.getLine(this.line + n);
        if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
        return line
      };

      Context.prototype.baseToken = function (n) {
        if (!this.baseTokens) { return null }
        while (this.baseTokens[this.baseTokenPos] <= n)
          { this.baseTokenPos += 2; }
        var type = this.baseTokens[this.baseTokenPos + 1];
        return {type: type && type.replace(/( |^)overlay .*/, ""),
                size: this.baseTokens[this.baseTokenPos] - n}
      };

      Context.prototype.nextLine = function () {
        this.line++;
        if (this.maxLookAhead > 0) { this.maxLookAhead--; }
      };

      Context.fromSaved = function (doc, saved, line) {
        if (saved instanceof SavedContext)
          { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
        else
          { return new Context(doc, copyState(doc.mode, saved), line) }
      };

      Context.prototype.save = function (copy) {
        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
      };


      // Compute a style array (an array starting with a mode generation
      // -- for invalidation -- followed by pairs of end positions and
      // style strings), which is used to highlight the tokens on the
      // line.
      function highlightLine(cm, line, context, forceToEnd) {
        // A styles array always starts with a number identifying the
        // mode/overlays that it is based on (for easy invalidation).
        var st = [cm.state.modeGen], lineClasses = {};
        // Compute the base array of styles
        runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
                lineClasses, forceToEnd);
        var state = context.state;

        // Run overlays, adjust style array.
        var loop = function ( o ) {
          context.baseTokens = st;
          var overlay = cm.state.overlays[o], i = 1, at = 0;
          context.state = true;
          runMode(cm, line.text, overlay.mode, context, function (end, style) {
            var start = i;
            // Ensure there's a token end at the current position, and that i points at it
            while (at < end) {
              var i_end = st[i];
              if (i_end > end)
                { st.splice(i, 1, end, st[i+1], i_end); }
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style) { return }
            if (overlay.opaque) {
              st.splice(start, i - start, end, "overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start+1];
                st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };

        for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

        return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
      }

      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);
          if (resetState) { context.state = resetState; }
          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;
          if (result.classes) { line.styleClasses = result.classes; }
          else if (line.styleClasses) { line.styleClasses = null; }
          if (updateFrontier === cm.doc.highlightFrontier)
            { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
        }
        return line.styles
      }

      function getContextBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState) { return new Context(doc, true, n) }
        var start = findStartLine(cm, n, precise);
        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

        doc.iter(start, n, function (line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });
        if (precise) { doc.modeFrontier = context.line; }
        return context
      }

      // Lightweight form of highlight -- proceed over this line and
      // update state, but don't save a style array. Used for lines that
      // aren't currently visible.
      function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text == "") { callBlankLine(mode, context.state); }
        while (!stream.eol()) {
          readToken(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }

      function callBlankLine(mode, state) {
        if (mode.blankLine) { return mode.blankLine(state) }
        if (!mode.innerMode) { return }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
      }

      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner) { inner[0] = innerMode(mode, state).mode; }
          var style = mode.token(stream, state);
          if (stream.pos > stream.start) { return style }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.")
      }

      var Token = function(stream, type, state) {
        this.start = stream.start; this.end = stream.pos;
        this.string = stream.current();
        this.type = type || null;
        this.state = state;
      };

      // Utility for getTokenAt and getLineTokens
      function takeToken(cm, pos, precise, asArray) {
        var doc = cm.doc, mode = doc.mode, style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray) { tokens = []; }
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, context.state);
          if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
        }
        return asArray ? tokens : new Token(stream, style, context.state)
      }

      function extractLineClasses(type, output) {
        if (type) { for (;;) {
          var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) { break }
          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
          var prop = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop] == null)
            { output[prop] = lineClass[2]; }
          else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
            { output[prop] += " " + lineClass[2]; }
        } }
        return type
      }

      // Run the given mode's parser over a line, calling f for each token.
      function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context), style;
        var inner = cm.options.addModeClass && [null];
        if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) { processLine(cm, text, context, stream.pos); }
            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5000);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          // Webkit seems to refuse to render text nodes longer than 57444
          // characters, and returns inaccurate measurements in nodes
          // starting around 5000 chars.
          var pos = Math.min(stream.pos, curStart + 5000);
          f(pos, curStyle);
          curStart = pos;
        }
      }

      // Finds the line to start with when starting a parse. Tries to
      // find a line with a stateAfter, so that it can start with a
      // valid state. If that fails, it returns the line with the
      // smallest indentation, which tends to need the least context to
      // parse correctly.
      function findStartLine(cm, n, precise) {
        var minindent, minline, doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first) { return doc.first }
          var line = getLine(doc, search - 1), after = line.stateAfter;
          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
            { return search }
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline
      }

      function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);
        if (doc.highlightFrontier < n - 10) { return }
        var start = doc.first;
        for (var line = n - 1; line > start; line--) {
          var saved = getLine(doc, line).stateAfter;
          // change is on 3
          // state on line 1 looked ahead 2 -- so saw 3
          // test 1 + 2 < 3 should cover this
          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
            start = line + 1;
            break
          }
        }
        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
      }

      // Optimize some code when these features are not used.
      var sawReadOnlySpans = false, sawCollapsedSpans = false;

      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }

      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      }

      // TEXTMARKER SPANS

      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from; this.to = to;
      }

      // Search an array of spans for a span matching the given marker.
      function getMarkedSpanFor(spans, marker) {
        if (spans) { for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.marker == marker) { return span }
        } }
      }
      // Remove a span from an array, returning undefined if no spans are
      // left (we don't store arrays for lines without spans).
      function removeMarkedSpan(spans, span) {
        var r;
        for (var i = 0; i < spans.length; ++i)
          { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
        return r
      }
      // Add a span to a line.
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }

      // Used for the algorithm that adjusts markers for a change in the
      // document. These functions cut an array of spans at a given
      // character position, returning an array of remaining chunks (or
      // undefined if nothing remains).
      function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) { for (var i = 0; i < old.length; ++i) {
          var span = old[i], marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
            ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
          }
        } }
        return nw
      }
      function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) { for (var i = 0; i < old.length; ++i) {
          var span = old[i], marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
            ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                                  span.to == null ? null : span.to - endCh));
          }
        } }
        return nw
      }

      // Given a change object, compute the new set of marker spans that
      // cover the line in which the change took place. Removes spans
      // entirely within the change, reconnects spans belonging to the
      // same marker that appear on both sides of the change, and cuts off
      // spans partially within the change. Returns an array of span
      // arrays with one element for each line in (after) the change.
      function stretchSpansOverChange(doc, change) {
        if (change.full) { return null }
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) { return null }

        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        // Get the spans that 'stick out' on both sides
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);

        // Next, merge those two ends
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          // Fix up .to properties of first
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) { span.to = startCh; }
              else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
            }
          }
        }
        if (last) {
          // Fix up .from in last (or move them into first in case of sameLine)
          for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];
            if (span$1.to != null) { span$1.to += offset; }
            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);
              if (!found$1) {
                span$1.from = offset;
                if (sameLine) { (first || (first = [])).push(span$1); }
              }
            } else {
              span$1.from += offset;
              if (sameLine) { (first || (first = [])).push(span$1); }
            }
          }
        }
        // Make sure we didn't create any zero-length spans
        if (first) { first = clearEmptySpans(first); }
        if (last && last != first) { last = clearEmptySpans(last); }

        var newMarkers = [first];
        if (!sameLine) {
          // Fill gap with whole-line-spans
          var gap = change.text.length - 2, gapMarkers;
          if (gap > 0 && first)
            { for (var i$2 = 0; i$2 < first.length; ++i$2)
              { if (first[i$2].to == null)
                { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
          for (var i$3 = 0; i$3 < gap; ++i$3)
            { newMarkers.push(gapMarkers); }
          newMarkers.push(last);
        }
        return newMarkers
      }

      // Remove spans that are empty and don't have a clearWhenEmpty
      // option of false.
      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
            { spans.splice(i--, 1); }
        }
        if (!spans.length) { return null }
        return spans
      }

      // Used to 'clip' out readOnly ranges when making a change.
      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
            var mark = line.markedSpans[i].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
              { (markers || (markers = [])).push(mark); }
          } }
        });
        if (!markers) { return null }
        var parts = [{from: from, to: to}];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i], m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
            var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
              { newParts.push({from: p.from, to: m.from}); }
            if (dto > 0 || !mk.inclusiveRight && !dto)
              { newParts.push({from: m.to, to: p.to}); }
            parts.splice.apply(parts, newParts);
            j += newParts.length - 3;
          }
        }
        return parts
      }

      // Connect or disconnect spans from a line.
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) { return }
        for (var i = 0; i < spans.length; ++i)
          { spans[i].marker.detachLine(line); }
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans) { return }
        for (var i = 0; i < spans.length; ++i)
          { spans[i].marker.attachLine(line); }
        line.markedSpans = spans;
      }

      // Helpers used when computing which overlapping collapsed span
      // counts as the larger one.
      function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
      function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

      // Returns a number indicating which of two overlapping collapsed
      // spans is larger (and thus includes the other). Falls back to
      // comparing ids when the spans cover exactly the same range.
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0) { return lenDiff }
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) { return -fromCmp }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp) { return toCmp }
        return b.id - a.id
      }

      // Find out whether a line ends or starts in a collapsed span. If
      // so, return the marker for that span.
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
              (!found || compareCollapsedMarkers(found, sp.marker) < 0))
            { found = sp.marker; }
        } }
        return found
      }
      function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
      function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) { for (var i = 0; i < sps.length; ++i) {
          var sp = sps[i];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
              (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
        } }
        return found
      }

      // Test whether there exists a collapsed span that partially
      // overlaps (covers the start or end, but not both) of a new span.
      // Such overlap is not allowed.
      function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
        var line = getLine(doc, lineNo$$1);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i) {
          var sp = sps[i];
          if (!sp.marker.collapsed) { continue }
          var found = sp.marker.find(0);
          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
              fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
            { return true }
        } }
      }

      // A visual line is a line as drawn on the screen. Folding, for
      // example, can cause multiple logical lines to appear on the same
      // visual line. This finds the start of the visual line that the
      // given line is part of (usually that is the line itself).
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line))
          { line = merged.find(-1, true).line; }
        return line
      }

      function visualLineEnd(line) {
        var merged;
        while (merged = collapsedSpanAtEnd(line))
          { line = merged.find(1, true).line; }
        return line
      }

      // Returns an array of logical lines that continue the visual line
      // started by the argument, or undefined if there are no such lines.
      function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line
          ;(lines || (lines = [])).push(line);
        }
        return lines
      }

      // Get the line number of the start of the visual line that the
      // given line number is part of.
      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        if (line == vis) { return lineN }
        return lineNo(vis)
      }

      // Get the line number of the start of the next visual line after
      // the given line.
      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) { return lineN }
        var line = getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line)) { return lineN }
        while (merged = collapsedSpanAtEnd(line))
          { line = merged.find(1, true).line; }
        return lineNo(line) + 1
      }

      // Compute whether a line is hidden. Lines count as hidden when they
      // are part of a visual line that starts with another line, or when
      // they are entirely covered by collapsed, non-widget span.
      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (!sp.marker.collapsed) { continue }
          if (sp.from == null) { return true }
          if (sp.marker.widgetNode) { continue }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
            { return true }
        } }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
          { return true }
        for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
              (sp.to == null || sp.to != span.from) &&
              (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
              lineIsHiddenInner(doc, line, sp)) { return true }
        }
      }

      // Find the height above the given line.
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);

        var h = 0, chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj) { break }
          else { h += line.height; }
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];
            if (cur == chunk) { break }
            else { h += cur.height; }
          }
        }
        return h
      }

      // Compute the character length of a line, taking into account
      // collapsed ranges (see markText) that might hide parts, and join
      // other lines onto it.
      function lineLength(line) {
        if (line.height == 0) { return 0 }
        var len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }
        return len
      }

      // Find the longest line in the document.
      function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }

      // LINE DATA STRUCTURE

      // Line objects. These hold state related to a line, including
      // highlighting info (the styles array).
      var Line = function(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };

      Line.prototype.lineNo = function () { return lineNo(this) };
      eventMixin(Line);

      // Change the content (text, markers) of a line. Automatically
      // invalidates cached information and tries to re-estimate the
      // line's height.
      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter) { line.stateAfter = null; }
        if (line.styles) { line.styles = null; }
        if (line.order != null) { line.order = null; }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height) { updateLineHeight(line, estHeight); }
      }

      // Detach a line from the document tree and its markers.
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }

      // Convert a style as returned by a mode (either null, or a string
      // containing one or more styles) to a CSS style. This is cached,
      // and also looks for line-wide styles.
      var styleToClassCache = {}, styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) { return null }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] ||
          (cache[style] = style.replace(/\S+/g, "cm-$&"))
      }

      // Render the DOM representation of the text of a line. Also builds
      // up a 'line map', which points at the DOM nodes that represent
      // specific stretches of text, and is used by the measuring code.
      // The returned object contains the DOM node, this map, and
      // information about line-wide styles that were set by the mode.
      function buildLineContent(cm, lineView) {
        // The padding-right forces the element to have a 'border', which
        // is needed on Webkit to be able to get line-level bounding
        // rectangles for it (in measureChar).
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                       col: 0, pos: 0, cm: cm,
                       trailingSpace: false,
                       splitSpaces: cm.getOption("lineWrapping")};
        lineView.measure = {};

        // Iterate over the logical lines that make up this visual line.
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
          builder.pos = 0;
          builder.addToken = buildToken;
          // Optionally wire in some hacks into the token-rendering
          // algorithm, to deal with browser quirks.
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
            { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass)
              { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
            if (line.styleClasses.textClass)
              { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
          }

          // Ensure at least a single node is present, for measuring.
          if (builder.map.length == 0)
            { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

          // Store the map and a cache object for the current logical line
          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
            ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }

        // See issue #2901
        if (webkit) {
          var last = builder.content.lastChild;
          if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
            { builder.content.className = "cm-tab-wrap-hack"; }
        }

        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className)
          { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

        return builder
      }

      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token
      }

      // Build up the DOM representation for a single token, and add it to
      // the line map. Takes care to render special characters separately.
      function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) { return }
        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars, mustWrap = false;
        var content;
        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);
          if (ie && ie_version < 9) { mustWrap = true; }
          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
              else { content.appendChild(txt); }
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m) { break }
            pos += skipped + 1;
            var txt$1 = (void 0);
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
              else { content.appendChild(txt$1); }
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }
        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css) {
          var fullStyle = style || "";
          if (startStyle) { fullStyle += startStyle; }
          if (endStyle) { fullStyle += endStyle; }
          var token = elt("span", [content], fullStyle, css);
          if (attributes) {
            for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
              { token.setAttribute(attr, attributes[attr]); } }
          }
          return builder.content.appendChild(token)
        }
        builder.content.appendChild(content);
      }

      // Change some spaces to NBSP to prevent the browser from collapsing
      // trailing spaces at the end of a line when rendering text (issue #1362).
      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) { return text }
        var spaceBefore = trailingBefore, result = "";
        for (var i = 0; i < text.length; i++) {
          var ch = text.charAt(i);
          if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
            { ch = "\u00a0"; }
          result += ch;
          spaceBefore = ch == " ";
        }
        return result
      }

      // Work around nonsense dimensions being reported for stretches of
      // right-to-left text.
      function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos, end = start + text.length;
          for (;;) {
            // Find the part that overlaps with the start of this text
            var part = (void 0);
            for (var i = 0; i < order.length; i++) {
              part = order[i];
              if (part.to > start && part.from <= start) { break }
            }
            if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
            inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        }
      }

      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget)
            { widget = builder.content.appendChild(document.createElement("span")); }
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
      }

      // Outputs a number of spans to make up a line, taking highlighting
      // and marked text into account.
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
          for (var i$1 = 1; i$1 < styles.length; i$1+=2)
            { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
          return
        }

        var len = allText.length, pos = 0, i = 1, text = "", style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for (;;) {
          if (nextChange == pos) { // Update current marker set
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null; nextChange = Infinity;
            var foundBookmarks = [], endStyles = (void 0);
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j], m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className) { spanStyle += " " + m.className; }
                if (m.css) { css = (css ? css + ";" : "") + m.css; }
                if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
                if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
                // support for the old title property
                // https://github.com/codemirror/CodeMirror/pull/5673
                if (m.title) { (attributes || (attributes = {})).title = m.title; }
                if (m.attributes) {
                  for (var attr in m.attributes)
                    { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
                }
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                  { collapsed = sp; }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
              { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

            if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
              { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                                 collapsed.marker, collapsed.from == null);
              if (collapsed.to == null) { return }
              if (collapsed.to == pos) { collapsed = false; }
            }
          }
          if (pos >= len) { break }

          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                                 spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
              }
              if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      }


      // These objects are used to represent the visible (currently drawn)
      // part of the document. A LineView may correspond to multiple
      // logical lines, if those are connected by collapsed ranges.
      function LineView(doc, line, lineN) {
        // The starting line
        this.line = line;
        // Continuing lines, if any
        this.rest = visualLineContinued(line);
        // Number of logical lines in this visual line
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      }

      // Create a range of LineView objects for the given lines.
      function buildViewArray(cm, from, to) {
        var array = [], nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array
      }

      var operationGroup = null;

      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }

      function fireCallbacksForOps(group) {
        // Calls delayed callbacks and cursorActivity handlers until no
        // new ones appear
        var callbacks = group.delayedCallbacks, i = 0;
        do {
          for (; i < callbacks.length; i++)
            { callbacks[i].call(null); }
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers)
              { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
          }
        } while (i < callbacks.length)
      }

      function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) { return }

        try { fireCallbacksForOps(group); }
        finally {
          operationGroup = null;
          endCb(group);
        }
      }

      var orphanDelayedCallbacks = null;

      // Often, we want to signal events at a point where we are in the
      // middle of some work, but don't want the handler to start calling
      // other methods on the editor, which might be in an inconsistent
      // state or simply not expect any other events to happen.
      // signalLater looks whether there are any handlers, and schedules
      // them to be executed when the last operation ends, or, if no
      // operation is active, when a timeout fires.
      function signalLater(emitter, type /*, values...*/) {
        var arr = getHandlers(emitter, type);
        if (!arr.length) { return }
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function ( i ) {
          list.push(function () { return arr[i].apply(null, args); });
        };

        for (var i = 0; i < arr.length; ++i)
          loop( i );
      }

      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
      }

      // When an aspect of a line changes, a string is added to
      // lineView.changes. This updates the relevant part of the line's
      // DOM structure.
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];
          if (type == "text") { updateLineText(cm, lineView); }
          else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
          else if (type == "class") { updateLineClasses(cm, lineView); }
          else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
        }
        lineView.changes = null;
      }

      // Lines with gutter elements, widgets or a background class need to
      // be wrapped, and have the extra elements added to the wrapper div
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode)
            { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
        }
        return lineView.node
      }

      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) { cls += " CodeMirror-linebackground"; }
        if (lineView.background) {
          if (cls) { lineView.background.className = cls; }
          else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      }

      // Wrapper around buildLineContent which will reuse the structure
      // in display.externalMeasured when possible.
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built
        }
        return buildLineContent(cm, lineView)
      }

      // Redraw the line's text. Interacts with the background and text
      // classes because the mode may output tokens that influence these
      // classes.
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) { lineView.node = built.pre; }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }

      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass)
          { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
        else if (lineView.node != lineView.text)
          { lineView.node.className = ""; }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }

      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                          ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass)
            { gutterWrap.className += " " + lineView.line.gutterClass; }
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
            { lineView.lineNumber = gutterWrap.appendChild(
              elt("div", lineNumberFor(cm.options, lineN),
                  "CodeMirror-linenumber CodeMirror-gutter-elt",
                  ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
          if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
            var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
            if (found)
              { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                         ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
          } }
        }
      }

      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) { lineView.alignable = null; }
        for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
          next = node.nextSibling;
          if (node.className == "CodeMirror-linewidget")
            { lineView.node.removeChild(node); }
        }
        insertLineWidgets(cm, lineView, dims);
      }

      // Build a line's DOM representation from scratch
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) { lineView.bgClass = built.bgClass; }
        if (built.textClass) { lineView.textClass = built.textClass; }

        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node
      }

      // A lineView may contain multiple logical lines (when merged by
      // collapsed spans). The widgets for all of them need to be drawn.
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
          { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
      }

      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) { return }
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above)
            { wrap.insertBefore(node, lineView.gutter || lineView.text); }
          else
            { wrap.appendChild(node); }
          signalLater(widget, "redraw");
        }
      }

      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
        }
      }

      function widgetHeight(widget) {
        if (widget.height != null) { return widget.height }
        var cm = widget.doc.cm;
        if (!cm) { return 0 }
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter)
            { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
          if (widget.noHScroll)
            { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight
      }

      // Return true when the given mouse event happened in a widget
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
              (n.parentNode == display.sizer && n != display.mover))
            { return true }
        }
      }

      // POSITION MEASUREMENT

      function paddingTop(display) {return display.lineSpace.offsetTop}
      function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
      function paddingH(display) {
        if (display.cachedPaddingH) { return display.cachedPaddingH }
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
        if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
        return data
      }

      function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
      }

      // Ensure the lineView.wrapping.heights array is populated. This is
      // an array of bottom offsets for the lines that make up a drawn
      // line. When lineWrapping is on, there might be more than one
      // height.
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i], next = rects[i + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2)
                { heights.push((cur.bottom + next.top) / 2 - rect.top); }
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }

      // Find a line map (mapping character offsets to text nodes) and a
      // measurement cache for the given line number. (A line view might
      // contain multiple lines when collapsed ranges are present.)
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
          { return {map: lineView.measure.map, cache: lineView.measure.cache} }
        for (var i = 0; i < lineView.rest.length; i++)
          { if (lineView.rest[i] == line)
            { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
          { if (lineNo(lineView.rest[i$1]) > lineN)
            { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
      }

      // Render a line into the hidden node display.externalMeasured. Used
      // when measurement is needed for a line that's not in the viewport.
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view
      }

      // Get a {top, bottom, left, right} box (in line-local coordinates)
      // for a given character.
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
      }

      // Find a line view that corresponds to the given line number.
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
          { return cm.display.view[findViewIndex(cm, lineN)] }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
          { return ext }
      }

      // Measurement can be split in two steps, the set-up work that
      // applies to the whole line, and the measurement of the actual
      // character. Functions like coordsChar, that need to do a lot of
      // measurements in a row, can thus ensure that the set-up work is
      // only done once.
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view)
          { view = updateExternalMeasurement(cm, line); }

        var info = mapFromLineView(view, line, lineN);
        return {
          line: line, view: view, rect: null,
          map: info.map, cache: info.cache, before: info.before,
          hasHeights: false
        }
      }

      // Given a prepared measurement object, measures the position of an
      // actual character (or fetches it from the cache).
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) { ch = -1; }
        var key = ch + (bias || ""), found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect)
            { prepared.rect = prepared.view.text.getBoundingClientRect(); }
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus) { prepared.cache[key] = found; }
        }
        return {left: found.left, right: found.right,
                top: varHeight ? found.rtop : found.top,
                bottom: varHeight ? found.rbottom : found.bottom}
      }

      var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

      function nodeAndOffsetInLineMap(map$$1, ch, bias) {
        var node, start, end, collapse, mStart, mEnd;
        // First, search the line map for the text node corresponding to,
        // or closest to, the target character.
        for (var i = 0; i < map$$1.length; i += 3) {
          mStart = map$$1[i];
          mEnd = map$$1[i + 1];
          if (ch < mStart) {
            start = 0; end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd) { collapse = "right"; }
          }
          if (start != null) {
            node = map$$1[i + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
              { collapse = bias; }
            if (bias == "left" && start == 0)
              { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
                node = map$$1[(i -= 3) + 2];
                collapse = "left";
              } }
            if (bias == "right" && start == mEnd - mStart)
              { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
                node = map$$1[(i += 3) + 2];
                collapse = "right";
              } }
            break
          }
        }
        return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
      }

      function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") { for (var i = 0; i < rects.length; i++) {
          if ((rect = rects[i]).left != rect.right) { break }
        } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
          if ((rect = rects[i$1]).left != rect.right) { break }
        } }
        return rect
      }

      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

        var rect;
        if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
          for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
              { rect = node.parentNode.getBoundingClientRect(); }
            else
              { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
            if (rect.left || rect.right || start == 0) { break }
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
        } else { // If it is a widget, simply get the box for the whole widget.
          if (start > 0) { collapse = bias = "right"; }
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
            { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
          else
            { rect = node.getBoundingClientRect(); }
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan)
            { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
          else
            { rect = nullRect; }
        }

        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i = 0;
        for (; i < heights.length - 1; i++)
          { if (mid < heights[i]) { break } }
        var top = i ? heights[i - 1] : 0, bot = heights[i];
        var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                      top: top, bottom: bot};
        if (!rect.left && !rect.right) { result.bogus = true; }
        if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

        return result
      }

      // Work around problem with bounding client rects on ranges being
      // returned incorrectly when zoomed on IE10 and below.
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null ||
            screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
          { return rect }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {left: rect.left * scaleX, right: rect.right * scaleX,
                top: rect.top * scaleY, bottom: rect.bottom * scaleY}
      }

      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
            { lineView.measure.caches[i] = {}; } }
        }
      }

      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
          { clearLineMeasurementCacheFor(cm.display.view[i]); }
      }

      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
        cm.display.lineNumChars = null;
      }

      function pageScrollX() {
        // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
        // which causes page_Offset and bounding client rects to use
        // different reference viewports and invalidate our calculations.
        if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft
      }
      function pageScrollY() {
        if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
        return window.pageYOffset || (document.documentElement || document.body).scrollTop
      }

      function widgetTopHeight(lineObj) {
        var height = 0;
        if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
          { height += widgetHeight(lineObj.widgets[i]); } } }
        return height
      }

      // Converts a {top, bottom, left, right} box from line-local
      // coordinates into another coordinate system. Context may be one of
      // "line", "div" (display.lineDiv), "local"./null (editor), "window",
      // or "page".
      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height; rect.bottom += height;
        }
        if (context == "line") { return rect }
        if (!context) { context = "local"; }
        var yOff = heightAtLine(lineObj);
        if (context == "local") { yOff += paddingTop(cm.display); }
        else { yOff -= cm.display.viewOffset; }
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff; rect.right += xOff;
        }
        rect.top += yOff; rect.bottom += yOff;
        return rect
      }

      // Coverts a box from "div" coords to another coordinate system.
      // Context may be "window", "page", "div", or "local"./null.
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") { return coords }
        var left = coords.left, top = coords.top;
        // First move into "page" coordinate system
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }

        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
      }

      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
      }

      // Returns a box for a given cursor position, which may have an
      // 'other' property containing the position of the secondary cursor
      // on a bidi boundary.
      // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
      // and after `char - 1` in writing order of `char - 1`
      // A cursor Pos(line, char, "after") is on the same visual line as `char`
      // and before `char` in writing order of `char`
      // Examples (upper-case letters are RTL, lower-case are LTR):
      //     Pos(0, 1, ...)
      //     before   after
      // ab     a|b     a|b
      // aB     a|B     aB|
      // Ab     |Ab     A|b
      // AB     B|A     B|A
      // Every position after the last character on a line is considered to stick
      // to the last character on the line.
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
          if (right) { m.left = m.right; } else { m.right = m.left; }
          return intoCoordSystem(cm, lineObj, m, context)
        }
        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }
        if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

        function getBidi(ch, partPos, invert) {
          var part = order[partPos], right = part.level == 1;
          return get(invert ? ch - 1 : ch, right != invert)
        }
        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");
        if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
        return val
      }

      // Used to cheaply estimate the coordinates for a position. Used for
      // intermediate scroll updates.
      function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {left: left, right: left, top: top, bottom: top + lineObj.height}
      }

      // Positions returned by coordsChar contain some extra information.
      // xRel is the relative x position of the input coordinates compared
      // to the found position (so xRel > 0 means the coordinates are to
      // the right of the character position, for example). When outside
      // is true, that means the coordinates lie outside the line's
      // vertical range.
      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside) { pos.outside = true; }
        return pos
      }

      // Compute the character position closest to the given coordinates.
      // Input must be lineSpace-local ("div" coordinate system).
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last)
          { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
        if (x < 0) { x = 0; }

        var lineObj = getLine(doc, lineN);
        for (;;) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));
          if (!collapsed) { return found }
          var rangeEnd = collapsed.find(1);
          if (rangeEnd.line == lineN) { return rangeEnd }
          lineObj = getLine(doc, lineN = rangeEnd.line);
        }
      }

      function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
        end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
        return {begin: begin, end: end}
      }

      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
      }

      // Returns true if the given side of a box is after the given
      // coordinates, in top-to-bottom, left-to-right order.
      function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
      }

      function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
        // Move y into line-local coordinate space
        y -= heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        // When directly calling `measureCharPrepared`, we have to adjust
        // for the widgets at this line.
        var widgetHeight$$1 = widgetTopHeight(lineObj);
        var begin = 0, end = lineObj.text.length, ltr = true;

        var order = getOrder(lineObj, cm.doc.direction);
        // If the line isn't plain left-to-right text, first figure out
        // which bidi section the coordinates fall into.
        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                       (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
          ltr = part.level != 1;
          // The awkward -1 offsets are needed because findFirst (called
          // on these below) will treat its first bound as inclusive,
          // second as exclusive, but we want to actually address the
          // characters in the part's range
          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        }

        // A binary search to find the first character whose bounding box
        // starts after the coordinates. If we run across any whose box wrap
        // the coordinates, store that.
        var chAround = null, boxAround = null;
        var ch = findFirst(function (ch) {
          var box = measureCharPrepared(cm, preparedMeasure, ch);
          box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
          if (!boxIsAfter(box, x, y, false)) { return false }
          if (box.top <= y && box.left <= x) {
            chAround = ch;
            boxAround = box;
          }
          return true
        }, begin, end);

        var baseX, sticky, outside = false;
        // If a box around the coordinates was found, use that
        if (boxAround) {
          // Distinguish coordinates nearer to the left or right side of the box
          var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          // (Adjust for extended bound, if necessary.)
          if (!ltr && (ch == end || ch == begin)) { ch++; }
          // To determine which side to associate with, get the box to the
          // left of the character and compare it's vertical position to the
          // coordinates
          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
            (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
            "after" : "before";
          // Now get accurate coordinates for this place, in order to get a
          // base X position
          var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
          baseX = coords.left;
          outside = y < coords.top || y >= coords.bottom;
        }

        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
      }

      function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
        // Bidi parts are sorted left-to-right, and in a non-line-wrapping
        // situation, we can take this ordering to correspond to the visual
        // ordering. This finds the first part whose end is after the given
        // coordinates.
        var index = findFirst(function (i) {
          var part = order[i], ltr = part.level != 1;
          return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                         "line", lineObj, preparedMeasure), x, y, true)
        }, 0, order.length - 1);
        var part = order[index];
        // If this isn't the first part, the part's start is also after
        // the coordinates, and the coordinates aren't on the same line as
        // that start, move one part back.
        if (index > 0) {
          var ltr = part.level != 1;
          var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                                   "line", lineObj, preparedMeasure);
          if (boxIsAfter(start, x, y, true) && start.top > y)
            { part = order[index - 1]; }
        }
        return part
      }

      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        // In a wrapped line, rtl text on wrapping boundaries can do things
        // that don't correspond to the ordering in our `order` array at
        // all, so a binary search doesn't work, and we want to return a
        // part that only spans one line so that the binary search in
        // coordsCharInner is safe. As such, we first find the extent of the
        // wrapped line, and then do a flat search in which we discard any
        // spans that aren't on the line.
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;
        if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
        var part = null, closestDist = null;
        for (var i = 0; i < order.length; i++) {
          var p = order[i];
          if (p.from >= end || p.to <= begin) { continue }
          var ltr = p.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
          // Weigh against spans ending before this, so that they are only
          // picked if nothing ends after
          var dist = endX < x ? x - endX + 1e9 : endX - x;
          if (!part || closestDist > dist) {
            part = p;
            closestDist = dist;
          }
        }
        if (!part) { part = order[order.length - 1]; }
        // Clip the part to the wrapped line.
        if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
        if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
        return part
      }

      var measureText;
      // Compute the default text height.
      function textHeight(display) {
        if (display.cachedTextHeight != null) { return display.cachedTextHeight }
        if (measureText == null) {
          measureText = elt("pre");
          // Measure a bunch of lines, for browsers that compute
          // fractional heights.
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) { display.cachedTextHeight = height; }
        removeChildren(display.measure);
        return height || 1
      }

      // Compute the default character width.
      function charWidth(display) {
        if (display.cachedCharWidth != null) { return display.cachedCharWidth }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2) { display.cachedCharWidth = width; }
        return width || 10
      }

      // Do a bulk-read of the DOM positions and sizes needed to draw the
      // view, so that we don't interleave reading and writing to the DOM.
      function getDimensions(cm) {
        var d = cm.display, left = {}, width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          var id = cm.display.gutterSpecs[i].className;
          left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[id] = n.clientWidth;
        }
        return {fixedPos: compensateForHScroll(d),
                gutterTotalWidth: d.gutters.offsetWidth,
                gutterLeft: left,
                gutterWidth: width,
                wrapperWidth: d.wrapper.clientWidth}
      }

      // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
      // but using getBoundingClientRect to get a sub-pixel-accurate
      // result.
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
      }

      // Returns a function that estimates the height of a line, to use as
      // first approximation until the line becomes visible (and is thus
      // properly measurable).
      function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) { return 0 }

          var widgetsHeight = 0;
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
            if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
          } }

          if (wrapping)
            { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
          else
            { return widgetsHeight + th }
        }
      }

      function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);
          if (estHeight != line.height) { updateLineHeight(line, estHeight); }
        });
      }

      // Given a mouse event, find the corresponding position. If liberal
      // is false, it checks whether a gutter or scrollbar was clicked,
      // and returns null if it was. forRect is used by rectangular
      // selections, and tries to estimate a character position even for
      // coordinates beyond the right of the text.
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

        var x, y, space = display.lineSpace.getBoundingClientRect();
        // Fails unpredictably on IE[67] when mouse is dragged around quickly.
        try { x = e.clientX - space.left; y = e.clientY - space.top; }
        catch (e) { return null }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords
      }

      // Find the view element corresponding to a given line. Return null
      // when the line isn't visible.
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) { return null }
        n -= cm.display.viewFrom;
        if (n < 0) { return null }
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;
          if (n < 0) { return i }
        }
      }

      // Updates the display.view data structure for a given change to the
      // document. From and to are in pre-change coordinates. Lendiff is
      // the amount of lines added or subtracted by the change. This is
      // used for changes that span multiple lines, or change the way
      // lines are divided into visual lines. regLineChange (below)
      // registers single-line changes.
      function regChange(cm, from, to, lendiff) {
        if (from == null) { from = cm.doc.first; }
        if (to == null) { to = cm.doc.first + cm.doc.size; }
        if (!lendiff) { lendiff = 0; }

        var display = cm.display;
        if (lendiff && to < display.viewTo &&
            (display.updateLineNumbers == null || display.updateLineNumbers > from))
          { display.updateLineNumbers = from; }

        cm.curOp.viewChanged = true;

        if (from >= display.viewTo) { // Change after
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
            { resetView(cm); }
        } else if (to <= display.viewFrom) { // Change before
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
          resetView(cm);
        } else if (from <= display.viewFrom) { // Top overlap
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) { // Bottom overlap
          var cut$1 = viewCuttingPoint(cm, from, from, -1);
          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else { // Gap in the middle
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index)
              .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
              .concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }

        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN)
            { ext.lineN += lendiff; }
          else if (from < ext.lineN + ext.size)
            { display.externalMeasured = null; }
        }
      }

      // Register a change to a single line. Type must be one of "text",
      // "gutter", "class", "widget"
      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
          { display.externalMeasured = null; }

        if (line < display.viewFrom || line >= display.viewTo) { return }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) { return }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1) { arr.push(type); }
      }

      // Clear the view.
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }

      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
          { return {index: index, lineN: newN} }
        var n = cm.display.viewFrom;
        for (var i = 0; i < index; i++)
          { n += view[i].size; }
        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1) { return null }
            diff = (n + view[index].size) - oldN;
            index++;
          } else {
            diff = n - oldN;
          }
          oldN += diff; newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }
        return {index: index, lineN: newN}
      }

      // Force the view to cover a given range, adding empty view element
      // or clipping off existing ones as needed.
      function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from)
            { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
          else if (display.viewFrom < from)
            { display.view = display.view.slice(findViewIndex(cm, from)); }
          display.viewFrom = from;
          if (display.viewTo < to)
            { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
          else if (display.viewTo > to)
            { display.view = display.view.slice(0, findViewIndex(cm, to)); }
        }
        display.viewTo = to;
      }

      // Count the number of lines in the view whose DOM representation is
      // out of date (or nonexistent).
      function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
        }
        return dirty
      }

      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }

      function prepareSelection(cm, primary) {
        if ( primary === void 0 ) primary = true;

        var doc = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (!primary && i == doc.sel.primIndex) { continue }
          var range$$1 = doc.sel.ranges[i];
          if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
          var collapsed = range$$1.empty();
          if (collapsed || cm.options.showCursorWhenSelecting)
            { drawSelectionCursor(cm, range$$1.head, curFragment); }
          if (!collapsed)
            { drawSelectionRange(cm, range$$1, selFragment); }
        }
        return result
      }

      // Draws a cursor for the given range
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

        var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

        if (pos.other) {
          // Secondary cursor, shown when on a 'jump' in bi-directional text
          var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }

      function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

      // Draws the given range as a highlighted selection
      function drawSelectionRange(cm, range$$1, output) {
        var display = cm.display, doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc.direction == "ltr";

        function add(left, top, width, bottom) {
          if (top < 0) { top = 0; }
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
        }

        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
          }

          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop)[prop]
          }

          var order = getOrder(lineObj, doc.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
            var ltr = dir == "ltr";
            var fromPos = coords(from, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");

            var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
            var first = i == 0, last = !order || i == order.length - 1;
            if (toPos.top - fromPos.top <= 3) { // Single line
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add(left, fromPos.top, right - left, fromPos.bottom);
            } else { // Multiple lines
              var topLeft, topRight, botLeft, botRight;
              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }
              add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
              if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
              add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }

            if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
            if (cmpCoords(toPos, start) < 0) { start = toPos; }
            if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
            if (cmpCoords(toPos, end) < 0) { end = toPos; }
          });
          return {start: start, end: end}
        }

        var sFrom = range$$1.from(), sTo = range$$1.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top)
            { add(leftSide, leftEnd.bottom, null, rightStart.top); }
        }

        output.appendChild(fragment);
      }

      // Cursor-blinking
      function restartBlink(cm) {
        if (!cm.state.focused) { return }
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0)
          { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
            cm.options.cursorBlinkRate); }
        else if (cm.options.cursorBlinkRate < 0)
          { display.cursorDiv.style.visibility = "hidden"; }
      }

      function ensureFocus(cm) {
        if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
      }

      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function () { if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          onBlur(cm);
        } }, 100);
      }

      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

        if (cm.options.readOnly == "nocursor") { return }
        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          // This test prevents this from firing when a context
          // menu is closed (since the input reset would kill the
          // select-all detection hack)
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) { return }

        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
      }

      // Read the actual heights of the rendered lines, and update their
      // stored heights to match.
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i], wrapping = cm.options.lineWrapping;
          var height = (void 0), width = 0;
          if (cur.hidden) { continue }
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
            // Check that lines don't extend past the right of the current
            // editor width
            if (!wrapping && cur.text.firstChild)
              { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
          }
          var diff = cur.line.height - height;
          if (diff > .005 || diff < -.005) {
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
              { updateWidgetHeight(cur.rest[j]); } }
          }
          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));
            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }
      }

      // Read and store the height of line widgets associated with the
      // given line.
      function updateWidgetHeight(line) {
        if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
          var w = line.widgets[i], parent = w.node.parentNode;
          if (parent) { w.height = parent.offsetHeight; }
        } }
      }

      // Compute the lines that are visible in a given viewport (defaults
      // the the current scroll position). viewport may contain top,
      // height, and ensure (see op.scrollToPos) properties.
      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
        // forces those lines into the viewport (if possible).
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return {from: from, to: Math.max(to, from + 1)}
      }

      // SCROLLING THINGS INTO VIEW

      // If an editor sits on the top or bottom of the window, partially
      // scrolled out of view, this ensures that the cursor is visible.
      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (rect.top + box.top < 0) { doScroll = true; }
        else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }

      // Scroll a given position into view (immediately), verifying that
      // it actually became visible (as line heights are accurately
      // measured, the position of something may 'drift' during drawing).
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) { margin = 0; }
        var rect;
        if (!cm.options.lineWrapping && pos == end) {
          // Set pos and end to the cursor positions around the character pos sticks to
          // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
          // If pos == Pos(_, 0, "before"), pos and end are unchanged
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        }
        for (var limit = 0; limit < 5; limit++) {
          var changed = false;
          var coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          rect = {left: Math.min(coords.left, endCoords.left),
                  top: Math.min(coords.top, endCoords.top) - margin,
                  right: Math.max(coords.left, endCoords.left),
                  bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
          }
          if (!changed) { break }
        }
        return rect
      }

      // Scroll a given set of coordinates into view (immediately).
      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
        if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
      }

      // Calculate a new scroll position needed to scroll the given
      // rectangle into view. Returns an object with scrollTop and
      // scrollLeft properties. When these are undefined, the
      // vertical/horizontal position does not need to be adjusted.
      function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (rect.top < 0) { rect.top = 0; }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm), result = {};
        if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
          if (newTop != screentop) { result.scrollTop = newTop; }
        }

        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = rect.right - rect.left > screenw;
        if (tooWide) { rect.right = rect.left + screenw; }
        if (rect.left < 10)
          { result.scrollLeft = 0; }
        else if (rect.left < screenleft)
          { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
        else if (rect.right > screenw + screenleft - 3)
          { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
        return result
      }

      // Store a relative adjustment to the scroll position in the current
      // operation (to be applied when the operation finishes).
      function addToScrollTop(cm, top) {
        if (top == null) { return }
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }

      // Make sure that at the end of the operation the current cursor is
      // shown.
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
      }

      function scrollToCoords(cm, x, y) {
        if (x != null || y != null) { resolveScrollToPos(cm); }
        if (x != null) { cm.curOp.scrollLeft = x; }
        if (y != null) { cm.curOp.scrollTop = y; }
      }

      function scrollToRange(cm, range$$1) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range$$1;
      }

      // When an operation has its scrollToPos property set, and another
      // scroll action is applied before the end of the operation, this
      // 'simulates' scrolling that position into view in a cheap way, so
      // that the effect of intermediate scroll commands is not ignored.
      function resolveScrollToPos(cm) {
        var range$$1 = cm.curOp.scrollToPos;
        if (range$$1) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
          scrollToCoordsRange(cm, from, to, range$$1.margin);
        }
      }

      function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from.left, to.left),
          top: Math.min(from.top, to.top) - margin,
          right: Math.max(from.right, to.right),
          bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      }

      // Sync the scrollable area and scrollbars, ensure the viewport
      // covers the visible area.
      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
        if (!gecko) { updateDisplaySimple(cm, {top: val}); }
        setScrollTop(cm, val, true);
        if (gecko) { updateDisplaySimple(cm); }
        startWorker(cm, 100);
      }

      function setScrollTop(cm, val, forceScroll) {
        val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
        if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
      }

      // Sync scroller and scrollbar, ensure the gutter elements are
      // aligned.
      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
        cm.display.scrollbars.setScrollLeft(val);
      }

      // SCROLLBARS

      // Prepare DOM reads needed to update the scrollbars. Done in one
      // shot to minimize update/measure roundtrips.
      function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        }
      }

      var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert); place(horiz);

        on(vert, "scroll", function () {
          if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
        });
        on(horiz, "scroll", function () {
          if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
        });

        this.checkedZeroWidth = false;
        // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
        if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
      };

      NativeScrollbars.prototype.update = function (measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;

        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
          // A bug in IE8 can cause this value to be negative, so guard it.
          this.vert.firstChild.style.height =
            Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }

        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width =
            Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }

        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) { this.zeroWidthHack(); }
          this.checkedZeroWidth = true;
        }

        return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
      };

      NativeScrollbars.prototype.setScrollLeft = function (pos) {
        if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
        if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
      };

      NativeScrollbars.prototype.setScrollTop = function (pos) {
        if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
        if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
      };

      NativeScrollbars.prototype.zeroWidthHack = function () {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
        this.disableHoriz = new Delayed;
        this.disableVert = new Delayed;
      };

      NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
        bar.style.pointerEvents = "auto";
        function maybeDisable() {
          // To find out whether the scrollbar is still visible, we
          // check whether the element under the pixel in the bottom
          // right corner of the scrollbar box is the scrollbar box
          // itself (when the bar is still visible) or its filler child
          // (when the bar is hidden). If it is still visible, we keep
          // it enabled, if it's hidden, we disable pointer events.
          var box = bar.getBoundingClientRect();
          var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
              : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
          if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
          else { delay.set(1000, maybeDisable); }
        }
        delay.set(1000, maybeDisable);
      };

      NativeScrollbars.prototype.clear = function () {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };

      var NullScrollbars = function () {};

      NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
      NullScrollbars.prototype.setScrollLeft = function () {};
      NullScrollbars.prototype.setScrollTop = function () {};
      NullScrollbars.prototype.clear = function () {};

      function updateScrollbars(cm, measure) {
        if (!measure) { measure = measureForScrollbars(cm); }
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
            { updateHeightsInViewport(cm); }
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
        }
      }

      // Re-synchronize the fake scrollbars with the actual size of the
      // content.
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);

        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else { d.scrollbarFiller.style.display = ""; }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else { d.gutterFiller.style.display = ""; }
      }

      var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass)
            { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
        }

        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          // Prevent clicks in the scrollbars from killing focus
          on(node, "mousedown", function () {
            if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
          });
          node.setAttribute("cm-not-content", "true");
        }, function (pos, axis) {
          if (axis == "horizontal") { setScrollLeft(cm, pos); }
          else { updateScrollTop(cm, pos); }
        }, cm);
        if (cm.display.scrollbars.addClass)
          { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
      }

      // Operations are used to wrap a series of changes to the editor
      // state in such a way that each change won't have to update the
      // cursor and display (which would be awkward, slow, and
      // error-prone). Instead, display updates are batched and then all
      // combined and executed at once.

      var nextOpId = 0;
      // Start a new operation.
      function startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,      // Flag that indicates that lines might need to be redrawn
          startHeight: cm.doc.height, // Used to detect need to update scrollbar
          forceUpdate: false,      // Used to force a redraw
          updateInput: 0,       // Whether to reset the input textarea
          typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,        // Accumulated changes, for firing change events
          cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
          selectionChanged: false, // Whether the selection needs to be redrawn
          updateMaxLine: false,    // Set when the widest line needs to be determined anew
          scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,       // Used to scroll to a specific position
          focus: false,
          id: ++nextOpId           // Unique ID
        };
        pushOperation(cm.curOp);
      }

      // Finish an operation, updating the display and signalling delayed events
      function endOperation(cm) {
        var op = cm.curOp;
        if (op) { finishOperation(op, function (group) {
          for (var i = 0; i < group.ops.length; i++)
            { group.ops[i].cm.curOp = null; }
          endOperations(group);
        }); }
      }

      // The DOM updates done when an operation finishes are batched so
      // that the minimum number of relayouts are required.
      function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++) // Read DOM
          { endOperation_R1(ops[i]); }
        for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
          { endOperation_W1(ops[i$1]); }
        for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
          { endOperation_R2(ops[i$2]); }
        for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
          { endOperation_W2(ops[i$3]); }
        for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
          { endOperation_finish(ops[i$4]); }
      }

      function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) { findMaxLine(cm); }

        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
          op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                             op.scrollToPos.to.line >= display.viewTo) ||
          display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate &&
          new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
      }

      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }

      function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay) { updateHeightsInViewport(cm); }

        op.barMeasure = measureForScrollbars(cm);

        // If the max line changed since it was last measured, measure it,
        // and ensure the document's width matches it.
        // updateDisplay_W2 will use these properties to do the actual resizing
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth =
            Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }

        if (op.updatedDisplay || op.selectionChanged)
          { op.preparedSelection = display.input.prepareSelection(); }
      }

      function endOperation_W2(op) {
        var cm = op.cm;

        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft)
            { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
          cm.display.maxLineChanged = false;
        }

        var takeFocus = op.focus && op.focus == activeElt();
        if (op.preparedSelection)
          { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
          { updateScrollbars(cm, op.barMeasure); }
        if (op.updatedDisplay)
          { setDocumentHeight(cm, op.barMeasure); }

        if (op.selectionChanged) { restartBlink(cm); }

        if (cm.state.focused && op.updateInput)
          { cm.display.input.reset(op.typing); }
        if (takeFocus) { ensureFocus(op.cm); }
      }

      function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;

        if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

        // Abort mouse wheel delta measurement, when scrolling explicitly
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
          { display.wheelStartX = display.wheelStartY = null; }

        // Propagate the scroll position to the actual DOM scroller
        if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

        if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
        // If we need to scroll a specific position into view, do so.
        if (op.scrollToPos) {
          var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                       clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          maybeScrollWindow(cm, rect);
        }

        // Fire events for markers that are hidden/unidden by editing or
        // undoing
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) { for (var i = 0; i < hidden.length; ++i)
          { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
        if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
          { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

        if (display.wrapper.offsetHeight)
          { doc.scrollTop = cm.display.scroller.scrollTop; }

        // Fire change events, and delayed event handlers
        if (op.changeObjs)
          { signal(cm, "changes", cm, op.changeObjs); }
        if (op.update)
          { op.update.finish(); }
      }

      // Run the given function in an operation
      function runInOp(cm, f) {
        if (cm.curOp) { return f() }
        startOperation(cm);
        try { return f() }
        finally { endOperation(cm); }
      }
      // Wraps a function in an operation. Returns the wrapped function.
      function operation(cm, f) {
        return function() {
          if (cm.curOp) { return f.apply(cm, arguments) }
          startOperation(cm);
          try { return f.apply(cm, arguments) }
          finally { endOperation(cm); }
        }
      }
      // Used to add methods to editor and doc instances, wrapping them in
      // operations.
      function methodOp(f) {
        return function() {
          if (this.curOp) { return f.apply(this, arguments) }
          startOperation(this);
          try { return f.apply(this, arguments) }
          finally { endOperation(this); }
        }
      }
      function docMethodOp(f) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp) { return f.apply(this, arguments) }
          startOperation(cm);
          try { return f.apply(this, arguments) }
          finally { endOperation(cm); }
        }
      }

      // HIGHLIGHT WORKER

      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo)
          { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
      }

      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.highlightFrontier >= cm.display.viewTo) { return }
        var end = +new Date + cm.options.workTime;
        var context = getContextBefore(cm, doc.highlightFrontier);
        var changedLines = [];

        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
          if (context.line >= cm.display.viewFrom) { // Visible
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);
            if (resetState) { context.state = resetState; }
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses, newCls = highlighted.classes;
            if (newCls) { line.styleClasses = newCls; }
            else if (oldCls) { line.styleClasses = null; }
            var ischange = !oldStyles || oldStyles.length != line.styles.length ||
              oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
            if (ischange) { changedLines.push(context.line); }
            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength)
              { processLine(cm, line.text, context); }
            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }
          if (+new Date > end) {
            startWorker(cm, cm.options.workDelay);
            return true
          }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
        if (changedLines.length) { runInOp(cm, function () {
          for (var i = 0; i < changedLines.length; i++)
            { regLineChange(cm, changedLines[i], "text"); }
        }); }
      }

      // DISPLAY DRAWING

      var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;

        this.viewport = viewport;
        // Store some values that we'll need later (but don't want to force a relayout for)
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };

      DisplayUpdate.prototype.signal = function (emitter, type) {
        if (hasHandler(emitter, type))
          { this.events.push(arguments); }
      };
      DisplayUpdate.prototype.finish = function () {
        for (var i = 0; i < this.events.length; i++)
          { signal.apply(null, this.events[i]); }
      };

      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }

      function selectionSnapshot(cm) {
        if (cm.hasFocus()) { return null }
        var active = activeElt();
        if (!active || !contains(cm.display.lineDiv, active)) { return null }
        var result = {activeElt: active};
        if (window.getSelection) {
          var sel = window.getSelection();
          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }
        return result
      }

      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
        snapshot.activeElt.focus();
        if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var sel = window.getSelection(), range$$1 = document.createRange();
          range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range$$1.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range$$1);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      }

      // Does the actual updating of the line display. Bails out
      // (returning false) when there is nothing to be done and forced is
      // false.
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;

        if (update.editorIsHidden) {
          resetView(cm);
          return false
        }

        // Bail out if the visible area is already rendered and nothing changed.
        if (!update.force &&
            update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
            (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
            display.renderedView == display.view && countDirtyView(cm) == 0)
          { return false }

        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }

        // Compute a suitable new viewport (from & to)
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
        if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }

        var different = from != display.viewFrom || to != display.viewTo ||
          display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);

        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        // Position the mover div to align with the current scroll position
        cm.display.mover.style.top = display.viewOffset + "px";

        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
            (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
          { return false }

        // For big changes, we hide the enclosing element during the
        // update, since that speeds up the operations on most browsers.
        var selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) { display.lineDiv.style.display = ""; }
        display.renderedView = display.view;
        // There might have been a widget with a focused element that got
        // hidden or updated, if so re-focus it.
        restoreSelection(selSnapshot);

        // Prevent selection and cursors from interfering with the scroll
        // width and height.
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;

        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }

        display.updateLineNumbers = null;

        return true
      }

      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;

        for (var first = true;; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            // Clip forced viewport to actual scrollable area.
            if (viewport && viewport.top != null)
              { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
            // Updated line heights might result in the drawn area not
            // actually covering the viewport. Keep looping until it does.
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
              { break }
          }
          if (!updateDisplayIfNeeded(cm, update)) { break }
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }

        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
        }
      }

      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }

      // Sync the actual display DOM structure with display.view, removing
      // nodes for lines that are no longer in view, and creating the ones
      // that are not there yet, and updating the ones that are out of
      // date.
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;

        function rm(node) {
          var next = node.nextSibling;
          // Works around a throw-scroll bug in OS X Webkit
          if (webkit && mac && cm.display.currentWheelTarget == node)
            { node.style.display = "none"; }
          else
            { node.parentNode.removeChild(node); }
          return next
        }

        var view = display.view, lineN = display.viewFrom;
        // Loop over the elements in the view, syncing cur (the DOM nodes
        // in display.lineDiv) with the view as we go.
        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else { // Already drawn
            while (cur != lineView.node) { cur = rm(cur); }
            var updateNumber = lineNumbers && updateNumbersFrom != null &&
              updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur) { cur = rm(cur); }
      }

      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
      }

      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
      }

      // Re-align line numbers and gutter marks to compensate for
      // horizontal scrolling.
      function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + "px";
        for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i].gutter)
              { view[i].gutter.style.left = left; }
            if (view[i].gutterBackground)
              { view[i].gutterBackground.style.left = left; }
          }
          var align = view[i].alignable;
          if (align) { for (var j = 0; j < align.length; j++)
            { align[j].style.left = left; } }
        } }
        if (cm.options.fixedGutter)
          { display.gutters.style.left = (comp + gutterW) + "px"; }
      }

      // Used to ensure that the line number gutter is still the right
      // size for the current document size. Returns true when an update
      // is needed.
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) { return false }
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                     "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true
        }
        return false
      }

      function getGutters(gutters, lineNumbers) {
        var result = [], sawLineNumbers = false;
        for (var i = 0; i < gutters.length; i++) {
          var name = gutters[i], style = null;
          if (typeof name != "string") { style = name.style; name = name.className; }
          if (name == "CodeMirror-linenumbers") {
            if (!lineNumbers) { continue }
            else { sawLineNumbers = true; }
          }
          result.push({className: name, style: style});
        }
        if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
        return result
      }

      // Rebuild the gutter elements, ensure the margin to the left of the
      // code matches their width.
      function renderGutters(display) {
        var gutters = display.gutters, specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;
        for (var i = 0; i < specs.length; ++i) {
          var ref = specs[i];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
          if (style) { gElt.style.cssText = style; }
          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }

      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      }

      // The display handles the DOM integration, both for input reading
      // and content drawing. It holds references to DOM nodes and
      // display-related state.

      function Display(place, doc, input, options) {
        var d = this;
        this.input = input;

        // Covers bottom-right square when both scrollbars are present.
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        // Covers bottom of gutter when coverGutterNextToScrollbar is on
        // and h scrollbar is present.
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        // Will contain the actual code, positioned to cover the viewport.
        d.lineDiv = eltP("div", null, "CodeMirror-code");
        // Elements are added to these to represent selection and cursors.
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        // A visibility: hidden element used to find the size of things.
        d.measure = elt("div", null, "CodeMirror-measure");
        // When lines outside of the viewport are measured, they are drawn in this.
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        // Wraps everything that needs to exist inside the vertically-padded coordinate system
        d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                          null, "position: relative; outline: none");
        var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
        // Moved around its parent to cover visible view.
        d.mover = elt("div", [lines], null, "position: relative");
        // Set to the height of the document, allowing scrolling.
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        // Behavior of elts with overflow: auto and padding is
        // inconsistent across browsers. This is used to ensure the
        // scrollable area is big enough.
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        // Will contain the gutters, if any.
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        // Actual scrollable element.
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        // The element in which the editor lives.
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

        // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
        if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
        if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

        if (place) {
          if (place.appendChild) { place.appendChild(d.wrapper); }
          else { place(d.wrapper); }
        }

        // Current rendered range (may be bigger than the view window).
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        // Information about the rendered lines.
        d.view = [];
        d.renderedView = null;
        // Holds info about a single rendered line when it was rendered
        // for measurement, while not in view.
        d.externalMeasured = null;
        // Empty space (in pixels) above the view
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;

        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;

        // Used to only resize the line number gutter when necessary (when
        // the amount of lines crosses a boundary that makes its width change)
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        // Set to true when a non-horizontal-scrolling line widget is
        // added. As an optimization, line widget aligning is skipped when
        // this is false.
        d.alignWidgets = false;

        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

        // Tracks the maximum line length so that the horizontal scrollbar
        // can be kept static when scrolling.
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;

        // Used for measuring wheel scrolling granularity
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

        // True when shift is held down.
        d.shift = false;

        // Used to track whether anything happened since the context menu
        // was opened.
        d.selForContextMenu = null;

        d.activeTouch = null;

        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);

        input.init(d);
      }

      // Since the delta values reported on mouse wheel events are
      // unstandardized between browsers and even browser versions, and
      // generally horribly unpredictable, this code starts by measuring
      // the scroll effect that the first few mouse wheel events have,
      // and, from that, detects the way it can convert deltas to pixel
      // offsets afterwards.
      //
      // The reason we want to know the amount a wheel event will scroll
      // is that it gives us a chance to update the display before the
      // actual scrolling happens, reducing flickering.

      var wheelSamples = 0, wheelPixelsPerUnit = null;
      // Fill in a browser-detected starting value on browsers where we
      // know one. These don't have to be accurate -- the result of them
      // being wrong would just be a slight flicker on the first wheel
      // scroll (if it is large enough).
      if (ie) { wheelPixelsPerUnit = -.53; }
      else if (gecko) { wheelPixelsPerUnit = 15; }
      else if (chrome) { wheelPixelsPerUnit = -.7; }
      else if (safari) { wheelPixelsPerUnit = -1/3; }

      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
        else if (dy == null) { dy = e.wheelDelta; }
        return {x: dx, y: dy}
      }
      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta
      }

      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

        var display = cm.display, scroll = display.scroller;
        // Quit if there's nothing to scroll here
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) { return }

        // Webkit browsers on OS X abort momentum scrolls when the target
        // of the scroll event is removed from the scrollable element.
        // This hack (see related code in patchDisplay) makes sure the
        // element is kept around.
        if (dy && mac && webkit) {
          outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer
              }
            }
          }
        }

        // On some browsers, horizontal scrolling will cause redraws to
        // happen before the gutter has been realigned, causing it to
        // wriggle around in a most unseemly way. When we have an
        // estimated pixels/delta value, we just handle horizontal
        // scrolling entirely here. It'll be slightly off from native, but
        // better than glitching out.
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
          if (dy && canScrollY)
            { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
          // Only prevent default scrolling if vertical scrolling is
          // actually possible. Otherwise, it causes vertical scroll
          // jitter on OSX trackpads when deltaX is small and deltaY
          // is large (issue #3579)
          if (!dy || (dy && canScrollY))
            { e_preventDefault(e); }
          display.wheelStartX = null; // Abort measurement, if in progress
          return
        }

        // 'Project' the visible viewport to cover the area that is being
        // scrolled into view (if we know enough to estimate it).
        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
          if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
          else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
          updateDisplaySimple(cm, {top: top, bottom: bot});
        }

        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx; display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) { return }
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
                (movedX && display.wheelDX && movedX / display.wheelDX);
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) { return }
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx; display.wheelDY += dy;
          }
        }
      }

      // Selection objects are immutable. A new one is created every time
      // the selection changes. A selection is one or more non-overlapping
      // (and non-touching) ranges, sorted, and an integer that indicates
      // which one is the primary selection (the one that's scrolled into
      // view, that getCursor returns, etc).
      var Selection = function(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };

      Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

      Selection.prototype.equals = function (other) {
        if (other == this) { return true }
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
        for (var i = 0; i < this.ranges.length; i++) {
          var here = this.ranges[i], there = other.ranges[i];
          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
        }
        return true
      };

      Selection.prototype.deepCopy = function () {
        var out = [];
        for (var i = 0; i < this.ranges.length; i++)
          { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
        return new Selection(out, this.primIndex)
      };

      Selection.prototype.somethingSelected = function () {
        for (var i = 0; i < this.ranges.length; i++)
          { if (!this.ranges[i].empty()) { return true } }
        return false
      };

      Selection.prototype.contains = function (pos, end) {
        if (!end) { end = pos; }
        for (var i = 0; i < this.ranges.length; i++) {
          var range = this.ranges[i];
          if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
            { return i }
        }
        return -1
      };

      var Range = function(anchor, head) {
        this.anchor = anchor; this.head = head;
      };

      Range.prototype.from = function () { return minPos(this.anchor, this.head) };
      Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
      Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

      // Take an unsorted, potentially overlapping set of ranges, and
      // build a selection out of it. 'Consumes' ranges array (modifying
      // it).
      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i], prev = ranges[i - 1];
          var diff = cmp(prev.to(), cur.from());
          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
            var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i <= primIndex) { --primIndex; }
            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection(ranges, primIndex)
      }

      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0)
      }

      // Compute the position of the end of a change (its 'to' property
      // refers to the pre-change end).
      function changeEnd(change) {
        if (!change.text) { return change.to }
        return Pos(change.from.line + change.text.length - 1,
                   lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
      }

      // Adjust a position to refer to the post-change position of the
      // same text, or the end of the change if the change covers it.
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) { return pos }
        if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
        return Pos(line, ch)
      }

      function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change),
                             adjustForChange(range.head, change)));
        }
        return normalizeSelection(doc.cm, out, doc.sel.primIndex)
      }

      function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
          { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
        else
          { return Pos(nw.line + (pos.line - old.line), pos.ch) }
      }

      // Used by replaceSelections to allow moving the selection to the
      // start or around the replaced test. Hint may be "start" or "around".
      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }
        return new Selection(out, doc.sel.primIndex)
      }

      // Used to get the editor into a consistent state again when options change.

      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }

      function resetModeState(cm) {
        cm.doc.iter(function (line) {
          if (line.stateAfter) { line.stateAfter = null; }
          if (line.styles) { line.styles = null; }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) { regChange(cm); }
      }

      // DOCUMENT DATA STRUCTURE

      // By default, updates that start and end at the beginning of a line
      // are treated specially, in order to make the association of line
      // widgets and marker elements with the text behave more intuitive.
      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
          (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
      }

      // Perform a change on the document data structure.
      function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
        function spansFor(n) {return markedSpans ? markedSpans[n] : null}
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight$$1);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          var result = [];
          for (var i = start; i < end; ++i)
            { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
          return result
        }

        var from = change.from, to = change.to, text = change.text;
        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

        // Adjust the line structure
        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          // This is a whole-line replace. Treated specially to make
          // sure line objects move the way they are supposed to.
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) { doc.remove(from.line, nlines); }
          if (added.length) { doc.insert(from.line, added); }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);
          if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
          doc.insert(from.line + 1, added$2);
        }

        signalLater(doc, "change", doc, change);
      }

      // Call f for all linked documents.
      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
            var rel = doc.linked[i];
            if (rel.doc == skip) { continue }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) { continue }
            f(rel.doc, shared);
            propagate(rel.doc, doc, shared);
          } }
        }
        propagate(doc, null, true);
      }

      // Attach a document to an editor.
      function attachDoc(cm, doc) {
        if (doc.cm) { throw new Error("This document is already in use.") }
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        if (!cm.options.lineWrapping) { findMaxLine(cm); }
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }

      function setDirectionClass(cm) {
      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }

      function directionChanged(cm) {
        runInOp(cm, function () {
          setDirectionClass(cm);
          regChange(cm);
        });
      }

      function History(startGen) {
        // Arrays of change events and selections. Doing something adds an
        // event to done and clears undo. Undoing moves events from done
        // to undone, redoing moves them in the other direction.
        this.done = []; this.undone = [];
        this.undoDepth = Infinity;
        // Used to track when changes can be merged into a single undo
        // event
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        // Used by the isClean() method
        this.generation = this.maxGeneration = startGen || 1;
      }

      // Create a history change event from an updateDoc-style change
      // object.
      function historyChangeFromChange(doc, change) {
        var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
        return histChange
      }

      // Pop all selection events off the end of a history array. Stop at
      // a change event.
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges) { array.pop(); }
          else { break }
        }
      }

      // Find the top change event in the history. Pop off selection
      // events that are in the way.
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done)
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done)
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done)
        }
      }

      // Register a change in the history. Merges changes that are within
      // a single operation, or are close together with an origin that
      // allows merging (starting with "+") into a single event.
      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date, cur;
        var last;

        if ((hist.lastOp == opId ||
             hist.lastOrigin == change.origin && change.origin &&
             ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
              change.origin.charAt(0) == "*")) &&
            (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          // Merge this change into the last event
          last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            // Optimized case for simple insertion -- don't want to add
            // new changesets for every character typed
            last.to = changeEnd(change);
          } else {
            // Add new sub-event
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          // Can not be merged, start a new event.
          var before = lst(hist.done);
          if (!before || !before.ranges)
            { pushSelectionToHistory(doc.sel, hist.done); }
          cur = {changes: [historyChangeFromChange(doc, change)],
                 generation: hist.generation};
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges) { hist.done.shift(); }
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;

        if (!last) { signal(doc, "historyAdded"); }
      }

      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" ||
          ch == "+" &&
          prev.ranges.length == sel.ranges.length &&
          prev.somethingSelected() == sel.somethingSelected() &&
          new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
      }

      // Called whenever the selection changes, sets the new selection as
      // the pending selection in the history, and pushes the old pending
      // selection into the 'done' array when it was significantly
      // different (in number of selected ranges, emptiness, or time).
      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;

        // A new event is started when the previous origin does not match
        // the current, or the origins don't allow matching. Origins
        // starting with * are always merged, those starting with + are
        // merged when similar and close together in time.
        if (opId == hist.lastSelOp ||
            (origin && hist.lastSelOrigin == origin &&
             (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
              selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
          { hist.done[hist.done.length - 1] = sel; }
        else
          { pushSelectionToHistory(sel, hist.done); }

        hist.lastSelTime = +new Date;
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
          { clearSelectionEvents(hist.undone); }
      }

      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
          { dest.push(sel); }
      }

      // Used to store marked span information in the history.
      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans)
            { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
          ++n;
        });
      }

      // When un/re-doing restores text containing marked spans, those
      // that have been explicitly cleared should not be restored.
      function removeClearedSpans(spans) {
        if (!spans) { return null }
        var out;
        for (var i = 0; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
          else if (out) { out.push(spans[i]); }
        }
        return !out ? spans : out.length ? out : null
      }

      // Retrieve and filter the old marked spans stored in a change event.
      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) { return null }
        var nw = [];
        for (var i = 0; i < change.text.length; ++i)
          { nw.push(removeClearedSpans(found[i])); }
        return nw
      }

      // Used for un/re-doing changes from the history. Combines the
      // result of computing the existing spans with the set of spans that
      // existed in the history (so that deleting around a span and then
      // undoing brings back the span).
      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) { return stretched }
        if (!stretched) { return old }

        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i], stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k)
                { if (oldCur[k].marker == span.marker) { continue spans } }
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old
      }

      // Used both to provide a JSON-safe object in .getHistory, and, when
      // detaching a document, to split the history in two
      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];
        for (var i = 0; i < events.length; ++i) {
          var event = events[i];
          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue
          }
          var changes = event.changes, newChanges = [];
          copy.push({changes: newChanges});
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j], m = (void 0);
            newChanges.push({from: change.from, to: change.to, text: change.text});
            if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            } } }
          }
        }
        return copy
      }

      // The 'scroll' parameter given to many of these indicated whether
      // the new cursor position should be scrolled into view after
      // modifying the selection.

      // If shift is held or the extend flag is set, extends a range to
      // include a given position (and optionally a second position).
      // Otherwise, simply returns the range between the given positions.
      // Used for cursor motion and such.
      function extendRange(range, head, other, extend) {
        if (extend) {
          var anchor = range.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != (cmp(other, anchor) < 0)) {
              anchor = head;
              head = other;
            } else if (posBefore != (cmp(head, other) < 0)) {
              head = other;
            }
          }
          return new Range(anchor, head)
        } else {
          return new Range(other || head, head)
        }
      }

      // Extend the primary selection range, discard the rest.
      function extendSelection(doc, head, other, options, extend) {
        if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
        setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
      }

      // Extend all selections (pos is an array of selections with length
      // equal the number of selections)
      function extendSelections(doc, heads, options) {
        var out = [];
        var extend = doc.cm && (doc.cm.display.shift || doc.extend);
        for (var i = 0; i < doc.sel.ranges.length; i++)
          { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      }

      // Updates a single range in the selection.
      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
      }

      // Reset the selection to a single range.
      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      }

      // Give beforeSelectionChange handlers a change to influence a
      // selection update.
      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i = 0; i < ranges.length; i++)
              { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                         clipPos(doc, ranges[i].head)); }
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
        if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
        else { return sel }
      }

      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      }

      // Set a new selection.
      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }

      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
          { sel = filterSelectionChange(doc, sel, options); }

        var bias = options && options.bias ||
          (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

        if (!(options && options.scroll === false) && doc.cm)
          { ensureCursorVisible(doc.cm); }
      }

      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) { return }

        doc.sel = sel;

        if (doc.cm) {
          doc.cm.curOp.updateInput = 1;
          doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
      }

      // Verify that the selection does not partially select any atomic
      // marked ranges.
      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
      }

      // Return a selection that does not partially select any atomic
      // ranges.
      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out) { out = sel.ranges.slice(0, i); }
            out[i] = new Range(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
      }

      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) { break }
                else {--i; continue}
              }
            }
            if (!m.atomic) { continue }

            if (oldPos) {
              var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
              if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
                { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
                { return skipAtomicInner(doc, near, pos, dir, mayClear) }
            }

            var far = m.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
              { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
          }
        } }
        return pos
      }

      // Ensure a given position is not inside an atomic range.
      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
            (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
            skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
            (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0)
        }
        return found
      }

      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
          else { return null }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
          else { return null }
        } else {
          return new Pos(pos.line, pos.ch + dir)
        }
      }

      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      }

      // UPDATING

      // Allow "beforeChange" event handlers to influence a change
      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function () { return obj.canceled = true; }
        };
        if (update) { obj.update = function (from, to, text, origin) {
          if (from) { obj.from = clipPos(doc, from); }
          if (to) { obj.to = clipPos(doc, to); }
          if (text) { obj.text = text; }
          if (origin !== undefined) { obj.origin = origin; }
        }; }
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

        if (obj.canceled) {
          if (doc.cm) { doc.cm.curOp.updateInput = 2; }
          return null
        }
        return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
      }

      // Apply a change to a document, and add it to the document's
      // history, and propagating it to all linked documents.
      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
          if (doc.cm.state.suppressEdits) { return }
        }

        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change) { return }
        }

        // Possibly split or suppress the update based on the presence
        // of read-only spans in its range.
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 0; --i)
            { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
        } else {
          makeChangeInner(doc, change);
        }
      }

      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];

        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }

      // Revert a change stored in a document's history.
      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        var suppress = doc.cm && doc.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly) { return }

        var hist = doc.history, event, selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

        // Verify that there is a useable event (so that ctrl-z won't
        // needlessly clear selection events)
        var i = 0;
        for (; i < source.length; i++) {
          event = source[i];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
            { break }
        }
        if (i == source.length) { return }
        hist.lastOrigin = hist.lastSelOrigin = null;

        for (;;) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, {clearRedo: false});
              return
            }
            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return
          } else { break }
        }

        // Build up a reverse change object to add to the opposite history
        // stack (redo when undoing, and vice versa).
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({changes: antiChanges, generation: hist.generation});
        hist.generation = event.generation || ++hist.maxGeneration;

        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

        var loop = function ( i ) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return {}
          }

          antiChanges.push(historyChangeFromChange(doc, change));

          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
          var rebased = [];

          // Propagate to the linked documents
          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        };

        for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
          var returned = loop( i$1 );

          if ( returned ) return returned.v;
        }
      }

      // Sub-views need their line numbers shifted when text is added
      // above or below them in the parent document.
      function shiftDoc(doc, distance) {
        if (distance == 0) { return }
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
          Pos(range.anchor.line + distance, range.anchor.ch),
          Pos(range.head.line + distance, range.head.ch)
        ); }), doc.sel.primIndex);
        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);
          for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
            { regLineChange(doc.cm, l, "gutter"); }
        }
      }

      // More lower-level change function, handling only a single document
      // (not linked ones).
      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
          { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return
        }
        if (change.from.line > doc.lastLine()) { return }

        // Clip the change to the size of this doc
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                    text: [lst(change.text)], origin: change.origin};
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                    text: [change.text[0]], origin: change.origin};
        }

        change.removed = getBetween(doc, change.from, change.to);

        if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
        if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
        else { updateDoc(doc, change, spans); }
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      }

      // Handle the interaction of a change to a document with the editor
      // that this document is part of.
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true
            }
          });
        }

        if (doc.sel.contains(change.from, change.to) > -1)
          { signalCursorActivity(cm); }

        updateDoc(doc, change, spans, estimateHeight(cm));

        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
        }

        retreatFrontier(doc, from.line);
        startWorker(cm, 400);

        var lendiff = change.text.length - (to.line - from.line) - 1;
        // Remember that these lines changed, for updating the display
        if (change.full)
          { regChange(cm); }
        else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
          { regLineChange(cm, from.line, "text"); }
        else
          { regChange(cm, from.line, to.line + 1, lendiff); }

        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from: from, to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler) { signalLater(cm, "change", cm, obj); }
          if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
        }
        cm.display.selForContextMenu = null;
      }

      function replaceRange(doc, code, from, to, origin) {
        var assign;

        if (!to) { to = from; }
        if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
        if (typeof code == "string") { code = doc.splitLines(code); }
        makeChange(doc, {from: from, to: to, text: code, origin: origin});
      }

      // Rebasing/resetting history to deal with externally-sourced changes

      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }

      // Tries to rebase an array of history events given a change in the
      // document. If the change touches the same lines as the event, the
      // event, and everything 'behind' it, is discarded. If the change is
      // before the event, the event's positions are updated. Uses a
      // copy-on-write scheme for the positions, to avoid having to
      // reallocate them all on every rebase, but also avoid problems with
      // shared position objects being unsafely updated.
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i], ok = true;
          if (sub.ranges) {
            if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }
            continue
          }
          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break
            }
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }

      function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }

      // Utility for applying a change to a line by handle or number,
      // returning the number and optionally registering the line as
      // changed.
      function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
        else { no = lineNo(handle); }
        if (no == null) { return null }
        if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
        return line
      }

      // The document is represented as a BTree consisting of leaves, with
      // chunk of lines in them, and branches, with up to ten leaves or
      // other branch nodes below them. The top node is always a branch
      // node, and is the document object itself (meaning it has
      // additional methods and properties).
      //
      // All nodes have parent links. The tree is used both to go from
      // line numbers to line objects, and to go from objects to numbers.
      // It also indexes by height, and is used to convert between height
      // and line object, and to find the total height of the document.
      //
      // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for (var i = 0; i < lines.length; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }
        this.height = height;
      }

      LeafChunk.prototype = {
        chunkSize: function() { return this.lines.length },

        // Remove the n lines at offset 'at'.
        removeInner: function(at, n) {
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },

        // Helper used to collapse a small branch into a single leaf.
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },

        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
        },

        // Used to iterate over a part of the tree.
        iterN: function(at, n, op) {
          for (var e = at + n; at < e; ++at)
            { if (op(this.lines[at])) { return true } }
        }
      };

      function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize(); height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }

      BranchChunk.prototype = {
        chunkSize: function() { return this.size },

        removeInner: function(at, n) {
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i], sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at), oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
              if ((n -= rm) == 0) { break }
              at = 0;
            } else { at -= sz; }
          }
          // If the result is smaller than 25 lines, ensure that it is a
          // single leaf node.
          if (this.size - n < 25 &&
              (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },

        collapse: function(lines) {
          for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
        },

        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i], sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
                // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
                var remaining = child.lines.length % 25 + 25;
                for (var pos = remaining; pos < child.lines.length;) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i, 0, leaf);
                  leaf.parent = this;
                }
                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }
              break
            }
            at -= sz;
          }
        },

        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (this.children.length <= 10) { return }
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) { // Become the parent node
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
           } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10)
          me.parent.maybeSpill();
        },

        iterN: function(at, n, op) {
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i], sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) { return true }
              if ((n -= used) == 0) { break }
              at = 0;
            } else { at -= sz; }
          }
        }
      };

      // Line widgets are block elements displayed above or below a line.

      var LineWidget = function(doc, node, options) {
        if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
          { this[opt] = options[opt]; } } }
        this.doc = doc;
        this.node = node;
      };

      LineWidget.prototype.clear = function () {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws) { return }
        for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
        if (!ws.length) { line.widgets = null; }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
          runInOp(cm, function () {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };

      LineWidget.prototype.changed = function () {
          var this$1 = this;

        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) { return }
        if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
        if (cm) {
          runInOp(cm, function () {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
          });
        }
      };
      eventMixin(LineWidget);

      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
          { addToScrollTop(cm, diff); }
      }

      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
        changeLine(doc, handle, "widget", function (line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) { widgets.push(widget); }
          else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
          widget.line = line;
          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) { addToScrollTop(cm, widget.height); }
            cm.curOp.forceUpdate = true;
          }
          return true
        });
        if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
        return widget
      }

      // TEXTMARKERS

      // Created with markText and setBookmark methods. A TextMarker is a
      // handle that can be used to clear or find a marked position in the
      // document. Line objects hold arrays (markedSpans) containing
      // {from, to, marker} object pointing to such marker objects, and
      // indicating that such a marker is present on that line. Multiple
      // lines may point to the same marker when it spans across lines.
      // The spans will have null for their from/to properties when the
      // marker continues beyond the start/end of the line. Markers have
      // links back to the lines they currently touch.

      // Collapsed markers have unique ids, in order to be able to order
      // them, which is needed for uniquely determining an outer marker
      // when they overlap (they may nest, but not partially overlap).
      var nextMarkerId = 0;

      var TextMarker = function(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      };

      // Clear the marker.
      TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) { return }
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp) { startOperation(cm); }
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) { signalLater(this, "clear", found.from, found.to); }
        }
        var min = null, max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
          else if (cm) {
            if (span.to != null) { max = lineNo(line); }
            if (span.from != null) { min = lineNo(line); }
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
            { updateLineHeight(line, textHeight(cm.display)); }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
          var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        } }

        if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) { reCheckSelection(cm.doc); }
        }
        if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
        if (withOp) { endOperation(cm); }
        if (this.parent) { this.parent.clear(); }
      };

      // Find the position of the marker in the document. Returns a {from,
      // to} object by default. Side can be passed to get a specific side
      // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
      // Pos objects returned contain a line object, rather than a line
      // number (used to prevent looking up the same line twice).
      TextMarker.prototype.find = function (side, lineObj) {
        if (side == null && this.type == "bookmark") { side = 1; }
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1) { return from }
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1) { return to }
          }
        }
        return from && {from: from, to: to}
      };

      // Signals that the marker's widget changed, and surrounding layout
      // should be recomputed.
      TextMarker.prototype.changed = function () {
          var this$1 = this;

        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm) { return }
        runInOp(cm, function () {
          var line = pos.line, lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight)
              { updateLineHeight(line, line.height + dHeight); }
          }
          signalLater(cm, "markerChanged", cm, this$1);
        });
      };

      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
            { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
        }
        this.lines.push(line);
      };

      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp
          ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      eventMixin(TextMarker);

      // Create a marker, wire it up to the right lines, and
      function markText(doc, from, to, options, type) {
        // Shared markers (across linked documents) are handled separately
        // (markTextShared will call out to this again, once per
        // document).
        if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
        // Ensure we are in an operation.
        if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options) { copyObj(options, marker, false); }
        // Don't connect empty markers unless clearWhenEmpty is false
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
          { return marker }
        if (marker.replacedWith) {
          // Showing up as a widget implies collapsed (widget replaces text)
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
          if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
              from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
            { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
          seeCollapsedSpans();
        }

        if (marker.addToHistory)
          { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

        var curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
            { updateMaxLine = true; }
          if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
          addMarkedSpan(line, new MarkedSpan(marker,
                                             curLine == from.line ? from.ch : null,
                                             curLine == to.line ? to.ch : null));
          ++curLine;
        });
        // lineIsHidden depends on the presence of the spans, so needs a second pass
        if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
          if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
        }); }

        if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

        if (marker.readOnly) {
          seeReadOnlySpans();
          if (doc.history.done.length || doc.history.undone.length)
            { doc.clearHistory(); }
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          // Sync editor state
          if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
          if (marker.collapsed)
            { regChange(cm, from.line, to.line + 1); }
          else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
                   marker.attributes || marker.title)
            { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
          if (marker.atomic) { reCheckSelection(cm.doc); }
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker
      }

      // SHARED TEXTMARKERS

      // A shared marker spans multiple linked documents. It is
      // implemented as a meta-marker-object controlling multiple normal
      // markers.
      var SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
          { markers[i].parent = this; }
      };

      SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) { return }
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i)
          { this.markers[i].clear(); }
        signalLater(this, "clear");
      };

      SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj)
      };
      eventMixin(SharedTextMarker);

      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
          if (widget) { options.widgetNode = widget.cloneNode(true); }
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i)
            { if (doc.linked[i].isParent) { return } }
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary)
      }

      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
      }

      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i], pos = marker.find();
          var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }

      function detachSharedMarkers(markers) {
        var loop = function ( i ) {
          var marker = markers[i], linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };

        for (var i = 0; i < markers.length; i++) loop( i );
      }

      var nextDocId = 0;
      var Doc = function(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
        if (firstLine == null) { firstLine = 0; }

        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = (direction == "rtl") ? "rtl" : "ltr";
        this.extend = false;

        if (typeof text == "string") { text = this.splitLines(text); }
        updateDoc(this, {from: start, to: start, text: text});
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };

      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(from, to, op) {
          if (op) { this.iterN(from - this.first, to - from, op); }
          else { this.iterN(this.first, this.first + this.size, from); }
        },

        // Non-public interface for adding and removing lines.
        insert: function(at, lines) {
          var height = 0;
          for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) { this.removeInner(at - this.first, n); },

        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.

        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) { return lines }
          return lines.join(lineSep || this.lineSeparator())
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0), last = this.first + this.size - 1;
          makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                            text: this.splitLines(code), origin: "setValue", full: true}, true);
          if (this.cm) { scrollToCoords(this.cm, 0, 0); }
          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) { return lines }
          return lines.join(lineSep || this.lineSeparator())
        },

        getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

        getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
        getLineNumber: function(line) {return lineNo(line)},

        getLineHandleVisualStart: function(line) {
          if (typeof line == "number") { line = getLine(this, line); }
          return visualLine(line)
        },

        lineCount: function() {return this.size},
        firstLine: function() {return this.first},
        lastLine: function() {return this.first + this.size - 1},

        clipPos: function(pos) {return clipPos(this, pos)},

        getCursor: function(start) {
          var range$$1 = this.sel.primary(), pos;
          if (start == null || start == "head") { pos = range$$1.head; }
          else if (start == "anchor") { pos = range$$1.anchor; }
          else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
          else { pos = range$$1.from(); }
          return pos
        },
        listSelections: function() { return this.sel.ranges },
        somethingSelected: function() {return this.sel.somethingSelected()},

        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
          var heads = map(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length) { return }
          var out = [];
          for (var i = 0; i < ranges.length; i++)
            { out[i] = new Range(clipPos(this, ranges[i].anchor),
                               clipPos(this, ranges[i].head)); }
          if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),

        getSelection: function(lineSep) {
          var ranges = this.sel.ranges, lines;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false) { return lines }
          else { return lines.join(lineSep || this.lineSeparator()) }
        },
        getSelections: function(lineSep) {
          var parts = [], ranges = this.sel.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
            parts[i] = sel;
          }
          return parts
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i = 0; i < this.sel.ranges.length; i++)
            { dup[i] = code; }
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [], sel = this.sel;
          for (var i = 0; i < sel.ranges.length; i++) {
            var range$$1 = sel.ranges[i];
            changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this.splitLines(code[i]), origin: origin};
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
            { makeChange(this, changes[i$1]); }
          if (newSel) { setSelectionReplaceHistory(this, newSel); }
          else if (this.cm) { ensureCursorVisible(this.cm); }
        }),
        undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
        redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
        undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
        redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

        setExtending: function(val) {this.extend = val;},
        getExtending: function() {return this.extend},

        historySize: function() {
          var hist = this.history, done = 0, undone = 0;
          for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
          for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
          return {undo: done, redo: undone}
        },
        clearHistory: function() {this.history = new History(this.history.maxGeneration);},

        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit)
            { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
          return this.history.generation
        },
        isClean: function (gen) {
          return this.history.generation == (gen || this.cleanGeneration)
        },

        getHistory: function() {
          return {done: copyHistoryArray(this.history.done),
                  undone: copyHistoryArray(this.history.undone)}
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history.maxGeneration);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },

        setGutterMarker: docMethodOp(function(line, gutterID, value) {
          return changeLine(this, line, "gutter", function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
            return true
          })
        }),

        clearGutter: docMethodOp(function(gutterID) {
          var this$1 = this;

          this.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1, line, "gutter", function () {
                line.gutterMarkers[gutterID] = null;
                if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
                return true
              });
            }
          });
        }),

        lineInfo: function(line) {
          var n;
          if (typeof line == "number") {
            if (!isLine(this, line)) { return null }
            n = line;
            line = getLine(this, line);
            if (!line) { return null }
          } else {
            n = lineNo(line);
            if (n == null) { return null }
          }
          return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
                  textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
                  widgets: line.widgets}
        },

        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass"
                     : where == "background" ? "bgClass"
                     : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop]) { line[prop] = cls; }
            else if (classTest(cls).test(line[prop])) { return false }
            else { line[prop] += " " + cls; }
            return true
          })
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass"
                     : where == "background" ? "bgClass"
                     : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];
            if (!cur) { return false }
            else if (cls == null) { line[prop] = null; }
            else {
              var found = cur.match(classTest(cls));
              if (!found) { return false }
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true
          })
        }),

        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options)
        }),
        removeLineWidget: function(widget) { widget.clear(); },

        markText: function(from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
        },
        setBookmark: function(pos, options) {
          var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                          insertLeft: options && options.insertLeft,
                          clearWhenEmpty: false, shared: options && options.shared,
                          handleMouseEvents: options && options.handleMouseEvents};
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark")
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [], spans = getLine(this, pos.line).markedSpans;
          if (spans) { for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if ((span.from == null || span.from <= pos.ch) &&
                (span.to == null || span.to >= pos.ch))
              { markers.push(span.marker.parent || span.marker); }
          } }
          return markers
        },
        findMarks: function(from, to, filter) {
          from = clipPos(this, from); to = clipPos(this, to);
          var found = [], lineNo$$1 = from.line;
          this.iter(from.line, to.line + 1, function (line) {
            var spans = line.markedSpans;
            if (spans) { for (var i = 0; i < spans.length; i++) {
              var span = spans[i];
              if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                    span.from == null && lineNo$$1 != from.line ||
                    span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
                  (!filter || filter(span.marker)))
                { found.push(span.marker.parent || span.marker); }
            } }
            ++lineNo$$1;
          });
          return found
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;
            if (sps) { for (var i = 0; i < sps.length; ++i)
              { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
          });
          return markers
        },

        posFromIndex: function(off) {
          var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
          this.iter(function (line) {
            var sz = line.text.length + sepSize;
            if (sz > off) { ch = off; return true }
            off -= sz;
            ++lineNo$$1;
          });
          return clipPos(this, Pos(lineNo$$1, ch))
        },
        indexFromPos: function (coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0) { return 0 }
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
            index += line.text.length + sepSize;
          });
          return index
        },

        copy: function(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size),
                            this.modeOption, this.first, this.lineSep, this.direction);
          doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc
        },

        linkedDoc: function(options) {
          if (!options) { options = {}; }
          var from = this.first, to = this.first + this.size;
          if (options.from != null && options.from > from) { from = options.from; }
          if (options.to != null && options.to < to) { to = options.to; }
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
          if (options.sharedHist) { copy.history = this.history
          ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
          copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror) { other = other.doc; }
          if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
            var link = this.linked[i];
            if (link.doc != other) { continue }
            this.linked.splice(i, 1);
            other.unlinkDoc(this);
            detachSharedMarkers(findSharedMarkers(this));
            break
          } }
          // If the histories were shared, split them again
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f) {linkedDocs(this, f);},

        getMode: function() {return this.mode},
        getEditor: function() {return this.cm},

        splitLines: function(str) {
          if (this.lineSep) { return str.split(this.lineSep) }
          return splitLinesAuto(str)
        },
        lineSeparator: function() { return this.lineSep || "\n" },

        setDirection: docMethodOp(function (dir) {
          if (dir != "rtl") { dir = "ltr"; }
          if (dir == this.direction) { return }
          this.direction = dir;
          this.iter(function (line) { return line.order = null; });
          if (this.cm) { directionChanged(this.cm); }
        })
      });

      // Public alias.
      Doc.prototype.eachLine = Doc.prototype.iter;

      // Kludge to work around strange IE behavior where it'll sometimes
      // re-fire a series of drag-related events right after the drop (#1551)
      var lastDrop = 0;

      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
          { return }
        e_preventDefault(e);
        if (ie) { lastDrop = +new Date; }
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly()) { return }
        // Might be a file drop, in which case we simply extract the text
        // and insert it.
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length, text = Array(n), read = 0;
          var loadFile = function (file, i) {
            if (cm.options.allowDropFileTypes &&
                indexOf(cm.options.allowDropFileTypes, file.type) == -1)
              { return }

            var reader = new FileReader;
            reader.onload = operation(cm, function () {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
              text[i] = content;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                var change = {from: pos, to: pos,
                              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                              origin: "paste"};
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
              }
            });
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
        } else { // Normal drop
          // Don't do a replace if the drop happened inside of the selected text.
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            // Ensure the editor is re-focused
            setTimeout(function () { return cm.display.input.focus(); }, 20);
            return
          }
          try {
            var text$1 = e.dataTransfer.getData("Text");
            if (text$1) {
              var selected;
              if (cm.state.draggingText && !cm.state.draggingText.copy)
                { selected = cm.listSelections(); }
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
                { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          }
          catch(e){}
        }
      }

      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";

        // Use dummy image instead of default browsers image.
        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            // Force a relayout, or Opera won't use our image for some obscure reason
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto) { img.parentNode.removeChild(img); }
        }
      }

      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos) { return }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }

      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }

      // These must be handled carefully, because naively registering a
      // handler for each editor will cause the editors to never be
      // garbage collected.

      function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) { return }
        var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;
          if (cm) { editors.push(cm); }
        }
        if (editors.length) { editors[0].operation(function () {
          for (var i = 0; i < editors.length; i++) { f(editors[i]); }
        }); }
      }

      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered) { return }
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        // When the window resizes, we need to refresh active editors.
        var resizeTimer;
        on(window, "resize", function () {
          if (resizeTimer == null) { resizeTimer = setTimeout(function () {
            resizeTimer = null;
            forEachCodeMirror(onResize);
          }, 100); }
        });
        // When the window loses focus, we want to show the editor as blurred
        on(window, "blur", function () { return forEachCodeMirror(onBlur); });
      }
      // Called when the window resizes
      function onResize(cm) {
        var d = cm.display;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }

      var keyNames = {
        3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
        19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
        36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
        46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
        106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
        173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
        221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
        63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
      };

      // Number keys
      for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
      // Alphabetic keys
      for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
      // Function keys
      for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

      var keyMap = {};

      keyMap.basic = {
        "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
        "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
        "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab", "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      // Note that the save and find-related commands aren't defined by
      // default. User code or addons can define them. Unknown commands
      // are simply ignored.
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
        "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
        "fallthrough": "basic"
      };
      // Very basic readline/emacs-style bindings, which are standard on Mac.
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
        "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

      // KEYMAP DISPATCH

      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
          else if (/^a(lt)?$/i.test(mod)) { alt = true; }
          else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
          else if (/^s(hift)?$/i.test(mod)) { shift = true; }
          else { throw new Error("Unrecognized modifier name: " + mod) }
        }
        if (alt) { name = "Alt-" + name; }
        if (ctrl) { name = "Ctrl-" + name; }
        if (cmd) { name = "Cmd-" + name; }
        if (shift) { name = "Shift-" + name; }
        return name
      }

      // This is a kludge to keep keymaps mostly working as raw objects
      // (backwards compatibility) while at the same time support features
      // like normalization and multi-stroke key bindings. It compiles a
      // new normalized keymap, and then updates the old object to reflect
      // this.
      function normalizeKeyMap(keymap) {
        var copy = {};
        for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
          var value = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
          if (value == "...") { delete keymap[keyname]; continue }

          var keys = map(keyname.split(" "), normalizeKeyName);
          for (var i = 0; i < keys.length; i++) {
            var val = (void 0), name = (void 0);
            if (i == keys.length - 1) {
              name = keys.join(" ");
              val = value;
            } else {
              name = keys.slice(0, i + 1).join(" ");
              val = "...";
            }
            var prev = copy[name];
            if (!prev) { copy[name] = val; }
            else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
          }
          delete keymap[keyname];
        } }
        for (var prop in copy) { keymap[prop] = copy[prop]; }
        return keymap
      }

      function lookupKey(key, map$$1, handle, context) {
        map$$1 = getKeyMap(map$$1);
        var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
        if (found === false) { return "nothing" }
        if (found === "...") { return "multi" }
        if (found != null && handle(found)) { return "handled" }

        if (map$$1.fallthrough) {
          if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
            { return lookupKey(key, map$$1.fallthrough, handle, context) }
          for (var i = 0; i < map$$1.fallthrough.length; i++) {
            var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
            if (result) { return result }
          }
        }
      }

      // Modifier key presses don't count as 'real' key presses for the
      // purpose of keymap fallthrough.
      function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
      }

      function addModifierNames(name, event, noShift) {
        var base = name;
        if (event.altKey && base != "Alt") { name = "Alt-" + name; }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
        if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
        return name
      }

      // Look up the name of a key as indicated by an event object.
      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) { return false }
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey) { return false }
        // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
        // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
        if (event.keyCode == 3 && event.code) { name = event.code; }
        return addModifierNames(name, event, noShift)
      }

      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val
      }

      // Helper for deleting text near the selection(s), used to implement
      // backspace, delete, and similar functionality.
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        // Build up a set of ranges to kill first, merging overlapping
        // ranges.
        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break
            }
          }
          kill.push(toKill);
        }
        // Next, remove those actual ranges.
        runInOp(cm, function () {
          for (var i = kill.length - 1; i >= 0; i--)
            { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
          ensureCursorVisible(cm);
        });
      }

      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target
      }

      function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
      }

      function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = (dir < 0) == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch;
            // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
            // it could be that the last bidi part is not on the last visual line,
            // since visual lines contain content order-consecutive chunks.
            // Thus, in rtl, we are looking for the first (content-order) character
            // in the rtl chunk that is on the last line (that is, the same line
            // as the last (content-order) character).
            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
              if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
            } else { ch = dir < 0 ? part.to : part.from; }
            return new Pos(lineNo, ch, sticky)
          }
        }
        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
      }

      function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) { return moveLogically(line, start, dir) }
        if (start.ch >= line.text.length) {
          start.ch = line.text.length;
          start.sticky = "before";
        } else if (start.ch <= 0) {
          start.ch = 0;
          start.sticky = "after";
        }
        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
          // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
          // nothing interesting happens.
          return moveLogically(line, start, dir)
        }

        var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
        var prep;
        var getWrappedLineExtent = function (ch) {
          if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch)
        };
        var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = (part.level == 1) == (dir < 0);
          var ch = mv(start, moveInStorageOrder ? 1 : -1);
          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
            // Case 2: We move within an rtl part or in an rtl editor on the same visual line
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start.line, ch, sticky)
          }
        }

        // Case 3: Could not move within this bidi part in this visual line, so leave
        // the current bidi part

        var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
          var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
            ? new Pos(start.line, mv(ch, 1), "before")
            : new Pos(start.line, ch, "after"); };

          for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
            var part = bidi[partPos];
            var moveInStorageOrder = (dir > 0) == (part.level != 1);
            var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
            if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
            ch = moveInStorageOrder ? part.from : mv(part.to, -1);
            if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
          }
        };

        // Case 3a: Look for other bidi parts on the same visual line
        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
        if (res) { return res }

        // Case 3b: Look for other bidi parts on the next visual line
        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
          if (res) { return res }
        }

        // Case 4: Nowhere to move
        return null
      }

      // Commands are parameter-less actions that can be performed on an
      // editor, mostly used for keybindings.
      var commands = {
        selectAll: selectAll,
        singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
        killLine: function (cm) { return deleteNearSelection(cm, function (range) {
          if (range.empty()) {
            var len = getLine(cm.doc, range.head.line).text.length;
            if (range.head.ch == len && range.head.line < cm.lastLine())
              { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
            else
              { return {from: range.head, to: Pos(range.head.line, len)} }
          } else {
            return {from: range.from(), to: range.to()}
          }
        }); },
        deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
          from: Pos(range.from().line, 0),
          to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
        }); }); },
        delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
          from: Pos(range.from().line, 0), to: range.from()
        }); }); },
        delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          var leftPos = cm.coordsChar({left: 0, top: top}, "div");
          return {from: leftPos, to: range.from()}
        }); },
        delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
          return {from: range.from(), to: rightPos }
        }); },
        undo: function (cm) { return cm.undo(); },
        redo: function (cm) { return cm.redo(); },
        undoSelection: function (cm) { return cm.undoSelection(); },
        redoSelection: function (cm) { return cm.redoSelection(); },
        goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
        goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
        goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
          {origin: "+move", bias: 1}
        ); },
        goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
          {origin: "+move", bias: 1}
        ); },
        goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
          {origin: "+move", bias: -1}
        ); },
        goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
          var top = cm.cursorCoords(range.head, "div").top + 5;
          return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
        }, sel_move); },
        goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
          var top = cm.cursorCoords(range.head, "div").top + 5;
          return cm.coordsChar({left: 0, top: top}, "div")
        }, sel_move); },
        goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
          var top = cm.cursorCoords(range.head, "div").top + 5;
          var pos = cm.coordsChar({left: 0, top: top}, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
          return pos
        }, sel_move); },
        goLineUp: function (cm) { return cm.moveV(-1, "line"); },
        goLineDown: function (cm) { return cm.moveV(1, "line"); },
        goPageUp: function (cm) { return cm.moveV(-1, "page"); },
        goPageDown: function (cm) { return cm.moveV(1, "page"); },
        goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
        goCharRight: function (cm) { return cm.moveH(1, "char"); },
        goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
        goColumnRight: function (cm) { return cm.moveH(1, "column"); },
        goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
        goGroupRight: function (cm) { return cm.moveH(1, "group"); },
        goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
        goWordRight: function (cm) { return cm.moveH(1, "word"); },
        delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
        delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
        delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
        delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
        delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
        delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
        indentAuto: function (cm) { return cm.indentSelection("smart"); },
        indentMore: function (cm) { return cm.indentSelection("add"); },
        indentLess: function (cm) { return cm.indentSelection("subtract"); },
        insertTab: function (cm) { return cm.replaceSelection("\t"); },
        insertSoftTab: function (cm) {
          var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function (cm) {
          if (cm.somethingSelected()) { cm.indentSelection("add"); }
          else { cm.execCommand("insertTab"); }
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function (cm) { return runInOp(cm, function () {
          var ranges = cm.listSelections(), newSel = [];
          for (var i = 0; i < ranges.length; i++) {
            if (!ranges[i].empty()) { continue }
            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                                Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos(cur.line, 1);
                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                  prev.charAt(prev.length - 1),
                                  Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        }); },
        newlineAndIndent: function (cm) { return runInOp(cm, function () {
          var sels = cm.listSelections();
          for (var i = sels.length - 1; i >= 0; i--)
            { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
          sels = cm.listSelections();
          for (var i$1 = 0; i$1 < sels.length; i$1++)
            { cm.indentLine(sels[i$1].from().line, null, true); }
          ensureCursorVisible(cm);
        }); },
        openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
        toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
      };


      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) { lineN = lineNo(visual); }
        return endOfLine(true, cm, visual, lineN, 1)
      }
      function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);
        if (visual != line) { lineN = lineNo(visual); }
        return endOfLine(true, cm, line, lineN, -1)
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
        }
        return start
      }

      // Run a handler that was bound to a key.
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) { return false }
        }
        // Ensure previous input has been read, so that the handler sees a
        // consistent view of the document
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
          if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
          if (dropShift) { cm.display.shift = false; }
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done
      }

      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
          if (result) { return result }
        }
        return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
          || lookupKey(name, cm.options.keyMap, handle, cm)
      }

      // Note that, despite the name, this function is also used to check
      // for bound mouse clicks.

      var stopSeq = new Delayed;

      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name)) { return "handled" }
          if (/\'$/.test(name))
            { cm.state.keySeq = null; }
          else
            { stopSeq.set(50, function () {
              if (cm.state.keySeq == seq) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            }); }
          if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
        }
        return dispatchKeyInner(cm, name, e, handle)
      }

      function dispatchKeyInner(cm, name, e, handle) {
        var result = lookupKeyForEditor(cm, name, handle);

        if (result == "multi")
          { cm.state.keySeq = name; }
        if (result == "handled")
          { signalLater(cm, "keyHandled", cm, name, e); }

        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }

        return !!result
      }

      // Handle a key from the keydown event.
      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name) { return false }

        if (e.shiftKey && !cm.state.keySeq) {
          // First try to resolve full name (including 'Shift-'). Failing
          // that, see if there is a cursor-motion command (starting with
          // 'go') bound to the keyname without 'Shift-'.
          return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
              || dispatchKey(cm, name, e, function (b) {
                   if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                     { return doHandleBinding(cm, b) }
                 })
        } else {
          return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
        }
      }

      // Handle a key from the keypress event
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
      }

      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e)) { return }
        // IE does strange things with escape.
        if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          // Opera has no cut event... we try to at least catch the key combo
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
            { cm.replaceSelection("", null, "cut"); }
        }

        // Turn mouse into crosshair when Alt is held on Mac.
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
          { showCrossHair(cm); }
      }

      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");

        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }

      function onKeyUp(e) {
        if (e.keyCode == 16) { this.doc.sel.shift = false; }
        signalDOMEvent(this, e);
      }

      function onKeyPress(e) {
        var cm = this;
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
        if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        // Some browsers fire keypress events for backspace
        if (ch == "\x08") { return }
        if (handleCharBinding(cm, e, ch)) { return }
        cm.display.input.onKeyPress(e);
      }

      var DOUBLECLICK_DELAY = 400;

      var PastClick = function(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };

      PastClick.prototype.compare = function (time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time &&
          cmp(pos, this.pos) == 0 && button == this.button
      };

      var lastClick, lastDoubleClick;
      function clickRepeat(pos, button) {
        var now = +new Date;
        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple"
        } else if (lastClick && lastClick.compare(now, pos, button)) {
          lastDoubleClick = new PastClick(now, pos, button);
          lastClick = null;
          return "double"
        } else {
          lastClick = new PastClick(now, pos, button);
          lastDoubleClick = null;
          return "single"
        }
      }

      // A mouse down can be a single click, double click, triple click,
      // start of selection drag, start of text drag, new cursor
      // (ctrl-click), rectangle drag (alt-drag), or xwin
      // middle-click-paste. Or it might be a click on something we should
      // not interfere with, such as a scrollbar or widget.
      function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
        display.input.ensurePolled();
        display.shift = e.shiftKey;

        if (eventInWidget(display, e)) {
          if (!webkit) {
            // Briefly turn off draggability, to allow widgets to do
            // normal dragging things.
            display.scroller.draggable = false;
            setTimeout(function () { return display.scroller.draggable = true; }, 100);
          }
          return
        }
        if (clickInGutter(cm, e)) { return }
        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
        window.focus();

        // #3261: make sure, that we're not starting a second selection
        if (button == 1 && cm.state.selectingText)
          { cm.state.selectingText(e); }

        if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

        if (button == 1) {
          if (pos) { leftButtonDown(cm, pos, repeat, e); }
          else if (e_target(e) == display.scroller) { e_preventDefault(e); }
        } else if (button == 2) {
          if (pos) { extendSelection(cm.doc, pos); }
          setTimeout(function () { return display.input.focus(); }, 20);
        } else if (button == 3) {
          if (captureRightClick) { cm.display.input.onContextMenu(e); }
          else { delayBlurEvent(cm); }
        }
      }

      function handleMappedButton(cm, button, pos, repeat, event) {
        var name = "Click";
        if (repeat == "double") { name = "Double" + name; }
        else if (repeat == "triple") { name = "Triple" + name; }
        name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

        return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
          if (typeof bound == "string") { bound = commands[bound]; }
          if (!bound) { return false }
          var done = false;
          try {
            if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }
          return done
        })
      }

      function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {};
        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }
        if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
        if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
        if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
        return value
      }

      function leftButtonDown(cm, pos, repeat, event) {
        if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
        else { cm.curOp.focus = activeElt(); }

        var behavior = configureMouse(cm, repeat, event);

        var sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
            repeat == "single" && (contained = sel.contains(pos)) > -1 &&
            (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
            (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
          { leftButtonStartDrag(cm, event, pos, behavior); }
        else
          { leftButtonSelect(cm, event, pos, behavior); }
      }

      // Start a text drag. When it ends, see if any dragging actually
      // happen, and treat as a click if it didn't.
      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display, moved = false;
        var dragEnd = operation(cm, function (e) {
          if (webkit) { display.scroller.draggable = false; }
          cm.state.draggingText = false;
          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);
          if (!moved) {
            e_preventDefault(e);
            if (!behavior.addNew)
              { extendSelection(cm.doc, pos, null, null, behavior.extend); }
            // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
            if (webkit || ie && ie_version == 9)
              { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
            else
              { display.input.focus(); }
          }
        });
        var mouseMove = function(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        var dragStart = function () { return moved = true; };
        // Let the drag handler handle this.
        if (webkit) { display.scroller.draggable = true; }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        // IE's approach to draggable
        if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);

        delayBlurEvent(cm);
        setTimeout(function () { return display.input.focus(); }, 20);
      }

      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") { return new Range(pos, pos) }
        if (unit == "word") { return cm.findWordAt(pos) }
        if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
        var result = unit(cm, pos);
        return new Range(result.from, result.to)
      }

      // Normal selection, as opposed to text dragging.
      function leftButtonSelect(cm, event, start, behavior) {
        var display = cm.display, doc = cm.doc;
        e_preventDefault(event);

        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc.sel.contains(start);
          if (ourIndex > -1)
            { ourRange = ranges[ourIndex]; }
          else
            { ourRange = new Range(start, start); }
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }

        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) { ourRange = new Range(start, start); }
          start = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range$$1 = rangeForUnit(cm, start, behavior.unit);
          if (behavior.extend)
            { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
          else
            { ourRange = range$$1; }
        }

        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                       {scroll: false, origin: "*mouse"});
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                       {scroll: false, origin: "*mouse"});
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }

        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) { return }
          lastPos = pos;

          if (behavior.unit == "rectangle") {
            var ranges = [], tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
                 line <= end; line++) {
              var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
              if (left == right)
                { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
              else if (text.length > leftPos)
                { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
            }
            if (!ranges.length) { ranges.push(new Range(start, start)); }
            setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                         {origin: "*mouse", scroll: false});
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range$$1 = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor, head;
            if (cmp(range$$1.anchor, anchor) > 0) {
              head = range$$1.head;
              anchor = minPos(oldRange.from(), range$$1.anchor);
            } else {
              head = range$$1.anchor;
              anchor = maxPos(oldRange.to(), range$$1.head);
            }
            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
            setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }

        var editorSize = display.wrapper.getBoundingClientRect();
        // Used to ensure timeout re-tries don't fire when another extend
        // happened in the meantime (clearTimeout isn't reliable -- at
        // least on Chrome, the timeouts still happen even when cleared,
        // if the clear happens after their scheduled firing time).
        var counter = 0;

        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
          if (!cur) { return }
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from)
              { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) { setTimeout(operation(cm, function () {
              if (counter != curCount) { return }
              display.scroller.scrollTop += outside;
              extend(e);
            }), 50); }
          }
        }

        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          // If e is null or undefined we interpret this as someone trying
          // to explicitly cancel the selection rather than the user
          // letting go of the mouse button.
          if (e) {
            e_preventDefault(e);
            display.input.focus();
          }
          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }

        var move = operation(cm, function (e) {
          if (e.buttons === 0 || !e_button(e)) { done(e); }
          else { extend(e); }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      }

      // Used when mouse-selecting to adjust the anchor to the proper side
      // of a bidi jump depending on the visual position of the head.
      function bidiSimplify(cm, range$$1) {
        var anchor = range$$1.anchor;
        var head = range$$1.head;
        var anchorLine = getLine(cm.doc, anchor.line);
        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
        var order = getOrder(anchorLine);
        if (!order) { return range$$1 }
        var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
        if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
        var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length) { return range$$1 }

        // Compute the relative visual position of the head compared to the
        // anchor (<0 is to the left, >0 to the right)
        var leftSide;
        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
          if (headIndex == boundary - 1 || headIndex == boundary)
            { leftSide = dir < 0; }
          else
            { leftSide = dir > 0; }
        }

        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
      }


      // Determines whether an event happened in the gutter, and fires the
      // handlers for the corresponding event.
      function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        if (e.touches) {
          mX = e.touches[0].clientX;
          mY = e.touches[0].clientY;
        } else {
          try { mX = e.clientX; mY = e.clientY; }
          catch(e) { return false }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
        if (prevent) { e_preventDefault(e); }

        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();

        if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
        mY -= lineBox.top - display.viewOffset;

        for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.display.gutterSpecs[i];
            signal(cm, type, cm, line, gutter.className, e);
            return e_defaultPrevented(e)
          }
        }
      }

      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true)
      }

      // CONTEXT MENU HANDLING

      // To make the context menu work, we need to briefly unhide the
      // textarea (making it as unobtrusive as possible) to let the
      // right-click take effect on it.
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
        if (signalDOMEvent(cm, e, "contextmenu")) { return }
        if (!captureRightClick) { cm.display.input.onContextMenu(e); }
      }

      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) { return false }
        return gutterEvent(cm, e, "gutterContextMenu", false)
      }

      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
          cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }

      var Init = {toString: function(){return "CodeMirror.Init"}};

      var defaults = {};
      var optionHandlers = {};

      function defineOptions(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;

        function option(name, deflt, handle, notOnInit) {
          CodeMirror.defaults[name] = deflt;
          if (handle) { optionHandlers[name] =
            notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
        }

        CodeMirror.defineOption = option;

        // Passed to option handlers when there is no old value.
        CodeMirror.Init = Init;

        // These two are, on init, called from the constructor because they
        // have to be initialized before the editor can start at all.
        option("value", "", function (cm, val) { return cm.setValue(val); }, true);
        option("mode", null, function (cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);

        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function (cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);

        option("lineSeparator", null, function (cm, val) {
          cm.doc.lineSep = val;
          if (!val) { return }
          var newBreaks = [], lineNo = cm.doc.first;
          cm.doc.iter(function (line) {
            for (var pos = 0;;) {
              var found = line.text.indexOf(val, pos);
              if (found == -1) { break }
              pos = found + val.length;
              newBreaks.push(Pos(lineNo, found));
            }
            lineNo++;
          });
          for (var i = newBreaks.length - 1; i >= 0; i--)
            { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
          if (old != Init) { cm.refresh(); }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
          throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
        }, true);
        option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
        option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
        option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);

        option("theme", "default", function (cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function (cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);
          if (prev && prev.detach) { prev.detach(cm, next); }
          if (next.attach) { next.attach(cm, prev || null); }
        });
        option("extraKeys", null);
        option("configureMouse", null);

        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function (cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function (cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
        option("scrollbarStyle", "native", function (cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function (cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);

        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);

        option("readOnly", false, function (cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }
          cm.display.input.readOnlyChanged(val);
        });
        option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);

        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
        option("maxHighlightLength", 10000, resetModeState, true);
        option("moveInputWithCursor", true, function (cm, val) {
          if (!val) { cm.display.input.resetPosition(); }
        });

        option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
        option("autofocus", null);
        option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
        option("phrases", null);
      }

      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }

      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () { return updateScrollbars(cm); }, 100);
      }

      // A CodeMirror instance represents an editor. This is the object
      // that user code is usually dealing with.

      function CodeMirror(place, options) {
        var this$1 = this;

        if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

        this.options = options = options ? copyObj(options) : {};
        // Determine effective options based on given values and defaults.
        copyObj(defaults, options, false);

        var doc = options.value;
        if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
        else if (options.mode) { doc.modeOption = options.mode; }
        this.doc = doc;

        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);
        if (options.lineWrapping)
          { this.display.wrapper.className += " CodeMirror-wrap"; }
        initScrollbars(this);

        this.state = {
          keyMaps: [],  // stores maps added by addKeyMap
          overlays: [], // highlighting overlays, as added by addOverlay
          modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(), // stores highlight worker timeout
          keySeq: null,  // Unfinished key sequence
          specialChars: null
        };

        if (options.autofocus && !mobile) { display.input.focus(); }

        // Override magic textarea content restore that IE sometimes does
        // on our hidden textarea on reload
        if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

        registerEventHandlers(this);
        ensureGlobalHandlers();

        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);

        if ((options.autofocus && !mobile) || this.hasFocus())
          { setTimeout(bind(onFocus, this), 20); }
        else
          { onBlur(this); }

        for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
          { optionHandlers[opt](this, options[opt], Init); } }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) { options.finishInit(this); }
        for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
        endOperation(this);
        // Suppress optimizelegibility in Webkit, since it breaks text
        // measuring on line wrapping boundaries.
        if (webkit && options.lineWrapping &&
            getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
          { display.lineDiv.style.textRendering = "auto"; }
      }

      // The default configuration options.
      CodeMirror.defaults = defaults;
      // Functions to run when options are changed.
      CodeMirror.optionHandlers = optionHandlers;

      // Attach the necessary event handlers when initializing the editor
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        // Older IE's will not fire a second mousedown for a double click
        if (ie && ie_version < 11)
          { on(d.scroller, "dblclick", operation(cm, function (e) {
            if (signalDOMEvent(cm, e)) { return }
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          })); }
        else
          { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
        // Some browsers fire contextmenu *after* opening the menu, at
        // which point we can't mess with it anymore. Context menu is
        // handled in onMouseDown for these browsers.
        on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

        // Used to suppress mouse event handling when a touch happens
        var touchFinished, prevTouch = {end: 0};
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date;
          }
        }
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) { return false }
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1
        }
        function farAway(touch, other) {
          if (other.left == null) { return true }
          var dx = other.left - touch.left, dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20
        }
        on(d.scroller, "touchstart", function (e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +new Date;
            d.activeTouch = {start: now, moved: false,
                             prev: now - prevTouch.end <= 300 ? prevTouch : null};
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function () {
          if (d.activeTouch) { d.activeTouch.moved = true; }
        });
        on(d.scroller, "touchend", function (e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null &&
              !touch.moved && new Date - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"), range;
            if (!touch.prev || farAway(touch, touch.prev)) // Single tap
              { range = new Range(pos, pos); }
            else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
              { range = cm.findWordAt(pos); }
            else // Triple tap
              { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);

        // Sync scrolling between fake scrollbars and real scrollable
        // area, ensure viewport is updated when scrolling.
        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            updateScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });

        // Listen to wheel events in order to try and update the viewport on time.
        on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
        on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

        // Prevent wrapper from ever scrolling
        on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

        d.dragFunctions = {
          enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
          over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
          start: function (e) { return onDragStart(cm, e); },
          drop: operation(cm, onDrop),
          leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
        };

        var inp = d.input.getField();
        on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function (e) { return onFocus(cm, e); });
        on(inp, "blur", function (e) { return onBlur(cm, e); });
      }

      var initHooks = [];
      CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

      // Indent the given line. The how parameter can be "smart",
      // "add"/null, "subtract", or "prev". When aggressive is false
      // (typically set to true for forced single-line indents), empty
      // lines are not indented, and places where the mode returns Pass
      // are left alone.
      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc, state;
        if (how == null) { how = "add"; }
        if (how == "smart") {
          // Fall back to "prev" when the mode doesn't have an indentation
          // method.
          if (!doc.mode.indent) { how = "prev"; }
          else { state = getContextBefore(cm, n).state; }
        }

        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) { line.stateAfter = null; }
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive) { return }
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
          else { indentation = 0; }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);

        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs)
          { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
        if (pos < indentation) { indentString += spaceStr(indentation - pos); }

        if (indentString != curSpaceString) {
          replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true
        } else {
          // Ensure that, if the cursor was in the whitespace at the start
          // of the line, it is moved to the end of that space.
          for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
              break
            }
          }
        }
      }

      // This will be set to a {lineWise: bool, text: [string]} object, so
      // that, when pasting, we know what kind of selections the copied
      // text was made out of.
      var lastCopied = null;

      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }

      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel) { sel = doc.sel; }

        var recent = +new Date - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted), multiPaste = null;
        // When pasting N lines into N selections, insert one line per selection
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];
              for (var i = 0; i < lastCopied.text.length; i++)
                { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map(textLines, function (l) { return [l]; });
          }
        }

        var updateInput = cm.curOp.updateInput;
        // Normal behavior is to insert the new text into every selection
        for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
          var range$$1 = sel.ranges[i$1];
          var from = range$$1.from(), to = range$$1.to();
          if (range$$1.empty()) {
            if (deleted && deleted > 0) // Handle deletion
              { from = Pos(from.line, from.ch - deleted); }
            else if (cm.state.overwrite && !paste) // Handle overwrite
              { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
            else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
              { from = to = Pos(from.line, 0); }
          }
          var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                             origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste)
          { triggerElectric(cm, inserted); }

        ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }

      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) {
          e.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput)
            { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
          return true
        }
      }

      function triggerElectric(cm, inserted) {
        // When an 'electric' character is inserted, immediately trigger a reindent
        if (!cm.options.electricChars || !cm.options.smartIndent) { return }
        var sel = cm.doc.sel;

        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range$$1 = sel.ranges[i];
          if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
          var mode = cm.getModeAt(range$$1.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++)
              { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range$$1.head.line, "smart");
                break
              } }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
              { indented = indentLine(cm, range$$1.head.line, "smart"); }
          }
          if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
        }
      }

      function copyableRanges(cm) {
        var text = [], ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {text: text, ranges: ranges}
      }

      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", !!autocorrect);
        field.setAttribute("autocapitalize", !!autocapitalize);
        field.setAttribute("spellcheck", !!spellcheck);
      }

      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        // The textarea is kept positioned near the cursor to prevent the
        // fact that it'll be scrolled into view on input from scrolling
        // our fake cursor out of view. On webkit, when wrap=off, paste is
        // very slow. So make the area wide instead.
        if (webkit) { te.style.width = "1000px"; }
        else { te.setAttribute("wrap", "off"); }
        // If border: 0; -- iOS fails to open keyboard (issue #1287)
        if (ios) { te.style.border = "1px solid black"; }
        disableBrowserMagic(te);
        return div
      }

      // The publicly visible API. Note that methodOp(f) means
      // 'wrap f in an operation, performed on its `this` parameter'.

      // This is not the complete set of editor methods. Most of the
      // methods defined on the Doc type are also injected into
      // CodeMirror.prototype, for backwards compatibility and
      // convenience.

      function addEditorMethods(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;

        var helpers = CodeMirror.helpers = {};

        CodeMirror.prototype = {
          constructor: CodeMirror,
          focus: function(){window.focus(); this.display.input.focus();},

          setOption: function(option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != "mode") { return }
            options[option] = value;
            if (optionHandlers.hasOwnProperty(option))
              { operation(this, optionHandlers[option])(this, value, old); }
            signal(this, "optionChange", this, option);
          },

          getOption: function(option) {return this.options[option]},
          getDoc: function() {return this.doc},

          addKeyMap: function(map$$1, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
          },
          removeKeyMap: function(map$$1) {
            var maps = this.state.keyMaps;
            for (var i = 0; i < maps.length; ++i)
              { if (maps[i] == map$$1 || maps[i].name == map$$1) {
                maps.splice(i, 1);
                return true
              } }
          },

          addOverlay: methodOp(function(spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState) { throw new Error("Overlays may not be stateful.") }
            insertSorted(this.state.overlays,
                         {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                          priority: (options && options.priority) || 0},
                         function (overlay) { return overlay.priority; });
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function(spec) {
            var overlays = this.state.overlays;
            for (var i = 0; i < overlays.length; ++i) {
              var cur = overlays[i].modeSpec;
              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i, 1);
                this.state.modeGen++;
                regChange(this);
                return
              }
            }
          }),

          indentLine: methodOp(function(n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
              else { dir = dir ? "add" : "subtract"; }
            }
            if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
          }),
          indentSelection: methodOp(function(how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i = 0; i < ranges.length; i++) {
              var range$$1 = ranges[i];
              if (!range$$1.empty()) {
                var from = range$$1.from(), to = range$$1.to();
                var start = Math.max(end, from.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                for (var j = start; j < end; ++j)
                  { indentLine(this, j, how); }
                var newRanges = this.doc.sel.ranges;
                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                  { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
              } else if (range$$1.head.line > end) {
                indentLine(this, range$$1.head.line, how, true);
                end = range$$1.head.line;
                if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
              }
            }
          }),

          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(pos, precise) {
            return takeToken(this, pos, precise)
          },

          getLineTokens: function(line, precise) {
            return takeToken(this, Pos(line), precise, true)
          },

          getTokenTypeAt: function(pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type;
            if (ch == 0) { type = styles[2]; }
            else { for (;;) {
              var mid = (before + after) >> 1;
              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
              else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
              else { type = styles[mid * 2 + 2]; break }
            } }
            var cut = type ? type.indexOf("overlay ") : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
          },

          getModeAt: function(pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode) { return mode }
            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
          },

          getHelper: function(pos, type) {
            return this.getHelpers(pos, type)[0]
          },

          getHelpers: function(pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type)) { return found }
            var help = helpers[type], mode = this.getModeAt(pos);
            if (typeof mode[type] == "string") {
              if (help[mode[type]]) { found.push(help[mode[type]]); }
            } else if (mode[type]) {
              for (var i = 0; i < mode[type].length; i++) {
                var val = help[mode[type][i]];
                if (val) { found.push(val); }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }
            for (var i$1 = 0; i$1 < help._global.length; i$1++) {
              var cur = help._global[i$1];
              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
                { found.push(cur.val); }
            }
            return found
          },

          getStateAfter: function(line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
            return getContextBefore(this, line + 1, precise).state
          },

          cursorCoords: function(start, mode) {
            var pos, range$$1 = this.doc.sel.primary();
            if (start == null) { pos = range$$1.head; }
            else if (typeof start == "object") { pos = clipPos(this.doc, start); }
            else { pos = start ? range$$1.from() : range$$1.to(); }
            return cursorCoords(this, pos, mode || "page")
          },

          charCoords: function(pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page")
          },

          coordsChar: function(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return coordsChar(this, coords.left, coords.top)
          },

          lineAtHeight: function(height, mode) {
            height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
            return lineAtHeight(this.doc, height + this.display.viewOffset)
          },
          heightAtLine: function(line, mode, includeWidgets) {
            var end = false, lineObj;
            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;
              if (line < this.doc.first) { line = this.doc.first; }
              else if (line > last) { line = last; end = true; }
              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }
            return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
              (end ? this.doc.height - heightAtLine(lineObj) : 0)
          },

          defaultTextHeight: function() { return textHeight(this.display) },
          defaultCharWidth: function() { return charWidth(this.display) },

          getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

          addWidget: function(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
              // Default to positioning above (if specified and possible); otherwise default to positioning below
              if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                { top = pos.top - node.offsetHeight; }
              else if (pos.bottom + node.offsetHeight <= vspace)
                { top = pos.bottom; }
              if (left + node.offsetWidth > hspace)
                { left = hspace - node.offsetWidth; }
            }
            node.style.top = top + "px";
            node.style.left = node.style.right = "";
            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") { left = 0; }
              else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
              node.style.left = left + "px";
            }
            if (scroll)
              { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
          },

          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),

          execCommand: function(cmd) {
            if (commands.hasOwnProperty(cmd))
              { return commands[cmd].call(null, this) }
          },

          triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

          findPosH: function(from, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) { dir = -1; amount = -amount; }
            var cur = clipPos(this.doc, from);
            for (var i = 0; i < amount; ++i) {
              cur = findPosH(this.doc, cur, dir, unit, visually);
              if (cur.hitSide) { break }
            }
            return cur
          },

          moveH: methodOp(function(dir, unit) {
            var this$1 = this;

            this.extendSelectionsBy(function (range$$1) {
              if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
                { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
              else
                { return dir < 0 ? range$$1.from() : range$$1.to() }
            }, sel_move);
          }),

          deleteH: methodOp(function(dir, unit) {
            var sel = this.doc.sel, doc = this.doc;
            if (sel.somethingSelected())
              { doc.replaceSelection("", null, "+delete"); }
            else
              { deleteNearSelection(this, function (range$$1) {
                var other = findPosH(doc, range$$1.head, dir, unit, false);
                return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
              }); }
          }),

          findPosV: function(from, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            if (amount < 0) { dir = -1; amount = -amount; }
            var cur = clipPos(this.doc, from);
            for (var i = 0; i < amount; ++i) {
              var coords = cursorCoords(this, cur, "div");
              if (x == null) { x = coords.left; }
              else { coords.left = x; }
              cur = findPosV(this, coords, dir, unit);
              if (cur.hitSide) { break }
            }
            return cur
          },

          moveV: methodOp(function(dir, unit) {
            var this$1 = this;

            var doc = this.doc, goals = [];
            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range$$1) {
              if (collapse)
                { return dir < 0 ? range$$1.from() : range$$1.to() }
              var headPos = cursorCoords(this$1, range$$1.head, "div");
              if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
              goals.push(headPos.left);
              var pos = findPosV(this$1, headPos, dir, unit);
              if (unit == "page" && range$$1 == doc.sel.primary())
                { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
              return pos
            }, sel_move);
            if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
              { doc.sel.ranges[i].goalColumn = goals[i]; } }
          }),

          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(pos) {
            var doc = this.doc, line = getLine(doc, pos.line).text;
            var start = pos.ch, end = pos.ch;
            if (line) {
              var helper = this.getHelper(pos, "wordChars");
              if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper)
                ? function (ch) { return isWordChar(ch, helper); }
                : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
                : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
              while (start > 0 && check(line.charAt(start - 1))) { --start; }
              while (end < line.length && check(line.charAt(end))) { ++end; }
            }
            return new Range(Pos(pos.line, start), Pos(pos.line, end))
          },

          toggleOverwrite: function(value) {
            if (value != null && value == this.state.overwrite) { return }
            if (this.state.overwrite = !this.state.overwrite)
              { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
            else
              { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function() { return this.display.input.getField() == activeElt() },
          isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

          scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
          getScrollInfo: function() {
            var scroller = this.display.scroller;
            return {left: scroller.scrollLeft, top: scroller.scrollTop,
                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                    clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
          },

          scrollIntoView: methodOp(function(range$$1, margin) {
            if (range$$1 == null) {
              range$$1 = {from: this.doc.sel.primary().head, to: null};
              if (margin == null) { margin = this.options.cursorScrollMargin; }
            } else if (typeof range$$1 == "number") {
              range$$1 = {from: Pos(range$$1, 0), to: null};
            } else if (range$$1.from == null) {
              range$$1 = {from: range$$1, to: null};
            }
            if (!range$$1.to) { range$$1.to = range$$1.from; }
            range$$1.margin = margin || 0;

            if (range$$1.from.line != null) {
              scrollToRange(this, range$$1);
            } else {
              scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
            }
          }),

          setSize: methodOp(function(width, height) {
            var this$1 = this;

            var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
            if (width != null) { this.display.wrapper.style.width = interpret(width); }
            if (height != null) { this.display.wrapper.style.height = interpret(height); }
            if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
            var lineNo$$1 = this.display.viewFrom;
            this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
              if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
                { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
              ++lineNo$$1;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),

          operation: function(f){return runInOp(this, f)},
          startOperation: function(){return startOperation(this)},
          endOperation: function(){return endOperation(this)},

          refresh: methodOp(function() {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
              { estimateLineHeights(this); }
            signal(this, "refresh", this);
          }),

          swapDoc: methodOp(function(doc) {
            var old = this.doc;
            old.cm = null;
            // Cancel the current text selection if any (#5821)
            if (this.state.selectingText) { this.state.selectingText(); }
            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old
          }),

          phrase: function(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
          },

          getInputField: function(){return this.display.input.getField()},
          getWrapperElement: function(){return this.display.wrapper},
          getScrollerElement: function(){return this.display.scroller},
          getGutterElement: function(){return this.display.gutters}
        };
        eventMixin(CodeMirror);

        CodeMirror.registerHelper = function(type, name, value) {
          if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
          helpers[type][name] = value;
        };
        CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
          CodeMirror.registerHelper(type, name, value);
          helpers[type]._global.push({pred: predicate, val: value});
        };
      }

      // Used for horizontal relative motion. Dir is -1 or 1 (left or
      // right), unit can be "char", "column" (like char, but doesn't
      // cross line boundaries), "word" (across next word), or "group" (to
      // the start of next group of word or non-word-non-whitespace
      // chars). The visually param controls whether, in right-to-left
      // text, direction 1 means to move towards the next index in the
      // string, or towards the character to the right of the current
      // position. The resulting position will have a hitSide=true
      // property if it reached the end of the document.
      function findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc, pos.line);
        function findNextLine() {
          var l = pos.line + dir;
          if (l < doc.first || l >= doc.first + doc.size) { return false }
          pos = new Pos(l, pos.ch, pos.sticky);
          return lineObj = getLine(doc, l)
        }
        function moveOnce(boundToLine) {
          var next;
          if (visually) {
            next = moveVisually(doc.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }
          if (next == null) {
            if (!boundToLine && findNextLine())
              { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
            else
              { return false }
          } else {
            pos = next;
          }
          return true
        }

        if (unit == "char") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null, group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) { break }
            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type = isWordChar(cur, helper) ? "w"
              : group && cur == "\n" ? "n"
              : !group || /\s/.test(cur) ? null
              : "p";
            if (group && !first && !type) { type = "s"; }
            if (sawType && sawType != type) {
              if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
              break
            }

            if (type) { sawType = type; }
            if (dir > 0 && !moveOnce(!first)) { break }
          }
        }
        var result = skipAtomic(doc, pos, oldPos, origDir, true);
        if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
        return result
      }

      // For relative vertical movement. Dir may be -1 or 1. Unit can be
      // "page" or "line". The resulting position will have a hitSide=true
      // property if it reached the end of the document.
      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc, x = pos.left, y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for (;;) {
          target = coordsChar(cm, x, y);
          if (!target.outside) { break }
          if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
          y += dir * 5;
        }
        return target
      }

      // CONTENTEDITABLE INPUT STYLE

      var ContentEditableInput = function(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };

      ContentEditableInput.prototype.init = function (display) {
          var this$1 = this;

        var input = this, cm = input.cm;
        var div = input.div = display.lineDiv;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

        on(div, "paste", function (e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
          // IE doesn't fire input events, so we schedule a read for the pasted content in this way
          if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
        });

        on(div, "compositionstart", function (e) {
          this$1.composing = {data: e.data, done: false};
        });
        on(div, "compositionupdate", function (e) {
          if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
        });
        on(div, "compositionend", function (e) {
          if (this$1.composing) {
            if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
            this$1.composing.done = true;
          }
        });

        on(div, "touchstart", function () { return input.forceCompositionEnd(); });

        on(div, "input", function () {
          if (!this$1.composing) { this$1.readFromDOMSoon(); }
        });

        function onCopyCut(e) {
          if (signalDOMEvent(cm, e)) { return }
          if (cm.somethingSelected()) {
            setLastCopied({lineWise: false, text: cm.getSelections()});
            if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
          } else if (!cm.options.lineWiseCopyCut) {
            return
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({lineWise: true, text: ranges.text});
            if (e.type == "cut") {
              cm.operation(function () {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }
          if (e.clipboardData) {
            e.clipboardData.clearData();
            var content = lastCopied.text.join("\n");
            // iOS exposes the clipboard API, but seems to discard content inserted into it
            e.clipboardData.setData("Text", content);
            if (e.clipboardData.getData("Text") == content) {
              e.preventDefault();
              return
            }
          }
          // Old-fashioned briefly-focus-a-textarea hack
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function () {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
            if (hadFocus == div) { input.showPrimarySelection(); }
          }, 50);
        }
        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };

      ContentEditableInput.prototype.prepareSelection = function () {
        var result = prepareSelection(this.cm, false);
        result.focus = this.cm.state.focused;
        return result
      };

      ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
        if (!info || !this.cm.display.view.length) { return }
        if (info.focus || takeFocus) { this.showPrimarySelection(); }
        this.showMultipleSelections(info);
      };

      ContentEditableInput.prototype.getSelection = function () {
        return this.cm.display.wrapper.ownerDocument.getSelection()
      };

      ContentEditableInput.prototype.showPrimarySelection = function () {
        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
        var from = prim.from(), to = prim.to();

        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return
        }

        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
            cmp(minPos(curAnchor, curFocus), from) == 0 &&
            cmp(maxPos(curAnchor, curFocus), to) == 0)
          { return }

        var view = cm.display.view;
        var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
            {node: view[0].measure.map[2], offset: 0};
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);
        if (!end) {
          var measure = view[view.length - 1].measure;
          var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
        }

        if (!start || !end) {
          sel.removeAllRanges();
          return
        }

        var old = sel.rangeCount && sel.getRangeAt(0), rng;
        try { rng = range(start.node, start.offset, end.offset, end.node); }
        catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start.node, start.offset);
            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
          if (old && sel.anchorNode == null) { sel.addRange(old); }
          else if (gecko) { this.startGracePeriod(); }
        }
        this.rememberSelection();
      };

      ContentEditableInput.prototype.startGracePeriod = function () {
          var this$1 = this;

        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function () {
          this$1.gracePeriod = false;
          if (this$1.selectionChanged())
            { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
        }, 20);
      };

      ContentEditableInput.prototype.showMultipleSelections = function (info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };

      ContentEditableInput.prototype.rememberSelection = function () {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
      };

      ContentEditableInput.prototype.selectionInEditor = function () {
        var sel = this.getSelection();
        if (!sel.rangeCount) { return false }
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node)
      };

      ContentEditableInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor())
            { this.showSelection(this.prepareSelection(), true); }
          this.div.focus();
        }
      };
      ContentEditableInput.prototype.blur = function () { this.div.blur(); };
      ContentEditableInput.prototype.getField = function () { return this.div };

      ContentEditableInput.prototype.supportsTouch = function () { return true };

      ContentEditableInput.prototype.receivedFocus = function () {
        var input = this;
        if (this.selectionInEditor())
          { this.pollSelection(); }
        else
          { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }
        this.polling.set(this.cm.options.pollInterval, poll);
      };

      ContentEditableInput.prototype.selectionChanged = function () {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
          sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
      };

      ContentEditableInput.prototype.pollSelection = function () {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
        var sel = this.getSelection(), cm = this.cm;
        // On Android Chrome (version 56, at least), backspacing into an
        // uneditable block element will put the cursor in that element,
        // and then, because it's not editable, hide the virtual keyboard.
        // Because Android doesn't allow us to actually detect backspace
        // presses in a sane way, this code checks for when that happens
        // and simulates a backspace press in this case.
        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
          this.blur();
          this.focus();
          return
        }
        if (this.composing) { return }
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) { runInOp(cm, function () {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
        }); }
      };

      ContentEditableInput.prototype.pollContent = function () {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }

        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
        var from = sel.from(), to = sel.to();
        if (from.ch == 0 && from.line > cm.firstLine())
          { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
          { to = Pos(to.line + 1, 0); }
        if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

        var fromIndex, fromLine, fromNode;
        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }
        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;
        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }

        if (!fromNode) { return false }
        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
          else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
          else { break }
        }

        var cutFront = 0, cutEnd = 0;
        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
          { ++cutFront; }
        var newBot = lst(newText), oldBot = lst(oldText);
        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                                 oldBot.length - (oldText.length == 1 ? cutFront : 0));
        while (cutEnd < maxCutEnd &&
               newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
          { ++cutEnd; }
        // Try to move start of change to start of selection if ambiguous
        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
          while (cutFront && cutFront > from.ch &&
                 newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }

        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          replaceRange(cm.doc, newText, chFrom, chTo, "+input");
          return true
        }
      };

      ContentEditableInput.prototype.ensurePolled = function () {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.reset = function () {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.forceCompositionEnd = function () {
        if (!this.composing) { return }
        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };
      ContentEditableInput.prototype.readFromDOMSoon = function () {
          var this$1 = this;

        if (this.readDOMTimeout != null) { return }
        this.readDOMTimeout = setTimeout(function () {
          this$1.readDOMTimeout = null;
          if (this$1.composing) {
            if (this$1.composing.done) { this$1.composing = null; }
            else { return }
          }
          this$1.updateFromDOM();
        }, 80);
      };

      ContentEditableInput.prototype.updateFromDOM = function () {
          var this$1 = this;

        if (this.cm.isReadOnly() || !this.pollContent())
          { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
      };

      ContentEditableInput.prototype.setUneditable = function (node) {
        node.contentEditable = "false";
      };

      ContentEditableInput.prototype.onKeyPress = function (e) {
        if (e.charCode == 0 || this.composing) { return }
        e.preventDefault();
        if (!this.cm.isReadOnly())
          { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
      };

      ContentEditableInput.prototype.readOnlyChanged = function (val) {
        this.div.contentEditable = String(val != "nocursor");
      };

      ContentEditableInput.prototype.onContextMenu = function () {};
      ContentEditableInput.prototype.resetPosition = function () {};

      ContentEditableInput.prototype.needsContentAttribute = true;

      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) { return null }
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);

        var order = getOrder(line, cm.doc.direction), side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result
      }

      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode)
          { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
        return false
      }

      function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
        function close() {
          if (closing) {
            text += lineSep;
            if (extraLinebreak) { text += lineSep; }
            closing = extraLinebreak = false;
          }
        }
        function addText(str) {
          if (str) {
            close();
            text += str;
          }
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText) {
              addText(cmText);
              return
            }
            var markerID = node.getAttribute("cm-marker"), range$$1;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range$$1 = found[0].find(0)))
                { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
              return
            }
            if (node.getAttribute("contenteditable") == "false") { return }
            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

            if (isBlock) { close(); }
            for (var i = 0; i < node.childNodes.length; i++)
              { walk(node.childNodes[i]); }

            if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
            if (isBlock) { closing = true; }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }
        for (;;) {
          walk(from);
          if (from == to) { break }
          from = from.nextSibling;
          extraLinebreak = false;
        }
        return text
      }

      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
          node = null; offset = 0;
        } else {
          for (lineNode = node;; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) { return null }
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
          }
        }
        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];
          if (lineView.node == lineNode)
            { return locateNodeInLineView(lineView, node, offset) }
        }
      }

      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad)
          }
        }

        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset) { offset = textNode.nodeValue.length; }
        }
        while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
        var measure = lineView.measure, maps = measure.maps;

        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map$$1 = i < 0 ? measure.map : maps[i];
            for (var j = 0; j < map$$1.length; j += 3) {
              var curNode = map$$1[j + 2];
              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map$$1[j] + offset;
                if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
                return Pos(line, ch)
              }
            }
          }
        }
        var found = find(textNode, topNode, offset);
        if (found) { return badPos(found, bad) }

        // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);
          if (found)
            { return badPos(Pos(found.line, found.ch - dist), bad) }
          else
            { dist += after.textContent.length; }
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);
          if (found)
            { return badPos(Pos(found.line, found.ch + dist$1), bad) }
          else
            { dist$1 += before.textContent.length; }
        }
      }

      // TEXTAREA INPUT STYLE

      var TextareaInput = function(cm) {
        this.cm = cm;
        // See input.poll and input.reset
        this.prevInput = "";

        // Flag that indicates whether we expect input to appear real soon
        // now (after some event like 'keypress' or 'input') and are
        // polling intensively.
        this.pollingFast = false;
        // Self-resetting timeout for the poller
        this.polling = new Delayed();
        // Used to work around IE issue with selection being forgotten when focus moves away from textarea
        this.hasSelection = false;
        this.composing = null;
      };

      TextareaInput.prototype.init = function (display) {
          var this$1 = this;

        var input = this, cm = this.cm;
        this.createField(display);
        var te = this.textarea;

        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

        // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
        if (ios) { te.style.width = "0px"; }

        on(te, "input", function () {
          if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
          input.poll();
        });

        on(te, "paste", function (e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

          cm.state.pasteIncoming = +new Date;
          input.fastPoll();
        });

        function prepareCopyCut(e) {
          if (signalDOMEvent(cm, e)) { return }
          if (cm.somethingSelected()) {
            setLastCopied({lineWise: false, text: cm.getSelections()});
          } else if (!cm.options.lineWiseCopyCut) {
            return
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({lineWise: true, text: ranges.text});
            if (e.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }
          if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
        }
        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);

        on(display.scroller, "paste", function (e) {
          if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +new Date;
            input.focus();
            return
          }

          // Pass the `paste` event to the textarea so it's handled by its event listener.
          var event = new Event("paste");
          event.clipboardData = e.clipboardData;
          te.dispatchEvent(event);
        });

        // Prevent normal selection in the editor (we handle our own)
        on(display.lineSpace, "selectstart", function (e) {
          if (!eventInWidget(display, e)) { e_preventDefault(e); }
        });

        on(te, "compositionstart", function () {
          var start = cm.getCursor("from");
          if (input.composing) { input.composing.range.clear(); }
          input.composing = {
            start: start,
            range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
          };
        });
        on(te, "compositionend", function () {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };

      TextareaInput.prototype.createField = function (_display) {
        // Wraps and hides input textarea
        this.wrapper = hiddenTextarea();
        // The semihidden textarea that is focused when the editor is
        // focused, and receives input.
        this.textarea = this.wrapper.firstChild;
      };

      TextareaInput.prototype.prepareSelection = function () {
        // Redraw the selection and/or cursor
        var cm = this.cm, display = cm.display, doc = cm.doc;
        var result = prepareSelection(cm);

        // Move the hidden textarea near the cursor to prevent scrolling artifacts
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
          var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                              headPos.top + lineOff.top - wrapOff.top));
          result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                               headPos.left + lineOff.left - wrapOff.left));
        }

        return result
      };

      TextareaInput.prototype.showSelection = function (drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      };

      // Reset the input to correspond to the selection (or to be empty,
      // when not typing and nothing is selected)
      TextareaInput.prototype.reset = function (typing) {
        if (this.contextMenuPending || this.composing) { return }
        var cm = this.cm;
        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;
          if (cm.state.focused) { selectInput(this.textarea); }
          if (ie && ie_version >= 9) { this.hasSelection = content; }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";
          if (ie && ie_version >= 9) { this.hasSelection = null; }
        }
      };

      TextareaInput.prototype.getField = function () { return this.textarea };

      TextareaInput.prototype.supportsTouch = function () { return false };

      TextareaInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
          try { this.textarea.focus(); }
          catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
        }
      };

      TextareaInput.prototype.blur = function () { this.textarea.blur(); };

      TextareaInput.prototype.resetPosition = function () {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };

      TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

      // Poll for input changes, using the normal rate of polling. This
      // runs as long as the editor is focused.
      TextareaInput.prototype.slowPoll = function () {
          var this$1 = this;

        if (this.pollingFast) { return }
        this.polling.set(this.cm.options.pollInterval, function () {
          this$1.poll();
          if (this$1.cm.state.focused) { this$1.slowPoll(); }
        });
      };

      // When an event has just come in that is likely to add or change
      // something in the input textarea, we poll faster, to ensure that
      // the change appears on the screen quickly.
      TextareaInput.prototype.fastPoll = function () {
        var missed = false, input = this;
        input.pollingFast = true;
        function p() {
          var changed = input.poll();
          if (!changed && !missed) {missed = true; input.polling.set(60, p);}
          else {input.pollingFast = false; input.slowPoll();}
        }
        input.polling.set(20, p);
      };

      // Read input from the textarea, and update the document to match.
      // When something is selected, it is present in the textarea, and
      // selected (unless it is huge, in which case a placeholder is
      // used). When nothing is selected, the cursor sits after previously
      // seen text (can be empty), which is stored in prevInput (we must
      // not reset the textarea when typing, because that breaks IME).
      TextareaInput.prototype.poll = function () {
          var this$1 = this;

        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        // Since this is called a *lot*, try to bail out as cheaply as
        // possible when it is clear that nothing happened. hasSelection
        // will be the case when there is a lot of text in the textarea,
        // in which case reading its value would be expensive.
        if (this.contextMenuPending || !cm.state.focused ||
            (hasSelection(input) && !prevInput && !this.composing) ||
            cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
          { return false }

        var text = input.value;
        // If nothing changed, bail.
        if (text == prevInput && !cm.somethingSelected()) { return false }
        // Work around nonsensical selection resetting in IE9/10, and
        // inexplicable appearance of private area unicode characters on
        // some key combos in Mac (#2689).
        if (ie && ie_version >= 9 && this.hasSelection === text ||
            mac && /[\uf700-\uf7ff]/.test(text)) {
          cm.display.input.reset();
          return false
        }

        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text.charCodeAt(0);
          if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
          if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
        }
        // Find the part of the input that is actually new
        var same = 0, l = Math.min(prevInput.length, text.length);
        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

        runInOp(cm, function () {
          applyTextInput(cm, text.slice(same), prevInput.length - same,
                         null, this$1.composing ? "*compose" : null);

          // Don't leave long text in the textarea, since it makes further polling slow
          if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
          else { this$1.prevInput = text; }

          if (this$1.composing) {
            this$1.composing.range.clear();
            this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                               {className: "CodeMirror-composing"});
          }
        });
        return true
      };

      TextareaInput.prototype.ensurePolled = function () {
        if (this.pollingFast && this.poll()) { this.pollingFast = false; }
      };

      TextareaInput.prototype.onKeyPress = function () {
        if (ie && ie_version >= 9) { this.hasSelection = null; }
        this.fastPoll();
      };

      TextareaInput.prototype.onContextMenu = function (e) {
        var input = this, cm = input.cm, display = cm.display, te = input.textarea;
        if (input.contextMenuPending) { input.contextMenuPending(); }
        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (!pos || presto) { return } // Opera is difficult.

        // Reset the current text selection only if the click is done outside of the selection
        // and 'resetSelectionOnContextMenu' option is true.
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1)
          { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;
        if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
        display.input.focus();
        if (webkit) { window.scrollTo(null, oldScrollY); }
        display.input.reset();
        // Adds "Select all" to context menu in FF
        if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);

        // Select-all will be greyed out if there's nothing to select, so
        // this adds a zero-width space so that we can later check whether
        // it got selected.
        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "\u200b" + (selected ? te.value : "");
            te.value = "\u21da"; // Used to catch context-menu undo
            te.value = extval;
            input.prevInput = selected ? "" : "\u200b";
            te.selectionStart = 1; te.selectionEnd = extval.length;
            // Re-set this, in case some other handler touched the
            // selection in the meantime.
            display.selForContextMenu = cm.doc.sel;
          }
        }
        function rehide() {
          if (input.contextMenuPending != rehide) { return }
          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;
          if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

          // Try to detect the user choosing select-all
          if (te.selectionStart != null) {
            if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
            var i = 0, poll = function () {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                  te.selectionEnd > 0 && input.prevInput == "\u200b") {
                operation(cm, selectAll)(cm);
              } else if (i++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };
            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }

        if (ie && ie_version >= 9) { prepareSelectAllHack(); }
        if (captureRightClick) {
          e_stop(e);
          var mouseup = function () {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };

      TextareaInput.prototype.readOnlyChanged = function (val) {
        if (!val) { this.reset(); }
        this.textarea.disabled = val == "nocursor";
      };

      TextareaInput.prototype.setUneditable = function () {};

      TextareaInput.prototype.needsContentAttribute = false;

      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex)
          { options.tabindex = textarea.tabIndex; }
        if (!options.placeholder && textarea.placeholder)
          { options.placeholder = textarea.placeholder; }
        // Set autofocus to true if this textarea is focused, or if it has
        // autofocus and no other element is focused.
        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea ||
            textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }

        function save() {textarea.value = cm.getValue();}

        var realSubmit;
        if (textarea.form) {
          on(textarea.form, "submit", save);
          // Deplorable hack to make the submit method do the right thing.
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch(e) {}
          }
        }

        options.finishInit = function (cm) {
          cm.save = save;
          cm.getTextArea = function () { return textarea; };
          cm.toTextArea = function () {
            cm.toTextArea = isNaN; // Prevent this from being ran twice
            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (typeof textarea.form.submit == "function")
                { textarea.form.submit = realSubmit; }
            }
          };
        };

        textarea.style.display = "none";
        var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
          options);
        return cm
      }

      function addLegacyProps(CodeMirror) {
        CodeMirror.off = off;
        CodeMirror.on = on;
        CodeMirror.wheelEventPixels = wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = splitLinesAuto;
        CodeMirror.countColumn = countColumn;
        CodeMirror.findColumn = findColumn;
        CodeMirror.isWordChar = isWordCharBasic;
        CodeMirror.Pass = Pass;
        CodeMirror.signal = signal;
        CodeMirror.Line = Line;
        CodeMirror.changeEnd = changeEnd;
        CodeMirror.scrollbarModel = scrollbarModel;
        CodeMirror.Pos = Pos;
        CodeMirror.cmpPos = cmp;
        CodeMirror.modes = modes;
        CodeMirror.mimeModes = mimeModes;
        CodeMirror.resolveMode = resolveMode;
        CodeMirror.getMode = getMode;
        CodeMirror.modeExtensions = modeExtensions;
        CodeMirror.extendMode = extendMode;
        CodeMirror.copyState = copyState;
        CodeMirror.startState = startState;
        CodeMirror.innerMode = innerMode;
        CodeMirror.commands = commands;
        CodeMirror.keyMap = keyMap;
        CodeMirror.keyName = keyName;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.normalizeKeyMap = normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = SharedTextMarker;
        CodeMirror.TextMarker = TextMarker;
        CodeMirror.LineWidget = LineWidget;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        CodeMirror.e_stop = e_stop;
        CodeMirror.addClass = addClass;
        CodeMirror.contains = contains;
        CodeMirror.rmClass = rmClass;
        CodeMirror.keyNames = keyNames;
      }

      // EDITOR CONSTRUCTOR

      defineOptions(CodeMirror);
      addEditorMethods(CodeMirror);

      // Set up methods on CodeMirror's prototype to redirect to the editor's document.
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
        { CodeMirror.prototype[prop] = (function(method) {
          return function() {return method.apply(this.doc, arguments)}
        })(Doc.prototype[prop]); } }

      eventMixin(Doc);
      CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

      // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)
      CodeMirror.defineMode = function(name/*, mode, …*/) {
        if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
        defineMode.apply(this, arguments);
      };

      CodeMirror.defineMIME = defineMIME;

      // Minimal default mode.
      CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
      CodeMirror.defineMIME("text/plain", "null");

      // EXTENSIONS

      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };

      CodeMirror.fromTextArea = fromTextArea;

      addLegacyProps(CodeMirror);

      CodeMirror.version = "5.45.1";
      return CodeMirror;

    }

    class CodeBlock{
        constructor(codeMirrorTarget){
            this.insert=this.insert.bind(this);
            this.show=this.show.bind(this);
            this.hide=this.hide.bind(this);
            this.codeLanguages = this.codeLanguagesF();
            this.codeMirrorConfig=this.codeMirrorConfigF();
            this.langSelect="";
            this.codeMirrorTarget=codeMirrorTarget;
            this.me="";
            this.codeMirror="";
        }
        codeMirrorConfigF(){
            return {
                mode                      : {name: "python",version: 3},
                tabSize                   : 4,
                lineNumbers               : true,
                lineWrapping              : true,
                styleActiveLine: true,
                matchBrackets: true
            }
        }
        create() {
            let html = `
            <div class="yaposi_CB">
                <div class="yaposi-code-toolbar">
                    <label>Pick language</label> 
                    <select>
                        <option value="other" data-mode="other">other</option>
                    </select>
                </div>
                <div class="yaposi_CB_cm">
                </div>
                <div class="yaposi_CB_actions">
                    <button class="cancel">cancel</button>
                    <button class="insert">insert</button>
                </div>
            </div>
        `;
            const temp=document.createElement("template");
            temp.innerHTML=html;
            let me=temp.content.querySelector(".yaposi_CB");
            this.codeMirror=CodeMirror(me.querySelector(".yaposi_CB_cm"), this.codeMirrorConfig);
            
            let insert=me.querySelector(".insert");
            insert.addEventListener("click",this.insert);

            let cancel=me.querySelector(".cancel");
            cancel.addEventListener("click",this.hide);
            this.langSelect = me.querySelector("select");
            
            for (let key in this.codeLanguages){
                let codeLang = this.codeLanguages[key];
                let agregar=document.createElement("option");
                if (key=="python"){
                    agregar.setAttribute("selected","");
                }
                agregar.value=key;
                agregar.dataset.mode=codeLang[1];
                agregar.textContent=codeLang[0];
                this.langSelect.appendChild(agregar);
            }
            this.langSelect.addEventListener("change",(e)=>{
                let selected=this.langSelect.options[this.langSelect.selectedIndex];
                this.codeMirror.setOption("mode", selected.dataset.mode);
            });
            this.me=me;  
            this.codeMirror.refresh();
            return me
        }
        hide(){
            this.me.addEventListener("transitionend",()=>{
                this.me.style.display="none";
            },{once:true});
            this.me.style.transform="translate(-50%,-730px)";
        }
        show() {
            this.me.style.display="grid";
            setTimeout(()=>{this.me.style.transform="translate(-50%,-50%)";},0);
            let selection   = this.codeMirrorTarget.getSelection();
            this.codeMirror.setValue(selection);
            this.codeMirror.focus();    
        }
        insert(){
            this.hide();
            const codeTexts=this.codeMirror.getValue();
            if (codeTexts === ""){
                alert(dialogLang.emptyAlert);
                return false;
            }
            const langName   = this.langSelect.value;

            //check if cursor, in principal editor, it's at the beginning, if does it jumps to new line.
            let atBeggining="```" + langName;
            const cursor    = this.codeMirrorTarget.getCursor();
            if (cursor.ch !== 0) {
                atBeggining = "\r\n\r\n" + atBeggining;
            }
               
            this.codeMirrorTarget.replaceSelection([atBeggining, codeTexts, "```\r\n"].join("\n"));
            if (langName === "") {
                this.codeMirrorTarget.setCursor(cursor.line, cursor.ch + 3);
            }
        }
        
        codeLanguagesF(){
            return  {
    			asp           : ["ASP", "vbscript"],
    			actionscript  : ["ActionScript(3.0)/Flash/Flex", "clike"],
    			bash          : ["Bash/Bat", "shell"],
    			css           : ["CSS", "css"],
    			c             : ["C", "clike"],
    			cpp           : ["C++", "clike"],
    			csharp        : ["C#", "clike"],
    			coffeescript  : ["CoffeeScript", "coffeescript"],
    			d             : ["D", "d"],
    			dart          : ["Dart", "dart"],
    			delphi        : ["Delphi/Pascal", "pascal"],
    			erlang        : ["Erlang", "erlang"],
    			go            : ["Golang", "go"],
    			groovy        : ["Groovy", "groovy"],
    			html          : ["HTML", "text/html"],
    			java          : ["Java", "clike"],
    			json          : ["JSON", "text/json"],
    			javascript    : ["Javascript", "javascript"],
    			lua           : ["Lua", "lua"],
    			less          : ["LESS", "css"],
    			markdown      : ["Markdown", "gfm"],
    			"objective-c" : ["Objective-C", "clike"],
    			php           : ["PHP", "php"],
    			perl          : ["Perl", "perl"],
    			python        : ["Python", "python"],
    			r             : ["R", "r"],
    			rst           : ["reStructedText", "rst"],
    			ruby          : ["Ruby", "ruby"],
    			sql           : ["SQL", "sql"],
    			sass          : ["SASS/SCSS", "sass"],
    			shell         : ["Shell", "shell"],
    			scala         : ["Scala", "clike"],
    			swift         : ["Swift", "clike"],
    			vb            : ["VB/VBScript", "vb"],
    			xml           : ["XML", "text/xml"],
    			yaml          : ["YAML", "yaml"]
            }
        }
    }

    /**
     * @license
     * Copyright (C) 2006 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */


    /**
     * {@type !{
     *   'createSimpleLexer': function (Array, Array): (function (JobT)),
     *   'registerLangHandler': function (function (JobT), Array.<string>),
     *   'PR_ATTRIB_NAME': string,
     *   'PR_ATTRIB_NAME': string,
     *   'PR_ATTRIB_VALUE': string,
     *   'PR_COMMENT': string,
     *   'PR_DECLARATION': string,
     *   'PR_KEYWORD': string,
     *   'PR_LITERAL': string,
     *   'PR_NOCODE': string,
     *   'PR_PLAIN': string,
     *   'PR_PUNCTUATION': string,
     *   'PR_SOURCE': string,
     *   'PR_STRING': string,
     *   'PR_TAG': string,
     *   'PR_TYPE': string,
     *   'prettyPrintOne': function (string, string, number|boolean),
     *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))
     * }}
     * @const
     */
    /**
     * Split {@code prettyPrint} into multiple timeouts so as not to interfere with
     * UI events.
     * If set to {@code false}, {@code prettyPrint()} is synchronous.
     */
    var PR_SHOULD_USE_CONTINUATION = true;
    if (typeof window !== 'undefined') {
      window['PR_SHOULD_USE_CONTINUATION'] = PR_SHOULD_USE_CONTINUATION;
    }


    const PR=function () {
      var win = (typeof window !== 'undefined') ? window : {};
      // Keyword lists for various languages.
      // We use things that coerce to strings to make them compact when minified
      // and to defeat aggressive optimizers that fold large string constants.
      var FLOW_CONTROL_KEYWORDS = ["break,continue,do,else,for,if,return,while"];
      var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,"auto,case,char,const,default," +
          "double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed," +
          "sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"];
      var COMMON_KEYWORDS = [C_KEYWORDS,"catch,class,delete,false,import," +
          "new,operator,private,protected,public,this,throw,true,try,typeof"];
      var CPP_KEYWORDS = [COMMON_KEYWORDS,"alignas,alignof,align_union,asm,axiom,bool," +
          "concept,concept_map,const_cast,constexpr,decltype,delegate," +
          "dynamic_cast,explicit,export,friend,generic,late_check," +
          "mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert," +
          "static_cast,template,typeid,typename,using,virtual,where"];
      var JAVA_KEYWORDS = [COMMON_KEYWORDS,
          "abstract,assert,boolean,byte,extends,finally,final,implements,import," +
          "instanceof,interface,null,native,package,strictfp,super,synchronized," +
          "throws,transient"];
      var CSHARP_KEYWORDS = [COMMON_KEYWORDS,
          "abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending," +
          "dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface," +
          "internal,into,is,join,let,lock,null,object,out,override,orderby,params," +
          "partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong," +
          "unchecked,unsafe,ushort,value,var,virtual,where,yield"];
      var COFFEE_KEYWORDS = "all,and,by,catch,class,else,extends,false,finally," +
          "for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then," +
          "throw,true,try,unless,until,when,while,yes";
      var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,
          "abstract,async,await,constructor,debugger,enum,eval,export,from,function," +
          "get,import,implements,instanceof,interface,let,null,of,set,undefined," +
          "var,with,yield,Infinity,NaN"];
      var PERL_KEYWORDS = "caller,delete,die,do,dump,elsif,eval,exit,foreach,for," +
          "goto,if,import,last,local,my,next,no,our,print,package,redo,require," +
          "sub,undef,unless,until,use,wantarray,while,BEGIN,END";
      var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "and,as,assert,class,def,del," +
          "elif,except,exec,finally,from,global,import,in,is,lambda," +
          "nonlocal,not,or,pass,print,raise,try,with,yield," +
          "False,True,None"];
      var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "alias,and,begin,case,class," +
          "def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo," +
          "rescue,retry,self,super,then,true,undef,unless,until,when,yield," +
          "BEGIN,END"];
      var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "case,done,elif,esac,eval,fi," +
          "function,in,local,set,then,until"];
      var ALL_KEYWORDS = [
          CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,
          PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];
      var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\d*)\b/;

      // token style names.  correspond to css classes
      /**
       * token style for a string literal
       * @const
       */
      var PR_STRING = 'str';
      /**
       * token style for a keyword
       * @const
       */
      var PR_KEYWORD = 'kwd';
      /**
       * token style for a comment
       * @const
       */
      var PR_COMMENT = 'com';
      /**
       * token style for a type
       * @const
       */
      var PR_TYPE = 'typ';
      /**
       * token style for a literal value.  e.g. 1, null, true.
       * @const
       */
      var PR_LITERAL = 'lit';
      /**
       * token style for a punctuation string.
       * @const
       */
      var PR_PUNCTUATION = 'pun';
      /**
       * token style for plain text.
       * @const
       */
      var PR_PLAIN = 'pln';

      /**
       * token style for an sgml tag.
       * @const
       */
      var PR_TAG = 'tag';
      /**
       * token style for a markup declaration such as a DOCTYPE.
       * @const
       */
      var PR_DECLARATION = 'dec';
      /**
       * token style for embedded source.
       * @const
       */
      var PR_SOURCE = 'src';
      /**
       * token style for an sgml attribute name.
       * @const
       */
      var PR_ATTRIB_NAME = 'atn';
      /**
       * token style for an sgml attribute value.
       * @const
       */
      var PR_ATTRIB_VALUE = 'atv';

      /**
       * A class that indicates a section of markup that is not code, e.g. to allow
       * embedding of line numbers within code listings.
       * @const
       */
      var PR_NOCODE = 'nocode';


      // Regex pattern below is automatically generated by regexpPrecederPatterns.pl
      // Do not modify, your changes will be erased.

      // CAVEAT: this does not properly handle the case where a regular
      // expression immediately follows another since a regular expression may
      // have flags for case-sensitivity and the like.  Having regexp tokens
      // adjacent is not valid in any language I'm aware of, so I'm punting.
      // TODO: maybe style special characters inside a regexp as punctuation.

      /**
       * A set of tokens that can precede a regular expression literal in
       * javascript
       * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html
       * has the full list, but I've removed ones that might be problematic when
       * seen in languages that don't support regular expression literals.
       *
       * Specifically, I've removed any keywords that can't precede a regexp
       * literal in a syntactically legal javascript program, and I've removed the
       * "in" keyword since it's not a keyword in many languages, and might be used
       * as a count of inches.
       *
       * The link above does not accurately describe EcmaScript rules since
       * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works
       * very well in practice.
       *
       * @private
       * @const
       */
      var REGEXP_PRECEDER_PATTERN = '(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*';


      /**
       * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally
       * matches the union of the sets of strings matched by the input RegExp.
       * Since it matches globally, if the input strings have a start-of-input
       * anchor (/^.../), it is ignored for the purposes of unioning.
       * @param {Array.<RegExp>} regexs non multiline, non-global regexs.
       * @return {RegExp} a global regex.
       */
      function combinePrefixPatterns(regexs) {
        var capturedGroupIndex = 0;

        var needToFoldCase = false;
        var ignoreCase = false;
        for (var i = 0, n = regexs.length; i < n; ++i) {
          var regex = regexs[i];
          if (regex.ignoreCase) {
            ignoreCase = true;
          } else if (/[a-z]/i.test(regex.source.replace(
                         /\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi, ''))) {
            needToFoldCase = true;
            ignoreCase = false;
            break;
          }
        }

        var escapeCharToCodeUnit = {
          'b': 8,
          't': 9,
          'n': 0xa,
          'v': 0xb,
          'f': 0xc,
          'r': 0xd
        };

        function decodeEscape(charsetPart) {
          var cc0 = charsetPart.charCodeAt(0);
          if (cc0 !== 92 /* \\ */) {
            return cc0;
          }
          var c1 = charsetPart.charAt(1);
          cc0 = escapeCharToCodeUnit[c1];
          if (cc0) {
            return cc0;
          } else if ('0' <= c1 && c1 <= '7') {
            return parseInt(charsetPart.substring(1), 8);
          } else if (c1 === 'u' || c1 === 'x') {
            return parseInt(charsetPart.substring(2), 16);
          } else {
            return charsetPart.charCodeAt(1);
          }
        }

        function encodeEscape(charCode) {
          if (charCode < 0x20) {
            return (charCode < 0x10 ? '\\x0' : '\\x') + charCode.toString(16);
          }
          var ch = String.fromCharCode(charCode);
          return (ch === '\\' || ch === '-' || ch === ']' || ch === '^')
              ? "\\" + ch : ch;
        }

        function caseFoldCharset(charSet) {
          var charsetParts = charSet.substring(1, charSet.length - 1).match(
              new RegExp(
                  '\\\\u[0-9A-Fa-f]{4}'
                  + '|\\\\x[0-9A-Fa-f]{2}'
                  + '|\\\\[0-3][0-7]{0,2}'
                  + '|\\\\[0-7]{1,2}'
                  + '|\\\\[\\s\\S]'
                  + '|-'
                  + '|[^-\\\\]',
                  'g'));
          var ranges = [];
          var inverse = charsetParts[0] === '^';

          var out = ['['];
          if (inverse) { out.push('^'); }

          for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {
            var p = charsetParts[i];
            if (/\\[bdsw]/i.test(p)) {  // Don't muck with named groups.
              out.push(p);
            } else {
              var start = decodeEscape(p);
              var end;
              if (i + 2 < n && '-' === charsetParts[i + 1]) {
                end = decodeEscape(charsetParts[i + 2]);
                i += 2;
              } else {
                end = start;
              }
              ranges.push([start, end]);
              // If the range might intersect letters, then expand it.
              // This case handling is too simplistic.
              // It does not deal with non-latin case folding.
              // It works for latin source code identifiers though.
              if (!(end < 65 || start > 122)) {
                if (!(end < 65 || start > 90)) {
                  ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);
                }
                if (!(end < 97 || start > 122)) {
                  ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);
                }
              }
            }
          }

          // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]
          // -> [[1, 12], [14, 14], [16, 17]]
          ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });
          var consolidatedRanges = [];
          var lastRange = [];
          for (var i = 0; i < ranges.length; ++i) {
            var range = ranges[i];
            if (range[0] <= lastRange[1] + 1) {
              lastRange[1] = Math.max(lastRange[1], range[1]);
            } else {
              consolidatedRanges.push(lastRange = range);
            }
          }

          for (var i = 0; i < consolidatedRanges.length; ++i) {
            var range = consolidatedRanges[i];
            out.push(encodeEscape(range[0]));
            if (range[1] > range[0]) {
              if (range[1] + 1 > range[0]) { out.push('-'); }
              out.push(encodeEscape(range[1]));
            }
          }
          out.push(']');
          return out.join('');
        }

        function allowAnywhereFoldCaseAndRenumberGroups(regex) {
          // Split into character sets, escape sequences, punctuation strings
          // like ('(', '(?:', ')', '^'), and runs of characters that do not
          // include any of the above.
          var parts = regex.source.match(
              new RegExp(
                  '(?:'
                  + '\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]'  // a character set
                  + '|\\\\u[A-Fa-f0-9]{4}'  // a unicode escape
                  + '|\\\\x[A-Fa-f0-9]{2}'  // a hex escape
                  + '|\\\\[0-9]+'  // a back-reference or octal escape
                  + '|\\\\[^ux0-9]'  // other escape sequence
                  + '|\\(\\?[:!=]'  // start of a non-capturing group
                  + '|[\\(\\)\\^]'  // start/end of a group, or line start
                  + '|[^\\x5B\\x5C\\(\\)\\^]+'  // run of other characters
                  + ')',
                  'g'));
          var n = parts.length;

          // Maps captured group numbers to the number they will occupy in
          // the output or to -1 if that has not been determined, or to
          // undefined if they need not be capturing in the output.
          var capturedGroups = [];

          // Walk over and identify back references to build the capturedGroups
          // mapping.
          for (var i = 0, groupIndex = 0; i < n; ++i) {
            var p = parts[i];
            if (p === '(') {
              // groups are 1-indexed, so max group index is count of '('
              ++groupIndex;
            } else if ('\\' === p.charAt(0)) {
              var decimalValue = +p.substring(1);
              if (decimalValue) {
                if (decimalValue <= groupIndex) {
                  capturedGroups[decimalValue] = -1;
                } else {
                  // Replace with an unambiguous escape sequence so that
                  // an octal escape sequence does not turn into a backreference
                  // to a capturing group from an earlier regex.
                  parts[i] = encodeEscape(decimalValue);
                }
              }
            }
          }

          // Renumber groups and reduce capturing groups to non-capturing groups
          // where possible.
          for (var i = 1; i < capturedGroups.length; ++i) {
            if (-1 === capturedGroups[i]) {
              capturedGroups[i] = ++capturedGroupIndex;
            }
          }
          for (var i = 0, groupIndex = 0; i < n; ++i) {
            var p = parts[i];
            if (p === '(') {
              ++groupIndex;
              if (!capturedGroups[groupIndex]) {
                parts[i] = '(?:';
              }
            } else if ('\\' === p.charAt(0)) {
              var decimalValue = +p.substring(1);
              if (decimalValue && decimalValue <= groupIndex) {
                parts[i] = '\\' + capturedGroups[decimalValue];
              }
            }
          }

          // Remove any prefix anchors so that the output will match anywhere.
          // ^^ really does mean an anchored match though.
          for (var i = 0; i < n; ++i) {
            if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }
          }

          // Expand letters to groups to handle mixing of case-sensitive and
          // case-insensitive patterns if necessary.
          if (regex.ignoreCase && needToFoldCase) {
            for (var i = 0; i < n; ++i) {
              var p = parts[i];
              var ch0 = p.charAt(0);
              if (p.length >= 2 && ch0 === '[') {
                parts[i] = caseFoldCharset(p);
              } else if (ch0 !== '\\') {
                // TODO: handle letters in numeric escapes.
                parts[i] = p.replace(
                    /[a-zA-Z]/g,
                    function (ch) {
                      var cc = ch.charCodeAt(0);
                      return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';
                    });
              }
            }
          }

          return parts.join('');
        }

        var rewritten = [];
        for (var i = 0, n = regexs.length; i < n; ++i) {
          var regex = regexs[i];
          if (regex.global || regex.multiline) { throw new Error('' + regex); }
          rewritten.push(
              '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');
        }

        return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');
      }


      /**
       * Split markup into a string of source code and an array mapping ranges in
       * that string to the text nodes in which they appear.
       *
       * <p>
       * The HTML DOM structure:</p>
       * <pre>
       * (Element   "p"
       *   (Element "b"
       *     (Text  "print "))       ; #1
       *   (Text    "'Hello '")      ; #2
       *   (Element "br")            ; #3
       *   (Text    "  + 'World';")) ; #4
       * </pre>
       * <p>
       * corresponds to the HTML
       * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>
       *
       * <p>
       * It will produce the output:</p>
       * <pre>
       * {
       *   sourceCode: "print 'Hello '\n  + 'World';",
       *   //                     1          2
       *   //           012345678901234 5678901234567
       *   spans: [0, #1, 6, #2, 14, #3, 15, #4]
       * }
       * </pre>
       * <p>
       * where #1 is a reference to the {@code "print "} text node above, and so
       * on for the other text nodes.
       * </p>
       *
       * <p>
       * The {@code} spans array is an array of pairs.  Even elements are the start
       * indices of substrings, and odd elements are the text nodes (or BR elements)
       * that contain the text for those substrings.
       * Substrings continue until the next index or the end of the source.
       * </p>
       *
       * @param {Node} node an HTML DOM subtree containing source-code.
       * @param {boolean|number} isPreformatted truthy if white-space in
       *    text nodes should be considered significant.
       * @return {SourceSpansT} source code and the nodes in which they occur.
       */
      function extractSourceSpans(node, isPreformatted) {
        var nocode = /(?:^|\s)nocode(?:\s|$)/;

        var chunks = [];
        var length = 0;
        var spans = [];
        var k = 0;

        function walk(node) {
          var type = node.nodeType;
          if (type == 1) {  // Element
            if (nocode.test(node.className)) { return; }
            for (var child = node.firstChild; child; child = child.nextSibling) {
              walk(child);
            }
            var nodeName = node.nodeName.toLowerCase();
            if ('br' === nodeName || 'li' === nodeName) {
              chunks[k] = '\n';
              spans[k << 1] = length++;
              spans[(k++ << 1) | 1] = node;
            }
          } else if (type == 3 || type == 4) {  // Text
            var text = node.nodeValue;
            if (text.length) {
              if (!isPreformatted) {
                text = text.replace(/[ \t\r\n]+/g, ' ');
              } else {
                text = text.replace(/\r\n?/g, '\n');  // Normalize newlines.
              }
              // TODO: handle tabs here?
              chunks[k] = text;
              spans[k << 1] = length;
              length += text.length;
              spans[(k++ << 1) | 1] = node;
            }
          }
        }

        walk(node);

        return {
          sourceCode: chunks.join('').replace(/\n$/, ''),
          spans: spans
        };
      }


      /**
       * Apply the given language handler to sourceCode and add the resulting
       * decorations to out.
       * @param {!Element} sourceNode
       * @param {number} basePos the index of sourceCode within the chunk of source
       *    whose decorations are already present on out.
       * @param {string} sourceCode
       * @param {function(JobT)} langHandler
       * @param {DecorationsT} out
       */
      function appendDecorations(
          sourceNode, basePos, sourceCode, langHandler, out) {
        if (!sourceCode) { return; }
        /** @type {JobT} */
        var job = {
          sourceNode: sourceNode,
          pre: 1,
          langExtension: null,
          numberLines: null,
          sourceCode: sourceCode,
          spans: null,
          basePos: basePos,
          decorations: null
        };
        langHandler(job);
        out.push.apply(out, job.decorations);
      }

      var notWs = /\S/;

      /**
       * Given an element, if it contains only one child element and any text nodes
       * it contains contain only space characters, return the sole child element.
       * Otherwise returns undefined.
       * <p>
       * This is meant to return the CODE element in {@code <pre><code ...>} when
       * there is a single child element that contains all the non-space textual
       * content, but not to return anything where there are multiple child elements
       * as in {@code <pre><code>...</code><code>...</code></pre>} or when there
       * is textual content.
       */
      function childContentWrapper(element) {
        var wrapper = undefined;
        for (var c = element.firstChild; c; c = c.nextSibling) {
          var type = c.nodeType;
          wrapper = (type === 1)  // Element Node
              ? (wrapper ? element : c)
              : (type === 3)  // Text Node
              ? (notWs.test(c.nodeValue) ? element : wrapper)
              : wrapper;
        }
        return wrapper === element ? undefined : wrapper;
      }

      /** Given triples of [style, pattern, context] returns a lexing function,
        * The lexing function interprets the patterns to find token boundaries and
        * returns a decoration list of the form
        * [index_0, style_0, index_1, style_1, ..., index_n, style_n]
        * where index_n is an index into the sourceCode, and style_n is a style
        * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to
        * all characters in sourceCode[index_n-1:index_n].
        *
        * The stylePatterns is a list whose elements have the form
        * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].
        *
        * Style is a style constant like PR_PLAIN, or can be a string of the
        * form 'lang-FOO', where FOO is a language extension describing the
        * language of the portion of the token in $1 after pattern executes.
        * E.g., if style is 'lang-lisp', and group 1 contains the text
        * '(hello (world))', then that portion of the token will be passed to the
        * registered lisp handler for formatting.
        * The text before and after group 1 will be restyled using this decorator
        * so decorators should take care that this doesn't result in infinite
        * recursion.  For example, the HTML lexer rule for SCRIPT elements looks
        * something like ['lang-js', /<[s]cript>(.+?)<\/script>/].  This may match
        * '<script>foo()<\/script>', which would cause the current decorator to
        * be called with '<script>' which would not match the same rule since
        * group 1 must not be empty, so it would be instead styled as PR_TAG by
        * the generic tag rule.  The handler registered for the 'js' extension would
        * then be called with 'foo()', and finally, the current decorator would
        * be called with '<\/script>' which would not match the original rule and
        * so the generic tag rule would identify it as a tag.
        *
        * Pattern must only match prefixes, and if it matches a prefix, then that
        * match is considered a token with the same style.
        *
        * Context is applied to the last non-whitespace, non-comment token
        * recognized.
        *
        * Shortcut is an optional string of characters, any of which, if the first
        * character, gurantee that this pattern and only this pattern matches.
        *
        * @param {Array} shortcutStylePatterns patterns that always start with
        *   a known character.  Must have a shortcut string.
        * @param {Array} fallthroughStylePatterns patterns that will be tried in
        *   order if the shortcut ones fail.  May have shortcuts.
        *
        * @return {function (JobT)} a function that takes an undecorated job and
        *   attaches a list of decorations.
        */
      function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {
        var shortcuts = {};
        var tokenizer;
        (function () {
          var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);
          var allRegexs = [];
          var regexKeys = {};
          for (var i = 0, n = allPatterns.length; i < n; ++i) {
            var patternParts = allPatterns[i];
            var shortcutChars = patternParts[3];
            if (shortcutChars) {
              for (var c = shortcutChars.length; --c >= 0;) {
                shortcuts[shortcutChars.charAt(c)] = patternParts;
              }
            }
            var regex = patternParts[1];
            var k = '' + regex;
            if (!regexKeys.hasOwnProperty(k)) {
              allRegexs.push(regex);
              regexKeys[k] = null;
            }
          }
          allRegexs.push(/[\0-\uffff]/);
          tokenizer = combinePrefixPatterns(allRegexs);
        })();

        var nPatterns = fallthroughStylePatterns.length;

        /**
         * Lexes job.sourceCode and attaches an output array job.decorations of
         * style classes preceded by the position at which they start in
         * job.sourceCode in order.
         *
         * @type{function (JobT)}
         */
        var decorate = function (job) {
          var sourceCode = job.sourceCode, basePos = job.basePos;
          var sourceNode = job.sourceNode;
          /** Even entries are positions in source in ascending order.  Odd enties
            * are style markers (e.g., PR_COMMENT) that run from that position until
            * the end.
            * @type {DecorationsT}
            */
          var decorations = [basePos, PR_PLAIN];
          var pos = 0;  // index into sourceCode
          var tokens = sourceCode.match(tokenizer) || [];
          var styleCache = {};

          for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {
            var token = tokens[ti];
            var style = styleCache[token];
            var match = void 0;

            var isEmbedded;
            if (typeof style === 'string') {
              isEmbedded = false;
            } else {
              var patternParts = shortcuts[token.charAt(0)];
              if (patternParts) {
                match = token.match(patternParts[1]);
                style = patternParts[0];
              } else {
                for (var i = 0; i < nPatterns; ++i) {
                  patternParts = fallthroughStylePatterns[i];
                  match = token.match(patternParts[1]);
                  if (match) {
                    style = patternParts[0];
                    break;
                  }
                }

                if (!match) {  // make sure that we make progress
                  style = PR_PLAIN;
                }
              }

              isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);
              if (isEmbedded && !(match && typeof match[1] === 'string')) {
                isEmbedded = false;
                style = PR_SOURCE;
              }

              if (!isEmbedded) { styleCache[token] = style; }
            }

            var tokenStart = pos;
            pos += token.length;

            if (!isEmbedded) {
              decorations.push(basePos + tokenStart, style);
            } else {  // Treat group 1 as an embedded block of source code.
              var embeddedSource = match[1];
              var embeddedSourceStart = token.indexOf(embeddedSource);
              var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;
              if (match[2]) {
                // If embeddedSource can be blank, then it would match at the
                // beginning which would cause us to infinitely recurse on the
                // entire token, so we catch the right context in match[2].
                embeddedSourceEnd = token.length - match[2].length;
                embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;
              }
              var lang = style.substring(5);
              // Decorate the left of the embedded source
              appendDecorations(
                  sourceNode,
                  basePos + tokenStart,
                  token.substring(0, embeddedSourceStart),
                  decorate, decorations);
              // Decorate the embedded source
              appendDecorations(
                  sourceNode,
                  basePos + tokenStart + embeddedSourceStart,
                  embeddedSource,
                  langHandlerForExtension(lang, embeddedSource),
                  decorations);
              // Decorate the right of the embedded section
              appendDecorations(
                  sourceNode,
                  basePos + tokenStart + embeddedSourceEnd,
                  token.substring(embeddedSourceEnd),
                  decorate, decorations);
            }
          }
          job.decorations = decorations;
        };
        return decorate;
      }

      /** returns a function that produces a list of decorations from source text.
        *
        * This code treats ", ', and ` as string delimiters, and \ as a string
        * escape.  It does not recognize perl's qq() style strings.
        * It has no special handling for double delimiter escapes as in basic, or
        * the tripled delimiters used in python, but should work on those regardless
        * although in those cases a single string literal may be broken up into
        * multiple adjacent string literals.
        *
        * It recognizes C, C++, and shell style comments.
        *
        * @param {Object} options a set of optional parameters.
        * @return {function (JobT)} a function that examines the source code
        *     in the input job and builds a decoration list which it attaches to
        *     the job.
        */
      function sourceDecorator(options) {
        var shortcutStylePatterns = [], fallthroughStylePatterns = [];
        if (options['tripleQuotedStrings']) {
          // '''multi-line-string''', 'single-line-string', and double-quoted
          shortcutStylePatterns.push(
              [PR_STRING,  /^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,
               null, '\'"']);
        } else if (options['multiLineStrings']) {
          // 'multi-line-string', "multi-line-string"
          shortcutStylePatterns.push(
              [PR_STRING,  /^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,
               null, '\'"`']);
        } else {
          // 'single-line-string', "single-line-string"
          shortcutStylePatterns.push(
              [PR_STRING,
               /^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,
               null, '"\'']);
        }
        if (options['verbatimStrings']) {
          // verbatim-string-literal production from the C# grammar.  See issue 93.
          fallthroughStylePatterns.push(
              [PR_STRING, /^@\"(?:[^\"]|\"\")*(?:\"|$)/, null]);
        }
        var hc = options['hashComments'];
        if (hc) {
          if (options['cStyleComments']) {
            if (hc > 1) {  // multiline hash comments
              shortcutStylePatterns.push(
                  [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);
            } else {
              // Stop C preprocessor declarations at an unclosed open comment
              shortcutStylePatterns.push(
                  [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\r\n]*)/,
                   null, '#']);
            }
            // #include <stdio.h>
            fallthroughStylePatterns.push(
                [PR_STRING,
                 /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,
                 null]);
          } else {
            shortcutStylePatterns.push([PR_COMMENT, /^#[^\r\n]*/, null, '#']);
          }
        }
        if (options['cStyleComments']) {
          fallthroughStylePatterns.push([PR_COMMENT, /^\/\/[^\r\n]*/, null]);
          fallthroughStylePatterns.push(
              [PR_COMMENT, /^\/\*[\s\S]*?(?:\*\/|$)/, null]);
        }
        var regexLiterals = options['regexLiterals'];
        if (regexLiterals) {
          /**
           * @const
           */
          var regexExcls = regexLiterals > 1
            ? ''  // Multiline regex literals
            : '\n\r';
          /**
           * @const
           */
          var regexAny = regexExcls ? '.' : '[\\S\\s]';
          /**
           * @const
           */
          var REGEX_LITERAL = (
              // A regular expression literal starts with a slash that is
              // not followed by * or / so that it is not confused with
              // comments.
              '/(?=[^/*' + regexExcls + '])'
              // and then contains any number of raw characters,
              + '(?:[^/\\x5B\\x5C' + regexExcls + ']'
              // escape sequences (\x5C),
              +    '|\\x5C' + regexAny
              // or non-nesting character sets (\x5B\x5D);
              +    '|\\x5B(?:[^\\x5C\\x5D' + regexExcls + ']'
              +             '|\\x5C' + regexAny + ')*(?:\\x5D|$))+'
              // finally closed by a /.
              + '/');
          fallthroughStylePatterns.push(
              ['lang-regex',
               RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')
               ]);
        }

        var types = options['types'];
        if (types) {
          fallthroughStylePatterns.push([PR_TYPE, types]);
        }

        var keywords = ("" + options['keywords']).replace(/^ | $/g, '');
        if (keywords.length) {
          fallthroughStylePatterns.push(
              [PR_KEYWORD,
               new RegExp('^(?:' + keywords.replace(/[\s,]+/g, '|') + ')\\b'),
               null]);
        }

        shortcutStylePatterns.push([PR_PLAIN,       /^\s+/, null, ' \r\n\t\xA0']);

        var punctuation =
          // The Bash man page says

          // A word is a sequence of characters considered as a single
          // unit by GRUB. Words are separated by metacharacters,
          // which are the following plus space, tab, and newline: { }
          // | & $ ; < >
          // ...

          // A word beginning with # causes that word and all remaining
          // characters on that line to be ignored.

          // which means that only a '#' after /(?:^|[{}|&$;<>\s])/ starts a
          // comment but empirically
          // $ echo {#}
          // {#}
          // $ echo \$#
          // $#
          // $ echo }#
          // }#

          // so /(?:^|[|&;<>\s])/ is more appropriate.

          // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3
          // suggests that this definition is compatible with a
          // default mode that tries to use a single token definition
          // to recognize both bash/python style comments and C
          // preprocessor directives.

          // This definition of punctuation does not include # in the list of
          // follow-on exclusions, so # will not be broken before if preceeded
          // by a punctuation character.  We could try to exclude # after
          // [|&;<>] but that doesn't seem to cause many major problems.
          // If that does turn out to be a problem, we should change the below
          // when hc is truthy to include # in the run of punctuation characters
          // only when not followint [|&;<>].
          '^.[^\\s\\w.$@\'"`/\\\\]*';
        if (options['regexLiterals']) {
          punctuation += '(?!\s*\/)';
        }

        fallthroughStylePatterns.push(
            // TODO(mikesamuel): recognize non-latin letters and numerals in idents
            [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],
            [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/, null],
            [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],
            [PR_LITERAL,
             new RegExp(
                 '^(?:'
                 // A hex number
                 + '0x[a-f0-9]+'
                 // or an octal or decimal number,
                 + '|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)'
                 // possibly in scientific notation
                 + '(?:e[+\\-]?\\d+)?'
                 + ')'
                 // with an optional modifier like UL for unsigned long
                 + '[a-z]*', 'i'),
             null, '0123456789'],
            // Don't treat escaped quotes in bash as starting strings.
            // See issue 144.
            [PR_PLAIN,       /^\\[\s\S]?/, null],
            [PR_PUNCTUATION, new RegExp(punctuation), null]);

        return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);
      }

      var decorateSource = sourceDecorator({
            'keywords': ALL_KEYWORDS,
            'hashComments': true,
            'cStyleComments': true,
            'multiLineStrings': true,
            'regexLiterals': true
          });

      /**
       * Given a DOM subtree, wraps it in a list, and puts each line into its own
       * list item.
       *
       * @param {Node} node modified in place.  Its content is pulled into an
       *     HTMLOListElement, and each line is moved into a separate list item.
       *     This requires cloning elements, so the input might not have unique
       *     IDs after numbering.
       * @param {number|null|boolean} startLineNum
       *     If truthy, coerced to an integer which is the 1-indexed line number
       *     of the first line of code.  The number of the first line will be
       *     attached to the list.
       * @param {boolean} isPreformatted true iff white-space in text nodes should
       *     be treated as significant.
       */
      function numberLines(node, startLineNum, isPreformatted) {
        var nocode = /(?:^|\s)nocode(?:\s|$)/;
        var lineBreak = /\r\n?|\n/;

        var document = node.ownerDocument;

        var li = document.createElement('li');
        while (node.firstChild) {
          li.appendChild(node.firstChild);
        }
        // An array of lines.  We split below, so this is initialized to one
        // un-split line.
        var listItems = [li];

        function walk(node) {
          var type = node.nodeType;
          if (type == 1 && !nocode.test(node.className)) {  // Element
            if ('br' === node.nodeName.toLowerCase()) {
              breakAfter(node);
              // Discard the <BR> since it is now flush against a </LI>.
              if (node.parentNode) {
                node.parentNode.removeChild(node);
              }
            } else {
              for (var child = node.firstChild; child; child = child.nextSibling) {
                walk(child);
              }
            }
          } else if ((type == 3 || type == 4) && isPreformatted) {  // Text
            var text = node.nodeValue;
            var match = text.match(lineBreak);
            if (match) {
              var firstLine = text.substring(0, match.index);
              node.nodeValue = firstLine;
              var tail = text.substring(match.index + match[0].length);
              if (tail) {
                var parent = node.parentNode;
                parent.insertBefore(
                  document.createTextNode(tail), node.nextSibling);
              }
              breakAfter(node);
              if (!firstLine) {
                // Don't leave blank text nodes in the DOM.
                node.parentNode.removeChild(node);
              }
            }
          }
        }

        // Split a line after the given node.
        function breakAfter(lineEndNode) {
          // If there's nothing to the right, then we can skip ending the line
          // here, and move root-wards since splitting just before an end-tag
          // would require us to create a bunch of empty copies.
          while (!lineEndNode.nextSibling) {
            lineEndNode = lineEndNode.parentNode;
            if (!lineEndNode) { return; }
          }

          function breakLeftOf(limit, copy) {
            // Clone shallowly if this node needs to be on both sides of the break.
            var rightSide = copy ? limit.cloneNode(false) : limit;
            var parent = limit.parentNode;
            if (parent) {
              // We clone the parent chain.
              // This helps us resurrect important styling elements that cross lines.
              // E.g. in <i>Foo<br>Bar</i>
              // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.
              var parentClone = breakLeftOf(parent, 1);
              // Move the clone and everything to the right of the original
              // onto the cloned parent.
              var next = limit.nextSibling;
              parentClone.appendChild(rightSide);
              for (var sibling = next; sibling; sibling = next) {
                next = sibling.nextSibling;
                parentClone.appendChild(sibling);
              }
            }
            return rightSide;
          }

          var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);

          // Walk the parent chain until we reach an unattached LI.
          for (var parent;
               // Check nodeType since IE invents document fragments.
               (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {
            copiedListItem = parent;
          }
          // Put it on the list of lines for later processing.
          listItems.push(copiedListItem);
        }

        // Split lines while there are lines left to split.
        for (var i = 0;  // Number of lines that have been split so far.
             i < listItems.length;  // length updated by breakAfter calls.
             ++i) {
          walk(listItems[i]);
        }

        // Make sure numeric indices show correctly.
        if (startLineNum === (startLineNum|0)) {
          listItems[0].setAttribute('value', startLineNum);
        }

        var ol = document.createElement('ol');
        ol.className = 'linenums';
        var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;
        for (var i = 0, n = listItems.length; i < n; ++i) {
          li = listItems[i];
          // Stick a class on the LIs so that stylesheets can
          // color odd/even rows, or any other row pattern that
          // is co-prime with 10.
          li.className = 'L' + ((i + offset) % 10);
          if (!li.firstChild) {
            li.appendChild(document.createTextNode('\xA0'));
          }
          ol.appendChild(li);
        }

        node.appendChild(ol);
      }


      /**
       * Breaks {@code job.sourceCode} around style boundaries in
       * {@code job.decorations} and modifies {@code job.sourceNode} in place.
       * @param {JobT} job
       * @private
       */
      function recombineTagsAndDecorations(job) {
        var isIE8OrEarlier = /\bMSIE\s(\d+)/.exec(navigator.userAgent);
        isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;
        var newlineRe = /\n/g;

        var source = job.sourceCode;
        var sourceLength = source.length;
        // Index into source after the last code-unit recombined.
        var sourceIndex = 0;

        var spans = job.spans;
        var nSpans = spans.length;
        // Index into spans after the last span which ends at or before sourceIndex.
        var spanIndex = 0;

        var decorations = job.decorations;
        var nDecorations = decorations.length;
        // Index into decorations after the last decoration which ends at or before
        // sourceIndex.
        var decorationIndex = 0;

        // Remove all zero-length decorations.
        decorations[nDecorations] = sourceLength;
        var decPos, i;
        for (i = decPos = 0; i < nDecorations;) {
          if (decorations[i] !== decorations[i + 2]) {
            decorations[decPos++] = decorations[i++];
            decorations[decPos++] = decorations[i++];
          } else {
            i += 2;
          }
        }
        nDecorations = decPos;

        // Simplify decorations.
        for (i = decPos = 0; i < nDecorations;) {
          var startPos = decorations[i];
          // Conflate all adjacent decorations that use the same style.
          var startDec = decorations[i + 1];
          var end = i + 2;
          while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {
            end += 2;
          }
          decorations[decPos++] = startPos;
          decorations[decPos++] = startDec;
          i = end;
        }

        nDecorations = decorations.length = decPos;

        var sourceNode = job.sourceNode;
        var oldDisplay = "";
        if (sourceNode) {
          oldDisplay = sourceNode.style.display;
          sourceNode.style.display = 'none';
        }
        try {
          while (spanIndex < nSpans) {
            var spanStart = spans[spanIndex];
            var spanEnd = /** @type{number} */ (spans[spanIndex + 2])
                || sourceLength;

            var decEnd = decorations[decorationIndex + 2] || sourceLength;

            var end = Math.min(spanEnd, decEnd);

            var textNode = /** @type{Node} */ (spans[spanIndex + 1]);
            var styledText;
            if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s
                // Don't introduce spans around empty text nodes.
                && (styledText = source.substring(sourceIndex, end))) {
              // This may seem bizarre, and it is.  Emitting LF on IE causes the
              // code to display with spaces instead of line breaks.
              // Emitting Windows standard issue linebreaks (CRLF) causes a blank
              // space to appear at the beginning of every line but the first.
              // Emitting an old Mac OS 9 line separator makes everything spiffy.
              if (isIE8OrEarlier) {
                styledText = styledText.replace(newlineRe, '\r');
              }
              textNode.nodeValue = styledText;
              var document = textNode.ownerDocument;
              var span = document.createElement('span');
              span.className = decorations[decorationIndex + 1];
              var parentNode = textNode.parentNode;
              parentNode.replaceChild(span, textNode);
              span.appendChild(textNode);
              if (sourceIndex < spanEnd) {  // Split off a text node.
                spans[spanIndex + 1] = textNode
                    // TODO: Possibly optimize by using '' if there's no flicker.
                    = document.createTextNode(source.substring(end, spanEnd));
                parentNode.insertBefore(textNode, span.nextSibling);
              }
            }

            sourceIndex = end;

            if (sourceIndex >= spanEnd) {
              spanIndex += 2;
            }
            if (sourceIndex >= decEnd) {
              decorationIndex += 2;
            }
          }
        } finally {
          if (sourceNode) {
            sourceNode.style.display = oldDisplay;
          }
        }
      }


      /** Maps language-specific file extensions to handlers. */
      var langHandlerRegistry = {};
      /** Register a language handler for the given file extensions.
        * @param {function (JobT)} handler a function from source code to a list
        *      of decorations.  Takes a single argument job which describes the
        *      state of the computation and attaches the decorations to it.
        * @param {Array.<string>} fileExtensions
        */
      function registerLangHandler(handler, fileExtensions) {
        for (var i = fileExtensions.length; --i >= 0;) {
          var ext = fileExtensions[i];
          if (!langHandlerRegistry.hasOwnProperty(ext)) {
            langHandlerRegistry[ext] = handler;
          } else if (win['console']) {
            console['warn']('cannot override language handler %s', ext);
          }
        }
      }
      function langHandlerForExtension(extension, source) {
        if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {
          // Treat it as markup if the first non whitespace character is a < and
          // the last non-whitespace character is a >.
          extension = /^\s*</.test(source)
              ? 'default-markup'
              : 'default-code';
        }
        return langHandlerRegistry[extension];
      }
      registerLangHandler(decorateSource, ['default-code']);
      registerLangHandler(
          createSimpleLexer(
              [],
              [
               [PR_PLAIN,       /^[^<?]+/],
               [PR_DECLARATION, /^<!\w[^>]*(?:>|$)/],
               [PR_COMMENT,     /^<\!--[\s\S]*?(?:-\->|$)/],
               // Unescaped content in an unknown language
               ['lang-',        /^<\?([\s\S]+?)(?:\?>|$)/],
               ['lang-',        /^<%([\s\S]+?)(?:%>|$)/],
               [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],
               ['lang-',        /^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],
               // Unescaped content in javascript.  (Or possibly vbscript).
               ['lang-js',      /^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],
               // Contains unescaped stylesheet content
               ['lang-css',     /^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],
               ['lang-in.tag',  /^(<\/?[a-z][^<>]*>)/i]
              ]),
          ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);
      registerLangHandler(
          createSimpleLexer(
              [
               [PR_PLAIN,        /^[\s]+/, null, ' \t\r\n'],
               [PR_ATTRIB_VALUE, /^(?:\"[^\"]*\"?|\'[^\']*\'?)/, null, '\"\'']
               ],
              [
               [PR_TAG,          /^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],
               [PR_ATTRIB_NAME,  /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],
               ['lang-uq.val',   /^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],
               [PR_PUNCTUATION,  /^[=<>\/]+/],
               ['lang-js',       /^on\w+\s*=\s*\"([^\"]+)\"/i],
               ['lang-js',       /^on\w+\s*=\s*\'([^\']+)\'/i],
               ['lang-js',       /^on\w+\s*=\s*([^\"\'>\s]+)/i],
               ['lang-css',      /^style\s*=\s*\"([^\"]+)\"/i],
               ['lang-css',      /^style\s*=\s*\'([^\']+)\'/i],
               ['lang-css',      /^style\s*=\s*([^\"\'>\s]+)/i]
               ]),
          ['in.tag']);
      registerLangHandler(
          createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\s\S]+/]]), ['uq.val']);
      registerLangHandler(sourceDecorator({
              'keywords': CPP_KEYWORDS,
              'hashComments': true,
              'cStyleComments': true,
              'types': C_TYPES
            }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);
      registerLangHandler(sourceDecorator({
              'keywords': 'null,true,false'
            }), ['json']);
      registerLangHandler(sourceDecorator({
              'keywords': CSHARP_KEYWORDS,
              'hashComments': true,
              'cStyleComments': true,
              'verbatimStrings': true,
              'types': C_TYPES
            }), ['cs']);
      registerLangHandler(sourceDecorator({
              'keywords': JAVA_KEYWORDS,
              'cStyleComments': true
            }), ['java']);
      registerLangHandler(sourceDecorator({
              'keywords': SH_KEYWORDS,
              'hashComments': true,
              'multiLineStrings': true
            }), ['bash', 'bsh', 'csh', 'sh']);
      registerLangHandler(sourceDecorator({
              'keywords': PYTHON_KEYWORDS,
              'hashComments': true,
              'multiLineStrings': true,
              'tripleQuotedStrings': true
            }), ['cv', 'py', 'python']);
      registerLangHandler(sourceDecorator({
              'keywords': PERL_KEYWORDS,
              'hashComments': true,
              'multiLineStrings': true,
              'regexLiterals': 2  // multiline regex literals
            }), ['perl', 'pl', 'pm']);
      registerLangHandler(sourceDecorator({
              'keywords': RUBY_KEYWORDS,
              'hashComments': true,
              'multiLineStrings': true,
              'regexLiterals': true
            }), ['rb', 'ruby']);
      registerLangHandler(sourceDecorator({
              'keywords': JSCRIPT_KEYWORDS,
              'cStyleComments': true,
              'regexLiterals': true
            }), ['javascript', 'js', 'ts', 'typescript']);
      registerLangHandler(sourceDecorator({
              'keywords': COFFEE_KEYWORDS,
              'hashComments': 3,  // ### style block comments
              'cStyleComments': true,
              'multilineStrings': true,
              'tripleQuotedStrings': true,
              'regexLiterals': true
            }), ['coffee']);
      registerLangHandler(
          createSimpleLexer([], [[PR_STRING, /^[\s\S]+/]]), ['regex']);

      /** @param {JobT} job */
      function applyDecorator(job) {
        var opt_langExtension = job.langExtension;

        try {
          // Extract tags, and convert the source code to plain text.
          var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);
          /** Plain text. @type {string} */
          var source = sourceAndSpans.sourceCode;
          job.sourceCode = source;
          job.spans = sourceAndSpans.spans;
          job.basePos = 0;

          // Apply the appropriate language handler
          langHandlerForExtension(opt_langExtension, source)(job);

          // Integrate the decorations and tags back into the source code,
          // modifying the sourceNode in place.
          recombineTagsAndDecorations(job);
        } catch (e) {
          if (win['console']) {
            console['log'](e && e['stack'] || e);
          }
        }
      }

      /**
       * Pretty print a chunk of code.
       * @param sourceCodeHtml {string} The HTML to pretty print.
       * @param opt_langExtension {string} The language name to use.
       *     Typically, a filename extension like 'cpp' or 'java'.
       * @param opt_numberLines {number|boolean} True to number lines,
       *     or the 1-indexed number of the first line in sourceCodeHtml.
       */
      function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {
        /** @type{number|boolean} */
        var nl = opt_numberLines || false;
        /** @type{string|null} */
        var langExtension = opt_langExtension || null;
        /** @type{!Element} */
        var container = document.createElement('div');
        // This could cause images to load and onload listeners to fire.
        // E.g. <img onerror="alert(1337)" src="nosuchimage.png">.
        // We assume that the inner HTML is from a trusted source.
        // The pre-tag is required for IE8 which strips newlines from innerHTML
        // when it is injected into a <pre> tag.
        // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie
        // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript
        container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';
        container = /** @type{!Element} */(container.firstChild);
        if (nl) {
          numberLines(container, nl, true);
        }

        /** @type{JobT} */
        var job = {
          langExtension: langExtension,
          numberLines: nl,
          sourceNode: container,
          pre: 1,
          sourceCode: null,
          basePos: null,
          spans: null,
          decorations: null
        };
        applyDecorator(job);
        return container.innerHTML;
      }

       /**
        * Find all the {@code <pre>} and {@code <code>} tags in the DOM with
        * {@code class=prettyprint} and prettify them.
        *
        * @param {Function} opt_whenDone called when prettifying is done.
        * @param {HTMLElement|HTMLDocument} opt_root an element or document
        *   containing all the elements to pretty print.
        *   Defaults to {@code document.body}.
        */
      function $prettyPrint(opt_whenDone, opt_root) {
        var root = opt_root || document.body;
        var doc = root.ownerDocument || document;
        function byTagName(tn) { return root.getElementsByTagName(tn); }
        // fetch a list of nodes to rewrite
        var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];
        var elements = [];
        for (var i = 0; i < codeSegments.length; ++i) {
          for (var j = 0, n = codeSegments[i].length; j < n; ++j) {
            elements.push(codeSegments[i][j]);
          }
        }
        codeSegments = null;

        var clock = Date;
        if (!clock['now']) {
          clock = { 'now': function () { return +(new Date); } };
        }

        // The loop is broken into a series of continuations to make sure that we
        // don't make the browser unresponsive when rewriting a large page.
        var k = 0;

        var langExtensionRe = /\blang(?:uage)?-([\w.]+)(?!\S)/;
        var prettyPrintRe = /\bprettyprint\b/;
        var prettyPrintedRe = /\bprettyprinted\b/;
        var preformattedTagNameRe = /pre|xmp/i;
        var codeRe = /^code$/i;
        var preCodeXmpRe = /^(?:pre|code|xmp)$/i;
        var EMPTY = {};

        function doWork() {
          var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?
                         clock['now']() + 250 /* ms */ :
                         Infinity);
          for (; k < elements.length && clock['now']() < endTime; k++) {
            var cs = elements[k];

            // Look for a preceding comment like
            // <?prettify lang="..." linenums="..."?>
            var attrs = EMPTY;
            {
              for (var preceder = cs; (preceder = preceder.previousSibling);) {
                var nt = preceder.nodeType;
                // <?foo?> is parsed by HTML 5 to a comment node (8)
                // like <!--?foo?-->, but in XML is a processing instruction
                var value = (nt === 7 || nt === 8) && preceder.nodeValue;
                if (value
                    ? !/^\??prettify\b/.test(value)
                    : (nt !== 3 || /\S/.test(preceder.nodeValue))) {
                  // Skip over white-space text nodes but not others.
                  break;
                }
                if (value) {
                  attrs = {};
                  value.replace(
                      /\b(\w+)=([\w:.%+-]+)/g,
                    function (_, name, value) { attrs[name] = value; });
                  break;
                }
              }
            }

            var className = cs.className;
            if ((attrs !== EMPTY || prettyPrintRe.test(className))
                // Don't redo this if we've already done it.
                // This allows recalling pretty print to just prettyprint elements
                // that have been added to the page since last call.
                && !prettyPrintedRe.test(className)) {

              // make sure this is not nested in an already prettified element
              var nested = false;
              for (var p = cs.parentNode; p; p = p.parentNode) {
                var tn = p.tagName;
                if (preCodeXmpRe.test(tn)
                    && p.className && prettyPrintRe.test(p.className)) {
                  nested = true;
                  break;
                }
              }
              if (!nested) {
                // Mark done.  If we fail to prettyprint for whatever reason,
                // we shouldn't try again.
                cs.className += ' prettyprinted';

                // If the classes includes a language extensions, use it.
                // Language extensions can be specified like
                //     <pre class="prettyprint lang-cpp">
                // the language extension "cpp" is used to find a language handler
                // as passed to PR.registerLangHandler.
                // HTML5 recommends that a language be specified using "language-"
                // as the prefix instead.  Google Code Prettify supports both.
                // http://dev.w3.org/html5/spec-author-view/the-code-element.html
                var langExtension = attrs['lang'];
                if (!langExtension) {
                  langExtension = className.match(langExtensionRe);
                  // Support <pre class="prettyprint"><code class="language-c">
                  var wrapper;
                  if (!langExtension && (wrapper = childContentWrapper(cs))
                      && codeRe.test(wrapper.tagName)) {
                    langExtension = wrapper.className.match(langExtensionRe);
                  }

                  if (langExtension) { langExtension = langExtension[1]; }
                }

                var preformatted;
                if (preformattedTagNameRe.test(cs.tagName)) {
                  preformatted = 1;
                } else {
                  var currentStyle = cs['currentStyle'];
                  var defaultView = doc.defaultView;
                  var whitespace = (
                      currentStyle
                      ? currentStyle['whiteSpace']
                      : (defaultView
                         && defaultView.getComputedStyle)
                      ? defaultView.getComputedStyle(cs, null)
                      .getPropertyValue('white-space')
                      : 0);
                  preformatted = whitespace
                      && 'pre' === whitespace.substring(0, 3);
                }

                // Look for a class like linenums or linenums:<n> where <n> is the
                // 1-indexed number of the first line.
                var lineNums = attrs['linenums'];
                if (!(lineNums = lineNums === 'true' || +lineNums)) {
                  lineNums = className.match(/\blinenums\b(?::(\d+))?/);
                  lineNums =
                    lineNums
                    ? lineNums[1] && lineNums[1].length
                      ? +lineNums[1] : true
                    : false;
                }
                if (lineNums) { numberLines(cs, lineNums, preformatted); }

                // do the pretty printing
                var prettyPrintingJob = {
                  langExtension: langExtension,
                  sourceNode: cs,
                  numberLines: lineNums,
                  pre: preformatted,
                  sourceCode: null,
                  basePos: null,
                  spans: null,
                  decorations: null
                };
                applyDecorator(prettyPrintingJob);
              }
            }
          }
          if (k < elements.length) {
            // finish up in a continuation
            win.setTimeout(doWork, 250);
          } else if ('function' === typeof opt_whenDone) {
            opt_whenDone();
          }
        }

        doWork();
      }

      /**
       * Contains functions for creating and registering new language handlers.
       * @type {Object}
       */
      var PR = win['PR'] = {
            'createSimpleLexer': createSimpleLexer,
            'registerLangHandler': registerLangHandler,
            'sourceDecorator': sourceDecorator,
            'PR_ATTRIB_NAME': PR_ATTRIB_NAME,
            'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,
            'PR_COMMENT': PR_COMMENT,
            'PR_DECLARATION': PR_DECLARATION,
            'PR_KEYWORD': PR_KEYWORD,
            'PR_LITERAL': PR_LITERAL,
            'PR_NOCODE': PR_NOCODE,
            'PR_PLAIN': PR_PLAIN,
            'PR_PUNCTUATION': PR_PUNCTUATION,
            'PR_SOURCE': PR_SOURCE,
            'PR_STRING': PR_STRING,
            'PR_TAG': PR_TAG,
            'PR_TYPE': PR_TYPE,
            'prettyPrintOne': $prettyPrintOne,
            'prettyPrint': $prettyPrint,
                 
          };
      // Make PR available via the Asynchronous Module Definition (AMD) API.
      // Per https://github.com/amdjs/amdjs-api/wiki/AMD:
      // The Asynchronous Module Definition (AMD) API specifies a
      // mechanism for defining modules such that the module and its
      // dependencies can be asynchronously loaded.
      // ...
      // To allow a clear indicator that a global define function (as
      // needed for script src browser loading) conforms to the AMD API,
      // any global define function SHOULD have a property called "amd"
      // whose value is an object. This helps avoid conflict with any
      // other existing JavaScript code that could have defined a define()
      // function that does not conform to the AMD API.
      return PR;
    }();

    /**
     * marked - a markdown parser
     * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
     * https://github.com/markedjs/marked
     */

    const marked = function() {
      var block = {
        newline: /^\n+/,
        code: /^( {4}[^\n]+\n*)+/,
        fences: noop,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
        nptable: noop,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
        html: '^ {0,3}(?:' // optional indentation
          + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
          + '|comment[^\\n]*(\\n+|$)' // (2)
          + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
          + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
          + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
          + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
          + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
          + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
          + ')',
        def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
        table: noop,
        lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
        paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,
        text: /^[^\n]+/
      };
      
      block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
      block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
      block.def = edit(block.def)
        .replace('label', block._label)
        .replace('title', block._title)
        .getRegex();
      
      block.bullet = /(?:[*+-]|\d{1,9}\.)/;
      block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
      block.item = edit(block.item, 'gm')
        .replace(/bull/g, block.bullet)
        .getRegex();
      
      block.list = edit(block.list)
        .replace(/bull/g, block.bullet)
        .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
        .replace('def', '\\n+(?=' + block.def.source + ')')
        .getRegex();
      
      block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
        + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
        + '|track|ul';
      block._comment = /<!--(?!-?>)[\s\S]*?-->/;
      block.html = edit(block.html, 'i')
        .replace('comment', block._comment)
        .replace('tag', block._tag)
        .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
        .getRegex();
      
      block.paragraph = edit(block.paragraph)
        .replace('hr', block.hr)
        .replace('heading', block.heading)
        .replace('lheading', block.lheading)
        .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
        .getRegex();
      
      block.blockquote = edit(block.blockquote)
        .replace('paragraph', block.paragraph)
        .getRegex();
      
      /**
       * Normal Block Grammar
       */
      
      block.normal = merge({}, block);
      
      /**
       * GFM Block Grammar
       */
      
      block.gfm = merge({}, block.normal, {
        fences: /^ {0,3}(`{3,}|~{3,})([^`\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
        paragraph: /^/,
        heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
      });
      
      block.gfm.paragraph = edit(block.paragraph)
        .replace('(?!', '(?!'
          + block.gfm.fences.source.replace('\\1', '\\2') + '|'
          + block.list.source.replace('\\1', '\\3') + '|')
        .getRegex();
      
      /**
       * GFM + Tables Block Grammar
       */
      
      block.tables = merge({}, block.gfm, {
        nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
        table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
      });
      
      /**
       * Pedantic grammar
       */
      
      block.pedantic = merge({}, block.normal, {
        html: edit(
          '^ *(?:comment *(?:\\n|\\s*$)'
          + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
          + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
          .replace('comment', block._comment)
          .replace(/tag/g, '(?!(?:'
            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
            + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
          .getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/
      });
      
      /**
       * Block Lexer
       */
      
      function Lexer(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || marked.defaults;
        this.rules = block.normal;
      
        if (this.options.pedantic) {
          this.rules = block.pedantic;
        } else if (this.options.gfm) {
          if (this.options.tables) {
            this.rules = block.tables;
          } else {
            this.rules = block.gfm;
          }
        }
      }
      
      /**
       * Expose Block Rules
       */
      
      Lexer.rules = block;
      
      /**
       * Static Lex Method
       */
      
      Lexer.lex = function(src, options) {
        var lexer = new Lexer(options);
        return lexer.lex(src);
      };
      
      /**
       * Preprocessing
       */
      
      Lexer.prototype.lex = function(src) {
        src = src
          .replace(/\r\n|\r/g, '\n')
          .replace(/\t/g, '    ')
          .replace(/\u00a0/g, ' ')
          .replace(/\u2424/g, '\n');
      
        return this.token(src, true);
      };
      
      /**
       * Lexing
       */
      
      Lexer.prototype.token = function(src, top) {
        src = src.replace(/^ +$/gm, '');
        var next,
            loose,
            cap,
            bull,
            b,
            item,
            listStart,
            listItems,
            t,
            space,
            i,
            tag,
            l,
            isordered,
            istask,
            ischecked;
      
        while (src) {
          // newline
          if (cap = this.rules.newline.exec(src)) {
            src = src.substring(cap[0].length);
            if (cap[0].length > 1) {
              this.tokens.push({
                type: 'space'
              });
            }
          }
      
          // code
          if (cap = this.rules.code.exec(src)) {
            src = src.substring(cap[0].length);
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              text: !this.options.pedantic
                ? rtrim(cap, '\n')
                : cap
            });
            continue;
          }
      
          // fences (gfm)
          if (cap = this.rules.fences.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'code',
              lang: cap[2] ? cap[2].trim() : cap[2],
              text: cap[3] || ''
            });
            continue;
          }
      
          // heading
          if (cap = this.rules.heading.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[1].length,
              text: cap[2]
            });
            continue;
          }
      
          // table no leading pipe (gfm)
          if (cap = this.rules.nptable.exec(src)) {
            item = {
              type: 'table',
              header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
            };
      
            if (item.header.length === item.align.length) {
              src = src.substring(cap[0].length);
      
              for (i = 0; i < item.align.length; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }
      
              for (i = 0; i < item.cells.length; i++) {
                item.cells[i] = splitCells(item.cells[i], item.header.length);
              }
      
              this.tokens.push(item);
      
              continue;
            }
          }
      
          // hr
          if (cap = this.rules.hr.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'hr'
            });
            continue;
          }
      
          // blockquote
          if (cap = this.rules.blockquote.exec(src)) {
            src = src.substring(cap[0].length);
      
            this.tokens.push({
              type: 'blockquote_start'
            });
      
            cap = cap[0].replace(/^ *> ?/gm, '');
      
            // Pass `top` to keep the current
            // "toplevel" state. This is exactly
            // how markdown.pl works.
            this.token(cap, top);
      
            this.tokens.push({
              type: 'blockquote_end'
            });
      
            continue;
          }
      
          // list
          if (cap = this.rules.list.exec(src)) {
            src = src.substring(cap[0].length);
            bull = cap[2];
            isordered = bull.length > 1;
      
            listStart = {
              type: 'list_start',
              ordered: isordered,
              start: isordered ? +bull : '',
              loose: false
            };
      
            this.tokens.push(listStart);
      
            // Get each top-level item.
            cap = cap[0].match(this.rules.item);
      
            listItems = [];
            next = false;
            l = cap.length;
            i = 0;
      
            for (; i < l; i++) {
              item = cap[i];
      
              // Remove the list item's bullet
              // so it is seen as the next token.
              space = item.length;
              item = item.replace(/^ *([*+-]|\d+\.) */, '');
      
              // Outdent whatever the
              // list item contains. Hacky.
              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = !this.options.pedantic
                  ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                  : item.replace(/^ {1,4}/gm, '');
              }
      
              // Determine whether the next list item belongs here.
              // Backpedal if it does not belong in this list.
              if (i !== l - 1) {
                b = block.bullet.exec(cap[i + 1])[0];
                if (bull.length > 1 ? b.length === 1
                  : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                  src = cap.slice(i + 1).join('\n') + src;
                  i = l - 1;
                }
              }
      
              // Determine whether item is loose or not.
              // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
              // for discount behavior.
              loose = next || /\n\n(?!\s*$)/.test(item);
              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose) loose = next;
              }
      
              if (loose) {
                listStart.loose = true;
              }
      
              // Check for task list items
              istask = /^\[[ xX]\] /.test(item);
              ischecked = undefined;
              if (istask) {
                ischecked = item[1] !== ' ';
                item = item.replace(/^\[[ xX]\] +/, '');
              }
      
              t = {
                type: 'list_item_start',
                task: istask,
                checked: ischecked,
                loose: loose
              };
      
              listItems.push(t);
              this.tokens.push(t);
      
              // Recurse.
              this.token(item, false);
      
              this.tokens.push({
                type: 'list_item_end'
              });
            }
      
            if (listStart.loose) {
              l = listItems.length;
              i = 0;
              for (; i < l; i++) {
                listItems[i].loose = true;
              }
            }
      
            this.tokens.push({
              type: 'list_end'
            });
      
            continue;
          }
      
          // html
          if (cap = this.rules.html.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: this.options.sanitize
                ? 'paragraph'
                : 'html',
              pre: !this.options.sanitizer
                && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
              text: cap[0]
            });
            continue;
          }
      
          // def
          if (top && (cap = this.rules.def.exec(src))) {
            src = src.substring(cap[0].length);
            if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
            tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            if (!this.tokens.links[tag]) {
              this.tokens.links[tag] = {
                href: cap[2],
                title: cap[3]
              };
            }
            continue;
          }
      
          // table (gfm)
          if (cap = this.rules.table.exec(src)) {
            item = {
              type: 'table',
              header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
            };
      
            if (item.header.length === item.align.length) {
              src = src.substring(cap[0].length);
      
              for (i = 0; i < item.align.length; i++) {
                if (/^ *-+: *$/.test(item.align[i])) {
                  item.align[i] = 'right';
                } else if (/^ *:-+: *$/.test(item.align[i])) {
                  item.align[i] = 'center';
                } else if (/^ *:-+ *$/.test(item.align[i])) {
                  item.align[i] = 'left';
                } else {
                  item.align[i] = null;
                }
              }
      
              for (i = 0; i < item.cells.length; i++) {
                item.cells[i] = splitCells(
                  item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
                  item.header.length);
              }
      
              this.tokens.push(item);
      
              continue;
            }
          }
      
          // lheading
          if (cap = this.rules.lheading.exec(src)) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[2] === '=' ? 1 : 2,
              text: cap[1]
            });
            continue;
          }
      
          // top-level paragraph
          if (top && (cap = this.rules.paragraph.exec(src))) {
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'paragraph',
              text: cap[1].charAt(cap[1].length - 1) === '\n'
                ? cap[1].slice(0, -1)
                : cap[1]
            });
            continue;
          }
      
          // text
          if (cap = this.rules.text.exec(src)) {
            // Top-level should never reach here.
            src = src.substring(cap[0].length);
            this.tokens.push({
              type: 'text',
              text: cap[0]
            });
            continue;
          }
      
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
      
        return this.tokens;
      };
      
      /**
       * Inline-Level Grammar
       */
      
      var inline = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: noop,
        tag: '^comment'
          + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
          + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
          + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
          + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
          + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
        link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
        nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
        strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
        em: /^_([^\s_])_(?!_)|^\*([^\s*"<\[])\*(?!\*)|^_([^\s][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s"<\[][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: noop,
        text: /^(`+|[^`])[\s\S]*?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
      };
      
      // list of punctuation marks from common mark spec
      // without ` and ] to workaround Rule 17 (inline code blocks/links)
      inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
      inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();
      
      inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      
      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline.autolink = edit(inline.autolink)
        .replace('scheme', inline._scheme)
        .replace('email', inline._email)
        .getRegex();
      
      inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      
      inline.tag = edit(inline.tag)
        .replace('comment', block._comment)
        .replace('attribute', inline._attribute)
        .getRegex();
      
      inline._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|`(?!`)|[^\[\]\\`])*?/;
      inline._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*)/;
      inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      
      inline.link = edit(inline.link)
        .replace('label', inline._label)
        .replace('href', inline._href)
        .replace('title', inline._title)
        .getRegex();
      
      inline.reflink = edit(inline.reflink)
        .replace('label', inline._label)
        .getRegex();
      
      /**
       * Normal Inline Grammar
       */
      
      inline.normal = merge({}, inline);
      
      /**
       * Pedantic Inline Grammar
       */
      
      inline.pedantic = merge({}, inline.normal, {
        strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
        link: edit(/^!?\[(label)\]\((.*?)\)/)
          .replace('label', inline._label)
          .getRegex(),
        reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
          .replace('label', inline._label)
          .getRegex()
      });
      
      /**
       * GFM Inline Grammar
       */
      
      inline.gfm = merge({}, inline.normal, {
        escape: edit(inline.escape).replace('])', '~|])').getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^~+(?=\S)([\s\S]*?\S)~+/,
        text: edit(inline.text)
          .replace(']|', '~]|')
          .replace('|$', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|$')
          .getRegex()
      });
      
      inline.gfm.url = edit(inline.gfm.url, 'i')
        .replace('email', inline.gfm._extended_email)
        .getRegex();
      /**
       * GFM + Line Breaks Inline Grammar
       */
      
      inline.breaks = merge({}, inline.gfm, {
        br: edit(inline.br).replace('{2,}', '*').getRegex(),
        text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
      });
      
      /**
       * Inline Lexer & Compiler
       */
      
      function InlineLexer(links, options) {
        this.options = options || marked.defaults;
        this.links = links;
        this.rules = inline.normal;
        this.renderer = this.options.renderer || new Renderer();
        this.renderer.options = this.options;
      
        if (!this.links) {
          throw new Error('Tokens array requires a `links` property.');
        }
      
        if (this.options.pedantic) {
          this.rules = inline.pedantic;
        } else if (this.options.gfm) {
          if (this.options.breaks) {
            this.rules = inline.breaks;
          } else {
            this.rules = inline.gfm;
          }
        }
      }
      
      /**
       * Expose Inline Rules
       */
      
      InlineLexer.rules = inline;
      
      /**
       * Static Lexing/Compiling Method
       */
      
      InlineLexer.output = function(src, links, options) {
        var inline = new InlineLexer(links, options);
        return inline.output(src);
      };
      
      /**
       * Lexing/Compiling
       */
      
      InlineLexer.prototype.output = function(src) {
        var out = '',
            link,
            text,
            href,
            title,
            cap,
            prevCapZero;
      
        while (src) {
          // escape
          if (cap = this.rules.escape.exec(src)) {
            src = src.substring(cap[0].length);
            out += escape(cap[1]);
            continue;
          }
      
          // tag
          if (cap = this.rules.tag.exec(src)) {
            if (!this.inLink && /^<a /i.test(cap[0])) {
              this.inLink = true;
            } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
              this.inLink = false;
            }
            if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              this.inRawBlock = true;
            } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              this.inRawBlock = false;
            }
      
            src = src.substring(cap[0].length);
            out += this.options.sanitize
              ? this.options.sanitizer
                ? this.options.sanitizer(cap[0])
                : escape(cap[0])
              : cap[0];
            continue;
          }
      
          // link
          if (cap = this.rules.link.exec(src)) {
            var lastParenIndex = findClosingBracket(cap[2], '()');
            if (lastParenIndex > -1) {
              var linkLen = cap[0].length - (cap[2].length - lastParenIndex) - (cap[3] || '').length;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = '';
            }
            src = src.substring(cap[0].length);
            this.inLink = true;
            href = cap[2];
            if (this.options.pedantic) {
              link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
      
              if (link) {
                href = link[1];
                title = link[3];
              } else {
                title = '';
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
            out += this.outputLink(cap, {
              href: InlineLexer.escapes(href),
              title: InlineLexer.escapes(title)
            });
            this.inLink = false;
            continue;
          }
      
          // reflink, nolink
          if ((cap = this.rules.reflink.exec(src))
              || (cap = this.rules.nolink.exec(src))) {
            src = src.substring(cap[0].length);
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!link || !link.href) {
              out += cap[0].charAt(0);
              src = cap[0].substring(1) + src;
              continue;
            }
            this.inLink = true;
            out += this.outputLink(cap, link);
            this.inLink = false;
            continue;
          }
      
          // strong
          if (cap = this.rules.strong.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
            continue;
          }
      
          // em
          if (cap = this.rules.em.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
            continue;
          }
      
          // code
          if (cap = this.rules.code.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.renderer.codespan(escape(cap[2].trim(), true));
            continue;
          }
      
          // br
          if (cap = this.rules.br.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.renderer.br();
            continue;
          }
      
          // del (gfm)
          if (cap = this.rules.del.exec(src)) {
            src = src.substring(cap[0].length);
            out += this.renderer.del(this.output(cap[1]));
            continue;
          }
      
          // autolink
          if (cap = this.rules.autolink.exec(src)) {
            src = src.substring(cap[0].length);
            if (cap[2] === '@') {
              text = escape(this.mangle(cap[1]));
              href = 'mailto:' + text;
            } else {
              text = escape(cap[1]);
              href = text;
            }
            out += this.renderer.link(href, null, text);
            continue;
          }
      
          // url (gfm)
          if (!this.inLink && (cap = this.rules.url.exec(src))) {
            if (cap[2] === '@') {
              text = escape(cap[0]);
              href = 'mailto:' + text;
            } else {
              // do extended autolink path validation
              do {
                prevCapZero = cap[0];
                cap[0] = this.rules._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);
              text = escape(cap[0]);
              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }
            src = src.substring(cap[0].length);
            out += this.renderer.link(href, null, text);
            continue;
          }
      
          // text
          if (cap = this.rules.text.exec(src)) {
            src = src.substring(cap[0].length);
            if (this.inRawBlock) {
              out += this.renderer.text(cap[0]);
            } else {
              out += this.renderer.text(escape(this.smartypants(cap[0])));
            }
            continue;
          }
      
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
      
        return out;
      };
      
      InlineLexer.escapes = function(text) {
        return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
      };
      
      /**
       * Compile Link
       */
      
      InlineLexer.prototype.outputLink = function(cap, link) {
        var href = link.href,
            title = link.title ? escape(link.title) : null;
      
        return cap[0].charAt(0) !== '!'
          ? this.renderer.link(href, title, this.output(cap[1]))
          : this.renderer.image(href, title, escape(cap[1]));
      };
      
      /**
       * Smartypants Transformations
       */
      
      InlineLexer.prototype.smartypants = function(text) {
        if (!this.options.smartypants) return text;
        return text
          // em-dashes
          .replace(/---/g, '\u2014')
          // en-dashes
          .replace(/--/g, '\u2013')
          // opening singles
          .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
          // closing singles & apostrophes
          .replace(/'/g, '\u2019')
          // opening doubles
          .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
          // closing doubles
          .replace(/"/g, '\u201d')
          // ellipses
          .replace(/\.{3}/g, '\u2026');
      };
      
      /**
       * Mangle Links
       */
      
      InlineLexer.prototype.mangle = function(text) {
        if (!this.options.mangle) return text;
        var out = '',
            l = text.length,
            i = 0,
            ch;
      
        for (; i < l; i++) {
          ch = text.charCodeAt(i);
          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }
          out += '&#' + ch + ';';
        }
      
        return out;
      };
      
      /**
       * Renderer
       */
      
      function Renderer(options) {
        this.options = options || marked.defaults;
      }
      
      Renderer.prototype.code = function(code, infostring, escaped) {
        var lang = (infostring || '').match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
      
        if (!lang) {
          return '<pre><code>'
            + (escaped ? code : escape(code, true))
            + '</code></pre>';
        }
      
        return '<pre><code class="'
          + this.options.langPrefix
          + escape(lang, true)
          + '">'
          + (escaped ? code : escape(code, true))
          + '</code></pre>\n';
      };
      
      Renderer.prototype.blockquote = function(quote) {
        return '<blockquote>\n' + quote + '</blockquote>\n';
      };
      
      Renderer.prototype.html = function(html) {
        return html;
      };
      
      Renderer.prototype.heading = function(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return '<h'
            + level
            + ' id="'
            + this.options.headerPrefix
            + slugger.slug(raw)
            + '">'
            + text
            + '</h'
            + level
            + '>\n';
        }
        // ignore IDs
        return '<h' + level + '>' + text + '</h' + level + '>\n';
      };
      
      Renderer.prototype.hr = function() {
        return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
      };
      
      Renderer.prototype.list = function(body, ordered, start) {
        var type = ordered ? 'ol' : 'ul',
            startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      };
      
      Renderer.prototype.listitem = function(text) {
        return '<li>' + text + '</li>\n';
      };
      
      Renderer.prototype.checkbox = function(checked) {
        return '<input '
          + (checked ? 'checked="" ' : '')
          + 'disabled="" type="checkbox"'
          + (this.options.xhtml ? ' /' : '')
          + '> ';
      };
      
      Renderer.prototype.paragraph = function(text) {
        return '<p>' + text + '</p>\n';
      };
      
      Renderer.prototype.table = function(header, body) {
        if (body) body = '<tbody>' + body + '</tbody>';
      
        return '<table>\n'
          + '<thead>\n'
          + header
          + '</thead>\n'
          + body
          + '</table>\n';
      };
      
      Renderer.prototype.tablerow = function(content) {
        return '<tr>\n' + content + '</tr>\n';
      };
      
      Renderer.prototype.tablecell = function(content, flags) {
        var type = flags.header ? 'th' : 'td';
        var tag = flags.align
          ? '<' + type + ' align="' + flags.align + '">'
          : '<' + type + '>';
        return tag + content + '</' + type + '>\n';
      };
      
      // span level renderer
      Renderer.prototype.strong = function(text) {
        return '<strong>' + text + '</strong>';
      };
      
      Renderer.prototype.em = function(text) {
        return '<em>' + text + '</em>';
      };
      
      Renderer.prototype.codespan = function(text) {
        return '<code>' + text + '</code>';
      };
      
      Renderer.prototype.br = function() {
        return this.options.xhtml ? '<br/>' : '<br>';
      };
      
      Renderer.prototype.del = function(text) {
        return '<del>' + text + '</del>';
      };
      
      Renderer.prototype.link = function(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      };
      
      Renderer.prototype.image = function(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
      
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? '/>' : '>';
        return out;
      };
      
      Renderer.prototype.text = function(text) {
        return text;
      };
      
      /**
       * TextRenderer
       * returns only the textual part of the token
       */
      
      function TextRenderer() {}
      
      // no need for block level renderers
      
      TextRenderer.prototype.strong =
      TextRenderer.prototype.em =
      TextRenderer.prototype.codespan =
      TextRenderer.prototype.del =
      TextRenderer.prototype.text = function (text) {
        return text;
      };
      
      TextRenderer.prototype.link =
      TextRenderer.prototype.image = function(href, title, text) {
        return '' + text;
      };
      
      TextRenderer.prototype.br = function() {
        return '';
      };
      
      /**
       * Parsing & Compiling
       */
      
      function Parser(options) {
        this.tokens = [];
        this.token = null;
        this.options = options || marked.defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.slugger = new Slugger();
      }
      
      /**
       * Static Parse Method
       */
      
      Parser.parse = function(src, options) {
        var parser = new Parser(options);
        return parser.parse(src);
      };
      
      /**
       * Parse Loop
       */
      
      Parser.prototype.parse = function(src) {
        this.inline = new InlineLexer(src.links, this.options);
        // use an InlineLexer with a TextRenderer to extract pure text
        this.inlineText = new InlineLexer(
          src.links,
          merge({}, this.options, {renderer: new TextRenderer()})
        );
        this.tokens = src.reverse();
      
        var out = '';
        while (this.next()) {
          out += this.tok();
        }
      
        return out;
      };
      
      /**
       * Next Token
       */
      
      Parser.prototype.next = function() {
        return this.token = this.tokens.pop();
      };
      
      /**
       * Preview Next Token
       */
      
      Parser.prototype.peek = function() {
        return this.tokens[this.tokens.length - 1] || 0;
      };
      
      /**
       * Parse Text Tokens
       */
      
      Parser.prototype.parseText = function() {
        var body = this.token.text;
      
        while (this.peek().type === 'text') {
          body += '\n' + this.next().text;
        }
      
        return this.inline.output(body);
      };
      
      /**
       * Parse Current Token
       */
      
      Parser.prototype.tok = function() {
        switch (this.token.type) {
          case 'space': {
            return '';
          }
          case 'hr': {
            return this.renderer.hr();
          }
          case 'heading': {
            return this.renderer.heading(
              this.inline.output(this.token.text),
              this.token.depth,
              unescape(this.inlineText.output(this.token.text)),
              this.slugger);
          }
          case 'code': {
            return this.renderer.code(this.token.text,
              this.token.lang,
              this.token.escaped);
          }
          case 'table': {
            var header = '',
                body = '',
                i,
                row,
                cell,
                j;
      
            // header
            cell = '';
            for (i = 0; i < this.token.header.length; i++) {
              cell += this.renderer.tablecell(
                this.inline.output(this.token.header[i]),
                { header: true, align: this.token.align[i] }
              );
            }
            header += this.renderer.tablerow(cell);
      
            for (i = 0; i < this.token.cells.length; i++) {
              row = this.token.cells[i];
      
              cell = '';
              for (j = 0; j < row.length; j++) {
                cell += this.renderer.tablecell(
                  this.inline.output(row[j]),
                  { header: false, align: this.token.align[j] }
                );
              }
      
              body += this.renderer.tablerow(cell);
            }
            return this.renderer.table(header, body);
          }
          case 'blockquote_start': {
            body = '';
      
            while (this.next().type !== 'blockquote_end') {
              body += this.tok();
            }
      
            return this.renderer.blockquote(body);
          }
          case 'list_start': {
            body = '';
            var ordered = this.token.ordered,
                start = this.token.start;
      
            while (this.next().type !== 'list_end') {
              body += this.tok();
            }
      
            return this.renderer.list(body, ordered, start);
          }
          case 'list_item_start': {
            body = '';
            var loose = this.token.loose;
            var checked = this.token.checked;
            var task = this.token.task;
      
            if (this.token.task) {
              body += this.renderer.checkbox(checked);
            }
      
            while (this.next().type !== 'list_item_end') {
              body += !loose && this.token.type === 'text'
                ? this.parseText()
                : this.tok();
            }
            return this.renderer.listitem(body, task, checked);
          }
          case 'html': {
            // TODO parse inline content if parameter markdown=1
            return this.renderer.html(this.token.text);
          }
          case 'paragraph': {
            return this.renderer.paragraph(this.inline.output(this.token.text));
          }
          case 'text': {
            return this.renderer.paragraph(this.parseText());
          }
          default: {
            var errMsg = 'Token with "' + this.token.type + '" type was not found.';
            if (this.options.silent) {
              console.log(errMsg);
            } else {
              throw new Error(errMsg);
            }
          }
        }
      };
      
      /**
       * Slugger generates header id
       */
      
      function Slugger () {
        this.seen = {};
      }
      
      /**
       * Convert string to unique id
       */
      
      Slugger.prototype.slug = function (value) {
        var slug = value
          .toLowerCase()
          .trim()
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
          .replace(/\s/g, '-');
      
        if (this.seen.hasOwnProperty(slug)) {
          var originalSlug = slug;
          do {
            this.seen[originalSlug]++;
            slug = originalSlug + '-' + this.seen[originalSlug];
          } while (this.seen.hasOwnProperty(slug));
        }
        this.seen[slug] = 0;
      
        return slug;
      };
      
      /**
       * Helpers
       */
      
      function escape(html, encode) {
        if (encode) {
          if (escape.escapeTest.test(html)) {
            return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch]; });
          }
        } else {
          if (escape.escapeTestNoEncode.test(html)) {
            return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch]; });
          }
        }
      
        return html;
      }
      
      escape.escapeTest = /[&<>"']/;
      escape.escapeReplace = /[&<>"']/g;
      escape.replacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };
      
      escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
      escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
      
      function unescape(html) {
        // explicitly match decimal, hex, and named HTML entities
        return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
          n = n.toLowerCase();
          if (n === 'colon') return ':';
          if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x'
              ? String.fromCharCode(parseInt(n.substring(2), 16))
              : String.fromCharCode(+n.substring(1));
          }
          return '';
        });
      }
      
      function edit(regex, opt) {
        regex = regex.source || regex;
        opt = opt || '';
        return {
          replace: function(name, val) {
            val = val.source || val;
            val = val.replace(/(^|[^\[])\^/g, '$1');
            regex = regex.replace(name, val);
            return this;
          },
          getRegex: function() {
            return new RegExp(regex, opt);
          }
        };
      }
      
      function cleanUrl(sanitize, base, href) {
        if (sanitize) {
          try {
            var prot = decodeURIComponent(unescape(href))
              .replace(/[^\w:]/g, '')
              .toLowerCase();
          } catch (e) {
            return null;
          }
          if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
            return null;
          }
        }
        if (base && !originIndependentUrl.test(href)) {
          href = resolveUrl(base, href);
        }
        try {
          href = encodeURI(href).replace(/%25/g, '%');
        } catch (e) {
          return null;
        }
        return href;
      }
      
      function resolveUrl(base, href) {
        if (!baseUrls[' ' + base]) {
          // we can ignore everything in base after the last slash of its path component,
          // but we might need to add _that_
          // https://tools.ietf.org/html/rfc3986#section-3
          if (/^[^:]+:\/*[^/]*$/.test(base)) {
            baseUrls[' ' + base] = base + '/';
          } else {
            baseUrls[' ' + base] = rtrim(base, '/', true);
          }
        }
        base = baseUrls[' ' + base];
      
        if (href.slice(0, 2) === '//') {
          return base.replace(/:[\s\S]*/, ':') + href;
        } else if (href.charAt(0) === '/') {
          return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
        } else {
          return base + href;
        }
      }
      var baseUrls = {};
      var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
      
      function noop() {}
      noop.exec = noop;
      
      function merge(obj) {
        var i = 1,
            target,
            key;
      
        for (; i < arguments.length; i++) {
          target = arguments[i];
          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }
      
        return obj;
      }
      
      function splitCells(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        var row = tableRow.replace(/\|/g, function (match, offset, str) {
              var escaped = false,
                  curr = offset;
              while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
              if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
              } else {
                // add space before unescaped |
                return ' |';
              }
            }),
            cells = row.split(/ \|/),
            i = 0;
      
        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count) cells.push('');
        }
      
        for (; i < cells.length; i++) {
          // leading or trailing whitespace is ignored per the gfm spec
          cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }
        return cells;
      }
      
      // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
      // /c*$/ is vulnerable to REDOS.
      // invert: Remove suffix of non-c chars instead. Default falsey.
      function rtrim(str, c, invert) {
        if (str.length === 0) {
          return '';
        }
      
        // Length of suffix matching the invert condition.
        var suffLen = 0;
      
        // Step left until we fail to match the invert condition.
        while (suffLen < str.length) {
          var currChar = str.charAt(str.length - suffLen - 1);
          if (currChar === c && !invert) {
            suffLen++;
          } else if (currChar !== c && invert) {
            suffLen++;
          } else {
            break;
          }
        }
      
        return str.substr(0, str.length - suffLen);
      }
      
      function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
          return -1;
        }
        var level = 0;
        for (var i = 0; i < str.length; i++) {
          if (str[i] === '\\') {
            i++;
          } else if (str[i] === b[0]) {
            level++;
          } else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
              return i;
            }
          }
        }
        return -1;
      }
      
      /**
       * Marked
       */
      
      function marked(src, opt, callback) {
        // throw error in case of non string input
        if (typeof src === 'undefined' || src === null) {
          throw new Error('marked(): input parameter is undefined or null');
        }
        if (typeof src !== 'string') {
          throw new Error('marked(): input parameter is of type '
            + Object.prototype.toString.call(src) + ', string expected');
        }
      
        if (callback || typeof opt === 'function') {
          if (!callback) {
            callback = opt;
            opt = null;
          }
      
          opt = merge({}, marked.defaults, opt || {});
      
          var highlight = opt.highlight,
              tokens,
              pending,
              i = 0;
      
          try {
            tokens = Lexer.lex(src, opt);
          } catch (e) {
            return callback(e);
          }
      
          pending = tokens.length;
      
          var done = function(err) {
            if (err) {
              opt.highlight = highlight;
              return callback(err);
            }
      
            var out;
      
            try {
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
      
            opt.highlight = highlight;
      
            return err
              ? callback(err)
              : callback(null, out);
          };
      
          if (!highlight || highlight.length < 3) {
            return done();
          }
      
          delete opt.highlight;
      
          if (!pending) return done();
      
          for (; i < tokens.length; i++) {
            (function(token) {
              if (token.type !== 'code') {
                return --pending || done();
              }
              return highlight(token.text, token.lang, function(err, code) {
                if (err) return done(err);
                if (code == null || code === token.text) {
                  return --pending || done();
                }
                token.text = code;
                token.escaped = true;
                --pending || done();
              });
            })(tokens[i]);
          }
      
          return;
        }
        try {
          if (opt) opt = merge({}, marked.defaults, opt);
          return Parser.parse(Lexer.lex(src, opt), opt);
        } catch (e) {
          e.message += '\nPlease report this to https://github.com/markedjs/marked.';
          if ((opt || marked.defaults).silent) {
            return '<p>An error occurred:</p><pre>'
              + escape(e.message + '', true)
              + '</pre>';
          }
          throw e;
        }
      }
      
      /**
       * Options
       */
      
      marked.options =
      marked.setOptions = function(opt) {
        merge(marked.defaults, opt);
        return marked;
      };
      
      marked.getDefaults = function () {
        return {
          baseUrl: null,
          breaks: false,
          gfm: true,
          headerIds: true,
          headerPrefix: '',
          highlight: null,
          langPrefix: 'language-',
          mangle: true,
          pedantic: false,
          renderer: new Renderer(),
          sanitize: false,
          sanitizer: null,
          silent: false,
          smartLists: false,
          smartypants: false,
          tables: true,
          xhtml: false
        };
      };
      
      marked.defaults = marked.getDefaults();
      
      /**
       * Expose
       */
      
      marked.Parser = Parser;
      marked.parser = Parser.parse;
      
      marked.Renderer = Renderer;
      marked.TextRenderer = TextRenderer;
      
      marked.Lexer = Lexer;
      marked.lexer = Lexer.lex;
      
      marked.InlineLexer = InlineLexer;
      marked.inlineLexer = InlineLexer.output;
      
      marked.Slugger = Slugger;
      
      marked.parse = marked;
      
      return marked
      }();

    /**
     * Lexing or parsing positional information for error reporting.
     * This object is immutable.
     */
    class SourceLocation {
      // The + prefix indicates that these fields aren't writeable
      // Lexer holding the input string.
      // Start offset, zero-based inclusive.
      // End offset, zero-based exclusive.
      constructor(lexer, start, end) {
        this.lexer = void 0;
        this.start = void 0;
        this.end = void 0;
        this.lexer = lexer;
        this.start = start;
        this.end = end;
      }
      /**
       * Merges two `SourceLocation`s from location providers, given they are
       * provided in order of appearance.
       * - Returns the first one's location if only the first is provided.
       * - Returns a merged range of the first and the last if both are provided
       *   and their lexers match.
       * - Otherwise, returns null.
       */


      static range(first, second) {
        if (!second) {
          return first && first.loc;
        } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
          return null;
        } else {
          return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
        }
      }

    }

    /**
     * Interface required to break circular dependency between Token, Lexer, and
     * ParseError.
     */

    /**
     * The resulting token returned from `lex`.
     *
     * It consists of the token text plus some position information.
     * The position information is essentially a range in an input string,
     * but instead of referencing the bare input string, we refer to the lexer.
     * That way it is possible to attach extra metadata to the input string,
     * like for example a file name or similar.
     *
     * The position information is optional, so it is OK to construct synthetic
     * tokens if appropriate. Not providing available position information may
     * lead to degraded error reporting, though.
     */
    class Token {
      constructor(text, // the text of this token
      loc) {
        this.text = void 0;
        this.loc = void 0;
        this.text = text;
        this.loc = loc;
      }
      /**
       * Given a pair of tokens (this and endToken), compute a `Token` encompassing
       * the whole input range enclosed by these two.
       */


      range(endToken, // last token of the range, inclusive
      text) // the text of the newly constructed token
      {
        return new Token(text, SourceLocation.range(this, endToken));
      }

    }

    /**
     * This is the ParseError class, which is the main error thrown by KaTeX
     * functions when something has gone wrong. This is used to distinguish internal
     * errors from errors in the expression that the user provided.
     *
     * If possible, a caller should provide a Token or ParseNode with information
     * about where in the source string the problem occurred.
     */
    class ParseError {
      // Error position based on passed-in Token or ParseNode.
      constructor(message, // The error message
      token) // An object providing position information
      {
        this.position = void 0;
        let error = "KaTeX parse error: " + message;
        let start;
        const loc = token && token.loc;

        if (loc && loc.start <= loc.end) {
          // If we have the input and a position, make the error a bit fancier
          // Get the input
          const input = loc.lexer.input; // Prepend some information

          start = loc.start;
          const end = loc.end;

          if (start === input.length) {
            error += " at end of input: ";
          } else {
            error += " at position " + (start + 1) + ": ";
          } // Underline token in question using combining underscores


          const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332"); // Extract some context from the input and add it to the error

          let left;

          if (start > 15) {
            left = "…" + input.slice(start - 15, start);
          } else {
            left = input.slice(0, start);
          }

          let right;

          if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "…";
          } else {
            right = input.slice(end);
          }

          error += left + underlined + right;
        } // Some hackery to make ParseError a prototype of Error
        // See http://stackoverflow.com/a/8460753


        const self = new Error(error);
        self.name = "ParseError"; // $FlowFixMe

        self.__proto__ = ParseError.prototype; // $FlowFixMe

        self.position = start;
        return self;
      }

    } // $FlowFixMe More hackery


    ParseError.prototype.__proto__ = Error.prototype;

    /**
     * This file contains a list of utility functions which are useful in other
     * files.
     */

    /**
     * Return whether an element is contained in a list
     */
    const contains = function contains(list, elem) {
      return list.indexOf(elem) !== -1;
    };
    /**
     * Provide a default value if a setting is undefined
     * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.
     */


    const deflt = function deflt(setting, defaultIfUndefined) {
      return setting === undefined ? defaultIfUndefined : setting;
    }; // hyphenate and escape adapted from Facebook's React under Apache 2 license


    const uppercase = /([A-Z])/g;

    const hyphenate = function hyphenate(str) {
      return str.replace(uppercase, "-$1").toLowerCase();
    };

    const ESCAPE_LOOKUP = {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      "\"": "&quot;",
      "'": "&#x27;"
    };
    const ESCAPE_REGEX = /[&><"']/g;
    /**
     * Escapes text to prevent scripting attacks.
     */

    function escape(text) {
      return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
    }
    /**
     * Sometimes we want to pull out the innermost element of a group. In most
     * cases, this will just be the group itself, but when ordgroups and colors have
     * a single element, we want to pull that out.
     */


    const getBaseElem = function getBaseElem(group) {
      if (group.type === "ordgroup") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "color") {
        if (group.body.length === 1) {
          return getBaseElem(group.body[0]);
        } else {
          return group;
        }
      } else if (group.type === "font") {
        return getBaseElem(group.body);
      } else {
        return group;
      }
    };
    /**
     * TeXbook algorithms often reference "character boxes", which are simply groups
     * with a single character in them. To decide if something is a character box,
     * we find its innermost group, and see if it is a single character.
     */


    const isCharacterBox = function isCharacterBox(group) {
      const baseElem = getBaseElem(group); // These are all they types of groups which hold single characters

      return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
    };

    const assert = function assert(value) {
      if (!value) {
        throw new Error('Expected non-null, but got ' + String(value));
      }

      return value;
    };
    var utils = {
      contains,
      deflt,
      escape,
      hyphenate,
      getBaseElem,
      isCharacterBox
    };

    /* eslint no-console:0 */

    /**
     * The main Settings object
     *
     * The current options stored are:
     *  - displayMode: Whether the expression should be typeset as inline math
     *                 (false, the default), meaning that the math starts in
     *                 \textstyle and is placed in an inline-block); or as display
     *                 math (true), meaning that the math starts in \displaystyle
     *                 and is placed in a block with vertical margin.
     */
    class Settings {
      constructor(options) {
        this.displayMode = void 0;
        this.leqno = void 0;
        this.fleqn = void 0;
        this.throwOnError = void 0;
        this.errorColor = void 0;
        this.macros = void 0;
        this.colorIsTextColor = void 0;
        this.strict = void 0;
        this.maxSize = void 0;
        this.maxExpand = void 0;
        this.allowedProtocols = void 0;
        // allow null options
        options = options || {};
        this.displayMode = utils.deflt(options.displayMode, false);
        this.leqno = utils.deflt(options.leqno, false);
        this.fleqn = utils.deflt(options.fleqn, false);
        this.throwOnError = utils.deflt(options.throwOnError, true);
        this.errorColor = utils.deflt(options.errorColor, "#cc0000");
        this.macros = options.macros || {};
        this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
        this.strict = utils.deflt(options.strict, "warn");
        this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
        this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000));
        this.allowedProtocols = utils.deflt(options.allowedProtocols, ["http", "https", "mailto", "_relative"]);
      }
      /**
       * Report nonstrict (non-LaTeX-compatible) input.
       * Can safely not be called if `this.strict` is false in JavaScript.
       */


      reportNonstrict(errorCode, errorMsg, token) {
        let strict = this.strict;

        if (typeof strict === "function") {
          // Allow return value of strict function to be boolean or string
          // (or null/undefined, meaning no further processing).
          strict = strict(errorCode, errorMsg, token);
        }

        if (!strict || strict === "ignore") {
          return;
        } else if (strict === true || strict === "error") {
          throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + `${errorMsg} [${errorCode}]`, token);
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + `${errorMsg} [${errorCode}]`);
        } else {
          // won't happen in type-safe code
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + `unrecognized '${strict}': ${errorMsg} [${errorCode}]`);
        }
      }
      /**
       * Check whether to apply strict (LaTeX-adhering) behavior for unusual
       * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
       * instead, "error" translates to a return value of `true`, while "ignore"
       * translates to a return value of `false`.  May still print a warning:
       * "warn" prints a warning and returns `false`.
       * This is for the second category of `errorCode`s listed in the README.
       */


      useStrictBehavior(errorCode, errorMsg, token) {
        let strict = this.strict;

        if (typeof strict === "function") {
          // Allow return value of strict function to be boolean or string
          // (or null/undefined, meaning no further processing).
          // But catch any exceptions thrown by function, treating them
          // like "error".
          try {
            strict = strict(errorCode, errorMsg, token);
          } catch (error) {
            strict = "error";
          }
        }

        if (!strict || strict === "ignore") {
          return false;
        } else if (strict === true || strict === "error") {
          return true;
        } else if (strict === "warn") {
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + `${errorMsg} [${errorCode}]`);
          return false;
        } else {
          // won't happen in type-safe code
          typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + `unrecognized '${strict}': ${errorMsg} [${errorCode}]`);
          return false;
        }
      }

    }

    /**
     * This file contains information and classes for the various kinds of styles
     * used in TeX. It provides a generic `Style` class, which holds information
     * about a specific style. It then provides instances of all the different kinds
     * of styles possible, and provides functions to move between them and get
     * information about them.
     */

    /**
     * The main style class. Contains a unique id for the style, a size (which is
     * the same for cramped and uncramped version of a style), and a cramped flag.
     */
    class Style {
      constructor(id, size, cramped) {
        this.id = void 0;
        this.size = void 0;
        this.cramped = void 0;
        this.id = id;
        this.size = size;
        this.cramped = cramped;
      }
      /**
       * Get the style of a superscript given a base in the current style.
       */


      sup() {
        return styles[sup[this.id]];
      }
      /**
       * Get the style of a subscript given a base in the current style.
       */


      sub() {
        return styles[sub[this.id]];
      }
      /**
       * Get the style of a fraction numerator given the fraction in the current
       * style.
       */


      fracNum() {
        return styles[fracNum[this.id]];
      }
      /**
       * Get the style of a fraction denominator given the fraction in the current
       * style.
       */


      fracDen() {
        return styles[fracDen[this.id]];
      }
      /**
       * Get the cramped version of a style (in particular, cramping a cramped style
       * doesn't change the style).
       */


      cramp() {
        return styles[cramp[this.id]];
      }
      /**
       * Get a text or display version of this style.
       */


      text() {
        return styles[text[this.id]];
      }
      /**
       * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
       */


      isTight() {
        return this.size >= 2;
      }

    } // Export an interface for type checking, but don't expose the implementation.
    // This way, no more styles can be generated.


    // IDs of the different styles
    const D$1 = 0;
    const Dc = 1;
    const T = 2;
    const Tc = 3;
    const S = 4;
    const Sc = 5;
    const SS = 6;
    const SSc = 7; // Instances of the different styles

    const styles = [new Style(D$1, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another

    const sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
    const sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
    const fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
    const fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
    const cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
    const text = [D$1, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.

    var Style$1 = {
      DISPLAY: styles[D$1],
      TEXT: styles[T],
      SCRIPT: styles[S],
      SCRIPTSCRIPT: styles[SS]
    };

    /*
     * This file defines the Unicode scripts and script families that we
     * support. To add new scripts or families, just add a new entry to the
     * scriptData array below. Adding scripts to the scriptData array allows
     * characters from that script to appear in \text{} environments.
     */

    /**
     * Each script or script family has a name and an array of blocks.
     * Each block is an array of two numbers which specify the start and
     * end points (inclusive) of a block of Unicode codepoints.
     */

    /**
     * Unicode block data for the families of scripts we support in \text{}.
     * Scripts only need to appear here if they do not have font metrics.
     */
    const scriptData = [{
      // Latin characters beyond the Latin-1 characters we have metrics for.
      // Needed for Czech, Hungarian and Turkish text, for example.
      name: 'latin',
      blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B
      [0x0300, 0x036f]]
    }, {
      // The Cyrillic script used by Russian and related languages.
      // A Cyrillic subset used to be supported as explicitly defined
      // symbols in symbols.js
      name: 'cyrillic',
      blocks: [[0x0400, 0x04ff]]
    }, {
      // The Brahmic scripts of South and Southeast Asia
      // Devanagari (0900–097F)
      // Bengali (0980–09FF)
      // Gurmukhi (0A00–0A7F)
      // Gujarati (0A80–0AFF)
      // Oriya (0B00–0B7F)
      // Tamil (0B80–0BFF)
      // Telugu (0C00–0C7F)
      // Kannada (0C80–0CFF)
      // Malayalam (0D00–0D7F)
      // Sinhala (0D80–0DFF)
      // Thai (0E00–0E7F)
      // Lao (0E80–0EFF)
      // Tibetan (0F00–0FFF)
      // Myanmar (1000–109F)
      name: 'brahmic',
      blocks: [[0x0900, 0x109F]]
    }, {
      name: 'georgian',
      blocks: [[0x10A0, 0x10ff]]
    }, {
      // Chinese and Japanese.
      // The "k" in cjk is for Korean, but we've separated Korean out
      name: "cjk",
      blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana
      [0x4E00, 0x9FAF], // CJK ideograms
      [0xFF00, 0xFF60]]
    }, {
      // Korean
      name: 'hangul',
      blocks: [[0xAC00, 0xD7AF]]
    }];
    /**
     * Given a codepoint, return the name of the script or script family
     * it is from, or null if it is not part of a known block
     */

    function scriptFromCodepoint(codepoint) {
      for (let i = 0; i < scriptData.length; i++) {
        const script = scriptData[i];

        for (let i = 0; i < script.blocks.length; i++) {
          const block = script.blocks[i];

          if (codepoint >= block[0] && codepoint <= block[1]) {
            return script.name;
          }
        }
      }

      return null;
    }
    /**
     * A flattened version of all the supported blocks in a single array.
     * This is an optimization to make supportedCodepoint() fast.
     */

    const allBlocks = [];
    scriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));
    /**
     * Given a codepoint, return true if it falls within one of the
     * scripts or script families defined above and false otherwise.
     *
     * Micro benchmarks shows that this is faster than
     * /[\u3000-\u30FF\u4E00-\u9FAF\uFF00-\uFF60\uAC00-\uD7AF\u0900-\u109F]/.test()
     * in Firefox, Chrome and Node.
     */

    function supportedCodepoint(codepoint) {
      for (let i = 0; i < allBlocks.length; i += 2) {
        if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
          return true;
        }
      }

      return false;
    }

    /**
     * This file provides support to domTree.js
     * It's a storehouse of path geometry for SVG images.
     */
    // In all paths below, the viewBox-to-em scale is 1000:1.
    const hLinePad = 80; // padding above a sqrt viniculum.

    const path = {
      // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
      // All surds have 80 units padding above the viniculumn.
      sqrtMain: `M95,${622 + hLinePad}c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 ${hLinePad}H400000v40H845z`,
      // size1 is from glyph U221A in the font KaTeX_Size1-Regular
      sqrtSize1: `M263,${601 + hLinePad}c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 ${hLinePad}H40000v40H1012z`,
      // size2 is from glyph U221A in the font KaTeX_Size2-Regular
      // The 80 units padding is most obvious here. Note start node at M1001 80.
      sqrtSize2: `M1001,${hLinePad}H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 ${hLinePad}H400000v40H1013z`,
      // size3 is from glyph U221A in the font KaTeX_Size3-Regular
      sqrtSize3: `M424,${2398 + hLinePad}c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,
-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,
25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,
-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079
c169.3,-717.3,254.7,-1077.7,256,-1081c4,-6.7,10,-10,18,-10H400000v40H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M1001 ${hLinePad}H400000v40H1014z`,
      // size4 is from glyph U221A in the font KaTeX_Size4-Regular
      sqrtSize4: `M473,${2713 + hLinePad}c339.3,-1799.3,509.3,-2700,510,-2702
c3.3,-7.3,9.3,-11,18,-11H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,
-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,
-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,
21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,
77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606z
M1001 ${hLinePad}H400000v40H1017z`,
      // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
      doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
      // doublerightarrow is from glyph U+21D2 in font KaTeX Main
      doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
      // leftarrow is from glyph U+2190 in font KaTeX Main
      leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
      // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
      leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
      leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
      // overgroup is from the MnSymbol package (public domain)
      leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
      leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
      // Harpoons are from glyph U+21BD in font KaTeX Main
      leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
      leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
      leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
      leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
      // hook is from glyph U+21A9 in font KaTeX Main
      lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
      leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
      leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
      // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
      leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
      longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
      midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
      midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
      oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
      oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
      oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
      oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
      rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
      rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
      rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
      rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
      rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
      rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
      rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
      rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
      rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
      righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
      rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
      rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
      // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
      twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
      twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
      // tilde1 is a modified version of a glyph from the MnSymbol package
      tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
      // ditto tilde2, tilde3, & tilde4
      tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
      tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
      tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
      // vec is from glyph U+20D7 in font KaTeX Main
      vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
      // widehat1 is a modified version of a glyph from the MnSymbol package
      widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
      // ditto widehat2, widehat3, & widehat4
      widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      // widecheck paths are all inverted versions of widehat
      widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
      widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      // The next ten paths support reaction arrows from the mhchem package.
      // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
      // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
      baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
      // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
      rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
      // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
      // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
      baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
      rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
      shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
      shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
    };
    var svgGeometry = {
      path
    };

    /**
     * This node represents a document fragment, which contains elements, but when
     * placed into the DOM doesn't have any representation itself. It only contains
     * children and doesn't have any DOM node properties.
     */
    class DocumentFragment {
      // HtmlDomNode
      // Never used; needed for satisfying interface.
      constructor(children) {
        this.children = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        this.children = children;
        this.classes = [];
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = {};
      }

      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      /** Convert the fragment into a node. */


      toNode() {
        const frag = document.createDocumentFragment();

        for (let i = 0; i < this.children.length; i++) {
          frag.appendChild(this.children[i].toNode());
        }

        return frag;
      }
      /** Convert the fragment into HTML markup. */


      toMarkup() {
        let markup = ""; // Simply concatenate the markup for the children together.

        for (let i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        return markup;
      }
      /**
       * Converts the math node into a string, similar to innerText. Applies to
       * MathDomNode's only.
       */


      toText() {
        // To avoid this, we would subclass documentFragment separately for
        // MathML, but polyfills for subclassing is expensive per PR 1469.
        // $FlowFixMe: Only works for ChildType = MathDomNode.
        const toText = child => child.toText();

        return this.children.map(toText).join("");
      }

    }

    /**
     * These objects store the data about the DOM nodes we create, as well as some
     * extra data. They can then be transformed into real DOM nodes with the
     * `toNode` function or HTML markup using `toMarkup`. They are useful for both
     * storing extra properties on the nodes, as well as providing a way to easily
     * work with the DOM.
     *
     * Similar functions for working with MathML nodes exist in mathMLTree.js.
     *
     * TODO: refactor `span` and `anchor` into common superclass when
     * target environments support class inheritance
     */

    /**
     * Create an HTML className based on a list of classes. In addition to joining
     * with spaces, we also remove empty classes.
     */
    const createClass = function createClass(classes) {
      return classes.filter(cls => cls).join(" ");
    };

    const initNode = function initNode(classes, options, style) {
      this.classes = classes || [];
      this.attributes = {};
      this.height = 0;
      this.depth = 0;
      this.maxFontSize = 0;
      this.style = style || {};

      if (options) {
        if (options.style.isTight()) {
          this.classes.push("mtight");
        }

        const color = options.getColor();

        if (color) {
          this.style.color = color;
        }
      }
    };
    /**
     * Convert into an HTML node
     */


    const toNode = function toNode(tagName) {
      const node = document.createElement(tagName); // Apply the class

      node.className = createClass(this.classes); // Apply inline styles

      for (const style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          // $FlowFixMe Flow doesn't seem to understand span.style's type.
          node.style[style] = this.style[style];
        }
      } // Apply attributes


      for (const attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          node.setAttribute(attr, this.attributes[attr]);
        }
      } // Append the children, also as HTML nodes


      for (let i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
      }

      return node;
    };
    /**
     * Convert into an HTML markup string
     */


    const toMarkup = function toMarkup(tagName) {
      let markup = `<${tagName}`; // Add the class

      if (this.classes.length) {
        markup += ` class="${utils.escape(createClass(this.classes))}"`;
      }

      let styles = ""; // Add the styles, after hyphenation

      for (const style in this.style) {
        if (this.style.hasOwnProperty(style)) {
          styles += `${utils.hyphenate(style)}:${this.style[style]};`;
        }
      }

      if (styles) {
        markup += ` style="${utils.escape(styles)}"`;
      } // Add the attributes


      for (const attr in this.attributes) {
        if (this.attributes.hasOwnProperty(attr)) {
          markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
        }
      }

      markup += ">"; // Add the markup of the children, also as markup

      for (let i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
      }

      markup += `</${tagName}>`;
      return markup;
    }; // Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.
    // This type does not include all CSS properties. Additional properties should
    // be added as needed.


    /**
     * This node represents a span node, with a className, a list of children, and
     * an inline style. It also contains information about its height, depth, and
     * maxFontSize.
     *
     * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan
     * otherwise. This typesafety is important when HTML builders access a span's
     * children.
     */
    class Span {
      constructor(classes, children, options, style) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options, style);
        this.children = children || [];
      }
      /**
       * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
       * all browsers support attributes the same, and having too many custom
       * attributes is probably bad.
       */


      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }

      hasClass(className) {
        return utils.contains(this.classes, className);
      }

      toNode() {
        return toNode.call(this, "span");
      }

      toMarkup() {
        return toMarkup.call(this, "span");
      }

    }
    /**
     * This node represents an anchor (<a>) element with a hyperlink.  See `span`
     * for further details.
     */

    class Anchor {
      constructor(href, classes, children, options) {
        this.children = void 0;
        this.attributes = void 0;
        this.classes = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.maxFontSize = void 0;
        this.style = void 0;
        initNode.call(this, classes, options);
        this.children = children || [];
        this.setAttribute('href', href);
      }

      setAttribute(attribute, value) {
        this.attributes[attribute] = value;
      }

      hasClass(className) {
        return utils.contains(this.classes, className);
      }

      toNode() {
        return toNode.call(this, "a");
      }

      toMarkup() {
        return toMarkup.call(this, "a");
      }

    }
    const iCombinations = {
      'î': '\u0131\u0302',
      'ï': '\u0131\u0308',
      'í': '\u0131\u0301',
      // 'ī': '\u0131\u0304', // enable when we add Extended Latin
      'ì': '\u0131\u0300'
    };
    /**
     * A symbol node contains information about a single symbol. It either renders
     * to a single text node, or a span with a single text node in it, depending on
     * whether it has CSS classes, styles, or needs italic correction.
     */

    class SymbolNode {
      constructor(text, height, depth, italic, skew, width, classes, style) {
        this.text = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.italic = void 0;
        this.skew = void 0;
        this.width = void 0;
        this.maxFontSize = void 0;
        this.classes = void 0;
        this.style = void 0;
        this.text = text;
        this.height = height || 0;
        this.depth = depth || 0;
        this.italic = italic || 0;
        this.skew = skew || 0;
        this.width = width || 0;
        this.classes = classes || [];
        this.style = style || {};
        this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we
        // can specify which fonts to use.  This allows us to render these
        // characters with a serif font in situations where the browser would
        // either default to a sans serif or render a placeholder character.
        // We use CSS class names like cjk_fallback, hangul_fallback and
        // brahmic_fallback. See ./unicodeScripts.js for the set of possible
        // script names

        const script = scriptFromCodepoint(this.text.charCodeAt(0));

        if (script) {
          this.classes.push(script + "_fallback");
        }

        if (/[îïíì]/.test(this.text)) {
          // add ī when we add Extended Latin
          this.text = iCombinations[this.text];
        }
      }

      hasClass(className) {
        return utils.contains(this.classes, className);
      }
      /**
       * Creates a text node or span from a symbol node. Note that a span is only
       * created if it is needed.
       */


      toNode() {
        const node = document.createTextNode(this.text);
        let span = null;

        if (this.italic > 0) {
          span = document.createElement("span");
          span.style.marginRight = this.italic + "em";
        }

        if (this.classes.length > 0) {
          span = span || document.createElement("span");
          span.className = createClass(this.classes);
        }

        for (const style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span"); // $FlowFixMe Flow doesn't seem to understand span.style's type.

            span.style[style] = this.style[style];
          }
        }

        if (span) {
          span.appendChild(node);
          return span;
        } else {
          return node;
        }
      }
      /**
       * Creates markup for a symbol node.
       */


      toMarkup() {
        // TODO(alpert): More duplication than I'd like from
        // span.prototype.toMarkup and symbolNode.prototype.toNode...
        let needsSpan = false;
        let markup = "<span";

        if (this.classes.length) {
          needsSpan = true;
          markup += " class=\"";
          markup += utils.escape(createClass(this.classes));
          markup += "\"";
        }

        let styles = "";

        if (this.italic > 0) {
          styles += "margin-right:" + this.italic + "em;";
        }

        for (const style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }

        if (styles) {
          needsSpan = true;
          markup += " style=\"" + utils.escape(styles) + "\"";
        }

        const escaped = utils.escape(this.text);

        if (needsSpan) {
          markup += ">";
          markup += escaped;
          markup += "</span>";
          return markup;
        } else {
          return escaped;
        }
      }

    }
    /**
     * SVG nodes are used to render stretchy wide elements.
     */

    class SvgNode {
      constructor(children, attributes) {
        this.children = void 0;
        this.attributes = void 0;
        this.children = children || [];
        this.attributes = attributes || {};
      }

      toNode() {
        const svgNS = "http://www.w3.org/2000/svg";
        const node = document.createElementNS(svgNS, "svg"); // Apply attributes

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        for (let i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }

        return node;
      }

      toMarkup() {
        let markup = "<svg"; // Apply attributes

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += ` ${attr}='${this.attributes[attr]}'`;
          }
        }

        markup += ">";

        for (let i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        markup += "</svg>";
        return markup;
      }

    }
    class PathNode {
      constructor(pathName, alternate) {
        this.pathName = void 0;
        this.alternate = void 0;
        this.pathName = pathName;
        this.alternate = alternate; // Used only for tall \sqrt
      }

      toNode() {
        const svgNS = "http://www.w3.org/2000/svg";
        const node = document.createElementNS(svgNS, "path");

        if (this.alternate) {
          node.setAttribute("d", this.alternate);
        } else {
          node.setAttribute("d", svgGeometry.path[this.pathName]);
        }

        return node;
      }

      toMarkup() {
        if (this.alternate) {
          return `<path d='${this.alternate}'/>`;
        } else {
          return `<path d='${svgGeometry.path[this.pathName]}'/>`;
        }
      }

    }
    class LineNode {
      constructor(attributes) {
        this.attributes = void 0;
        this.attributes = attributes || {};
      }

      toNode() {
        const svgNS = "http://www.w3.org/2000/svg";
        const node = document.createElementNS(svgNS, "line"); // Apply attributes

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        return node;
      }

      toMarkup() {
        let markup = "<line";

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += ` ${attr}='${this.attributes[attr]}'`;
          }
        }

        markup += "/>";
        return markup;
      }

    }
    function assertSymbolDomNode(group) {
      if (group instanceof SymbolNode) {
        return group;
      } else {
        throw new Error(`Expected symbolNode but got ${String(group)}.`);
      }
    }
    function assertSpan(group) {
      if (group instanceof Span) {
        return group;
      } else {
        throw new Error(`Expected span<HtmlDomNode> but got ${String(group)}.`);
      }
    }

    // This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.
    var metricMap = {
      "AMS-Regular": {
        "65": [0, 0.68889, 0, 0, 0.72222],
        "66": [0, 0.68889, 0, 0, 0.66667],
        "67": [0, 0.68889, 0, 0, 0.72222],
        "68": [0, 0.68889, 0, 0, 0.72222],
        "69": [0, 0.68889, 0, 0, 0.66667],
        "70": [0, 0.68889, 0, 0, 0.61111],
        "71": [0, 0.68889, 0, 0, 0.77778],
        "72": [0, 0.68889, 0, 0, 0.77778],
        "73": [0, 0.68889, 0, 0, 0.38889],
        "74": [0.16667, 0.68889, 0, 0, 0.5],
        "75": [0, 0.68889, 0, 0, 0.77778],
        "76": [0, 0.68889, 0, 0, 0.66667],
        "77": [0, 0.68889, 0, 0, 0.94445],
        "78": [0, 0.68889, 0, 0, 0.72222],
        "79": [0.16667, 0.68889, 0, 0, 0.77778],
        "80": [0, 0.68889, 0, 0, 0.61111],
        "81": [0.16667, 0.68889, 0, 0, 0.77778],
        "82": [0, 0.68889, 0, 0, 0.72222],
        "83": [0, 0.68889, 0, 0, 0.55556],
        "84": [0, 0.68889, 0, 0, 0.66667],
        "85": [0, 0.68889, 0, 0, 0.72222],
        "86": [0, 0.68889, 0, 0, 0.72222],
        "87": [0, 0.68889, 0, 0, 1.0],
        "88": [0, 0.68889, 0, 0, 0.72222],
        "89": [0, 0.68889, 0, 0, 0.72222],
        "90": [0, 0.68889, 0, 0, 0.66667],
        "107": [0, 0.68889, 0, 0, 0.55556],
        "165": [0, 0.675, 0.025, 0, 0.75],
        "174": [0.15559, 0.69224, 0, 0, 0.94666],
        "240": [0, 0.68889, 0, 0, 0.55556],
        "295": [0, 0.68889, 0, 0, 0.54028],
        "710": [0, 0.825, 0, 0, 2.33334],
        "732": [0, 0.9, 0, 0, 2.33334],
        "770": [0, 0.825, 0, 0, 2.33334],
        "771": [0, 0.9, 0, 0, 2.33334],
        "989": [0.08167, 0.58167, 0, 0, 0.77778],
        "1008": [0, 0.43056, 0.04028, 0, 0.66667],
        "8245": [0, 0.54986, 0, 0, 0.275],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8487": [0, 0.68889, 0, 0, 0.72222],
        "8498": [0, 0.68889, 0, 0, 0.55556],
        "8502": [0, 0.68889, 0, 0, 0.66667],
        "8503": [0, 0.68889, 0, 0, 0.44445],
        "8504": [0, 0.68889, 0, 0, 0.66667],
        "8513": [0, 0.68889, 0, 0, 0.63889],
        "8592": [-0.03598, 0.46402, 0, 0, 0.5],
        "8594": [-0.03598, 0.46402, 0, 0, 0.5],
        "8602": [-0.13313, 0.36687, 0, 0, 1.0],
        "8603": [-0.13313, 0.36687, 0, 0, 1.0],
        "8606": [0.01354, 0.52239, 0, 0, 1.0],
        "8608": [0.01354, 0.52239, 0, 0, 1.0],
        "8610": [0.01354, 0.52239, 0, 0, 1.11111],
        "8611": [0.01354, 0.52239, 0, 0, 1.11111],
        "8619": [0, 0.54986, 0, 0, 1.0],
        "8620": [0, 0.54986, 0, 0, 1.0],
        "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
        "8622": [-0.13313, 0.36687, 0, 0, 1.0],
        "8624": [0, 0.69224, 0, 0, 0.5],
        "8625": [0, 0.69224, 0, 0, 0.5],
        "8630": [0, 0.43056, 0, 0, 1.0],
        "8631": [0, 0.43056, 0, 0, 1.0],
        "8634": [0.08198, 0.58198, 0, 0, 0.77778],
        "8635": [0.08198, 0.58198, 0, 0, 0.77778],
        "8638": [0.19444, 0.69224, 0, 0, 0.41667],
        "8639": [0.19444, 0.69224, 0, 0, 0.41667],
        "8642": [0.19444, 0.69224, 0, 0, 0.41667],
        "8643": [0.19444, 0.69224, 0, 0, 0.41667],
        "8644": [0.1808, 0.675, 0, 0, 1.0],
        "8646": [0.1808, 0.675, 0, 0, 1.0],
        "8647": [0.1808, 0.675, 0, 0, 1.0],
        "8648": [0.19444, 0.69224, 0, 0, 0.83334],
        "8649": [0.1808, 0.675, 0, 0, 1.0],
        "8650": [0.19444, 0.69224, 0, 0, 0.83334],
        "8651": [0.01354, 0.52239, 0, 0, 1.0],
        "8652": [0.01354, 0.52239, 0, 0, 1.0],
        "8653": [-0.13313, 0.36687, 0, 0, 1.0],
        "8654": [-0.13313, 0.36687, 0, 0, 1.0],
        "8655": [-0.13313, 0.36687, 0, 0, 1.0],
        "8666": [0.13667, 0.63667, 0, 0, 1.0],
        "8667": [0.13667, 0.63667, 0, 0, 1.0],
        "8669": [-0.13313, 0.37788, 0, 0, 1.0],
        "8672": [-0.064, 0.437, 0, 0, 1.334],
        "8674": [-0.064, 0.437, 0, 0, 1.334],
        "8705": [0, 0.825, 0, 0, 0.5],
        "8708": [0, 0.68889, 0, 0, 0.55556],
        "8709": [0.08167, 0.58167, 0, 0, 0.77778],
        "8717": [0, 0.43056, 0, 0, 0.42917],
        "8722": [-0.03598, 0.46402, 0, 0, 0.5],
        "8724": [0.08198, 0.69224, 0, 0, 0.77778],
        "8726": [0.08167, 0.58167, 0, 0, 0.77778],
        "8733": [0, 0.69224, 0, 0, 0.77778],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8737": [0, 0.69224, 0, 0, 0.72222],
        "8738": [0.03517, 0.52239, 0, 0, 0.72222],
        "8739": [0.08167, 0.58167, 0, 0, 0.22222],
        "8740": [0.25142, 0.74111, 0, 0, 0.27778],
        "8741": [0.08167, 0.58167, 0, 0, 0.38889],
        "8742": [0.25142, 0.74111, 0, 0, 0.5],
        "8756": [0, 0.69224, 0, 0, 0.66667],
        "8757": [0, 0.69224, 0, 0, 0.66667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
        "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8774": [0.30274, 0.79383, 0, 0, 0.77778],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8778": [0.08167, 0.58167, 0, 0, 0.77778],
        "8782": [0.06062, 0.54986, 0, 0, 0.77778],
        "8783": [0.06062, 0.54986, 0, 0, 0.77778],
        "8785": [0.08198, 0.58198, 0, 0, 0.77778],
        "8786": [0.08198, 0.58198, 0, 0, 0.77778],
        "8787": [0.08198, 0.58198, 0, 0, 0.77778],
        "8790": [0, 0.69224, 0, 0, 0.77778],
        "8791": [0.22958, 0.72958, 0, 0, 0.77778],
        "8796": [0.08198, 0.91667, 0, 0, 0.77778],
        "8806": [0.25583, 0.75583, 0, 0, 0.77778],
        "8807": [0.25583, 0.75583, 0, 0, 0.77778],
        "8808": [0.25142, 0.75726, 0, 0, 0.77778],
        "8809": [0.25142, 0.75726, 0, 0, 0.77778],
        "8812": [0.25583, 0.75583, 0, 0, 0.5],
        "8814": [0.20576, 0.70576, 0, 0, 0.77778],
        "8815": [0.20576, 0.70576, 0, 0, 0.77778],
        "8816": [0.30274, 0.79383, 0, 0, 0.77778],
        "8817": [0.30274, 0.79383, 0, 0, 0.77778],
        "8818": [0.22958, 0.72958, 0, 0, 0.77778],
        "8819": [0.22958, 0.72958, 0, 0, 0.77778],
        "8822": [0.1808, 0.675, 0, 0, 0.77778],
        "8823": [0.1808, 0.675, 0, 0, 0.77778],
        "8828": [0.13667, 0.63667, 0, 0, 0.77778],
        "8829": [0.13667, 0.63667, 0, 0, 0.77778],
        "8830": [0.22958, 0.72958, 0, 0, 0.77778],
        "8831": [0.22958, 0.72958, 0, 0, 0.77778],
        "8832": [0.20576, 0.70576, 0, 0, 0.77778],
        "8833": [0.20576, 0.70576, 0, 0, 0.77778],
        "8840": [0.30274, 0.79383, 0, 0, 0.77778],
        "8841": [0.30274, 0.79383, 0, 0, 0.77778],
        "8842": [0.13597, 0.63597, 0, 0, 0.77778],
        "8843": [0.13597, 0.63597, 0, 0, 0.77778],
        "8847": [0.03517, 0.54986, 0, 0, 0.77778],
        "8848": [0.03517, 0.54986, 0, 0, 0.77778],
        "8858": [0.08198, 0.58198, 0, 0, 0.77778],
        "8859": [0.08198, 0.58198, 0, 0, 0.77778],
        "8861": [0.08198, 0.58198, 0, 0, 0.77778],
        "8862": [0, 0.675, 0, 0, 0.77778],
        "8863": [0, 0.675, 0, 0, 0.77778],
        "8864": [0, 0.675, 0, 0, 0.77778],
        "8865": [0, 0.675, 0, 0, 0.77778],
        "8872": [0, 0.69224, 0, 0, 0.61111],
        "8873": [0, 0.69224, 0, 0, 0.72222],
        "8874": [0, 0.69224, 0, 0, 0.88889],
        "8876": [0, 0.68889, 0, 0, 0.61111],
        "8877": [0, 0.68889, 0, 0, 0.61111],
        "8878": [0, 0.68889, 0, 0, 0.72222],
        "8879": [0, 0.68889, 0, 0, 0.72222],
        "8882": [0.03517, 0.54986, 0, 0, 0.77778],
        "8883": [0.03517, 0.54986, 0, 0, 0.77778],
        "8884": [0.13667, 0.63667, 0, 0, 0.77778],
        "8885": [0.13667, 0.63667, 0, 0, 0.77778],
        "8888": [0, 0.54986, 0, 0, 1.11111],
        "8890": [0.19444, 0.43056, 0, 0, 0.55556],
        "8891": [0.19444, 0.69224, 0, 0, 0.61111],
        "8892": [0.19444, 0.69224, 0, 0, 0.61111],
        "8901": [0, 0.54986, 0, 0, 0.27778],
        "8903": [0.08167, 0.58167, 0, 0, 0.77778],
        "8905": [0.08167, 0.58167, 0, 0, 0.77778],
        "8906": [0.08167, 0.58167, 0, 0, 0.77778],
        "8907": [0, 0.69224, 0, 0, 0.77778],
        "8908": [0, 0.69224, 0, 0, 0.77778],
        "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
        "8910": [0, 0.54986, 0, 0, 0.76042],
        "8911": [0, 0.54986, 0, 0, 0.76042],
        "8912": [0.03517, 0.54986, 0, 0, 0.77778],
        "8913": [0.03517, 0.54986, 0, 0, 0.77778],
        "8914": [0, 0.54986, 0, 0, 0.66667],
        "8915": [0, 0.54986, 0, 0, 0.66667],
        "8916": [0, 0.69224, 0, 0, 0.66667],
        "8918": [0.0391, 0.5391, 0, 0, 0.77778],
        "8919": [0.0391, 0.5391, 0, 0, 0.77778],
        "8920": [0.03517, 0.54986, 0, 0, 1.33334],
        "8921": [0.03517, 0.54986, 0, 0, 1.33334],
        "8922": [0.38569, 0.88569, 0, 0, 0.77778],
        "8923": [0.38569, 0.88569, 0, 0, 0.77778],
        "8926": [0.13667, 0.63667, 0, 0, 0.77778],
        "8927": [0.13667, 0.63667, 0, 0, 0.77778],
        "8928": [0.30274, 0.79383, 0, 0, 0.77778],
        "8929": [0.30274, 0.79383, 0, 0, 0.77778],
        "8934": [0.23222, 0.74111, 0, 0, 0.77778],
        "8935": [0.23222, 0.74111, 0, 0, 0.77778],
        "8936": [0.23222, 0.74111, 0, 0, 0.77778],
        "8937": [0.23222, 0.74111, 0, 0, 0.77778],
        "8938": [0.20576, 0.70576, 0, 0, 0.77778],
        "8939": [0.20576, 0.70576, 0, 0, 0.77778],
        "8940": [0.30274, 0.79383, 0, 0, 0.77778],
        "8941": [0.30274, 0.79383, 0, 0, 0.77778],
        "8994": [0.19444, 0.69224, 0, 0, 0.77778],
        "8995": [0.19444, 0.69224, 0, 0, 0.77778],
        "9416": [0.15559, 0.69224, 0, 0, 0.90222],
        "9484": [0, 0.69224, 0, 0, 0.5],
        "9488": [0, 0.69224, 0, 0, 0.5],
        "9492": [0, 0.37788, 0, 0, 0.5],
        "9496": [0, 0.37788, 0, 0, 0.5],
        "9585": [0.19444, 0.68889, 0, 0, 0.88889],
        "9586": [0.19444, 0.74111, 0, 0, 0.88889],
        "9632": [0, 0.675, 0, 0, 0.77778],
        "9633": [0, 0.675, 0, 0, 0.77778],
        "9650": [0, 0.54986, 0, 0, 0.72222],
        "9651": [0, 0.54986, 0, 0, 0.72222],
        "9654": [0.03517, 0.54986, 0, 0, 0.77778],
        "9660": [0, 0.54986, 0, 0, 0.72222],
        "9661": [0, 0.54986, 0, 0, 0.72222],
        "9664": [0.03517, 0.54986, 0, 0, 0.77778],
        "9674": [0.11111, 0.69224, 0, 0, 0.66667],
        "9733": [0.19444, 0.69224, 0, 0, 0.94445],
        "10003": [0, 0.69224, 0, 0, 0.83334],
        "10016": [0, 0.69224, 0, 0, 0.83334],
        "10731": [0.11111, 0.69224, 0, 0, 0.66667],
        "10846": [0.19444, 0.75583, 0, 0, 0.61111],
        "10877": [0.13667, 0.63667, 0, 0, 0.77778],
        "10878": [0.13667, 0.63667, 0, 0, 0.77778],
        "10885": [0.25583, 0.75583, 0, 0, 0.77778],
        "10886": [0.25583, 0.75583, 0, 0, 0.77778],
        "10887": [0.13597, 0.63597, 0, 0, 0.77778],
        "10888": [0.13597, 0.63597, 0, 0, 0.77778],
        "10889": [0.26167, 0.75726, 0, 0, 0.77778],
        "10890": [0.26167, 0.75726, 0, 0, 0.77778],
        "10891": [0.48256, 0.98256, 0, 0, 0.77778],
        "10892": [0.48256, 0.98256, 0, 0, 0.77778],
        "10901": [0.13667, 0.63667, 0, 0, 0.77778],
        "10902": [0.13667, 0.63667, 0, 0, 0.77778],
        "10933": [0.25142, 0.75726, 0, 0, 0.77778],
        "10934": [0.25142, 0.75726, 0, 0, 0.77778],
        "10935": [0.26167, 0.75726, 0, 0, 0.77778],
        "10936": [0.26167, 0.75726, 0, 0, 0.77778],
        "10937": [0.26167, 0.75726, 0, 0, 0.77778],
        "10938": [0.26167, 0.75726, 0, 0, 0.77778],
        "10949": [0.25583, 0.75583, 0, 0, 0.77778],
        "10950": [0.25583, 0.75583, 0, 0, 0.77778],
        "10955": [0.28481, 0.79383, 0, 0, 0.77778],
        "10956": [0.28481, 0.79383, 0, 0, 0.77778],
        "57350": [0.08167, 0.58167, 0, 0, 0.22222],
        "57351": [0.08167, 0.58167, 0, 0, 0.38889],
        "57352": [0.08167, 0.58167, 0, 0, 0.77778],
        "57353": [0, 0.43056, 0.04028, 0, 0.66667],
        "57356": [0.25142, 0.75726, 0, 0, 0.77778],
        "57357": [0.25142, 0.75726, 0, 0, 0.77778],
        "57358": [0.41951, 0.91951, 0, 0, 0.77778],
        "57359": [0.30274, 0.79383, 0, 0, 0.77778],
        "57360": [0.30274, 0.79383, 0, 0, 0.77778],
        "57361": [0.41951, 0.91951, 0, 0, 0.77778],
        "57366": [0.25142, 0.75726, 0, 0, 0.77778],
        "57367": [0.25142, 0.75726, 0, 0, 0.77778],
        "57368": [0.25142, 0.75726, 0, 0, 0.77778],
        "57369": [0.25142, 0.75726, 0, 0, 0.77778],
        "57370": [0.13597, 0.63597, 0, 0, 0.77778],
        "57371": [0.13597, 0.63597, 0, 0, 0.77778]
      },
      "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0, 0.5],
        "49": [0, 0.43056, 0, 0, 0.5],
        "50": [0, 0.43056, 0, 0, 0.5],
        "51": [0.19444, 0.43056, 0, 0, 0.5],
        "52": [0.19444, 0.43056, 0, 0, 0.5],
        "53": [0.19444, 0.43056, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0.19444, 0.43056, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0.19444, 0.43056, 0, 0, 0.5],
        "65": [0, 0.68333, 0, 0.19445, 0.79847],
        "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
        "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
        "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
        "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
        "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
        "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
        "72": [0, 0.68333, 0.00965, 0.11111, 0.84452],
        "73": [0, 0.68333, 0.07382, 0, 0.54452],
        "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
        "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
        "76": [0, 0.68333, 0, 0.13889, 0.68972],
        "77": [0, 0.68333, 0, 0.13889, 1.2009],
        "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
        "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
        "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
        "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
        "82": [0, 0.68333, 0, 0.08334, 0.8475],
        "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
        "84": [0, 0.68333, 0.25417, 0, 0.54464],
        "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
        "86": [0, 0.68333, 0.08222, 0, 0.61278],
        "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
        "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
        "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
        "90": [0, 0.68333, 0.07944, 0.13889, 0.72473]
      },
      "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0, 0.29574],
        "34": [0, 0.69141, 0, 0, 0.21471],
        "38": [0, 0.69141, 0, 0, 0.73786],
        "39": [0, 0.69141, 0, 0, 0.21201],
        "40": [0.24982, 0.74947, 0, 0, 0.38865],
        "41": [0.24982, 0.74947, 0, 0, 0.38865],
        "42": [0, 0.62119, 0, 0, 0.27764],
        "43": [0.08319, 0.58283, 0, 0, 0.75623],
        "44": [0, 0.10803, 0, 0, 0.27764],
        "45": [0.08319, 0.58283, 0, 0, 0.75623],
        "46": [0, 0.10803, 0, 0, 0.27764],
        "47": [0.24982, 0.74947, 0, 0, 0.50181],
        "48": [0, 0.47534, 0, 0, 0.50181],
        "49": [0, 0.47534, 0, 0, 0.50181],
        "50": [0, 0.47534, 0, 0, 0.50181],
        "51": [0.18906, 0.47534, 0, 0, 0.50181],
        "52": [0.18906, 0.47534, 0, 0, 0.50181],
        "53": [0.18906, 0.47534, 0, 0, 0.50181],
        "54": [0, 0.69141, 0, 0, 0.50181],
        "55": [0.18906, 0.47534, 0, 0, 0.50181],
        "56": [0, 0.69141, 0, 0, 0.50181],
        "57": [0.18906, 0.47534, 0, 0, 0.50181],
        "58": [0, 0.47534, 0, 0, 0.21606],
        "59": [0.12604, 0.47534, 0, 0, 0.21606],
        "61": [-0.13099, 0.36866, 0, 0, 0.75623],
        "63": [0, 0.69141, 0, 0, 0.36245],
        "65": [0, 0.69141, 0, 0, 0.7176],
        "66": [0, 0.69141, 0, 0, 0.88397],
        "67": [0, 0.69141, 0, 0, 0.61254],
        "68": [0, 0.69141, 0, 0, 0.83158],
        "69": [0, 0.69141, 0, 0, 0.66278],
        "70": [0.12604, 0.69141, 0, 0, 0.61119],
        "71": [0, 0.69141, 0, 0, 0.78539],
        "72": [0.06302, 0.69141, 0, 0, 0.7203],
        "73": [0, 0.69141, 0, 0, 0.55448],
        "74": [0.12604, 0.69141, 0, 0, 0.55231],
        "75": [0, 0.69141, 0, 0, 0.66845],
        "76": [0, 0.69141, 0, 0, 0.66602],
        "77": [0, 0.69141, 0, 0, 1.04953],
        "78": [0, 0.69141, 0, 0, 0.83212],
        "79": [0, 0.69141, 0, 0, 0.82699],
        "80": [0.18906, 0.69141, 0, 0, 0.82753],
        "81": [0.03781, 0.69141, 0, 0, 0.82699],
        "82": [0, 0.69141, 0, 0, 0.82807],
        "83": [0, 0.69141, 0, 0, 0.82861],
        "84": [0, 0.69141, 0, 0, 0.66899],
        "85": [0, 0.69141, 0, 0, 0.64576],
        "86": [0, 0.69141, 0, 0, 0.83131],
        "87": [0, 0.69141, 0, 0, 1.04602],
        "88": [0, 0.69141, 0, 0, 0.71922],
        "89": [0.18906, 0.69141, 0, 0, 0.83293],
        "90": [0.12604, 0.69141, 0, 0, 0.60201],
        "91": [0.24982, 0.74947, 0, 0, 0.27764],
        "93": [0.24982, 0.74947, 0, 0, 0.27764],
        "94": [0, 0.69141, 0, 0, 0.49965],
        "97": [0, 0.47534, 0, 0, 0.50046],
        "98": [0, 0.69141, 0, 0, 0.51315],
        "99": [0, 0.47534, 0, 0, 0.38946],
        "100": [0, 0.62119, 0, 0, 0.49857],
        "101": [0, 0.47534, 0, 0, 0.40053],
        "102": [0.18906, 0.69141, 0, 0, 0.32626],
        "103": [0.18906, 0.47534, 0, 0, 0.5037],
        "104": [0.18906, 0.69141, 0, 0, 0.52126],
        "105": [0, 0.69141, 0, 0, 0.27899],
        "106": [0, 0.69141, 0, 0, 0.28088],
        "107": [0, 0.69141, 0, 0, 0.38946],
        "108": [0, 0.69141, 0, 0, 0.27953],
        "109": [0, 0.47534, 0, 0, 0.76676],
        "110": [0, 0.47534, 0, 0, 0.52666],
        "111": [0, 0.47534, 0, 0, 0.48885],
        "112": [0.18906, 0.52396, 0, 0, 0.50046],
        "113": [0.18906, 0.47534, 0, 0, 0.48912],
        "114": [0, 0.47534, 0, 0, 0.38919],
        "115": [0, 0.47534, 0, 0, 0.44266],
        "116": [0, 0.62119, 0, 0, 0.33301],
        "117": [0, 0.47534, 0, 0, 0.5172],
        "118": [0, 0.52396, 0, 0, 0.5118],
        "119": [0, 0.52396, 0, 0, 0.77351],
        "120": [0.18906, 0.47534, 0, 0, 0.38865],
        "121": [0.18906, 0.47534, 0, 0, 0.49884],
        "122": [0.18906, 0.47534, 0, 0, 0.39054],
        "8216": [0, 0.69141, 0, 0, 0.21471],
        "8217": [0, 0.69141, 0, 0, 0.21471],
        "58112": [0, 0.62119, 0, 0, 0.49749],
        "58113": [0, 0.62119, 0, 0, 0.4983],
        "58114": [0.18906, 0.69141, 0, 0, 0.33328],
        "58115": [0.18906, 0.69141, 0, 0, 0.32923],
        "58116": [0.18906, 0.47534, 0, 0, 0.50343],
        "58117": [0, 0.69141, 0, 0, 0.33301],
        "58118": [0, 0.62119, 0, 0, 0.33409],
        "58119": [0, 0.47534, 0, 0, 0.50073]
      },
      "Main-Bold": {
        "33": [0, 0.69444, 0, 0, 0.35],
        "34": [0, 0.69444, 0, 0, 0.60278],
        "35": [0.19444, 0.69444, 0, 0, 0.95833],
        "36": [0.05556, 0.75, 0, 0, 0.575],
        "37": [0.05556, 0.75, 0, 0, 0.95833],
        "38": [0, 0.69444, 0, 0, 0.89444],
        "39": [0, 0.69444, 0, 0, 0.31944],
        "40": [0.25, 0.75, 0, 0, 0.44722],
        "41": [0.25, 0.75, 0, 0, 0.44722],
        "42": [0, 0.75, 0, 0, 0.575],
        "43": [0.13333, 0.63333, 0, 0, 0.89444],
        "44": [0.19444, 0.15556, 0, 0, 0.31944],
        "45": [0, 0.44444, 0, 0, 0.38333],
        "46": [0, 0.15556, 0, 0, 0.31944],
        "47": [0.25, 0.75, 0, 0, 0.575],
        "48": [0, 0.64444, 0, 0, 0.575],
        "49": [0, 0.64444, 0, 0, 0.575],
        "50": [0, 0.64444, 0, 0, 0.575],
        "51": [0, 0.64444, 0, 0, 0.575],
        "52": [0, 0.64444, 0, 0, 0.575],
        "53": [0, 0.64444, 0, 0, 0.575],
        "54": [0, 0.64444, 0, 0, 0.575],
        "55": [0, 0.64444, 0, 0, 0.575],
        "56": [0, 0.64444, 0, 0, 0.575],
        "57": [0, 0.64444, 0, 0, 0.575],
        "58": [0, 0.44444, 0, 0, 0.31944],
        "59": [0.19444, 0.44444, 0, 0, 0.31944],
        "60": [0.08556, 0.58556, 0, 0, 0.89444],
        "61": [-0.10889, 0.39111, 0, 0, 0.89444],
        "62": [0.08556, 0.58556, 0, 0, 0.89444],
        "63": [0, 0.69444, 0, 0, 0.54305],
        "64": [0, 0.69444, 0, 0, 0.89444],
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0, 0, 0.81805],
        "67": [0, 0.68611, 0, 0, 0.83055],
        "68": [0, 0.68611, 0, 0, 0.88194],
        "69": [0, 0.68611, 0, 0, 0.75555],
        "70": [0, 0.68611, 0, 0, 0.72361],
        "71": [0, 0.68611, 0, 0, 0.90416],
        "72": [0, 0.68611, 0, 0, 0.9],
        "73": [0, 0.68611, 0, 0, 0.43611],
        "74": [0, 0.68611, 0, 0, 0.59444],
        "75": [0, 0.68611, 0, 0, 0.90138],
        "76": [0, 0.68611, 0, 0, 0.69166],
        "77": [0, 0.68611, 0, 0, 1.09166],
        "78": [0, 0.68611, 0, 0, 0.9],
        "79": [0, 0.68611, 0, 0, 0.86388],
        "80": [0, 0.68611, 0, 0, 0.78611],
        "81": [0.19444, 0.68611, 0, 0, 0.86388],
        "82": [0, 0.68611, 0, 0, 0.8625],
        "83": [0, 0.68611, 0, 0, 0.63889],
        "84": [0, 0.68611, 0, 0, 0.8],
        "85": [0, 0.68611, 0, 0, 0.88472],
        "86": [0, 0.68611, 0.01597, 0, 0.86944],
        "87": [0, 0.68611, 0.01597, 0, 1.18888],
        "88": [0, 0.68611, 0, 0, 0.86944],
        "89": [0, 0.68611, 0.02875, 0, 0.86944],
        "90": [0, 0.68611, 0, 0, 0.70277],
        "91": [0.25, 0.75, 0, 0, 0.31944],
        "92": [0.25, 0.75, 0, 0, 0.575],
        "93": [0.25, 0.75, 0, 0, 0.31944],
        "94": [0, 0.69444, 0, 0, 0.575],
        "95": [0.31, 0.13444, 0.03194, 0, 0.575],
        "97": [0, 0.44444, 0, 0, 0.55902],
        "98": [0, 0.69444, 0, 0, 0.63889],
        "99": [0, 0.44444, 0, 0, 0.51111],
        "100": [0, 0.69444, 0, 0, 0.63889],
        "101": [0, 0.44444, 0, 0, 0.52708],
        "102": [0, 0.69444, 0.10903, 0, 0.35139],
        "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
        "104": [0, 0.69444, 0, 0, 0.63889],
        "105": [0, 0.69444, 0, 0, 0.31944],
        "106": [0.19444, 0.69444, 0, 0, 0.35139],
        "107": [0, 0.69444, 0, 0, 0.60694],
        "108": [0, 0.69444, 0, 0, 0.31944],
        "109": [0, 0.44444, 0, 0, 0.95833],
        "110": [0, 0.44444, 0, 0, 0.63889],
        "111": [0, 0.44444, 0, 0, 0.575],
        "112": [0.19444, 0.44444, 0, 0, 0.63889],
        "113": [0.19444, 0.44444, 0, 0, 0.60694],
        "114": [0, 0.44444, 0, 0, 0.47361],
        "115": [0, 0.44444, 0, 0, 0.45361],
        "116": [0, 0.63492, 0, 0, 0.44722],
        "117": [0, 0.44444, 0, 0, 0.63889],
        "118": [0, 0.44444, 0.01597, 0, 0.60694],
        "119": [0, 0.44444, 0.01597, 0, 0.83055],
        "120": [0, 0.44444, 0, 0, 0.60694],
        "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
        "122": [0, 0.44444, 0, 0, 0.51111],
        "123": [0.25, 0.75, 0, 0, 0.575],
        "124": [0.25, 0.75, 0, 0, 0.31944],
        "125": [0.25, 0.75, 0, 0, 0.575],
        "126": [0.35, 0.34444, 0, 0, 0.575],
        "168": [0, 0.69444, 0, 0, 0.575],
        "172": [0, 0.44444, 0, 0, 0.76666],
        "176": [0, 0.69444, 0, 0, 0.86944],
        "177": [0.13333, 0.63333, 0, 0, 0.89444],
        "184": [0.17014, 0, 0, 0, 0.51111],
        "198": [0, 0.68611, 0, 0, 1.04166],
        "215": [0.13333, 0.63333, 0, 0, 0.89444],
        "216": [0.04861, 0.73472, 0, 0, 0.89444],
        "223": [0, 0.69444, 0, 0, 0.59722],
        "230": [0, 0.44444, 0, 0, 0.83055],
        "247": [0.13333, 0.63333, 0, 0, 0.89444],
        "248": [0.09722, 0.54167, 0, 0, 0.575],
        "305": [0, 0.44444, 0, 0, 0.31944],
        "338": [0, 0.68611, 0, 0, 1.16944],
        "339": [0, 0.44444, 0, 0, 0.89444],
        "567": [0.19444, 0.44444, 0, 0, 0.35139],
        "710": [0, 0.69444, 0, 0, 0.575],
        "711": [0, 0.63194, 0, 0, 0.575],
        "713": [0, 0.59611, 0, 0, 0.575],
        "714": [0, 0.69444, 0, 0, 0.575],
        "715": [0, 0.69444, 0, 0, 0.575],
        "728": [0, 0.69444, 0, 0, 0.575],
        "729": [0, 0.69444, 0, 0, 0.31944],
        "730": [0, 0.69444, 0, 0, 0.86944],
        "732": [0, 0.69444, 0, 0, 0.575],
        "733": [0, 0.69444, 0, 0, 0.575],
        "915": [0, 0.68611, 0, 0, 0.69166],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0, 0, 0.89444],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0, 0, 0.76666],
        "928": [0, 0.68611, 0, 0, 0.9],
        "931": [0, 0.68611, 0, 0, 0.83055],
        "933": [0, 0.68611, 0, 0, 0.89444],
        "934": [0, 0.68611, 0, 0, 0.83055],
        "936": [0, 0.68611, 0, 0, 0.89444],
        "937": [0, 0.68611, 0, 0, 0.83055],
        "8211": [0, 0.44444, 0.03194, 0, 0.575],
        "8212": [0, 0.44444, 0.03194, 0, 1.14999],
        "8216": [0, 0.69444, 0, 0, 0.31944],
        "8217": [0, 0.69444, 0, 0, 0.31944],
        "8220": [0, 0.69444, 0, 0, 0.60278],
        "8221": [0, 0.69444, 0, 0, 0.60278],
        "8224": [0.19444, 0.69444, 0, 0, 0.51111],
        "8225": [0.19444, 0.69444, 0, 0, 0.51111],
        "8242": [0, 0.55556, 0, 0, 0.34444],
        "8407": [0, 0.72444, 0.15486, 0, 0.575],
        "8463": [0, 0.69444, 0, 0, 0.66759],
        "8465": [0, 0.69444, 0, 0, 0.83055],
        "8467": [0, 0.69444, 0, 0, 0.47361],
        "8472": [0.19444, 0.44444, 0, 0, 0.74027],
        "8476": [0, 0.69444, 0, 0, 0.83055],
        "8501": [0, 0.69444, 0, 0, 0.70277],
        "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8593": [0.19444, 0.69444, 0, 0, 0.575],
        "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8595": [0.19444, 0.69444, 0, 0, 0.575],
        "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8597": [0.25, 0.75, 0, 0, 0.575],
        "8598": [0.19444, 0.69444, 0, 0, 1.14999],
        "8599": [0.19444, 0.69444, 0, 0, 1.14999],
        "8600": [0.19444, 0.69444, 0, 0, 1.14999],
        "8601": [0.19444, 0.69444, 0, 0, 1.14999],
        "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8657": [0.19444, 0.69444, 0, 0, 0.70277],
        "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8659": [0.19444, 0.69444, 0, 0, 0.70277],
        "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
        "8661": [0.25, 0.75, 0, 0, 0.70277],
        "8704": [0, 0.69444, 0, 0, 0.63889],
        "8706": [0, 0.69444, 0.06389, 0, 0.62847],
        "8707": [0, 0.69444, 0, 0, 0.63889],
        "8709": [0.05556, 0.75, 0, 0, 0.575],
        "8711": [0, 0.68611, 0, 0, 0.95833],
        "8712": [0.08556, 0.58556, 0, 0, 0.76666],
        "8715": [0.08556, 0.58556, 0, 0, 0.76666],
        "8722": [0.13333, 0.63333, 0, 0, 0.89444],
        "8723": [0.13333, 0.63333, 0, 0, 0.89444],
        "8725": [0.25, 0.75, 0, 0, 0.575],
        "8726": [0.25, 0.75, 0, 0, 0.575],
        "8727": [-0.02778, 0.47222, 0, 0, 0.575],
        "8728": [-0.02639, 0.47361, 0, 0, 0.575],
        "8729": [-0.02639, 0.47361, 0, 0, 0.575],
        "8730": [0.18, 0.82, 0, 0, 0.95833],
        "8733": [0, 0.44444, 0, 0, 0.89444],
        "8734": [0, 0.44444, 0, 0, 1.14999],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.31944],
        "8741": [0.25, 0.75, 0, 0, 0.575],
        "8743": [0, 0.55556, 0, 0, 0.76666],
        "8744": [0, 0.55556, 0, 0, 0.76666],
        "8745": [0, 0.55556, 0, 0, 0.76666],
        "8746": [0, 0.55556, 0, 0, 0.76666],
        "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
        "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
        "8768": [0.19444, 0.69444, 0, 0, 0.31944],
        "8771": [0.00222, 0.50222, 0, 0, 0.89444],
        "8776": [0.02444, 0.52444, 0, 0, 0.89444],
        "8781": [0.00222, 0.50222, 0, 0, 0.89444],
        "8801": [0.00222, 0.50222, 0, 0, 0.89444],
        "8804": [0.19667, 0.69667, 0, 0, 0.89444],
        "8805": [0.19667, 0.69667, 0, 0, 0.89444],
        "8810": [0.08556, 0.58556, 0, 0, 1.14999],
        "8811": [0.08556, 0.58556, 0, 0, 1.14999],
        "8826": [0.08556, 0.58556, 0, 0, 0.89444],
        "8827": [0.08556, 0.58556, 0, 0, 0.89444],
        "8834": [0.08556, 0.58556, 0, 0, 0.89444],
        "8835": [0.08556, 0.58556, 0, 0, 0.89444],
        "8838": [0.19667, 0.69667, 0, 0, 0.89444],
        "8839": [0.19667, 0.69667, 0, 0, 0.89444],
        "8846": [0, 0.55556, 0, 0, 0.76666],
        "8849": [0.19667, 0.69667, 0, 0, 0.89444],
        "8850": [0.19667, 0.69667, 0, 0, 0.89444],
        "8851": [0, 0.55556, 0, 0, 0.76666],
        "8852": [0, 0.55556, 0, 0, 0.76666],
        "8853": [0.13333, 0.63333, 0, 0, 0.89444],
        "8854": [0.13333, 0.63333, 0, 0, 0.89444],
        "8855": [0.13333, 0.63333, 0, 0, 0.89444],
        "8856": [0.13333, 0.63333, 0, 0, 0.89444],
        "8857": [0.13333, 0.63333, 0, 0, 0.89444],
        "8866": [0, 0.69444, 0, 0, 0.70277],
        "8867": [0, 0.69444, 0, 0, 0.70277],
        "8868": [0, 0.69444, 0, 0, 0.89444],
        "8869": [0, 0.69444, 0, 0, 0.89444],
        "8900": [-0.02639, 0.47361, 0, 0, 0.575],
        "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
        "8902": [-0.02778, 0.47222, 0, 0, 0.575],
        "8968": [0.25, 0.75, 0, 0, 0.51111],
        "8969": [0.25, 0.75, 0, 0, 0.51111],
        "8970": [0.25, 0.75, 0, 0, 0.51111],
        "8971": [0.25, 0.75, 0, 0, 0.51111],
        "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
        "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
        "9651": [0.19444, 0.69444, 0, 0, 1.02222],
        "9657": [-0.02778, 0.47222, 0, 0, 0.575],
        "9661": [0.19444, 0.69444, 0, 0, 1.02222],
        "9667": [-0.02778, 0.47222, 0, 0, 0.575],
        "9711": [0.19444, 0.69444, 0, 0, 1.14999],
        "9824": [0.12963, 0.69444, 0, 0, 0.89444],
        "9825": [0.12963, 0.69444, 0, 0, 0.89444],
        "9826": [0.12963, 0.69444, 0, 0, 0.89444],
        "9827": [0.12963, 0.69444, 0, 0, 0.89444],
        "9837": [0, 0.75, 0, 0, 0.44722],
        "9838": [0.19444, 0.69444, 0, 0, 0.44722],
        "9839": [0.19444, 0.69444, 0, 0, 0.44722],
        "10216": [0.25, 0.75, 0, 0, 0.44722],
        "10217": [0.25, 0.75, 0, 0, 0.44722],
        "10815": [0, 0.68611, 0, 0, 0.9],
        "10927": [0.19667, 0.69667, 0, 0, 0.89444],
        "10928": [0.19667, 0.69667, 0, 0, 0.89444],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Main-BoldItalic": {
        "33": [0, 0.69444, 0.11417, 0, 0.38611],
        "34": [0, 0.69444, 0.07939, 0, 0.62055],
        "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
        "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
        "38": [0, 0.69444, 0.08528, 0, 0.88555],
        "39": [0, 0.69444, 0.12945, 0, 0.35555],
        "40": [0.25, 0.75, 0.15806, 0, 0.47333],
        "41": [0.25, 0.75, 0.03306, 0, 0.47333],
        "42": [0, 0.75, 0.14333, 0, 0.59111],
        "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
        "44": [0.19444, 0.14722, 0, 0, 0.35555],
        "45": [0, 0.44444, 0.02611, 0, 0.41444],
        "46": [0, 0.14722, 0, 0, 0.35555],
        "47": [0.25, 0.75, 0.15806, 0, 0.59111],
        "48": [0, 0.64444, 0.13167, 0, 0.59111],
        "49": [0, 0.64444, 0.13167, 0, 0.59111],
        "50": [0, 0.64444, 0.13167, 0, 0.59111],
        "51": [0, 0.64444, 0.13167, 0, 0.59111],
        "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "53": [0, 0.64444, 0.13167, 0, 0.59111],
        "54": [0, 0.64444, 0.13167, 0, 0.59111],
        "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
        "56": [0, 0.64444, 0.13167, 0, 0.59111],
        "57": [0, 0.64444, 0.13167, 0, 0.59111],
        "58": [0, 0.44444, 0.06695, 0, 0.35555],
        "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
        "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
        "63": [0, 0.69444, 0.11472, 0, 0.59111],
        "64": [0, 0.69444, 0.09208, 0, 0.88555],
        "65": [0, 0.68611, 0, 0, 0.86555],
        "66": [0, 0.68611, 0.0992, 0, 0.81666],
        "67": [0, 0.68611, 0.14208, 0, 0.82666],
        "68": [0, 0.68611, 0.09062, 0, 0.87555],
        "69": [0, 0.68611, 0.11431, 0, 0.75666],
        "70": [0, 0.68611, 0.12903, 0, 0.72722],
        "71": [0, 0.68611, 0.07347, 0, 0.89527],
        "72": [0, 0.68611, 0.17208, 0, 0.8961],
        "73": [0, 0.68611, 0.15681, 0, 0.47166],
        "74": [0, 0.68611, 0.145, 0, 0.61055],
        "75": [0, 0.68611, 0.14208, 0, 0.89499],
        "76": [0, 0.68611, 0, 0, 0.69777],
        "77": [0, 0.68611, 0.17208, 0, 1.07277],
        "78": [0, 0.68611, 0.17208, 0, 0.8961],
        "79": [0, 0.68611, 0.09062, 0, 0.85499],
        "80": [0, 0.68611, 0.0992, 0, 0.78721],
        "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
        "82": [0, 0.68611, 0.02559, 0, 0.85944],
        "83": [0, 0.68611, 0.11264, 0, 0.64999],
        "84": [0, 0.68611, 0.12903, 0, 0.7961],
        "85": [0, 0.68611, 0.17208, 0, 0.88083],
        "86": [0, 0.68611, 0.18625, 0, 0.86555],
        "87": [0, 0.68611, 0.18625, 0, 1.15999],
        "88": [0, 0.68611, 0.15681, 0, 0.86555],
        "89": [0, 0.68611, 0.19803, 0, 0.86555],
        "90": [0, 0.68611, 0.14208, 0, 0.70888],
        "91": [0.25, 0.75, 0.1875, 0, 0.35611],
        "93": [0.25, 0.75, 0.09972, 0, 0.35611],
        "94": [0, 0.69444, 0.06709, 0, 0.59111],
        "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
        "97": [0, 0.44444, 0.09426, 0, 0.59111],
        "98": [0, 0.69444, 0.07861, 0, 0.53222],
        "99": [0, 0.44444, 0.05222, 0, 0.53222],
        "100": [0, 0.69444, 0.10861, 0, 0.59111],
        "101": [0, 0.44444, 0.085, 0, 0.53222],
        "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
        "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "104": [0, 0.69444, 0.09426, 0, 0.59111],
        "105": [0, 0.69326, 0.11387, 0, 0.35555],
        "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
        "107": [0, 0.69444, 0.11111, 0, 0.53222],
        "108": [0, 0.69444, 0.10861, 0, 0.29666],
        "109": [0, 0.44444, 0.09426, 0, 0.94444],
        "110": [0, 0.44444, 0.09426, 0, 0.64999],
        "111": [0, 0.44444, 0.07861, 0, 0.59111],
        "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
        "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
        "114": [0, 0.44444, 0.11111, 0, 0.50167],
        "115": [0, 0.44444, 0.08167, 0, 0.48694],
        "116": [0, 0.63492, 0.09639, 0, 0.385],
        "117": [0, 0.44444, 0.09426, 0, 0.62055],
        "118": [0, 0.44444, 0.11111, 0, 0.53222],
        "119": [0, 0.44444, 0.11111, 0, 0.76777],
        "120": [0, 0.44444, 0.12583, 0, 0.56055],
        "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
        "122": [0, 0.44444, 0.13889, 0, 0.49055],
        "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
        "163": [0, 0.69444, 0, 0, 0.86853],
        "168": [0, 0.69444, 0.11473, 0, 0.59111],
        "176": [0, 0.69444, 0, 0, 0.94888],
        "184": [0.17014, 0, 0, 0, 0.53222],
        "198": [0, 0.68611, 0.11431, 0, 1.02277],
        "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
        "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
        "230": [0, 0.44444, 0.085, 0, 0.82666],
        "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
        "305": [0, 0.44444, 0.09426, 0, 0.35555],
        "338": [0, 0.68611, 0.11431, 0, 1.14054],
        "339": [0, 0.44444, 0.085, 0, 0.82666],
        "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
        "710": [0, 0.69444, 0.06709, 0, 0.59111],
        "711": [0, 0.63194, 0.08271, 0, 0.59111],
        "713": [0, 0.59444, 0.10444, 0, 0.59111],
        "714": [0, 0.69444, 0.08528, 0, 0.59111],
        "715": [0, 0.69444, 0, 0, 0.59111],
        "728": [0, 0.69444, 0.10333, 0, 0.59111],
        "729": [0, 0.69444, 0.12945, 0, 0.35555],
        "730": [0, 0.69444, 0, 0, 0.94888],
        "732": [0, 0.69444, 0.11472, 0, 0.59111],
        "733": [0, 0.69444, 0.11472, 0, 0.59111],
        "915": [0, 0.68611, 0.12903, 0, 0.69777],
        "916": [0, 0.68611, 0, 0, 0.94444],
        "920": [0, 0.68611, 0.09062, 0, 0.88555],
        "923": [0, 0.68611, 0, 0, 0.80666],
        "926": [0, 0.68611, 0.15092, 0, 0.76777],
        "928": [0, 0.68611, 0.17208, 0, 0.8961],
        "931": [0, 0.68611, 0.11431, 0, 0.82666],
        "933": [0, 0.68611, 0.10778, 0, 0.88555],
        "934": [0, 0.68611, 0.05632, 0, 0.82666],
        "936": [0, 0.68611, 0.10778, 0, 0.88555],
        "937": [0, 0.68611, 0.0992, 0, 0.82666],
        "8211": [0, 0.44444, 0.09811, 0, 0.59111],
        "8212": [0, 0.44444, 0.09811, 0, 1.18221],
        "8216": [0, 0.69444, 0.12945, 0, 0.35555],
        "8217": [0, 0.69444, 0.12945, 0, 0.35555],
        "8220": [0, 0.69444, 0.16772, 0, 0.62055],
        "8221": [0, 0.69444, 0.07939, 0, 0.62055]
      },
      "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0, 0.30667],
        "34": [0, 0.69444, 0.06961, 0, 0.51444],
        "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
        "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
        "38": [0, 0.69444, 0.09694, 0, 0.76666],
        "39": [0, 0.69444, 0.12417, 0, 0.30667],
        "40": [0.25, 0.75, 0.16194, 0, 0.40889],
        "41": [0.25, 0.75, 0.03694, 0, 0.40889],
        "42": [0, 0.75, 0.14917, 0, 0.51111],
        "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
        "44": [0.19444, 0.10556, 0, 0, 0.30667],
        "45": [0, 0.43056, 0.02826, 0, 0.35778],
        "46": [0, 0.10556, 0, 0, 0.30667],
        "47": [0.25, 0.75, 0.16194, 0, 0.51111],
        "48": [0, 0.64444, 0.13556, 0, 0.51111],
        "49": [0, 0.64444, 0.13556, 0, 0.51111],
        "50": [0, 0.64444, 0.13556, 0, 0.51111],
        "51": [0, 0.64444, 0.13556, 0, 0.51111],
        "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "53": [0, 0.64444, 0.13556, 0, 0.51111],
        "54": [0, 0.64444, 0.13556, 0, 0.51111],
        "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
        "56": [0, 0.64444, 0.13556, 0, 0.51111],
        "57": [0, 0.64444, 0.13556, 0, 0.51111],
        "58": [0, 0.43056, 0.0582, 0, 0.30667],
        "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
        "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
        "63": [0, 0.69444, 0.1225, 0, 0.51111],
        "64": [0, 0.69444, 0.09597, 0, 0.76666],
        "65": [0, 0.68333, 0, 0, 0.74333],
        "66": [0, 0.68333, 0.10257, 0, 0.70389],
        "67": [0, 0.68333, 0.14528, 0, 0.71555],
        "68": [0, 0.68333, 0.09403, 0, 0.755],
        "69": [0, 0.68333, 0.12028, 0, 0.67833],
        "70": [0, 0.68333, 0.13305, 0, 0.65277],
        "71": [0, 0.68333, 0.08722, 0, 0.77361],
        "72": [0, 0.68333, 0.16389, 0, 0.74333],
        "73": [0, 0.68333, 0.15806, 0, 0.38555],
        "74": [0, 0.68333, 0.14028, 0, 0.525],
        "75": [0, 0.68333, 0.14528, 0, 0.76888],
        "76": [0, 0.68333, 0, 0, 0.62722],
        "77": [0, 0.68333, 0.16389, 0, 0.89666],
        "78": [0, 0.68333, 0.16389, 0, 0.74333],
        "79": [0, 0.68333, 0.09403, 0, 0.76666],
        "80": [0, 0.68333, 0.10257, 0, 0.67833],
        "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
        "82": [0, 0.68333, 0.03868, 0, 0.72944],
        "83": [0, 0.68333, 0.11972, 0, 0.56222],
        "84": [0, 0.68333, 0.13305, 0, 0.71555],
        "85": [0, 0.68333, 0.16389, 0, 0.74333],
        "86": [0, 0.68333, 0.18361, 0, 0.74333],
        "87": [0, 0.68333, 0.18361, 0, 0.99888],
        "88": [0, 0.68333, 0.15806, 0, 0.74333],
        "89": [0, 0.68333, 0.19383, 0, 0.74333],
        "90": [0, 0.68333, 0.14528, 0, 0.61333],
        "91": [0.25, 0.75, 0.1875, 0, 0.30667],
        "93": [0.25, 0.75, 0.10528, 0, 0.30667],
        "94": [0, 0.69444, 0.06646, 0, 0.51111],
        "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
        "97": [0, 0.43056, 0.07671, 0, 0.51111],
        "98": [0, 0.69444, 0.06312, 0, 0.46],
        "99": [0, 0.43056, 0.05653, 0, 0.46],
        "100": [0, 0.69444, 0.10333, 0, 0.51111],
        "101": [0, 0.43056, 0.07514, 0, 0.46],
        "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
        "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "104": [0, 0.69444, 0.07671, 0, 0.51111],
        "105": [0, 0.65536, 0.1019, 0, 0.30667],
        "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
        "107": [0, 0.69444, 0.10764, 0, 0.46],
        "108": [0, 0.69444, 0.10333, 0, 0.25555],
        "109": [0, 0.43056, 0.07671, 0, 0.81777],
        "110": [0, 0.43056, 0.07671, 0, 0.56222],
        "111": [0, 0.43056, 0.06312, 0, 0.51111],
        "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
        "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
        "114": [0, 0.43056, 0.10764, 0, 0.42166],
        "115": [0, 0.43056, 0.08208, 0, 0.40889],
        "116": [0, 0.61508, 0.09486, 0, 0.33222],
        "117": [0, 0.43056, 0.07671, 0, 0.53666],
        "118": [0, 0.43056, 0.10764, 0, 0.46],
        "119": [0, 0.43056, 0.10764, 0, 0.66444],
        "120": [0, 0.43056, 0.12042, 0, 0.46389],
        "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
        "122": [0, 0.43056, 0.12292, 0, 0.40889],
        "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
        "163": [0, 0.69444, 0, 0, 0.76909],
        "168": [0, 0.66786, 0.10474, 0, 0.51111],
        "176": [0, 0.69444, 0, 0, 0.83129],
        "184": [0.17014, 0, 0, 0, 0.46],
        "198": [0, 0.68333, 0.12028, 0, 0.88277],
        "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
        "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
        "230": [0, 0.43056, 0.07514, 0, 0.71555],
        "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
        "305": [0, 0.43056, 0, 0.02778, 0.32246],
        "338": [0, 0.68333, 0.12028, 0, 0.98499],
        "339": [0, 0.43056, 0.07514, 0, 0.71555],
        "567": [0.19444, 0.43056, 0, 0.08334, 0.38403],
        "710": [0, 0.69444, 0.06646, 0, 0.51111],
        "711": [0, 0.62847, 0.08295, 0, 0.51111],
        "713": [0, 0.56167, 0.10333, 0, 0.51111],
        "714": [0, 0.69444, 0.09694, 0, 0.51111],
        "715": [0, 0.69444, 0, 0, 0.51111],
        "728": [0, 0.69444, 0.10806, 0, 0.51111],
        "729": [0, 0.66786, 0.11752, 0, 0.30667],
        "730": [0, 0.69444, 0, 0, 0.83129],
        "732": [0, 0.66786, 0.11585, 0, 0.51111],
        "733": [0, 0.69444, 0.1225, 0, 0.51111],
        "915": [0, 0.68333, 0.13305, 0, 0.62722],
        "916": [0, 0.68333, 0, 0, 0.81777],
        "920": [0, 0.68333, 0.09403, 0, 0.76666],
        "923": [0, 0.68333, 0, 0, 0.69222],
        "926": [0, 0.68333, 0.15294, 0, 0.66444],
        "928": [0, 0.68333, 0.16389, 0, 0.74333],
        "931": [0, 0.68333, 0.12028, 0, 0.71555],
        "933": [0, 0.68333, 0.11111, 0, 0.76666],
        "934": [0, 0.68333, 0.05986, 0, 0.71555],
        "936": [0, 0.68333, 0.11111, 0, 0.76666],
        "937": [0, 0.68333, 0.10257, 0, 0.71555],
        "8211": [0, 0.43056, 0.09208, 0, 0.51111],
        "8212": [0, 0.43056, 0.09208, 0, 1.02222],
        "8216": [0, 0.69444, 0.12417, 0, 0.30667],
        "8217": [0, 0.69444, 0.12417, 0, 0.30667],
        "8220": [0, 0.69444, 0.1685, 0, 0.51444],
        "8221": [0, 0.69444, 0.06961, 0, 0.51444],
        "8463": [0, 0.68889, 0, 0, 0.54028]
      },
      "Main-Regular": {
        "32": [0, 0, 0, 0, 0.25],
        "33": [0, 0.69444, 0, 0, 0.27778],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.77778],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.19444, 0.10556, 0, 0, 0.27778],
        "45": [0, 0.43056, 0, 0, 0.33333],
        "46": [0, 0.10556, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.64444, 0, 0, 0.5],
        "49": [0, 0.64444, 0, 0, 0.5],
        "50": [0, 0.64444, 0, 0, 0.5],
        "51": [0, 0.64444, 0, 0, 0.5],
        "52": [0, 0.64444, 0, 0, 0.5],
        "53": [0, 0.64444, 0, 0, 0.5],
        "54": [0, 0.64444, 0, 0, 0.5],
        "55": [0, 0.64444, 0, 0, 0.5],
        "56": [0, 0.64444, 0, 0, 0.5],
        "57": [0, 0.64444, 0, 0, 0.5],
        "58": [0, 0.43056, 0, 0, 0.27778],
        "59": [0.19444, 0.43056, 0, 0, 0.27778],
        "60": [0.0391, 0.5391, 0, 0, 0.77778],
        "61": [-0.13313, 0.36687, 0, 0, 0.77778],
        "62": [0.0391, 0.5391, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.77778],
        "65": [0, 0.68333, 0, 0, 0.75],
        "66": [0, 0.68333, 0, 0, 0.70834],
        "67": [0, 0.68333, 0, 0, 0.72222],
        "68": [0, 0.68333, 0, 0, 0.76389],
        "69": [0, 0.68333, 0, 0, 0.68056],
        "70": [0, 0.68333, 0, 0, 0.65278],
        "71": [0, 0.68333, 0, 0, 0.78472],
        "72": [0, 0.68333, 0, 0, 0.75],
        "73": [0, 0.68333, 0, 0, 0.36111],
        "74": [0, 0.68333, 0, 0, 0.51389],
        "75": [0, 0.68333, 0, 0, 0.77778],
        "76": [0, 0.68333, 0, 0, 0.625],
        "77": [0, 0.68333, 0, 0, 0.91667],
        "78": [0, 0.68333, 0, 0, 0.75],
        "79": [0, 0.68333, 0, 0, 0.77778],
        "80": [0, 0.68333, 0, 0, 0.68056],
        "81": [0.19444, 0.68333, 0, 0, 0.77778],
        "82": [0, 0.68333, 0, 0, 0.73611],
        "83": [0, 0.68333, 0, 0, 0.55556],
        "84": [0, 0.68333, 0, 0, 0.72222],
        "85": [0, 0.68333, 0, 0, 0.75],
        "86": [0, 0.68333, 0.01389, 0, 0.75],
        "87": [0, 0.68333, 0.01389, 0, 1.02778],
        "88": [0, 0.68333, 0, 0, 0.75],
        "89": [0, 0.68333, 0.025, 0, 0.75],
        "90": [0, 0.68333, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.27778],
        "92": [0.25, 0.75, 0, 0, 0.5],
        "93": [0.25, 0.75, 0, 0, 0.27778],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.31, 0.12056, 0.02778, 0, 0.5],
        "97": [0, 0.43056, 0, 0, 0.5],
        "98": [0, 0.69444, 0, 0, 0.55556],
        "99": [0, 0.43056, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.55556],
        "101": [0, 0.43056, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.07778, 0, 0.30556],
        "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.55556],
        "105": [0, 0.66786, 0, 0, 0.27778],
        "106": [0.19444, 0.66786, 0, 0, 0.30556],
        "107": [0, 0.69444, 0, 0, 0.52778],
        "108": [0, 0.69444, 0, 0, 0.27778],
        "109": [0, 0.43056, 0, 0, 0.83334],
        "110": [0, 0.43056, 0, 0, 0.55556],
        "111": [0, 0.43056, 0, 0, 0.5],
        "112": [0.19444, 0.43056, 0, 0, 0.55556],
        "113": [0.19444, 0.43056, 0, 0, 0.52778],
        "114": [0, 0.43056, 0, 0, 0.39167],
        "115": [0, 0.43056, 0, 0, 0.39445],
        "116": [0, 0.61508, 0, 0, 0.38889],
        "117": [0, 0.43056, 0, 0, 0.55556],
        "118": [0, 0.43056, 0.01389, 0, 0.52778],
        "119": [0, 0.43056, 0.01389, 0, 0.72222],
        "120": [0, 0.43056, 0, 0, 0.52778],
        "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
        "122": [0, 0.43056, 0, 0, 0.44445],
        "123": [0.25, 0.75, 0, 0, 0.5],
        "124": [0.25, 0.75, 0, 0, 0.27778],
        "125": [0.25, 0.75, 0, 0, 0.5],
        "126": [0.35, 0.31786, 0, 0, 0.5],
        "160": [0, 0, 0, 0, 0.25],
        "167": [0.19444, 0.69444, 0, 0, 0.44445],
        "168": [0, 0.66786, 0, 0, 0.5],
        "172": [0, 0.43056, 0, 0, 0.66667],
        "176": [0, 0.69444, 0, 0, 0.75],
        "177": [0.08333, 0.58333, 0, 0, 0.77778],
        "182": [0.19444, 0.69444, 0, 0, 0.61111],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "198": [0, 0.68333, 0, 0, 0.90278],
        "215": [0.08333, 0.58333, 0, 0, 0.77778],
        "216": [0.04861, 0.73194, 0, 0, 0.77778],
        "223": [0, 0.69444, 0, 0, 0.5],
        "230": [0, 0.43056, 0, 0, 0.72222],
        "247": [0.08333, 0.58333, 0, 0, 0.77778],
        "248": [0.09722, 0.52778, 0, 0, 0.5],
        "305": [0, 0.43056, 0, 0, 0.27778],
        "338": [0, 0.68333, 0, 0, 1.01389],
        "339": [0, 0.43056, 0, 0, 0.77778],
        "567": [0.19444, 0.43056, 0, 0, 0.30556],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.62847, 0, 0, 0.5],
        "713": [0, 0.56778, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.66786, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.75],
        "732": [0, 0.66786, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.68333, 0, 0, 0.625],
        "916": [0, 0.68333, 0, 0, 0.83334],
        "920": [0, 0.68333, 0, 0, 0.77778],
        "923": [0, 0.68333, 0, 0, 0.69445],
        "926": [0, 0.68333, 0, 0, 0.66667],
        "928": [0, 0.68333, 0, 0, 0.75],
        "931": [0, 0.68333, 0, 0, 0.72222],
        "933": [0, 0.68333, 0, 0, 0.77778],
        "934": [0, 0.68333, 0, 0, 0.72222],
        "936": [0, 0.68333, 0, 0, 0.77778],
        "937": [0, 0.68333, 0, 0, 0.72222],
        "8211": [0, 0.43056, 0.02778, 0, 0.5],
        "8212": [0, 0.43056, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5],
        "8224": [0.19444, 0.69444, 0, 0, 0.44445],
        "8225": [0.19444, 0.69444, 0, 0, 0.44445],
        "8230": [0, 0.12, 0, 0, 1.172],
        "8242": [0, 0.55556, 0, 0, 0.275],
        "8407": [0, 0.71444, 0.15382, 0, 0.5],
        "8463": [0, 0.68889, 0, 0, 0.54028],
        "8465": [0, 0.69444, 0, 0, 0.72222],
        "8467": [0, 0.69444, 0, 0.11111, 0.41667],
        "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
        "8476": [0, 0.69444, 0, 0, 0.72222],
        "8501": [0, 0.69444, 0, 0, 0.61111],
        "8592": [-0.13313, 0.36687, 0, 0, 1.0],
        "8593": [0.19444, 0.69444, 0, 0, 0.5],
        "8594": [-0.13313, 0.36687, 0, 0, 1.0],
        "8595": [0.19444, 0.69444, 0, 0, 0.5],
        "8596": [-0.13313, 0.36687, 0, 0, 1.0],
        "8597": [0.25, 0.75, 0, 0, 0.5],
        "8598": [0.19444, 0.69444, 0, 0, 1.0],
        "8599": [0.19444, 0.69444, 0, 0, 1.0],
        "8600": [0.19444, 0.69444, 0, 0, 1.0],
        "8601": [0.19444, 0.69444, 0, 0, 1.0],
        "8614": [0.011, 0.511, 0, 0, 1.0],
        "8617": [0.011, 0.511, 0, 0, 1.126],
        "8618": [0.011, 0.511, 0, 0, 1.126],
        "8636": [-0.13313, 0.36687, 0, 0, 1.0],
        "8637": [-0.13313, 0.36687, 0, 0, 1.0],
        "8640": [-0.13313, 0.36687, 0, 0, 1.0],
        "8641": [-0.13313, 0.36687, 0, 0, 1.0],
        "8652": [0.011, 0.671, 0, 0, 1.0],
        "8656": [-0.13313, 0.36687, 0, 0, 1.0],
        "8657": [0.19444, 0.69444, 0, 0, 0.61111],
        "8658": [-0.13313, 0.36687, 0, 0, 1.0],
        "8659": [0.19444, 0.69444, 0, 0, 0.61111],
        "8660": [-0.13313, 0.36687, 0, 0, 1.0],
        "8661": [0.25, 0.75, 0, 0, 0.61111],
        "8704": [0, 0.69444, 0, 0, 0.55556],
        "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
        "8707": [0, 0.69444, 0, 0, 0.55556],
        "8709": [0.05556, 0.75, 0, 0, 0.5],
        "8711": [0, 0.68333, 0, 0, 0.83334],
        "8712": [0.0391, 0.5391, 0, 0, 0.66667],
        "8715": [0.0391, 0.5391, 0, 0, 0.66667],
        "8722": [0.08333, 0.58333, 0, 0, 0.77778],
        "8723": [0.08333, 0.58333, 0, 0, 0.77778],
        "8725": [0.25, 0.75, 0, 0, 0.5],
        "8726": [0.25, 0.75, 0, 0, 0.5],
        "8727": [-0.03472, 0.46528, 0, 0, 0.5],
        "8728": [-0.05555, 0.44445, 0, 0, 0.5],
        "8729": [-0.05555, 0.44445, 0, 0, 0.5],
        "8730": [0.2, 0.8, 0, 0, 0.83334],
        "8733": [0, 0.43056, 0, 0, 0.77778],
        "8734": [0, 0.43056, 0, 0, 1.0],
        "8736": [0, 0.69224, 0, 0, 0.72222],
        "8739": [0.25, 0.75, 0, 0, 0.27778],
        "8741": [0.25, 0.75, 0, 0, 0.5],
        "8743": [0, 0.55556, 0, 0, 0.66667],
        "8744": [0, 0.55556, 0, 0, 0.66667],
        "8745": [0, 0.55556, 0, 0, 0.66667],
        "8746": [0, 0.55556, 0, 0, 0.66667],
        "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
        "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
        "8768": [0.19444, 0.69444, 0, 0, 0.27778],
        "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8773": [-0.022, 0.589, 0, 0, 1.0],
        "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
        "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8784": [-0.133, 0.67, 0, 0, 0.778],
        "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
        "8804": [0.13597, 0.63597, 0, 0, 0.77778],
        "8805": [0.13597, 0.63597, 0, 0, 0.77778],
        "8810": [0.0391, 0.5391, 0, 0, 1.0],
        "8811": [0.0391, 0.5391, 0, 0, 1.0],
        "8826": [0.0391, 0.5391, 0, 0, 0.77778],
        "8827": [0.0391, 0.5391, 0, 0, 0.77778],
        "8834": [0.0391, 0.5391, 0, 0, 0.77778],
        "8835": [0.0391, 0.5391, 0, 0, 0.77778],
        "8838": [0.13597, 0.63597, 0, 0, 0.77778],
        "8839": [0.13597, 0.63597, 0, 0, 0.77778],
        "8846": [0, 0.55556, 0, 0, 0.66667],
        "8849": [0.13597, 0.63597, 0, 0, 0.77778],
        "8850": [0.13597, 0.63597, 0, 0, 0.77778],
        "8851": [0, 0.55556, 0, 0, 0.66667],
        "8852": [0, 0.55556, 0, 0, 0.66667],
        "8853": [0.08333, 0.58333, 0, 0, 0.77778],
        "8854": [0.08333, 0.58333, 0, 0, 0.77778],
        "8855": [0.08333, 0.58333, 0, 0, 0.77778],
        "8856": [0.08333, 0.58333, 0, 0, 0.77778],
        "8857": [0.08333, 0.58333, 0, 0, 0.77778],
        "8866": [0, 0.69444, 0, 0, 0.61111],
        "8867": [0, 0.69444, 0, 0, 0.61111],
        "8868": [0, 0.69444, 0, 0, 0.77778],
        "8869": [0, 0.69444, 0, 0, 0.77778],
        "8872": [0.249, 0.75, 0, 0, 0.867],
        "8900": [-0.05555, 0.44445, 0, 0, 0.5],
        "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
        "8902": [-0.03472, 0.46528, 0, 0, 0.5],
        "8904": [0.005, 0.505, 0, 0, 0.9],
        "8942": [0.03, 0.9, 0, 0, 0.278],
        "8943": [-0.19, 0.31, 0, 0, 1.172],
        "8945": [-0.1, 0.82, 0, 0, 1.282],
        "8968": [0.25, 0.75, 0, 0, 0.44445],
        "8969": [0.25, 0.75, 0, 0, 0.44445],
        "8970": [0.25, 0.75, 0, 0, 0.44445],
        "8971": [0.25, 0.75, 0, 0, 0.44445],
        "8994": [-0.14236, 0.35764, 0, 0, 1.0],
        "8995": [-0.14236, 0.35764, 0, 0, 1.0],
        "9136": [0.244, 0.744, 0, 0, 0.412],
        "9137": [0.244, 0.744, 0, 0, 0.412],
        "9651": [0.19444, 0.69444, 0, 0, 0.88889],
        "9657": [-0.03472, 0.46528, 0, 0, 0.5],
        "9661": [0.19444, 0.69444, 0, 0, 0.88889],
        "9667": [-0.03472, 0.46528, 0, 0, 0.5],
        "9711": [0.19444, 0.69444, 0, 0, 1.0],
        "9824": [0.12963, 0.69444, 0, 0, 0.77778],
        "9825": [0.12963, 0.69444, 0, 0, 0.77778],
        "9826": [0.12963, 0.69444, 0, 0, 0.77778],
        "9827": [0.12963, 0.69444, 0, 0, 0.77778],
        "9837": [0, 0.75, 0, 0, 0.38889],
        "9838": [0.19444, 0.69444, 0, 0, 0.38889],
        "9839": [0.19444, 0.69444, 0, 0, 0.38889],
        "10216": [0.25, 0.75, 0, 0, 0.38889],
        "10217": [0.25, 0.75, 0, 0, 0.38889],
        "10222": [0.244, 0.744, 0, 0, 0.412],
        "10223": [0.244, 0.744, 0, 0, 0.412],
        "10229": [0.011, 0.511, 0, 0, 1.609],
        "10230": [0.011, 0.511, 0, 0, 1.638],
        "10231": [0.011, 0.511, 0, 0, 1.859],
        "10232": [0.024, 0.525, 0, 0, 1.609],
        "10233": [0.024, 0.525, 0, 0, 1.638],
        "10234": [0.024, 0.525, 0, 0, 1.858],
        "10236": [0.011, 0.511, 0, 0, 1.638],
        "10815": [0, 0.68333, 0, 0, 0.75],
        "10927": [0.13597, 0.63597, 0, 0, 0.77778],
        "10928": [0.13597, 0.63597, 0, 0, 0.77778],
        "57376": [0.19444, 0.69444, 0, 0, 0]
      },
      "Math-BoldItalic": {
        "65": [0, 0.68611, 0, 0, 0.86944],
        "66": [0, 0.68611, 0.04835, 0, 0.8664],
        "67": [0, 0.68611, 0.06979, 0, 0.81694],
        "68": [0, 0.68611, 0.03194, 0, 0.93812],
        "69": [0, 0.68611, 0.05451, 0, 0.81007],
        "70": [0, 0.68611, 0.15972, 0, 0.68889],
        "71": [0, 0.68611, 0, 0, 0.88673],
        "72": [0, 0.68611, 0.08229, 0, 0.98229],
        "73": [0, 0.68611, 0.07778, 0, 0.51111],
        "74": [0, 0.68611, 0.10069, 0, 0.63125],
        "75": [0, 0.68611, 0.06979, 0, 0.97118],
        "76": [0, 0.68611, 0, 0, 0.75555],
        "77": [0, 0.68611, 0.11424, 0, 1.14201],
        "78": [0, 0.68611, 0.11424, 0, 0.95034],
        "79": [0, 0.68611, 0.03194, 0, 0.83666],
        "80": [0, 0.68611, 0.15972, 0, 0.72309],
        "81": [0.19444, 0.68611, 0, 0, 0.86861],
        "82": [0, 0.68611, 0.00421, 0, 0.87235],
        "83": [0, 0.68611, 0.05382, 0, 0.69271],
        "84": [0, 0.68611, 0.15972, 0, 0.63663],
        "85": [0, 0.68611, 0.11424, 0, 0.80027],
        "86": [0, 0.68611, 0.25555, 0, 0.67778],
        "87": [0, 0.68611, 0.15972, 0, 1.09305],
        "88": [0, 0.68611, 0.07778, 0, 0.94722],
        "89": [0, 0.68611, 0.25555, 0, 0.67458],
        "90": [0, 0.68611, 0.06979, 0, 0.77257],
        "97": [0, 0.44444, 0, 0, 0.63287],
        "98": [0, 0.69444, 0, 0, 0.52083],
        "99": [0, 0.44444, 0, 0, 0.51342],
        "100": [0, 0.69444, 0, 0, 0.60972],
        "101": [0, 0.44444, 0, 0, 0.55361],
        "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
        "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
        "104": [0, 0.69444, 0, 0, 0.66759],
        "105": [0, 0.69326, 0, 0, 0.4048],
        "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
        "107": [0, 0.69444, 0.01852, 0, 0.6037],
        "108": [0, 0.69444, 0.0088, 0, 0.34815],
        "109": [0, 0.44444, 0, 0, 1.0324],
        "110": [0, 0.44444, 0, 0, 0.71296],
        "111": [0, 0.44444, 0, 0, 0.58472],
        "112": [0.19444, 0.44444, 0, 0, 0.60092],
        "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
        "114": [0, 0.44444, 0.03194, 0, 0.5287],
        "115": [0, 0.44444, 0, 0, 0.53125],
        "116": [0, 0.63492, 0, 0, 0.41528],
        "117": [0, 0.44444, 0, 0, 0.68102],
        "118": [0, 0.44444, 0.03704, 0, 0.56666],
        "119": [0, 0.44444, 0.02778, 0, 0.83148],
        "120": [0, 0.44444, 0, 0, 0.65903],
        "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
        "122": [0, 0.44444, 0.04213, 0, 0.55509],
        "915": [0, 0.68611, 0.15972, 0, 0.65694],
        "916": [0, 0.68611, 0, 0, 0.95833],
        "920": [0, 0.68611, 0.03194, 0, 0.86722],
        "923": [0, 0.68611, 0, 0, 0.80555],
        "926": [0, 0.68611, 0.07458, 0, 0.84125],
        "928": [0, 0.68611, 0.08229, 0, 0.98229],
        "931": [0, 0.68611, 0.05451, 0, 0.88507],
        "933": [0, 0.68611, 0.15972, 0, 0.67083],
        "934": [0, 0.68611, 0, 0, 0.76666],
        "936": [0, 0.68611, 0.11653, 0, 0.71402],
        "937": [0, 0.68611, 0.04835, 0, 0.8789],
        "945": [0, 0.44444, 0, 0, 0.76064],
        "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
        "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
        "948": [0, 0.69444, 0.03819, 0, 0.52222],
        "949": [0, 0.44444, 0, 0, 0.52882],
        "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
        "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
        "952": [0, 0.69444, 0.03194, 0, 0.5618],
        "953": [0, 0.44444, 0, 0, 0.41204],
        "954": [0, 0.44444, 0, 0, 0.66759],
        "955": [0, 0.69444, 0, 0, 0.67083],
        "956": [0.19444, 0.44444, 0, 0, 0.70787],
        "957": [0, 0.44444, 0.06898, 0, 0.57685],
        "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
        "959": [0, 0.44444, 0, 0, 0.58472],
        "960": [0, 0.44444, 0.03704, 0, 0.68241],
        "961": [0.19444, 0.44444, 0, 0, 0.6118],
        "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
        "963": [0, 0.44444, 0.03704, 0, 0.68588],
        "964": [0, 0.44444, 0.13472, 0, 0.52083],
        "965": [0, 0.44444, 0.03704, 0, 0.63055],
        "966": [0.19444, 0.44444, 0, 0, 0.74722],
        "967": [0.19444, 0.44444, 0, 0, 0.71805],
        "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
        "969": [0, 0.44444, 0.03704, 0, 0.71782],
        "977": [0, 0.69444, 0, 0, 0.69155],
        "981": [0.19444, 0.69444, 0, 0, 0.7125],
        "982": [0, 0.44444, 0.03194, 0, 0.975],
        "1009": [0.19444, 0.44444, 0, 0, 0.6118],
        "1013": [0, 0.44444, 0, 0, 0.48333]
      },
      "Math-Italic": {
        "65": [0, 0.68333, 0, 0.13889, 0.75],
        "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
        "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
        "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
        "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
        "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
        "71": [0, 0.68333, 0, 0.08334, 0.78625],
        "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
        "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
        "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
        "76": [0, 0.68333, 0, 0.02778, 0.68056],
        "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
        "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
        "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
        "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
        "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
        "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
        "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
        "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
        "86": [0, 0.68333, 0.22222, 0, 0.58333],
        "87": [0, 0.68333, 0.13889, 0, 0.94445],
        "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
        "89": [0, 0.68333, 0.22222, 0, 0.58056],
        "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
        "97": [0, 0.43056, 0, 0, 0.52859],
        "98": [0, 0.69444, 0, 0, 0.42917],
        "99": [0, 0.43056, 0, 0.05556, 0.43276],
        "100": [0, 0.69444, 0, 0.16667, 0.52049],
        "101": [0, 0.43056, 0, 0.05556, 0.46563],
        "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
        "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
        "104": [0, 0.69444, 0, 0, 0.57616],
        "105": [0, 0.65952, 0, 0, 0.34451],
        "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
        "107": [0, 0.69444, 0.03148, 0, 0.5206],
        "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
        "109": [0, 0.43056, 0, 0, 0.87801],
        "110": [0, 0.43056, 0, 0, 0.60023],
        "111": [0, 0.43056, 0, 0.05556, 0.48472],
        "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
        "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
        "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
        "115": [0, 0.43056, 0, 0.05556, 0.46875],
        "116": [0, 0.61508, 0, 0.08334, 0.36111],
        "117": [0, 0.43056, 0, 0.02778, 0.57246],
        "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
        "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
        "120": [0, 0.43056, 0, 0.02778, 0.57153],
        "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
        "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
        "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
        "916": [0, 0.68333, 0, 0.16667, 0.83334],
        "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "923": [0, 0.68333, 0, 0.16667, 0.69445],
        "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
        "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
        "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
        "934": [0, 0.68333, 0, 0.08334, 0.66667],
        "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
        "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
        "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
        "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
        "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
        "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
        "949": [0, 0.43056, 0, 0.08334, 0.46632],
        "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
        "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
        "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
        "953": [0, 0.43056, 0, 0.05556, 0.35394],
        "954": [0, 0.43056, 0, 0, 0.57616],
        "955": [0, 0.69444, 0, 0, 0.58334],
        "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
        "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
        "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
        "959": [0, 0.43056, 0, 0.05556, 0.48472],
        "960": [0, 0.43056, 0.03588, 0, 0.57003],
        "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
        "963": [0, 0.43056, 0.03588, 0, 0.57141],
        "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
        "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
        "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
        "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
        "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
        "969": [0, 0.43056, 0.03588, 0, 0.62245],
        "977": [0, 0.69444, 0, 0.08334, 0.59144],
        "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
        "982": [0, 0.43056, 0.02778, 0, 0.82813],
        "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "1013": [0, 0.43056, 0, 0.05556, 0.4059]
      },
      "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889, 0.75],
        "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
        "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
        "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
        "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
        "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
        "71": [0, 0.68333, 0, 0.08334, 0.78625],
        "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
        "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
        "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
        "76": [0, 0.68333, 0, 0.02778, 0.68056],
        "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
        "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
        "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
        "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
        "82": [0, 0.68333, 0.00773, 0.08334, 0.75929],
        "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
        "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
        "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
        "86": [0, 0.68333, 0.22222, 0, 0.58333],
        "87": [0, 0.68333, 0.13889, 0, 0.94445],
        "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
        "89": [0, 0.68333, 0.22222, 0, 0.58056],
        "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
        "97": [0, 0.43056, 0, 0, 0.52859],
        "98": [0, 0.69444, 0, 0, 0.42917],
        "99": [0, 0.43056, 0, 0.05556, 0.43276],
        "100": [0, 0.69444, 0, 0.16667, 0.52049],
        "101": [0, 0.43056, 0, 0.05556, 0.46563],
        "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
        "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
        "104": [0, 0.69444, 0, 0, 0.57616],
        "105": [0, 0.65952, 0, 0, 0.34451],
        "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
        "107": [0, 0.69444, 0.03148, 0, 0.5206],
        "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
        "109": [0, 0.43056, 0, 0, 0.87801],
        "110": [0, 0.43056, 0, 0, 0.60023],
        "111": [0, 0.43056, 0, 0.05556, 0.48472],
        "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
        "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
        "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
        "115": [0, 0.43056, 0, 0.05556, 0.46875],
        "116": [0, 0.61508, 0, 0.08334, 0.36111],
        "117": [0, 0.43056, 0, 0.02778, 0.57246],
        "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
        "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
        "120": [0, 0.43056, 0, 0.02778, 0.57153],
        "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
        "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
        "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
        "916": [0, 0.68333, 0, 0.16667, 0.83334],
        "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
        "923": [0, 0.68333, 0, 0.16667, 0.69445],
        "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
        "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
        "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
        "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
        "934": [0, 0.68333, 0, 0.08334, 0.66667],
        "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
        "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
        "945": [0, 0.43056, 0.0037, 0.02778, 0.6397],
        "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
        "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
        "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
        "949": [0, 0.43056, 0, 0.08334, 0.46632],
        "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
        "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
        "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
        "953": [0, 0.43056, 0, 0.05556, 0.35394],
        "954": [0, 0.43056, 0, 0, 0.57616],
        "955": [0, 0.69444, 0, 0, 0.58334],
        "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
        "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
        "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
        "959": [0, 0.43056, 0, 0.05556, 0.48472],
        "960": [0, 0.43056, 0.03588, 0, 0.57003],
        "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
        "963": [0, 0.43056, 0.03588, 0, 0.57141],
        "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
        "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
        "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
        "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
        "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
        "969": [0, 0.43056, 0.03588, 0, 0.62245],
        "977": [0, 0.69444, 0, 0.08334, 0.59144],
        "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
        "982": [0, 0.43056, 0.02778, 0, 0.82813],
        "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
        "1013": [0, 0.43056, 0, 0.05556, 0.4059]
      },
      "SansSerif-Bold": {
        "33": [0, 0.69444, 0, 0, 0.36667],
        "34": [0, 0.69444, 0, 0, 0.55834],
        "35": [0.19444, 0.69444, 0, 0, 0.91667],
        "36": [0.05556, 0.75, 0, 0, 0.55],
        "37": [0.05556, 0.75, 0, 0, 1.02912],
        "38": [0, 0.69444, 0, 0, 0.83056],
        "39": [0, 0.69444, 0, 0, 0.30556],
        "40": [0.25, 0.75, 0, 0, 0.42778],
        "41": [0.25, 0.75, 0, 0, 0.42778],
        "42": [0, 0.75, 0, 0, 0.55],
        "43": [0.11667, 0.61667, 0, 0, 0.85556],
        "44": [0.10556, 0.13056, 0, 0, 0.30556],
        "45": [0, 0.45833, 0, 0, 0.36667],
        "46": [0, 0.13056, 0, 0, 0.30556],
        "47": [0.25, 0.75, 0, 0, 0.55],
        "48": [0, 0.69444, 0, 0, 0.55],
        "49": [0, 0.69444, 0, 0, 0.55],
        "50": [0, 0.69444, 0, 0, 0.55],
        "51": [0, 0.69444, 0, 0, 0.55],
        "52": [0, 0.69444, 0, 0, 0.55],
        "53": [0, 0.69444, 0, 0, 0.55],
        "54": [0, 0.69444, 0, 0, 0.55],
        "55": [0, 0.69444, 0, 0, 0.55],
        "56": [0, 0.69444, 0, 0, 0.55],
        "57": [0, 0.69444, 0, 0, 0.55],
        "58": [0, 0.45833, 0, 0, 0.30556],
        "59": [0.10556, 0.45833, 0, 0, 0.30556],
        "61": [-0.09375, 0.40625, 0, 0, 0.85556],
        "63": [0, 0.69444, 0, 0, 0.51945],
        "64": [0, 0.69444, 0, 0, 0.73334],
        "65": [0, 0.69444, 0, 0, 0.73334],
        "66": [0, 0.69444, 0, 0, 0.73334],
        "67": [0, 0.69444, 0, 0, 0.70278],
        "68": [0, 0.69444, 0, 0, 0.79445],
        "69": [0, 0.69444, 0, 0, 0.64167],
        "70": [0, 0.69444, 0, 0, 0.61111],
        "71": [0, 0.69444, 0, 0, 0.73334],
        "72": [0, 0.69444, 0, 0, 0.79445],
        "73": [0, 0.69444, 0, 0, 0.33056],
        "74": [0, 0.69444, 0, 0, 0.51945],
        "75": [0, 0.69444, 0, 0, 0.76389],
        "76": [0, 0.69444, 0, 0, 0.58056],
        "77": [0, 0.69444, 0, 0, 0.97778],
        "78": [0, 0.69444, 0, 0, 0.79445],
        "79": [0, 0.69444, 0, 0, 0.79445],
        "80": [0, 0.69444, 0, 0, 0.70278],
        "81": [0.10556, 0.69444, 0, 0, 0.79445],
        "82": [0, 0.69444, 0, 0, 0.70278],
        "83": [0, 0.69444, 0, 0, 0.61111],
        "84": [0, 0.69444, 0, 0, 0.73334],
        "85": [0, 0.69444, 0, 0, 0.76389],
        "86": [0, 0.69444, 0.01528, 0, 0.73334],
        "87": [0, 0.69444, 0.01528, 0, 1.03889],
        "88": [0, 0.69444, 0, 0, 0.73334],
        "89": [0, 0.69444, 0.0275, 0, 0.73334],
        "90": [0, 0.69444, 0, 0, 0.67223],
        "91": [0.25, 0.75, 0, 0, 0.34306],
        "93": [0.25, 0.75, 0, 0, 0.34306],
        "94": [0, 0.69444, 0, 0, 0.55],
        "95": [0.35, 0.10833, 0.03056, 0, 0.55],
        "97": [0, 0.45833, 0, 0, 0.525],
        "98": [0, 0.69444, 0, 0, 0.56111],
        "99": [0, 0.45833, 0, 0, 0.48889],
        "100": [0, 0.69444, 0, 0, 0.56111],
        "101": [0, 0.45833, 0, 0, 0.51111],
        "102": [0, 0.69444, 0.07639, 0, 0.33611],
        "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
        "104": [0, 0.69444, 0, 0, 0.56111],
        "105": [0, 0.69444, 0, 0, 0.25556],
        "106": [0.19444, 0.69444, 0, 0, 0.28611],
        "107": [0, 0.69444, 0, 0, 0.53056],
        "108": [0, 0.69444, 0, 0, 0.25556],
        "109": [0, 0.45833, 0, 0, 0.86667],
        "110": [0, 0.45833, 0, 0, 0.56111],
        "111": [0, 0.45833, 0, 0, 0.55],
        "112": [0.19444, 0.45833, 0, 0, 0.56111],
        "113": [0.19444, 0.45833, 0, 0, 0.56111],
        "114": [0, 0.45833, 0.01528, 0, 0.37222],
        "115": [0, 0.45833, 0, 0, 0.42167],
        "116": [0, 0.58929, 0, 0, 0.40417],
        "117": [0, 0.45833, 0, 0, 0.56111],
        "118": [0, 0.45833, 0.01528, 0, 0.5],
        "119": [0, 0.45833, 0.01528, 0, 0.74445],
        "120": [0, 0.45833, 0, 0, 0.5],
        "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
        "122": [0, 0.45833, 0, 0, 0.47639],
        "126": [0.35, 0.34444, 0, 0, 0.55],
        "168": [0, 0.69444, 0, 0, 0.55],
        "176": [0, 0.69444, 0, 0, 0.73334],
        "180": [0, 0.69444, 0, 0, 0.55],
        "184": [0.17014, 0, 0, 0, 0.48889],
        "305": [0, 0.45833, 0, 0, 0.25556],
        "567": [0.19444, 0.45833, 0, 0, 0.28611],
        "710": [0, 0.69444, 0, 0, 0.55],
        "711": [0, 0.63542, 0, 0, 0.55],
        "713": [0, 0.63778, 0, 0, 0.55],
        "728": [0, 0.69444, 0, 0, 0.55],
        "729": [0, 0.69444, 0, 0, 0.30556],
        "730": [0, 0.69444, 0, 0, 0.73334],
        "732": [0, 0.69444, 0, 0, 0.55],
        "733": [0, 0.69444, 0, 0, 0.55],
        "915": [0, 0.69444, 0, 0, 0.58056],
        "916": [0, 0.69444, 0, 0, 0.91667],
        "920": [0, 0.69444, 0, 0, 0.85556],
        "923": [0, 0.69444, 0, 0, 0.67223],
        "926": [0, 0.69444, 0, 0, 0.73334],
        "928": [0, 0.69444, 0, 0, 0.79445],
        "931": [0, 0.69444, 0, 0, 0.79445],
        "933": [0, 0.69444, 0, 0, 0.85556],
        "934": [0, 0.69444, 0, 0, 0.79445],
        "936": [0, 0.69444, 0, 0, 0.85556],
        "937": [0, 0.69444, 0, 0, 0.79445],
        "8211": [0, 0.45833, 0.03056, 0, 0.55],
        "8212": [0, 0.45833, 0.03056, 0, 1.10001],
        "8216": [0, 0.69444, 0, 0, 0.30556],
        "8217": [0, 0.69444, 0, 0, 0.30556],
        "8220": [0, 0.69444, 0, 0, 0.55834],
        "8221": [0, 0.69444, 0, 0, 0.55834]
      },
      "SansSerif-Italic": {
        "33": [0, 0.69444, 0.05733, 0, 0.31945],
        "34": [0, 0.69444, 0.00316, 0, 0.5],
        "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
        "36": [0.05556, 0.75, 0.11156, 0, 0.5],
        "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
        "38": [0, 0.69444, 0.03058, 0, 0.75834],
        "39": [0, 0.69444, 0.07816, 0, 0.27778],
        "40": [0.25, 0.75, 0.13164, 0, 0.38889],
        "41": [0.25, 0.75, 0.02536, 0, 0.38889],
        "42": [0, 0.75, 0.11775, 0, 0.5],
        "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0.01946, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0.13164, 0, 0.5],
        "48": [0, 0.65556, 0.11156, 0, 0.5],
        "49": [0, 0.65556, 0.11156, 0, 0.5],
        "50": [0, 0.65556, 0.11156, 0, 0.5],
        "51": [0, 0.65556, 0.11156, 0, 0.5],
        "52": [0, 0.65556, 0.11156, 0, 0.5],
        "53": [0, 0.65556, 0.11156, 0, 0.5],
        "54": [0, 0.65556, 0.11156, 0, 0.5],
        "55": [0, 0.65556, 0.11156, 0, 0.5],
        "56": [0, 0.65556, 0.11156, 0, 0.5],
        "57": [0, 0.65556, 0.11156, 0, 0.5],
        "58": [0, 0.44444, 0.02502, 0, 0.27778],
        "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
        "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
        "63": [0, 0.69444, 0.11809, 0, 0.47222],
        "64": [0, 0.69444, 0.07555, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0.08293, 0, 0.66667],
        "67": [0, 0.69444, 0.11983, 0, 0.63889],
        "68": [0, 0.69444, 0.07555, 0, 0.72223],
        "69": [0, 0.69444, 0.11983, 0, 0.59722],
        "70": [0, 0.69444, 0.13372, 0, 0.56945],
        "71": [0, 0.69444, 0.11983, 0, 0.66667],
        "72": [0, 0.69444, 0.08094, 0, 0.70834],
        "73": [0, 0.69444, 0.13372, 0, 0.27778],
        "74": [0, 0.69444, 0.08094, 0, 0.47222],
        "75": [0, 0.69444, 0.11983, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0.08094, 0, 0.875],
        "78": [0, 0.69444, 0.08094, 0, 0.70834],
        "79": [0, 0.69444, 0.07555, 0, 0.73611],
        "80": [0, 0.69444, 0.08293, 0, 0.63889],
        "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
        "82": [0, 0.69444, 0.08293, 0, 0.64584],
        "83": [0, 0.69444, 0.09205, 0, 0.55556],
        "84": [0, 0.69444, 0.13372, 0, 0.68056],
        "85": [0, 0.69444, 0.08094, 0, 0.6875],
        "86": [0, 0.69444, 0.1615, 0, 0.66667],
        "87": [0, 0.69444, 0.1615, 0, 0.94445],
        "88": [0, 0.69444, 0.13372, 0, 0.66667],
        "89": [0, 0.69444, 0.17261, 0, 0.66667],
        "90": [0, 0.69444, 0.11983, 0, 0.61111],
        "91": [0.25, 0.75, 0.15942, 0, 0.28889],
        "93": [0.25, 0.75, 0.08719, 0, 0.28889],
        "94": [0, 0.69444, 0.0799, 0, 0.5],
        "95": [0.35, 0.09444, 0.08616, 0, 0.5],
        "97": [0, 0.44444, 0.00981, 0, 0.48056],
        "98": [0, 0.69444, 0.03057, 0, 0.51667],
        "99": [0, 0.44444, 0.08336, 0, 0.44445],
        "100": [0, 0.69444, 0.09483, 0, 0.51667],
        "101": [0, 0.44444, 0.06778, 0, 0.44445],
        "102": [0, 0.69444, 0.21705, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
        "104": [0, 0.69444, 0.01778, 0, 0.51667],
        "105": [0, 0.67937, 0.09718, 0, 0.23889],
        "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
        "107": [0, 0.69444, 0.08336, 0, 0.48889],
        "108": [0, 0.69444, 0.09483, 0, 0.23889],
        "109": [0, 0.44444, 0.01778, 0, 0.79445],
        "110": [0, 0.44444, 0.01778, 0, 0.51667],
        "111": [0, 0.44444, 0.06613, 0, 0.5],
        "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
        "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
        "114": [0, 0.44444, 0.10836, 0, 0.34167],
        "115": [0, 0.44444, 0.0778, 0, 0.38333],
        "116": [0, 0.57143, 0.07225, 0, 0.36111],
        "117": [0, 0.44444, 0.04169, 0, 0.51667],
        "118": [0, 0.44444, 0.10836, 0, 0.46111],
        "119": [0, 0.44444, 0.10836, 0, 0.68334],
        "120": [0, 0.44444, 0.09169, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
        "122": [0, 0.44444, 0.08752, 0, 0.43472],
        "126": [0.35, 0.32659, 0.08826, 0, 0.5],
        "168": [0, 0.67937, 0.06385, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.73752],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0.04169, 0, 0.23889],
        "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
        "710": [0, 0.69444, 0.0799, 0, 0.5],
        "711": [0, 0.63194, 0.08432, 0, 0.5],
        "713": [0, 0.60889, 0.08776, 0, 0.5],
        "714": [0, 0.69444, 0.09205, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0.09483, 0, 0.5],
        "729": [0, 0.67937, 0.07774, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.73752],
        "732": [0, 0.67659, 0.08826, 0, 0.5],
        "733": [0, 0.69444, 0.09205, 0, 0.5],
        "915": [0, 0.69444, 0.13372, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0.07555, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0.12816, 0, 0.66667],
        "928": [0, 0.69444, 0.08094, 0, 0.70834],
        "931": [0, 0.69444, 0.11983, 0, 0.72222],
        "933": [0, 0.69444, 0.09031, 0, 0.77778],
        "934": [0, 0.69444, 0.04603, 0, 0.72222],
        "936": [0, 0.69444, 0.09031, 0, 0.77778],
        "937": [0, 0.69444, 0.08293, 0, 0.72222],
        "8211": [0, 0.44444, 0.08616, 0, 0.5],
        "8212": [0, 0.44444, 0.08616, 0, 1.0],
        "8216": [0, 0.69444, 0.07816, 0, 0.27778],
        "8217": [0, 0.69444, 0.07816, 0, 0.27778],
        "8220": [0, 0.69444, 0.14205, 0, 0.5],
        "8221": [0, 0.69444, 0.00316, 0, 0.5]
      },
      "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0, 0.31945],
        "34": [0, 0.69444, 0, 0, 0.5],
        "35": [0.19444, 0.69444, 0, 0, 0.83334],
        "36": [0.05556, 0.75, 0, 0, 0.5],
        "37": [0.05556, 0.75, 0, 0, 0.83334],
        "38": [0, 0.69444, 0, 0, 0.75834],
        "39": [0, 0.69444, 0, 0, 0.27778],
        "40": [0.25, 0.75, 0, 0, 0.38889],
        "41": [0.25, 0.75, 0, 0, 0.38889],
        "42": [0, 0.75, 0, 0, 0.5],
        "43": [0.08333, 0.58333, 0, 0, 0.77778],
        "44": [0.125, 0.08333, 0, 0, 0.27778],
        "45": [0, 0.44444, 0, 0, 0.33333],
        "46": [0, 0.08333, 0, 0, 0.27778],
        "47": [0.25, 0.75, 0, 0, 0.5],
        "48": [0, 0.65556, 0, 0, 0.5],
        "49": [0, 0.65556, 0, 0, 0.5],
        "50": [0, 0.65556, 0, 0, 0.5],
        "51": [0, 0.65556, 0, 0, 0.5],
        "52": [0, 0.65556, 0, 0, 0.5],
        "53": [0, 0.65556, 0, 0, 0.5],
        "54": [0, 0.65556, 0, 0, 0.5],
        "55": [0, 0.65556, 0, 0, 0.5],
        "56": [0, 0.65556, 0, 0, 0.5],
        "57": [0, 0.65556, 0, 0, 0.5],
        "58": [0, 0.44444, 0, 0, 0.27778],
        "59": [0.125, 0.44444, 0, 0, 0.27778],
        "61": [-0.13, 0.37, 0, 0, 0.77778],
        "63": [0, 0.69444, 0, 0, 0.47222],
        "64": [0, 0.69444, 0, 0, 0.66667],
        "65": [0, 0.69444, 0, 0, 0.66667],
        "66": [0, 0.69444, 0, 0, 0.66667],
        "67": [0, 0.69444, 0, 0, 0.63889],
        "68": [0, 0.69444, 0, 0, 0.72223],
        "69": [0, 0.69444, 0, 0, 0.59722],
        "70": [0, 0.69444, 0, 0, 0.56945],
        "71": [0, 0.69444, 0, 0, 0.66667],
        "72": [0, 0.69444, 0, 0, 0.70834],
        "73": [0, 0.69444, 0, 0, 0.27778],
        "74": [0, 0.69444, 0, 0, 0.47222],
        "75": [0, 0.69444, 0, 0, 0.69445],
        "76": [0, 0.69444, 0, 0, 0.54167],
        "77": [0, 0.69444, 0, 0, 0.875],
        "78": [0, 0.69444, 0, 0, 0.70834],
        "79": [0, 0.69444, 0, 0, 0.73611],
        "80": [0, 0.69444, 0, 0, 0.63889],
        "81": [0.125, 0.69444, 0, 0, 0.73611],
        "82": [0, 0.69444, 0, 0, 0.64584],
        "83": [0, 0.69444, 0, 0, 0.55556],
        "84": [0, 0.69444, 0, 0, 0.68056],
        "85": [0, 0.69444, 0, 0, 0.6875],
        "86": [0, 0.69444, 0.01389, 0, 0.66667],
        "87": [0, 0.69444, 0.01389, 0, 0.94445],
        "88": [0, 0.69444, 0, 0, 0.66667],
        "89": [0, 0.69444, 0.025, 0, 0.66667],
        "90": [0, 0.69444, 0, 0, 0.61111],
        "91": [0.25, 0.75, 0, 0, 0.28889],
        "93": [0.25, 0.75, 0, 0, 0.28889],
        "94": [0, 0.69444, 0, 0, 0.5],
        "95": [0.35, 0.09444, 0.02778, 0, 0.5],
        "97": [0, 0.44444, 0, 0, 0.48056],
        "98": [0, 0.69444, 0, 0, 0.51667],
        "99": [0, 0.44444, 0, 0, 0.44445],
        "100": [0, 0.69444, 0, 0, 0.51667],
        "101": [0, 0.44444, 0, 0, 0.44445],
        "102": [0, 0.69444, 0.06944, 0, 0.30556],
        "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
        "104": [0, 0.69444, 0, 0, 0.51667],
        "105": [0, 0.67937, 0, 0, 0.23889],
        "106": [0.19444, 0.67937, 0, 0, 0.26667],
        "107": [0, 0.69444, 0, 0, 0.48889],
        "108": [0, 0.69444, 0, 0, 0.23889],
        "109": [0, 0.44444, 0, 0, 0.79445],
        "110": [0, 0.44444, 0, 0, 0.51667],
        "111": [0, 0.44444, 0, 0, 0.5],
        "112": [0.19444, 0.44444, 0, 0, 0.51667],
        "113": [0.19444, 0.44444, 0, 0, 0.51667],
        "114": [0, 0.44444, 0.01389, 0, 0.34167],
        "115": [0, 0.44444, 0, 0, 0.38333],
        "116": [0, 0.57143, 0, 0, 0.36111],
        "117": [0, 0.44444, 0, 0, 0.51667],
        "118": [0, 0.44444, 0.01389, 0, 0.46111],
        "119": [0, 0.44444, 0.01389, 0, 0.68334],
        "120": [0, 0.44444, 0, 0, 0.46111],
        "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
        "122": [0, 0.44444, 0, 0, 0.43472],
        "126": [0.35, 0.32659, 0, 0, 0.5],
        "168": [0, 0.67937, 0, 0, 0.5],
        "176": [0, 0.69444, 0, 0, 0.66667],
        "184": [0.17014, 0, 0, 0, 0.44445],
        "305": [0, 0.44444, 0, 0, 0.23889],
        "567": [0.19444, 0.44444, 0, 0, 0.26667],
        "710": [0, 0.69444, 0, 0, 0.5],
        "711": [0, 0.63194, 0, 0, 0.5],
        "713": [0, 0.60889, 0, 0, 0.5],
        "714": [0, 0.69444, 0, 0, 0.5],
        "715": [0, 0.69444, 0, 0, 0.5],
        "728": [0, 0.69444, 0, 0, 0.5],
        "729": [0, 0.67937, 0, 0, 0.27778],
        "730": [0, 0.69444, 0, 0, 0.66667],
        "732": [0, 0.67659, 0, 0, 0.5],
        "733": [0, 0.69444, 0, 0, 0.5],
        "915": [0, 0.69444, 0, 0, 0.54167],
        "916": [0, 0.69444, 0, 0, 0.83334],
        "920": [0, 0.69444, 0, 0, 0.77778],
        "923": [0, 0.69444, 0, 0, 0.61111],
        "926": [0, 0.69444, 0, 0, 0.66667],
        "928": [0, 0.69444, 0, 0, 0.70834],
        "931": [0, 0.69444, 0, 0, 0.72222],
        "933": [0, 0.69444, 0, 0, 0.77778],
        "934": [0, 0.69444, 0, 0, 0.72222],
        "936": [0, 0.69444, 0, 0, 0.77778],
        "937": [0, 0.69444, 0, 0, 0.72222],
        "8211": [0, 0.44444, 0.02778, 0, 0.5],
        "8212": [0, 0.44444, 0.02778, 0, 1.0],
        "8216": [0, 0.69444, 0, 0, 0.27778],
        "8217": [0, 0.69444, 0, 0, 0.27778],
        "8220": [0, 0.69444, 0, 0, 0.5],
        "8221": [0, 0.69444, 0, 0, 0.5]
      },
      "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0, 0.80253],
        "66": [0, 0.7, 0.04087, 0, 0.90757],
        "67": [0, 0.7, 0.1689, 0, 0.66619],
        "68": [0, 0.7, 0.09371, 0, 0.77443],
        "69": [0, 0.7, 0.18583, 0, 0.56162],
        "70": [0, 0.7, 0.13634, 0, 0.89544],
        "71": [0, 0.7, 0.17322, 0, 0.60961],
        "72": [0, 0.7, 0.29694, 0, 0.96919],
        "73": [0, 0.7, 0.19189, 0, 0.80907],
        "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
        "75": [0, 0.7, 0.31259, 0, 0.91364],
        "76": [0, 0.7, 0.19189, 0, 0.87373],
        "77": [0, 0.7, 0.15981, 0, 1.08031],
        "78": [0, 0.7, 0.3525, 0, 0.9015],
        "79": [0, 0.7, 0.08078, 0, 0.73787],
        "80": [0, 0.7, 0.08078, 0, 1.01262],
        "81": [0, 0.7, 0.03305, 0, 0.88282],
        "82": [0, 0.7, 0.06259, 0, 0.85],
        "83": [0, 0.7, 0.19189, 0, 0.86767],
        "84": [0, 0.7, 0.29087, 0, 0.74697],
        "85": [0, 0.7, 0.25815, 0, 0.79996],
        "86": [0, 0.7, 0.27523, 0, 0.62204],
        "87": [0, 0.7, 0.27523, 0, 0.80532],
        "88": [0, 0.7, 0.26006, 0, 0.94445],
        "89": [0, 0.7, 0.2939, 0, 0.70961],
        "90": [0, 0.7, 0.24037, 0, 0.8212]
      },
      "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0, 0.45834],
        "41": [0.35001, 0.85, 0, 0, 0.45834],
        "47": [0.35001, 0.85, 0, 0, 0.57778],
        "91": [0.35001, 0.85, 0, 0, 0.41667],
        "92": [0.35001, 0.85, 0, 0, 0.57778],
        "93": [0.35001, 0.85, 0, 0, 0.41667],
        "123": [0.35001, 0.85, 0, 0, 0.58334],
        "125": [0.35001, 0.85, 0, 0, 0.58334],
        "710": [0, 0.72222, 0, 0, 0.55556],
        "732": [0, 0.72222, 0, 0, 0.55556],
        "770": [0, 0.72222, 0, 0, 0.55556],
        "771": [0, 0.72222, 0, 0, 0.55556],
        "8214": [-0.00099, 0.601, 0, 0, 0.77778],
        "8593": [1e-05, 0.6, 0, 0, 0.66667],
        "8595": [1e-05, 0.6, 0, 0, 0.66667],
        "8657": [1e-05, 0.6, 0, 0, 0.77778],
        "8659": [1e-05, 0.6, 0, 0, 0.77778],
        "8719": [0.25001, 0.75, 0, 0, 0.94445],
        "8720": [0.25001, 0.75, 0, 0, 0.94445],
        "8721": [0.25001, 0.75, 0, 0, 1.05556],
        "8730": [0.35001, 0.85, 0, 0, 1.0],
        "8739": [-0.00599, 0.606, 0, 0, 0.33333],
        "8741": [-0.00599, 0.606, 0, 0, 0.55556],
        "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
        "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
        "8896": [0.25001, 0.75, 0, 0, 0.83334],
        "8897": [0.25001, 0.75, 0, 0, 0.83334],
        "8898": [0.25001, 0.75, 0, 0, 0.83334],
        "8899": [0.25001, 0.75, 0, 0, 0.83334],
        "8968": [0.35001, 0.85, 0, 0, 0.47222],
        "8969": [0.35001, 0.85, 0, 0, 0.47222],
        "8970": [0.35001, 0.85, 0, 0, 0.47222],
        "8971": [0.35001, 0.85, 0, 0, 0.47222],
        "9168": [-0.00099, 0.601, 0, 0, 0.66667],
        "10216": [0.35001, 0.85, 0, 0, 0.47222],
        "10217": [0.35001, 0.85, 0, 0, 0.47222],
        "10752": [0.25001, 0.75, 0, 0, 1.11111],
        "10753": [0.25001, 0.75, 0, 0, 1.11111],
        "10754": [0.25001, 0.75, 0, 0, 1.11111],
        "10756": [0.25001, 0.75, 0, 0, 0.83334],
        "10758": [0.25001, 0.75, 0, 0, 0.83334]
      },
      "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0, 0.59722],
        "41": [0.65002, 1.15, 0, 0, 0.59722],
        "47": [0.65002, 1.15, 0, 0, 0.81111],
        "91": [0.65002, 1.15, 0, 0, 0.47222],
        "92": [0.65002, 1.15, 0, 0, 0.81111],
        "93": [0.65002, 1.15, 0, 0, 0.47222],
        "123": [0.65002, 1.15, 0, 0, 0.66667],
        "125": [0.65002, 1.15, 0, 0, 0.66667],
        "710": [0, 0.75, 0, 0, 1.0],
        "732": [0, 0.75, 0, 0, 1.0],
        "770": [0, 0.75, 0, 0, 1.0],
        "771": [0, 0.75, 0, 0, 1.0],
        "8719": [0.55001, 1.05, 0, 0, 1.27778],
        "8720": [0.55001, 1.05, 0, 0, 1.27778],
        "8721": [0.55001, 1.05, 0, 0, 1.44445],
        "8730": [0.65002, 1.15, 0, 0, 1.0],
        "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
        "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
        "8896": [0.55001, 1.05, 0, 0, 1.11111],
        "8897": [0.55001, 1.05, 0, 0, 1.11111],
        "8898": [0.55001, 1.05, 0, 0, 1.11111],
        "8899": [0.55001, 1.05, 0, 0, 1.11111],
        "8968": [0.65002, 1.15, 0, 0, 0.52778],
        "8969": [0.65002, 1.15, 0, 0, 0.52778],
        "8970": [0.65002, 1.15, 0, 0, 0.52778],
        "8971": [0.65002, 1.15, 0, 0, 0.52778],
        "10216": [0.65002, 1.15, 0, 0, 0.61111],
        "10217": [0.65002, 1.15, 0, 0, 0.61111],
        "10752": [0.55001, 1.05, 0, 0, 1.51112],
        "10753": [0.55001, 1.05, 0, 0, 1.51112],
        "10754": [0.55001, 1.05, 0, 0, 1.51112],
        "10756": [0.55001, 1.05, 0, 0, 1.11111],
        "10758": [0.55001, 1.05, 0, 0, 1.11111]
      },
      "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0, 0.73611],
        "41": [0.95003, 1.45, 0, 0, 0.73611],
        "47": [0.95003, 1.45, 0, 0, 1.04445],
        "91": [0.95003, 1.45, 0, 0, 0.52778],
        "92": [0.95003, 1.45, 0, 0, 1.04445],
        "93": [0.95003, 1.45, 0, 0, 0.52778],
        "123": [0.95003, 1.45, 0, 0, 0.75],
        "125": [0.95003, 1.45, 0, 0, 0.75],
        "710": [0, 0.75, 0, 0, 1.44445],
        "732": [0, 0.75, 0, 0, 1.44445],
        "770": [0, 0.75, 0, 0, 1.44445],
        "771": [0, 0.75, 0, 0, 1.44445],
        "8730": [0.95003, 1.45, 0, 0, 1.0],
        "8968": [0.95003, 1.45, 0, 0, 0.58334],
        "8969": [0.95003, 1.45, 0, 0, 0.58334],
        "8970": [0.95003, 1.45, 0, 0, 0.58334],
        "8971": [0.95003, 1.45, 0, 0, 0.58334],
        "10216": [0.95003, 1.45, 0, 0, 0.75],
        "10217": [0.95003, 1.45, 0, 0, 0.75]
      },
      "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0, 0.79167],
        "41": [1.25003, 1.75, 0, 0, 0.79167],
        "47": [1.25003, 1.75, 0, 0, 1.27778],
        "91": [1.25003, 1.75, 0, 0, 0.58334],
        "92": [1.25003, 1.75, 0, 0, 1.27778],
        "93": [1.25003, 1.75, 0, 0, 0.58334],
        "123": [1.25003, 1.75, 0, 0, 0.80556],
        "125": [1.25003, 1.75, 0, 0, 0.80556],
        "710": [0, 0.825, 0, 0, 1.8889],
        "732": [0, 0.825, 0, 0, 1.8889],
        "770": [0, 0.825, 0, 0, 1.8889],
        "771": [0, 0.825, 0, 0, 1.8889],
        "8730": [1.25003, 1.75, 0, 0, 1.0],
        "8968": [1.25003, 1.75, 0, 0, 0.63889],
        "8969": [1.25003, 1.75, 0, 0, 0.63889],
        "8970": [1.25003, 1.75, 0, 0, 0.63889],
        "8971": [1.25003, 1.75, 0, 0, 0.63889],
        "9115": [0.64502, 1.155, 0, 0, 0.875],
        "9116": [1e-05, 0.6, 0, 0, 0.875],
        "9117": [0.64502, 1.155, 0, 0, 0.875],
        "9118": [0.64502, 1.155, 0, 0, 0.875],
        "9119": [1e-05, 0.6, 0, 0, 0.875],
        "9120": [0.64502, 1.155, 0, 0, 0.875],
        "9121": [0.64502, 1.155, 0, 0, 0.66667],
        "9122": [-0.00099, 0.601, 0, 0, 0.66667],
        "9123": [0.64502, 1.155, 0, 0, 0.66667],
        "9124": [0.64502, 1.155, 0, 0, 0.66667],
        "9125": [-0.00099, 0.601, 0, 0, 0.66667],
        "9126": [0.64502, 1.155, 0, 0, 0.66667],
        "9127": [1e-05, 0.9, 0, 0, 0.88889],
        "9128": [0.65002, 1.15, 0, 0, 0.88889],
        "9129": [0.90001, 0, 0, 0, 0.88889],
        "9130": [0, 0.3, 0, 0, 0.88889],
        "9131": [1e-05, 0.9, 0, 0, 0.88889],
        "9132": [0.65002, 1.15, 0, 0, 0.88889],
        "9133": [0.90001, 0, 0, 0, 0.88889],
        "9143": [0.88502, 0.915, 0, 0, 1.05556],
        "10216": [1.25003, 1.75, 0, 0, 0.80556],
        "10217": [1.25003, 1.75, 0, 0, 0.80556],
        "57344": [-0.00499, 0.605, 0, 0, 1.05556],
        "57345": [-0.00499, 0.605, 0, 0, 1.05556],
        "57680": [0, 0.12, 0, 0, 0.45],
        "57681": [0, 0.12, 0, 0, 0.45],
        "57682": [0, 0.12, 0, 0, 0.45],
        "57683": [0, 0.12, 0, 0, 0.45]
      },
      "Typewriter-Regular": {
        "32": [0, 0, 0, 0, 0.525],
        "33": [0, 0.61111, 0, 0, 0.525],
        "34": [0, 0.61111, 0, 0, 0.525],
        "35": [0, 0.61111, 0, 0, 0.525],
        "36": [0.08333, 0.69444, 0, 0, 0.525],
        "37": [0.08333, 0.69444, 0, 0, 0.525],
        "38": [0, 0.61111, 0, 0, 0.525],
        "39": [0, 0.61111, 0, 0, 0.525],
        "40": [0.08333, 0.69444, 0, 0, 0.525],
        "41": [0.08333, 0.69444, 0, 0, 0.525],
        "42": [0, 0.52083, 0, 0, 0.525],
        "43": [-0.08056, 0.53055, 0, 0, 0.525],
        "44": [0.13889, 0.125, 0, 0, 0.525],
        "45": [-0.08056, 0.53055, 0, 0, 0.525],
        "46": [0, 0.125, 0, 0, 0.525],
        "47": [0.08333, 0.69444, 0, 0, 0.525],
        "48": [0, 0.61111, 0, 0, 0.525],
        "49": [0, 0.61111, 0, 0, 0.525],
        "50": [0, 0.61111, 0, 0, 0.525],
        "51": [0, 0.61111, 0, 0, 0.525],
        "52": [0, 0.61111, 0, 0, 0.525],
        "53": [0, 0.61111, 0, 0, 0.525],
        "54": [0, 0.61111, 0, 0, 0.525],
        "55": [0, 0.61111, 0, 0, 0.525],
        "56": [0, 0.61111, 0, 0, 0.525],
        "57": [0, 0.61111, 0, 0, 0.525],
        "58": [0, 0.43056, 0, 0, 0.525],
        "59": [0.13889, 0.43056, 0, 0, 0.525],
        "60": [-0.05556, 0.55556, 0, 0, 0.525],
        "61": [-0.19549, 0.41562, 0, 0, 0.525],
        "62": [-0.05556, 0.55556, 0, 0, 0.525],
        "63": [0, 0.61111, 0, 0, 0.525],
        "64": [0, 0.61111, 0, 0, 0.525],
        "65": [0, 0.61111, 0, 0, 0.525],
        "66": [0, 0.61111, 0, 0, 0.525],
        "67": [0, 0.61111, 0, 0, 0.525],
        "68": [0, 0.61111, 0, 0, 0.525],
        "69": [0, 0.61111, 0, 0, 0.525],
        "70": [0, 0.61111, 0, 0, 0.525],
        "71": [0, 0.61111, 0, 0, 0.525],
        "72": [0, 0.61111, 0, 0, 0.525],
        "73": [0, 0.61111, 0, 0, 0.525],
        "74": [0, 0.61111, 0, 0, 0.525],
        "75": [0, 0.61111, 0, 0, 0.525],
        "76": [0, 0.61111, 0, 0, 0.525],
        "77": [0, 0.61111, 0, 0, 0.525],
        "78": [0, 0.61111, 0, 0, 0.525],
        "79": [0, 0.61111, 0, 0, 0.525],
        "80": [0, 0.61111, 0, 0, 0.525],
        "81": [0.13889, 0.61111, 0, 0, 0.525],
        "82": [0, 0.61111, 0, 0, 0.525],
        "83": [0, 0.61111, 0, 0, 0.525],
        "84": [0, 0.61111, 0, 0, 0.525],
        "85": [0, 0.61111, 0, 0, 0.525],
        "86": [0, 0.61111, 0, 0, 0.525],
        "87": [0, 0.61111, 0, 0, 0.525],
        "88": [0, 0.61111, 0, 0, 0.525],
        "89": [0, 0.61111, 0, 0, 0.525],
        "90": [0, 0.61111, 0, 0, 0.525],
        "91": [0.08333, 0.69444, 0, 0, 0.525],
        "92": [0.08333, 0.69444, 0, 0, 0.525],
        "93": [0.08333, 0.69444, 0, 0, 0.525],
        "94": [0, 0.61111, 0, 0, 0.525],
        "95": [0.09514, 0, 0, 0, 0.525],
        "96": [0, 0.61111, 0, 0, 0.525],
        "97": [0, 0.43056, 0, 0, 0.525],
        "98": [0, 0.61111, 0, 0, 0.525],
        "99": [0, 0.43056, 0, 0, 0.525],
        "100": [0, 0.61111, 0, 0, 0.525],
        "101": [0, 0.43056, 0, 0, 0.525],
        "102": [0, 0.61111, 0, 0, 0.525],
        "103": [0.22222, 0.43056, 0, 0, 0.525],
        "104": [0, 0.61111, 0, 0, 0.525],
        "105": [0, 0.61111, 0, 0, 0.525],
        "106": [0.22222, 0.61111, 0, 0, 0.525],
        "107": [0, 0.61111, 0, 0, 0.525],
        "108": [0, 0.61111, 0, 0, 0.525],
        "109": [0, 0.43056, 0, 0, 0.525],
        "110": [0, 0.43056, 0, 0, 0.525],
        "111": [0, 0.43056, 0, 0, 0.525],
        "112": [0.22222, 0.43056, 0, 0, 0.525],
        "113": [0.22222, 0.43056, 0, 0, 0.525],
        "114": [0, 0.43056, 0, 0, 0.525],
        "115": [0, 0.43056, 0, 0, 0.525],
        "116": [0, 0.55358, 0, 0, 0.525],
        "117": [0, 0.43056, 0, 0, 0.525],
        "118": [0, 0.43056, 0, 0, 0.525],
        "119": [0, 0.43056, 0, 0, 0.525],
        "120": [0, 0.43056, 0, 0, 0.525],
        "121": [0.22222, 0.43056, 0, 0, 0.525],
        "122": [0, 0.43056, 0, 0, 0.525],
        "123": [0.08333, 0.69444, 0, 0, 0.525],
        "124": [0.08333, 0.69444, 0, 0, 0.525],
        "125": [0.08333, 0.69444, 0, 0, 0.525],
        "126": [0, 0.61111, 0, 0, 0.525],
        "127": [0, 0.61111, 0, 0, 0.525],
        "160": [0, 0, 0, 0, 0.525],
        "176": [0, 0.61111, 0, 0, 0.525],
        "184": [0.19445, 0, 0, 0, 0.525],
        "305": [0, 0.43056, 0, 0, 0.525],
        "567": [0.22222, 0.43056, 0, 0, 0.525],
        "711": [0, 0.56597, 0, 0, 0.525],
        "713": [0, 0.56555, 0, 0, 0.525],
        "714": [0, 0.61111, 0, 0, 0.525],
        "715": [0, 0.61111, 0, 0, 0.525],
        "728": [0, 0.61111, 0, 0, 0.525],
        "730": [0, 0.61111, 0, 0, 0.525],
        "770": [0, 0.61111, 0, 0, 0.525],
        "771": [0, 0.61111, 0, 0, 0.525],
        "776": [0, 0.61111, 0, 0, 0.525],
        "915": [0, 0.61111, 0, 0, 0.525],
        "916": [0, 0.61111, 0, 0, 0.525],
        "920": [0, 0.61111, 0, 0, 0.525],
        "923": [0, 0.61111, 0, 0, 0.525],
        "926": [0, 0.61111, 0, 0, 0.525],
        "928": [0, 0.61111, 0, 0, 0.525],
        "931": [0, 0.61111, 0, 0, 0.525],
        "933": [0, 0.61111, 0, 0, 0.525],
        "934": [0, 0.61111, 0, 0, 0.525],
        "936": [0, 0.61111, 0, 0, 0.525],
        "937": [0, 0.61111, 0, 0, 0.525],
        "8216": [0, 0.61111, 0, 0, 0.525],
        "8217": [0, 0.61111, 0, 0, 0.525],
        "8242": [0, 0.61111, 0, 0, 0.525],
        "9251": [0.11111, 0.21944, 0, 0, 0.525]
      }
    };

    /**
     * This file contains metrics regarding fonts and individual symbols. The sigma
     * and xi variables, as well as the metricMap map contain data extracted from
     * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
     * `metrics` variable and the getCharacterMetrics function.
     */
    // In TeX, there are actually three sets of dimensions, one for each of
    // textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:
    // 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are
    // provided in the the arrays below, in that order.
    //
    // The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
    // This was determined by running the following script:
    //
    //     latex -interaction=nonstopmode \
    //     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
    //     '$a$ \expandafter\show\the\textfont2' \
    //     '\expandafter\show\the\scriptfont2' \
    //     '\expandafter\show\the\scriptscriptfont2' \
    //     '\stop'
    //
    // The metrics themselves were retreived using the following commands:
    //
    //     tftopl cmsy10
    //     tftopl cmsy7
    //     tftopl cmsy5
    //
    // The output of each of these commands is quite lengthy.  The only part we
    // care about is the FONTDIMEN section. Each value is measured in EMs.
    const sigmasAndXis = {
      slant: [0.250, 0.250, 0.250],
      // sigma1
      space: [0.000, 0.000, 0.000],
      // sigma2
      stretch: [0.000, 0.000, 0.000],
      // sigma3
      shrink: [0.000, 0.000, 0.000],
      // sigma4
      xHeight: [0.431, 0.431, 0.431],
      // sigma5
      quad: [1.000, 1.171, 1.472],
      // sigma6
      extraSpace: [0.000, 0.000, 0.000],
      // sigma7
      num1: [0.677, 0.732, 0.925],
      // sigma8
      num2: [0.394, 0.384, 0.387],
      // sigma9
      num3: [0.444, 0.471, 0.504],
      // sigma10
      denom1: [0.686, 0.752, 1.025],
      // sigma11
      denom2: [0.345, 0.344, 0.532],
      // sigma12
      sup1: [0.413, 0.503, 0.504],
      // sigma13
      sup2: [0.363, 0.431, 0.404],
      // sigma14
      sup3: [0.289, 0.286, 0.294],
      // sigma15
      sub1: [0.150, 0.143, 0.200],
      // sigma16
      sub2: [0.247, 0.286, 0.400],
      // sigma17
      supDrop: [0.386, 0.353, 0.494],
      // sigma18
      subDrop: [0.050, 0.071, 0.100],
      // sigma19
      delim1: [2.390, 1.700, 1.980],
      // sigma20
      delim2: [1.010, 1.157, 1.420],
      // sigma21
      axisHeight: [0.250, 0.250, 0.250],
      // sigma22
      // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
      // they correspond to the font parameters of the extension fonts (family 3).
      // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
      // match cmex7, we'd use cmex7.tfm values for script and scriptscript
      // values.
      defaultRuleThickness: [0.04, 0.049, 0.049],
      // xi8; cmex7: 0.049
      bigOpSpacing1: [0.111, 0.111, 0.111],
      // xi9
      bigOpSpacing2: [0.166, 0.166, 0.166],
      // xi10
      bigOpSpacing3: [0.2, 0.2, 0.2],
      // xi11
      bigOpSpacing4: [0.6, 0.611, 0.611],
      // xi12; cmex7: 0.611
      bigOpSpacing5: [0.1, 0.143, 0.143],
      // xi13; cmex7: 0.143
      // The \sqrt rule width is taken from the height of the surd character.
      // Since we use the same font at all sizes, this thickness doesn't scale.
      sqrtRuleThickness: [0.04, 0.04, 0.04],
      // This value determines how large a pt is, for metrics which are defined
      // in terms of pts.
      // This value is also used in katex.less; if you change it make sure the
      // values match.
      ptPerEm: [10.0, 10.0, 10.0],
      // The space between adjacent `|` columns in an array definition. From
      // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
      doubleRuleSep: [0.2, 0.2, 0.2]
    }; // This map contains a mapping from font name and character code to character
    // should have Latin-1 and Cyrillic characters, but may not depending on the
    // operating system.  The metrics do not account for extra height from the
    // accents.  In the case of Cyrillic characters which have both ascenders and
    // descenders we prefer approximations with ascenders, primarily to prevent
    // the fraction bar or root line from intersecting the glyph.
    // TODO(kevinb) allow union of multiple glyph metrics for better accuracy.

    const extraCharacterMap = {
      // Latin-1
      'Å': 'A',
      'Ç': 'C',
      'Ð': 'D',
      'Þ': 'o',
      'å': 'a',
      'ç': 'c',
      'ð': 'd',
      'þ': 'o',
      // Cyrillic
      'А': 'A',
      'Б': 'B',
      'В': 'B',
      'Г': 'F',
      'Д': 'A',
      'Е': 'E',
      'Ж': 'K',
      'З': '3',
      'И': 'N',
      'Й': 'N',
      'К': 'K',
      'Л': 'N',
      'М': 'M',
      'Н': 'H',
      'О': 'O',
      'П': 'N',
      'Р': 'P',
      'С': 'C',
      'Т': 'T',
      'У': 'y',
      'Ф': 'O',
      'Х': 'X',
      'Ц': 'U',
      'Ч': 'h',
      'Ш': 'W',
      'Щ': 'W',
      'Ъ': 'B',
      'Ы': 'X',
      'Ь': 'B',
      'Э': '3',
      'Ю': 'X',
      'Я': 'R',
      'а': 'a',
      'б': 'b',
      'в': 'a',
      'г': 'r',
      'д': 'y',
      'е': 'e',
      'ж': 'm',
      'з': 'e',
      'и': 'n',
      'й': 'n',
      'к': 'n',
      'л': 'n',
      'м': 'm',
      'н': 'n',
      'о': 'o',
      'п': 'n',
      'р': 'p',
      'с': 'c',
      'т': 'o',
      'у': 'y',
      'ф': 'b',
      'х': 'x',
      'ц': 'n',
      'ч': 'n',
      'ш': 'w',
      'щ': 'w',
      'ъ': 'a',
      'ы': 'm',
      'ь': 'a',
      'э': 'e',
      'ю': 'm',
      'я': 'r'
    };

    /**
     * This function adds new font metrics to default metricMap
     * It can also override existing metrics
     */
    function setFontMetrics(fontName, metrics) {
      metricMap[fontName] = metrics;
    }
    /**
     * This function is a convenience function for looking up information in the
     * metricMap table. It takes a character as a string, and a font.
     *
     * Note: the `width` property may be undefined if fontMetricsData.js wasn't
     * built using `Make extended_metrics`.
     */

    function getCharacterMetrics(character, font, mode) {
      if (!metricMap[font]) {
        throw new Error(`Font metrics not found for font: ${font}.`);
      }

      let ch = character.charCodeAt(0);

      if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
      }

      let metrics = metricMap[font][ch];

      if (!metrics && mode === 'text') {
        // We don't typically have font metrics for Asian scripts.
        // But since we support them in text mode, we need to return
        // some sort of metrics.
        // So if the character is in a script we support but we
        // don't have metrics for it, just use the metrics for
        // the Latin capital letter M. This is close enough because
        // we (currently) only care about the height of the glpyh
        // not its width.
        if (supportedCodepoint(ch)) {
          metrics = metricMap[font][77]; // 77 is the charcode for 'M'
        }
      }

      if (metrics) {
        return {
          depth: metrics[0],
          height: metrics[1],
          italic: metrics[2],
          skew: metrics[3],
          width: metrics[4]
        };
      }
    }
    const fontMetricsBySizeIndex = {};
    /**
     * Get the font metrics for a given size.
     */

    function getGlobalMetrics(size) {
      let sizeIndex;

      if (size >= 5) {
        sizeIndex = 0;
      } else if (size >= 3) {
        sizeIndex = 1;
      } else {
        sizeIndex = 2;
      }

      if (!fontMetricsBySizeIndex[sizeIndex]) {
        const metrics = fontMetricsBySizeIndex[sizeIndex] = {
          cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
        };

        for (const key in sigmasAndXis) {
          if (sigmasAndXis.hasOwnProperty(key)) {
            metrics[key] = sigmasAndXis[key][sizeIndex];
          }
        }
      }

      return fontMetricsBySizeIndex[sizeIndex];
    }

    /**
     * This file holds a list of all no-argument functions and single-character
     * symbols (like 'a' or ';').
     *
     * For each of the symbols, there are three properties they can have:
     * - font (required): the font to be used for this symbol. Either "main" (the
         normal font), or "ams" (the ams fonts).
     * - group (required): the ParseNode group type the symbol should have (i.e.
         "textord", "mathord", etc).
         See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types
     * - replace: the character that this symbol or function should be
     *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
     *   character in the main font).
     *
     * The outermost map in the table indicates what mode the symbols should be
     * accepted in (e.g. "math" or "text").
     */
    // Some of these have a "-token" suffix since these are also used as `ParseNode`
    // types for raw text tokens, and we want to avoid conflicts with higher-level
    // `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
    // looking up the `symbols` map.
    const ATOMS = {
      "bin": 1,
      "close": 1,
      "inner": 1,
      "open": 1,
      "punct": 1,
      "rel": 1
    };
    const NON_ATOMS = {
      "accent-token": 1,
      "mathord": 1,
      "op-token": 1,
      "spacing": 1,
      "textord": 1
    };
    const symbols = {
      "math": {},
      "text": {}
    };
    /** `acceptUnicodeChar = true` is only applicable if `replace` is set. */

    function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
      symbols[mode][name] = {
        font,
        group,
        replace
      };

      if (acceptUnicodeChar && replace) {
        symbols[mode][replace] = symbols[mode][name];
      }
    } // Some abbreviations for commonly used strings.
    // This helps minify the code, and also spotting typos using jshint.
    // modes:

    const math = "math";
    const text$1 = "text"; // fonts:

    const main = "main";
    const ams = "ams"; // groups:

    const accent = "accent-token";
    const bin = "bin";
    const close = "close";
    const inner = "inner";
    const mathord = "mathord";
    const op = "op-token";
    const open = "open";
    const punct = "punct";
    const rel = "rel";
    const spacing = "spacing";
    const textord = "textord"; // Now comes the symbol table
    // Relation Symbols

    defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
    defineSymbol(math, main, rel, "\u227a", "\\prec", true);
    defineSymbol(math, main, rel, "\u227b", "\\succ", true);
    defineSymbol(math, main, rel, "\u223c", "\\sim", true);
    defineSymbol(math, main, rel, "\u22a5", "\\perp");
    defineSymbol(math, main, rel, "\u2aaf", "\\preceq", true);
    defineSymbol(math, main, rel, "\u2ab0", "\\succeq", true);
    defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
    defineSymbol(math, main, rel, "\u2223", "\\mid", true);
    defineSymbol(math, main, rel, "\u226a", "\\ll", true);
    defineSymbol(math, main, rel, "\u226b", "\\gg", true);
    defineSymbol(math, main, rel, "\u224d", "\\asymp", true);
    defineSymbol(math, main, rel, "\u2225", "\\parallel");
    defineSymbol(math, main, rel, "\u22c8", "\\bowtie", true);
    defineSymbol(math, main, rel, "\u2323", "\\smile", true);
    defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
    defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
    defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
    defineSymbol(math, main, rel, "\u2322", "\\frown", true);
    defineSymbol(math, main, rel, "\u220b", "\\ni", true);
    defineSymbol(math, main, rel, "\u221d", "\\propto", true);
    defineSymbol(math, main, rel, "\u22a2", "\\vdash", true);
    defineSymbol(math, main, rel, "\u22a3", "\\dashv", true);
    defineSymbol(math, main, rel, "\u220b", "\\owns"); // Punctuation

    defineSymbol(math, main, punct, "\u002e", "\\ldotp");
    defineSymbol(math, main, punct, "\u22c5", "\\cdotp"); // Misc Symbols

    defineSymbol(math, main, textord, "\u0023", "\\#");
    defineSymbol(text$1, main, textord, "\u0023", "\\#");
    defineSymbol(math, main, textord, "\u0026", "\\&");
    defineSymbol(text$1, main, textord, "\u0026", "\\&");
    defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
    defineSymbol(math, main, textord, "\u2200", "\\forall", true);
    defineSymbol(math, main, textord, "\u210f", "\\hbar", true);
    defineSymbol(math, main, textord, "\u2203", "\\exists", true);
    defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
    defineSymbol(math, main, textord, "\u266d", "\\flat", true);
    defineSymbol(math, main, textord, "\u2113", "\\ell", true);
    defineSymbol(math, main, textord, "\u266e", "\\natural", true);
    defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
    defineSymbol(math, main, textord, "\u2118", "\\wp", true);
    defineSymbol(math, main, textord, "\u266f", "\\sharp", true);
    defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
    defineSymbol(math, main, textord, "\u211c", "\\Re", true);
    defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
    defineSymbol(math, main, textord, "\u2111", "\\Im", true);
    defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
    defineSymbol(text$1, main, textord, "\u00a7", "\\S", true);
    defineSymbol(text$1, main, textord, "\u00b6", "\\P", true); // Math and Text

    defineSymbol(math, main, textord, "\u2020", "\\dag");
    defineSymbol(text$1, main, textord, "\u2020", "\\dag");
    defineSymbol(text$1, main, textord, "\u2020", "\\textdagger");
    defineSymbol(math, main, textord, "\u2021", "\\ddag");
    defineSymbol(text$1, main, textord, "\u2021", "\\ddag");
    defineSymbol(text$1, main, textord, "\u2021", "\\textdaggerdbl"); // Large Delimiters

    defineSymbol(math, main, close, "\u23b1", "\\rmoustache", true);
    defineSymbol(math, main, open, "\u23b0", "\\lmoustache", true);
    defineSymbol(math, main, close, "\u27ef", "\\rgroup", true);
    defineSymbol(math, main, open, "\u27ee", "\\lgroup", true); // Binary Operators

    defineSymbol(math, main, bin, "\u2213", "\\mp", true);
    defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
    defineSymbol(math, main, bin, "\u228e", "\\uplus", true);
    defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
    defineSymbol(math, main, bin, "\u2217", "\\ast");
    defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
    defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
    defineSymbol(math, main, bin, "\u2219", "\\bullet");
    defineSymbol(math, main, bin, "\u2021", "\\ddagger");
    defineSymbol(math, main, bin, "\u2240", "\\wr", true);
    defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
    defineSymbol(math, main, bin, "\u0026", "\\And"); // from amsmath
    // Arrow Symbols

    defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow", true);
    defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow", true);
    defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow", true);
    defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow", true);
    defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow", true);
    defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow", true);
    defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow", true);
    defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow", true);
    defineSymbol(math, main, rel, "\u21a6", "\\mapsto", true);
    defineSymbol(math, main, rel, "\u27fc", "\\longmapsto", true);
    defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
    defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow", true);
    defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow", true);
    defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
    defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup", true);
    defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup", true);
    defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
    defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown", true);
    defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown", true);
    defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
    defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons", true); // AMS Negated Binary Relations

    defineSymbol(math, ams, rel, "\u226e", "\\nless", true);
    defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
    defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
    defineSymbol(math, ams, rel, "\u2a87", "\\lneq", true);
    defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
    defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
    defineSymbol(math, ams, rel, "\u22e6", "\\lnsim", true);
    defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox", true);
    defineSymbol(math, ams, rel, "\u2280", "\\nprec", true); // unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u22e0", "\\npreceq", true);
    defineSymbol(math, ams, rel, "\u22e8", "\\precnsim", true);
    defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox", true);
    defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
    defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
    defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
    defineSymbol(math, ams, rel, "\u22ac", "\\nvdash", true);
    defineSymbol(math, ams, rel, "\u22ad", "\\nvDash", true);
    defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
    defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq", true);
    defineSymbol(math, ams, rel, "\u228a", "\\subsetneq", true);
    defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
    defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq", true);
    defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
    defineSymbol(math, ams, rel, "\u226f", "\\ngtr", true);
    defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
    defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
    defineSymbol(math, ams, rel, "\u2a88", "\\gneq", true);
    defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
    defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
    defineSymbol(math, ams, rel, "\u22e7", "\\gnsim", true);
    defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox", true);
    defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true); // unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq", true);
    defineSymbol(math, ams, rel, "\u22e9", "\\succnsim", true);
    defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox", true); // unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
    defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
    defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
    defineSymbol(math, ams, rel, "\u22af", "\\nVDash", true);
    defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
    defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq", true);
    defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
    defineSymbol(math, ams, rel, "\u228b", "\\supsetneq", true);
    defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
    defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq", true);
    defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
    defineSymbol(math, ams, rel, "\u22ae", "\\nVdash", true);
    defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq", true);
    defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq", true);
    defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
    defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
    defineSymbol(math, ams, bin, "\u22b5", "\\unrhd"); // AMS Negated Arrows

    defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow", true);
    defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow", true);
    defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow", true);
    defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow", true);
    defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow", true);
    defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow", true); // AMS Misc

    defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
    defineSymbol(math, ams, textord, "\u210f", "\\hslash");
    defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
    defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
    defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
    defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(text$1, ams, textord, "\u00ae", "\\circledR");
    defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
    defineSymbol(math, ams, textord, "\u2204", "\\nexists");
    defineSymbol(math, ams, textord, "\u2127", "\\mho");
    defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
    defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
    defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
    defineSymbol(math, ams, textord, "\u2035", "\\backprime");
    defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
    defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
    defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
    defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
    defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
    defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
    defineSymbol(math, ams, textord, "\u2201", "\\complement", true); // unicode-math maps U+F0 (ð) to \matheth. We map to AMS function \eth

    defineSymbol(math, ams, textord, "\u00f0", "\\eth", true);
    defineSymbol(math, ams, textord, "\u2571", "\\diagup");
    defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
    defineSymbol(math, ams, textord, "\u25a1", "\\square");
    defineSymbol(math, ams, textord, "\u25a1", "\\Box");
    defineSymbol(math, ams, textord, "\u25ca", "\\Diamond"); // unicode-math maps U+A5 to \mathyen. We map to AMS function \yen

    defineSymbol(math, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(text$1, ams, textord, "\u00a5", "\\yen", true);
    defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
    defineSymbol(text$1, ams, textord, "\u2713", "\\checkmark"); // AMS Hebrew

    defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
    defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
    defineSymbol(math, ams, textord, "\u2137", "\\gimel", true); // AMS Greek

    defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
    defineSymbol(math, ams, textord, "\u03f0", "\\varkappa"); // AMS Delimiters

    defineSymbol(math, ams, open, "\u250c", "\\ulcorner", true);
    defineSymbol(math, ams, close, "\u2510", "\\urcorner", true);
    defineSymbol(math, ams, open, "\u2514", "\\llcorner", true);
    defineSymbol(math, ams, close, "\u2518", "\\lrcorner", true); // AMS Binary Relations

    defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
    defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant", true);
    defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless", true);
    defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
    defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox", true);
    defineSymbol(math, ams, rel, "\u224a", "\\approxeq", true);
    defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
    defineSymbol(math, ams, rel, "\u22d8", "\\lll", true);
    defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
    defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr", true);
    defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr", true);
    defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
    defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
    defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
    defineSymbol(math, ams, rel, "\u223d", "\\backsim", true);
    defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq", true);
    defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq", true);
    defineSymbol(math, ams, rel, "\u22d0", "\\Subset", true);
    defineSymbol(math, ams, rel, "\u228f", "\\sqsubset", true);
    defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq", true);
    defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec", true);
    defineSymbol(math, ams, rel, "\u227e", "\\precsim", true);
    defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox", true);
    defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
    defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
    defineSymbol(math, ams, rel, "\u22a8", "\\vDash", true);
    defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash", true);
    defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
    defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
    defineSymbol(math, ams, rel, "\u224f", "\\bumpeq", true);
    defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq", true);
    defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
    defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant", true);
    defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr", true);
    defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
    defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox", true);
    defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
    defineSymbol(math, ams, rel, "\u22d9", "\\ggg", true);
    defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
    defineSymbol(math, ams, rel, "\u22db", "\\gtreqless", true);
    defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless", true);
    defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
    defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
    defineSymbol(math, ams, rel, "\u225c", "\\triangleq", true);
    defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
    defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
    defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq", true);
    defineSymbol(math, ams, rel, "\u22d1", "\\Supset", true);
    defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
    defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq", true);
    defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc", true);
    defineSymbol(math, ams, rel, "\u227f", "\\succsim", true);
    defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox", true);
    defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
    defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
    defineSymbol(math, ams, rel, "\u22a9", "\\Vdash", true);
    defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
    defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
    defineSymbol(math, ams, rel, "\u226c", "\\between", true);
    defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork", true);
    defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
    defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft"); // unicode-math says that \therefore is a mathord atom.
    // We kept the amssymb atom type, which is rel.

    defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
    defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
    defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright"); // unicode-math says that \because is a mathord atom.
    // We kept the amssymb atom type, which is rel.

    defineSymbol(math, ams, rel, "\u2235", "\\because", true);
    defineSymbol(math, ams, rel, "\u22d8", "\\llless");
    defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
    defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
    defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
    defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
    defineSymbol(math, main, rel, "\u22c8", "\\Join");
    defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true); // AMS Binary Operators

    defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
    defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
    defineSymbol(math, ams, bin, "\u22d2", "\\Cap", true);
    defineSymbol(math, ams, bin, "\u22d3", "\\Cup", true);
    defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge", true);
    defineSymbol(math, ams, bin, "\u229f", "\\boxminus", true);
    defineSymbol(math, ams, bin, "\u229e", "\\boxplus", true);
    defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes", true);
    defineSymbol(math, ams, bin, "\u22c9", "\\ltimes", true);
    defineSymbol(math, ams, bin, "\u22ca", "\\rtimes", true);
    defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes", true);
    defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge", true);
    defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee", true);
    defineSymbol(math, ams, bin, "\u229d", "\\circleddash", true);
    defineSymbol(math, ams, bin, "\u229b", "\\circledast", true);
    defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
    defineSymbol(math, ams, bin, "\u22ba", "\\intercal", true);
    defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
    defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
    defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes", true); // AMS Arrows
    // Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
    // We'll map it to AMS function \dashrightarrow. It produces the same atom.

    defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow", true); // unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow", true);
    defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows", true);
    defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows", true);
    defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow", true);
    defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow", true);
    defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft", true);
    defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons", true);
    defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft", true); // unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft", true);
    defineSymbol(math, ams, rel, "\u21b0", "\\Lsh", true);
    defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows", true);
    defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft", true);
    defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft", true);
    defineSymbol(math, ams, rel, "\u22b8", "\\multimap", true);
    defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows", true);
    defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows", true);
    defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow", true);
    defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail", true);
    defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright", true);
    defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright", true); // unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.

    defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright", true);
    defineSymbol(math, ams, rel, "\u21b1", "\\Rsh", true);
    defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows", true);
    defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright", true);
    defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow", true);
    defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
    defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow", true);
    defineSymbol(math, ams, rel, "\u21be", "\\restriction");
    defineSymbol(math, main, textord, "\u2018", "`");
    defineSymbol(math, main, textord, "$", "\\$");
    defineSymbol(text$1, main, textord, "$", "\\$");
    defineSymbol(text$1, main, textord, "$", "\\textdollar");
    defineSymbol(math, main, textord, "%", "\\%");
    defineSymbol(text$1, main, textord, "%", "\\%");
    defineSymbol(math, main, textord, "_", "\\_");
    defineSymbol(text$1, main, textord, "_", "\\_");
    defineSymbol(text$1, main, textord, "_", "\\textunderscore");
    defineSymbol(math, main, textord, "\u2220", "\\angle", true);
    defineSymbol(math, main, textord, "\u221e", "\\infty", true);
    defineSymbol(math, main, textord, "\u2032", "\\prime");
    defineSymbol(math, main, textord, "\u25b3", "\\triangle");
    defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
    defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
    defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
    defineSymbol(math, main, textord, "\u039b", "\\Lambda", true);
    defineSymbol(math, main, textord, "\u039e", "\\Xi", true);
    defineSymbol(math, main, textord, "\u03a0", "\\Pi", true);
    defineSymbol(math, main, textord, "\u03a3", "\\Sigma", true);
    defineSymbol(math, main, textord, "\u03a5", "\\Upsilon", true);
    defineSymbol(math, main, textord, "\u03a6", "\\Phi", true);
    defineSymbol(math, main, textord, "\u03a8", "\\Psi", true);
    defineSymbol(math, main, textord, "\u03a9", "\\Omega", true);
    defineSymbol(math, main, textord, "A", "\u0391");
    defineSymbol(math, main, textord, "B", "\u0392");
    defineSymbol(math, main, textord, "E", "\u0395");
    defineSymbol(math, main, textord, "Z", "\u0396");
    defineSymbol(math, main, textord, "H", "\u0397");
    defineSymbol(math, main, textord, "I", "\u0399");
    defineSymbol(math, main, textord, "K", "\u039A");
    defineSymbol(math, main, textord, "M", "\u039C");
    defineSymbol(math, main, textord, "N", "\u039D");
    defineSymbol(math, main, textord, "O", "\u039F");
    defineSymbol(math, main, textord, "P", "\u03A1");
    defineSymbol(math, main, textord, "T", "\u03A4");
    defineSymbol(math, main, textord, "X", "\u03A7");
    defineSymbol(math, main, textord, "\u00ac", "\\neg", true);
    defineSymbol(math, main, textord, "\u00ac", "\\lnot");
    defineSymbol(math, main, textord, "\u22a4", "\\top");
    defineSymbol(math, main, textord, "\u22a5", "\\bot");
    defineSymbol(math, main, textord, "\u2205", "\\emptyset");
    defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
    defineSymbol(math, main, mathord, "\u03b1", "\\alpha", true);
    defineSymbol(math, main, mathord, "\u03b2", "\\beta", true);
    defineSymbol(math, main, mathord, "\u03b3", "\\gamma", true);
    defineSymbol(math, main, mathord, "\u03b4", "\\delta", true);
    defineSymbol(math, main, mathord, "\u03f5", "\\epsilon", true);
    defineSymbol(math, main, mathord, "\u03b6", "\\zeta", true);
    defineSymbol(math, main, mathord, "\u03b7", "\\eta", true);
    defineSymbol(math, main, mathord, "\u03b8", "\\theta", true);
    defineSymbol(math, main, mathord, "\u03b9", "\\iota", true);
    defineSymbol(math, main, mathord, "\u03ba", "\\kappa", true);
    defineSymbol(math, main, mathord, "\u03bb", "\\lambda", true);
    defineSymbol(math, main, mathord, "\u03bc", "\\mu", true);
    defineSymbol(math, main, mathord, "\u03bd", "\\nu", true);
    defineSymbol(math, main, mathord, "\u03be", "\\xi", true);
    defineSymbol(math, main, mathord, "\u03bf", "\\omicron", true);
    defineSymbol(math, main, mathord, "\u03c0", "\\pi", true);
    defineSymbol(math, main, mathord, "\u03c1", "\\rho", true);
    defineSymbol(math, main, mathord, "\u03c3", "\\sigma", true);
    defineSymbol(math, main, mathord, "\u03c4", "\\tau", true);
    defineSymbol(math, main, mathord, "\u03c5", "\\upsilon", true);
    defineSymbol(math, main, mathord, "\u03d5", "\\phi", true);
    defineSymbol(math, main, mathord, "\u03c7", "\\chi", true);
    defineSymbol(math, main, mathord, "\u03c8", "\\psi", true);
    defineSymbol(math, main, mathord, "\u03c9", "\\omega", true);
    defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon", true);
    defineSymbol(math, main, mathord, "\u03d1", "\\vartheta", true);
    defineSymbol(math, main, mathord, "\u03d6", "\\varpi", true);
    defineSymbol(math, main, mathord, "\u03f1", "\\varrho", true);
    defineSymbol(math, main, mathord, "\u03c2", "\\varsigma", true);
    defineSymbol(math, main, mathord, "\u03c6", "\\varphi", true);
    defineSymbol(math, main, bin, "\u2217", "*");
    defineSymbol(math, main, bin, "+", "+");
    defineSymbol(math, main, bin, "\u2212", "-");
    defineSymbol(math, main, bin, "\u22c5", "\\cdot", true);
    defineSymbol(math, main, bin, "\u2218", "\\circ");
    defineSymbol(math, main, bin, "\u00f7", "\\div", true);
    defineSymbol(math, main, bin, "\u00b1", "\\pm", true);
    defineSymbol(math, main, bin, "\u00d7", "\\times", true);
    defineSymbol(math, main, bin, "\u2229", "\\cap", true);
    defineSymbol(math, main, bin, "\u222a", "\\cup", true);
    defineSymbol(math, main, bin, "\u2216", "\\setminus");
    defineSymbol(math, main, bin, "\u2227", "\\land");
    defineSymbol(math, main, bin, "\u2228", "\\lor");
    defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
    defineSymbol(math, main, bin, "\u2228", "\\vee", true);
    defineSymbol(math, main, textord, "\u221a", "\\surd");
    defineSymbol(math, main, open, "(", "(");
    defineSymbol(math, main, open, "[", "[");
    defineSymbol(math, main, open, "\u27e8", "\\langle", true);
    defineSymbol(math, main, open, "\u2223", "\\lvert");
    defineSymbol(math, main, open, "\u2225", "\\lVert");
    defineSymbol(math, main, close, ")", ")");
    defineSymbol(math, main, close, "]", "]");
    defineSymbol(math, main, close, "?", "?");
    defineSymbol(math, main, close, "!", "!");
    defineSymbol(math, main, close, "\u27e9", "\\rangle", true);
    defineSymbol(math, main, close, "\u2223", "\\rvert");
    defineSymbol(math, main, close, "\u2225", "\\rVert");
    defineSymbol(math, main, rel, "=", "=");
    defineSymbol(math, main, rel, "<", "<");
    defineSymbol(math, main, rel, ">", ">");
    defineSymbol(math, main, rel, ":", ":");
    defineSymbol(math, main, rel, "\u2248", "\\approx", true);
    defineSymbol(math, main, rel, "\u2245", "\\cong", true);
    defineSymbol(math, main, rel, "\u2265", "\\ge");
    defineSymbol(math, main, rel, "\u2265", "\\geq", true);
    defineSymbol(math, main, rel, "\u2190", "\\gets");
    defineSymbol(math, main, rel, ">", "\\gt");
    defineSymbol(math, main, rel, "\u2208", "\\in", true);
    defineSymbol(math, main, rel, "\ue020", "\\@not");
    defineSymbol(math, main, rel, "\u2282", "\\subset", true);
    defineSymbol(math, main, rel, "\u2283", "\\supset", true);
    defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
    defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
    defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
    defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
    defineSymbol(math, main, rel, "\u22a8", "\\models");
    defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
    defineSymbol(math, main, rel, "\u2264", "\\le");
    defineSymbol(math, main, rel, "\u2264", "\\leq", true);
    defineSymbol(math, main, rel, "<", "\\lt");
    defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
    defineSymbol(math, main, rel, "\u2192", "\\to");
    defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
    defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
    defineSymbol(math, main, spacing, "\u00a0", "\\ ");
    defineSymbol(math, main, spacing, "\u00a0", "~");
    defineSymbol(math, main, spacing, "\u00a0", "\\space"); // Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%

    defineSymbol(math, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(text$1, main, spacing, "\u00a0", "\\ ");
    defineSymbol(text$1, main, spacing, "\u00a0", "~");
    defineSymbol(text$1, main, spacing, "\u00a0", "\\space");
    defineSymbol(text$1, main, spacing, "\u00a0", "\\nobreakspace");
    defineSymbol(math, main, spacing, null, "\\nobreak");
    defineSymbol(math, main, spacing, null, "\\allowbreak");
    defineSymbol(math, main, punct, ",", ",");
    defineSymbol(math, main, punct, ";", ";");
    defineSymbol(math, ams, bin, "\u22bc", "\\barwedge", true);
    defineSymbol(math, ams, bin, "\u22bb", "\\veebar", true);
    defineSymbol(math, main, bin, "\u2299", "\\odot", true);
    defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
    defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
    defineSymbol(math, main, textord, "\u2202", "\\partial", true);
    defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
    defineSymbol(math, ams, bin, "\u229a", "\\circledcirc", true);
    defineSymbol(math, ams, bin, "\u22a1", "\\boxdot", true);
    defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
    defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
    defineSymbol(math, main, bin, "\u2020", "\\dagger");
    defineSymbol(math, main, bin, "\u22c4", "\\diamond");
    defineSymbol(math, main, bin, "\u22c6", "\\star");
    defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
    defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
    defineSymbol(math, main, open, "{", "\\{");
    defineSymbol(text$1, main, textord, "{", "\\{");
    defineSymbol(text$1, main, textord, "{", "\\textbraceleft");
    defineSymbol(math, main, close, "}", "\\}");
    defineSymbol(text$1, main, textord, "}", "\\}");
    defineSymbol(text$1, main, textord, "}", "\\textbraceright");
    defineSymbol(math, main, open, "{", "\\lbrace");
    defineSymbol(math, main, close, "}", "\\rbrace");
    defineSymbol(math, main, open, "[", "\\lbrack");
    defineSymbol(text$1, main, textord, "[", "\\lbrack");
    defineSymbol(math, main, close, "]", "\\rbrack");
    defineSymbol(text$1, main, textord, "]", "\\rbrack");
    defineSymbol(math, main, open, "(", "\\lparen");
    defineSymbol(math, main, close, ")", "\\rparen");
    defineSymbol(text$1, main, textord, "<", "\\textless"); // in T1 fontenc

    defineSymbol(text$1, main, textord, ">", "\\textgreater"); // in T1 fontenc

    defineSymbol(math, main, open, "\u230a", "\\lfloor", true);
    defineSymbol(math, main, close, "\u230b", "\\rfloor", true);
    defineSymbol(math, main, open, "\u2308", "\\lceil", true);
    defineSymbol(math, main, close, "\u2309", "\\rceil", true);
    defineSymbol(math, main, textord, "\\", "\\backslash");
    defineSymbol(math, main, textord, "\u2223", "|");
    defineSymbol(math, main, textord, "\u2223", "\\vert");
    defineSymbol(text$1, main, textord, "|", "\\textbar"); // in T1 fontenc

    defineSymbol(math, main, textord, "\u2225", "\\|");
    defineSymbol(math, main, textord, "\u2225", "\\Vert");
    defineSymbol(text$1, main, textord, "\u2225", "\\textbardbl");
    defineSymbol(text$1, main, textord, "~", "\\textasciitilde");
    defineSymbol(text$1, main, textord, "\\", "\\textbackslash");
    defineSymbol(text$1, main, textord, "^", "\\textasciicircum");
    defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
    defineSymbol(math, main, rel, "\u21d1", "\\Uparrow", true);
    defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
    defineSymbol(math, main, rel, "\u21d3", "\\Downarrow", true);
    defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
    defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow", true);
    defineSymbol(math, main, op, "\u2210", "\\coprod");
    defineSymbol(math, main, op, "\u22c1", "\\bigvee");
    defineSymbol(math, main, op, "\u22c0", "\\bigwedge");
    defineSymbol(math, main, op, "\u2a04", "\\biguplus");
    defineSymbol(math, main, op, "\u22c2", "\\bigcap");
    defineSymbol(math, main, op, "\u22c3", "\\bigcup");
    defineSymbol(math, main, op, "\u222b", "\\int");
    defineSymbol(math, main, op, "\u222b", "\\intop");
    defineSymbol(math, main, op, "\u222c", "\\iint");
    defineSymbol(math, main, op, "\u222d", "\\iiint");
    defineSymbol(math, main, op, "\u220f", "\\prod");
    defineSymbol(math, main, op, "\u2211", "\\sum");
    defineSymbol(math, main, op, "\u2a02", "\\bigotimes");
    defineSymbol(math, main, op, "\u2a01", "\\bigoplus");
    defineSymbol(math, main, op, "\u2a00", "\\bigodot");
    defineSymbol(math, main, op, "\u222e", "\\oint");
    defineSymbol(math, main, op, "\u222f", "\\oiint");
    defineSymbol(math, main, op, "\u2230", "\\oiiint");
    defineSymbol(math, main, op, "\u2a06", "\\bigsqcup");
    defineSymbol(math, main, op, "\u222b", "\\smallint");
    defineSymbol(text$1, main, inner, "\u2026", "\\textellipsis");
    defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
    defineSymbol(text$1, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
    defineSymbol(math, main, inner, "\u22ef", "\\@cdots", true);
    defineSymbol(math, main, inner, "\u22f1", "\\ddots", true);
    defineSymbol(math, main, textord, "\u22ee", "\\varvdots"); // \vdots is a macro

    defineSymbol(math, main, accent, "\u02ca", "\\acute");
    defineSymbol(math, main, accent, "\u02cb", "\\grave");
    defineSymbol(math, main, accent, "\u00a8", "\\ddot");
    defineSymbol(math, main, accent, "\u007e", "\\tilde");
    defineSymbol(math, main, accent, "\u02c9", "\\bar");
    defineSymbol(math, main, accent, "\u02d8", "\\breve");
    defineSymbol(math, main, accent, "\u02c7", "\\check");
    defineSymbol(math, main, accent, "\u005e", "\\hat");
    defineSymbol(math, main, accent, "\u20d7", "\\vec");
    defineSymbol(math, main, accent, "\u02d9", "\\dot");
    defineSymbol(math, main, accent, "\u02da", "\\mathring");
    defineSymbol(math, main, mathord, "\u0131", "\\imath", true);
    defineSymbol(math, main, mathord, "\u0237", "\\jmath", true);
    defineSymbol(text$1, main, textord, "\u0131", "\\i", true);
    defineSymbol(text$1, main, textord, "\u0237", "\\j", true);
    defineSymbol(text$1, main, textord, "\u00df", "\\ss", true);
    defineSymbol(text$1, main, textord, "\u00e6", "\\ae", true);
    defineSymbol(text$1, main, textord, "\u00e6", "\\ae", true);
    defineSymbol(text$1, main, textord, "\u0153", "\\oe", true);
    defineSymbol(text$1, main, textord, "\u00f8", "\\o", true);
    defineSymbol(text$1, main, textord, "\u00c6", "\\AE", true);
    defineSymbol(text$1, main, textord, "\u0152", "\\OE", true);
    defineSymbol(text$1, main, textord, "\u00d8", "\\O", true);
    defineSymbol(text$1, main, accent, "\u02ca", "\\'"); // acute

    defineSymbol(text$1, main, accent, "\u02cb", "\\`"); // grave

    defineSymbol(text$1, main, accent, "\u02c6", "\\^"); // circumflex

    defineSymbol(text$1, main, accent, "\u02dc", "\\~"); // tilde

    defineSymbol(text$1, main, accent, "\u02c9", "\\="); // macron

    defineSymbol(text$1, main, accent, "\u02d8", "\\u"); // breve

    defineSymbol(text$1, main, accent, "\u02d9", "\\."); // dot above

    defineSymbol(text$1, main, accent, "\u02da", "\\r"); // ring above

    defineSymbol(text$1, main, accent, "\u02c7", "\\v"); // caron

    defineSymbol(text$1, main, accent, "\u00a8", '\\"'); // diaresis

    defineSymbol(text$1, main, accent, "\u02dd", "\\H"); // double acute

    defineSymbol(text$1, main, accent, "\u25ef", "\\textcircled"); // \bigcirc glyph
    // These ligatures are detected and created in Parser.js's `formLigatures`.

    const ligatures = {
      "--": true,
      "---": true,
      "``": true,
      "''": true
    };
    defineSymbol(text$1, main, textord, "\u2013", "--");
    defineSymbol(text$1, main, textord, "\u2013", "\\textendash");
    defineSymbol(text$1, main, textord, "\u2014", "---");
    defineSymbol(text$1, main, textord, "\u2014", "\\textemdash");
    defineSymbol(text$1, main, textord, "\u2018", "`");
    defineSymbol(text$1, main, textord, "\u2018", "\\textquoteleft");
    defineSymbol(text$1, main, textord, "\u2019", "'");
    defineSymbol(text$1, main, textord, "\u2019", "\\textquoteright");
    defineSymbol(text$1, main, textord, "\u201c", "``");
    defineSymbol(text$1, main, textord, "\u201c", "\\textquotedblleft");
    defineSymbol(text$1, main, textord, "\u201d", "''");
    defineSymbol(text$1, main, textord, "\u201d", "\\textquotedblright"); //  \degree from gensymb package

    defineSymbol(math, main, textord, "\u00b0", "\\degree", true);
    defineSymbol(text$1, main, textord, "\u00b0", "\\degree"); // \textdegree from inputenc package

    defineSymbol(text$1, main, textord, "\u00b0", "\\textdegree", true); // TODO: In LaTeX, \pounds can generate a different character in text and math
    // mode, but among our fonts, only Main-Italic defines this character "163".

    defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
    defineSymbol(math, main, mathord, "\u00a3", "\\mathsterling", true);
    defineSymbol(text$1, main, mathord, "\u00a3", "\\pounds");
    defineSymbol(text$1, main, mathord, "\u00a3", "\\textsterling", true);
    defineSymbol(math, ams, textord, "\u2720", "\\maltese");
    defineSymbol(text$1, ams, textord, "\u2720", "\\maltese");
    defineSymbol(text$1, main, spacing, "\u00a0", "\\ ");
    defineSymbol(text$1, main, spacing, "\u00a0", " ");
    defineSymbol(text$1, main, spacing, "\u00a0", "~"); // There are lots of symbols which are the same, so we add them in afterwards.
    // All of these are textords in math mode

    const mathTextSymbols = "0123456789/@.\"";

    for (let i = 0; i < mathTextSymbols.length; i++) {
      const ch = mathTextSymbols.charAt(i);
      defineSymbol(math, main, textord, ch, ch);
    } // All of these are textords in text mode


    const textSymbols = "0123456789!@*()-=+[]<>|\";:?/.,";

    for (let i = 0; i < textSymbols.length; i++) {
      const ch = textSymbols.charAt(i);
      defineSymbol(text$1, main, textord, ch, ch);
    } // All of these are textords in text mode, and mathords in math mode


    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    for (let i = 0; i < letters.length; i++) {
      const ch = letters.charAt(i);
      defineSymbol(math, main, mathord, ch, ch);
      defineSymbol(text$1, main, textord, ch, ch);
    } // Blackboard bold and script letters in Unicode range


    defineSymbol(math, ams, textord, "C", "\u2102"); // blackboard bold

    defineSymbol(text$1, ams, textord, "C", "\u2102");
    defineSymbol(math, ams, textord, "H", "\u210D");
    defineSymbol(text$1, ams, textord, "H", "\u210D");
    defineSymbol(math, ams, textord, "N", "\u2115");
    defineSymbol(text$1, ams, textord, "N", "\u2115");
    defineSymbol(math, ams, textord, "P", "\u2119");
    defineSymbol(text$1, ams, textord, "P", "\u2119");
    defineSymbol(math, ams, textord, "Q", "\u211A");
    defineSymbol(text$1, ams, textord, "Q", "\u211A");
    defineSymbol(math, ams, textord, "R", "\u211D");
    defineSymbol(text$1, ams, textord, "R", "\u211D");
    defineSymbol(math, ams, textord, "Z", "\u2124");
    defineSymbol(text$1, ams, textord, "Z", "\u2124");
    defineSymbol(math, main, mathord, "h", "\u210E"); // italic h, Planck constant

    defineSymbol(text$1, main, mathord, "h", "\u210E"); // The next loop loads wide (surrogate pair) characters.
    // We support some letters in the Unicode range U+1D400 to U+1D7FF,
    // Mathematical Alphanumeric Symbols.
    // Some editors do not deal well with wide characters. So don't write the
    // string into this file. Instead, create the string from the surrogate pair.

    let wideChar = "";

    for (let i = 0; i < letters.length; i++) {
      const ch = letters.charAt(i); // The hex numbers in the next line are a surrogate pair.
      // 0xD835 is the high surrogate for all letters in the range we support.
      // 0xDC00 is the low surrogate for bold A.

      wideChar = String.fromCharCode(0xD835, 0xDC00 + i); // A-Z a-z bold

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC34 + i); // A-Z a-z italic

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDC68 + i); // A-Z a-z bold italic

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDD04 + i); // A-Z a-z Fractur

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDA0 + i); // A-Z a-z sans-serif

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDDD4 + i); // A-Z a-z sans bold

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE08 + i); // A-Z a-z sans italic

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDE70 + i); // A-Z a-z monospace

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);

      if (i < 26) {
        // KaTeX fonts have only capital letters for blackboard bold and script.
        // See exception for k below.
        wideChar = String.fromCharCode(0xD835, 0xDD38 + i); // A-Z double struck

        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(text$1, main, textord, ch, wideChar);
        wideChar = String.fromCharCode(0xD835, 0xDC9C + i); // A-Z script

        defineSymbol(math, main, mathord, ch, wideChar);
        defineSymbol(text$1, main, textord, ch, wideChar);
      } // TODO: Add bold script when it is supported by a KaTeX font.

    } // "k" is the only double struck lower case letter in the KaTeX fonts.


    wideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck

    defineSymbol(math, main, mathord, "k", wideChar);
    defineSymbol(text$1, main, textord, "k", wideChar); // Next, some wide character numerals

    for (let i = 0; i < 10; i++) {
      const ch = i.toString();
      wideChar = String.fromCharCode(0xD835, 0xDFCE + i); // 0-9 bold

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFE2 + i); // 0-9 sans serif

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFEC + i); // 0-9 bold sans

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
      wideChar = String.fromCharCode(0xD835, 0xDFF6 + i); // 0-9 monospace

      defineSymbol(math, main, mathord, ch, wideChar);
      defineSymbol(text$1, main, textord, ch, wideChar);
    } // We add these Latin-1 letters as symbols for backwards-compatibility,
    // but they are not actually in the font, nor are they supported by the
    // Unicode accent mechanism, so they fall back to Times font and look ugly.
    // TODO(edemaine): Fix this.


    const extraLatin = "ÇÐÞçþ";

    for (let i = 0; i < extraLatin.length; i++) {
      const ch = extraLatin.charAt(i);
      defineSymbol(math, main, mathord, ch, ch);
      defineSymbol(text$1, main, textord, ch, ch);
    }

    defineSymbol(text$1, main, textord, "ð", "ð"); // Unicode versions of existing characters

    defineSymbol(text$1, main, textord, "\u2013", "–");
    defineSymbol(text$1, main, textord, "\u2014", "—");
    defineSymbol(text$1, main, textord, "\u2018", "‘");
    defineSymbol(text$1, main, textord, "\u2019", "’");
    defineSymbol(text$1, main, textord, "\u201c", "“");
    defineSymbol(text$1, main, textord, "\u201d", "”");

    /**
     * This file provides support for Unicode range U+1D400 to U+1D7FF,
     * Mathematical Alphanumeric Symbols.
     *
     * Function wideCharacterFont takes a wide character as input and returns
     * the font information necessary to render it properly.
     */
    /**
     * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf
     * That document sorts characters into groups by font type, say bold or italic.
     *
     * In the arrays below, each subarray consists three elements:
     *      * The CSS class of that group when in math mode.
     *      * The CSS class of that group when in text mode.
     *      * The font name, so that KaTeX can get font metrics.
     */

    const wideLatinLetterData = [["mathbf", "textbf", "Main-Bold"], // A-Z bold upright
    ["mathbf", "textbf", "Main-Bold"], // a-z bold upright
    ["mathdefault", "textit", "Math-Italic"], // A-Z italic
    ["mathdefault", "textit", "Math-Italic"], // a-z italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"], // A-Z bold italic
    ["boldsymbol", "boldsymbol", "Main-BoldItalic"], // a-z bold italic
    // Map fancy A-Z letters to script, not calligraphic.
    // This aligns with unicode-math and math fonts (except Cambria Math).
    ["mathscr", "textscr", "Script-Regular"], // A-Z script
    ["", "", ""], // a-z script.  No font
    ["", "", ""], // A-Z bold script. No font
    ["", "", ""], // a-z bold script. No font
    ["mathfrak", "textfrak", "Fraktur-Regular"], // A-Z Fraktur
    ["mathfrak", "textfrak", "Fraktur-Regular"], // a-z Fraktur
    ["mathbb", "textbb", "AMS-Regular"], // A-Z double-struck
    ["mathbb", "textbb", "AMS-Regular"], // k double-struck
    ["", "", ""], // A-Z bold Fraktur No font metrics
    ["", "", ""], // a-z bold Fraktur.   No font.
    ["mathsf", "textsf", "SansSerif-Regular"], // A-Z sans-serif
    ["mathsf", "textsf", "SansSerif-Regular"], // a-z sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // A-Z bold sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // a-z bold sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"], // A-Z italic sans-serif
    ["mathitsf", "textitsf", "SansSerif-Italic"], // a-z italic sans-serif
    ["", "", ""], // A-Z bold italic sans. No font
    ["", "", ""], // a-z bold italic sans. No font
    ["mathtt", "texttt", "Typewriter-Regular"], // A-Z monospace
    ["mathtt", "texttt", "Typewriter-Regular"]];
    const wideNumeralData = [["mathbf", "textbf", "Main-Bold"], // 0-9 bold
    ["", "", ""], // 0-9 double-struck. No KaTeX font.
    ["mathsf", "textsf", "SansSerif-Regular"], // 0-9 sans-serif
    ["mathboldsf", "textboldsf", "SansSerif-Bold"], // 0-9 bold sans-serif
    ["mathtt", "texttt", "Typewriter-Regular"]];
    const wideCharacterFont = function wideCharacterFont(wideChar, mode) {
      // IE doesn't support codePointAt(). So work with the surrogate pair.
      const H = wideChar.charCodeAt(0); // high surrogate

      const L = wideChar.charCodeAt(1); // low surrogate

      const codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;
      const j = mode === "math" ? 0 : 1; // column index for CSS class.

      if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {
        // wideLatinLetterData contains exactly 26 chars on each row.
        // So we can calculate the relevant row. No traverse necessary.
        const i = Math.floor((codePoint - 0x1D400) / 26);
        return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
      } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {
        // Numerals, ten per row.
        const i = Math.floor((codePoint - 0x1D7CE) / 10);
        return [wideNumeralData[i][2], wideNumeralData[i][j]];
      } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {
        // dotless i or j
        return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
      } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {
        // Greek letters. Not supported, yet.
        return ["", ""];
      } else {
        // We don't support any wide characters outside 1D400–1D7FF.
        throw new ParseError("Unsupported character: " + wideChar);
      }
    };

    /**
     * This file contains information about the options that the Parser carries
     * around with it while parsing. Data is held in an `Options` object, and when
     * recursing, a new `Options` object can be created with the `.with*` and
     * `.reset` functions.
     */
    const sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].
    // The size mappings are taken from TeX with \normalsize=10pt.
    [1, 1, 1], // size1: [5, 5, 5]              \tiny
    [2, 1, 1], // size2: [6, 5, 5]
    [3, 1, 1], // size3: [7, 5, 5]              \scriptsize
    [4, 2, 1], // size4: [8, 6, 5]              \footnotesize
    [5, 2, 1], // size5: [9, 6, 5]              \small
    [6, 3, 1], // size6: [10, 7, 5]             \normalsize
    [7, 4, 2], // size7: [12, 8, 6]             \large
    [8, 6, 3], // size8: [14.4, 10, 7]          \Large
    [9, 7, 6], // size9: [17.28, 12, 10]        \LARGE
    [10, 8, 7], // size10: [20.74, 14.4, 12]     \huge
    [11, 10, 9]];
    const sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if
    // you change size indexes, change that function.
    0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];

    const sizeAtStyle = function sizeAtStyle(size, style) {
      return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
    };

    /**
     * This is the main options class. It contains the current style, size, color,
     * and font.
     *
     * Options objects should not be modified. To create a new Options with
     * different properties, call a `.having*` method.
     */
    class Options {
      // A font family applies to a group of fonts (i.e. SansSerif), while a font
      // represents a specific font (i.e. SansSerif Bold).
      // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm

      /**
       * The base size index.
       */
      constructor(data) {
        this.style = void 0;
        this.color = void 0;
        this.size = void 0;
        this.textSize = void 0;
        this.phantom = void 0;
        this.font = void 0;
        this.fontFamily = void 0;
        this.fontWeight = void 0;
        this.fontShape = void 0;
        this.sizeMultiplier = void 0;
        this.maxSize = void 0;
        this._fontMetrics = void 0;
        this.style = data.style;
        this.color = data.color;
        this.size = data.size || Options.BASESIZE;
        this.textSize = data.textSize || this.size;
        this.phantom = !!data.phantom;
        this.font = data.font || "";
        this.fontFamily = data.fontFamily || "";
        this.fontWeight = data.fontWeight || '';
        this.fontShape = data.fontShape || '';
        this.sizeMultiplier = sizeMultipliers[this.size - 1];
        this.maxSize = data.maxSize;
        this._fontMetrics = undefined;
      }
      /**
       * Returns a new options object with the same properties as "this".  Properties
       * from "extension" will be copied to the new options object.
       */


      extend(extension) {
        const data = {
          style: this.style,
          size: this.size,
          textSize: this.textSize,
          color: this.color,
          phantom: this.phantom,
          font: this.font,
          fontFamily: this.fontFamily,
          fontWeight: this.fontWeight,
          fontShape: this.fontShape,
          maxSize: this.maxSize
        };

        for (const key in extension) {
          if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
          }
        }

        return new Options(data);
      }
      /**
       * Return an options object with the given style. If `this.style === style`,
       * returns `this`.
       */


      havingStyle(style) {
        if (this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: sizeAtStyle(this.textSize, style)
          });
        }
      }
      /**
       * Return an options object with a cramped version of the current style. If
       * the current style is cramped, returns `this`.
       */


      havingCrampedStyle() {
        return this.havingStyle(this.style.cramp());
      }
      /**
       * Return an options object with the given size and in at least `\textstyle`.
       * Returns `this` if appropriate.
       */


      havingSize(size) {
        if (this.size === size && this.textSize === size) {
          return this;
        } else {
          return this.extend({
            style: this.style.text(),
            size: size,
            textSize: size,
            sizeMultiplier: sizeMultipliers[size - 1]
          });
        }
      }
      /**
       * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
       * changes to at least `\textstyle`.
       */


      havingBaseStyle(style) {
        style = style || this.style.text();
        const wantSize = sizeAtStyle(Options.BASESIZE, style);

        if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
          return this;
        } else {
          return this.extend({
            style: style,
            size: wantSize
          });
        }
      }
      /**
       * Remove the effect of sizing changes such as \Huge.
       * Keep the effect of the current style, such as \scriptstyle.
       */


      havingBaseSizing() {
        let size;

        switch (this.style.id) {
          case 4:
          case 5:
            size = 3; // normalsize in scriptstyle

            break;

          case 6:
          case 7:
            size = 1; // normalsize in scriptscriptstyle

            break;

          default:
            size = 6;
          // normalsize in textstyle or displaystyle
        }

        return this.extend({
          style: this.style.text(),
          size: size
        });
      }
      /**
       * Create a new options object with the given color.
       */


      withColor(color) {
        return this.extend({
          color: color
        });
      }
      /**
       * Create a new options object with "phantom" set to true.
       */


      withPhantom() {
        return this.extend({
          phantom: true
        });
      }
      /**
       * Creates a new options object with the given math font or old text font.
       * @type {[type]}
       */


      withFont(font) {
        return this.extend({
          font
        });
      }
      /**
       * Create a new options objects with the given fontFamily.
       */


      withTextFontFamily(fontFamily) {
        return this.extend({
          fontFamily,
          font: ""
        });
      }
      /**
       * Creates a new options object with the given font weight
       */


      withTextFontWeight(fontWeight) {
        return this.extend({
          fontWeight,
          font: ""
        });
      }
      /**
       * Creates a new options object with the given font weight
       */


      withTextFontShape(fontShape) {
        return this.extend({
          fontShape,
          font: ""
        });
      }
      /**
       * Return the CSS sizing classes required to switch from enclosing options
       * `oldOptions` to `this`. Returns an array of classes.
       */


      sizingClasses(oldOptions) {
        if (oldOptions.size !== this.size) {
          return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
        } else {
          return [];
        }
      }
      /**
       * Return the CSS sizing classes required to switch to the base size. Like
       * `this.havingSize(BASESIZE).sizingClasses(this)`.
       */


      baseSizingClasses() {
        if (this.size !== Options.BASESIZE) {
          return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
        } else {
          return [];
        }
      }
      /**
       * Return the font metrics for this size.
       */


      fontMetrics() {
        if (!this._fontMetrics) {
          this._fontMetrics = getGlobalMetrics(this.size);
        }

        return this._fontMetrics;
      }
      /**
       * A map of color names to CSS colors.
       * TODO(emily): Remove this when we have real macros
       */


      /**
       * Gets the CSS color of the current options object, accounting for the
       * `colorMap`.
       */
      getColor() {
        if (this.phantom) {
          return "transparent";
        } else if (this.color != null && Options.colorMap.hasOwnProperty(this.color)) {
          return Options.colorMap[this.color];
        } else {
          return this.color;
        }
      }

    }

    Options.BASESIZE = 6;
    Options.colorMap = {
      "katex-blue": "#6495ed",
      "katex-orange": "#ffa500",
      "katex-pink": "#ff00af",
      "katex-red": "#df0030",
      "katex-green": "#28ae7b",
      "katex-gray": "gray",
      "katex-purple": "#9d38bd",
      "katex-blueA": "#ccfaff",
      "katex-blueB": "#80f6ff",
      "katex-blueC": "#63d9ea",
      "katex-blueD": "#11accd",
      "katex-blueE": "#0c7f99",
      "katex-tealA": "#94fff5",
      "katex-tealB": "#26edd5",
      "katex-tealC": "#01d1c1",
      "katex-tealD": "#01a995",
      "katex-tealE": "#208170",
      "katex-greenA": "#b6ffb0",
      "katex-greenB": "#8af281",
      "katex-greenC": "#74cf70",
      "katex-greenD": "#1fab54",
      "katex-greenE": "#0d923f",
      "katex-goldA": "#ffd0a9",
      "katex-goldB": "#ffbb71",
      "katex-goldC": "#ff9c39",
      "katex-goldD": "#e07d10",
      "katex-goldE": "#a75a05",
      "katex-redA": "#fca9a9",
      "katex-redB": "#ff8482",
      "katex-redC": "#f9685d",
      "katex-redD": "#e84d39",
      "katex-redE": "#bc2612",
      "katex-maroonA": "#ffbde0",
      "katex-maroonB": "#ff92c6",
      "katex-maroonC": "#ed5fa6",
      "katex-maroonD": "#ca337c",
      "katex-maroonE": "#9e034e",
      "katex-purpleA": "#ddd7ff",
      "katex-purpleB": "#c6b9fc",
      "katex-purpleC": "#aa87ff",
      "katex-purpleD": "#7854ab",
      "katex-purpleE": "#543b78",
      "katex-mintA": "#f5f9e8",
      "katex-mintB": "#edf2df",
      "katex-mintC": "#e0e5cc",
      "katex-grayA": "#f6f7f7",
      "katex-grayB": "#f0f1f2",
      "katex-grayC": "#e3e5e6",
      "katex-grayD": "#d6d8da",
      "katex-grayE": "#babec2",
      "katex-grayF": "#888d93",
      "katex-grayG": "#626569",
      "katex-grayH": "#3b3e40",
      "katex-grayI": "#21242c",
      "katex-kaBlue": "#314453",
      "katex-kaGreen": "#71B307"
    };

    /**
     * This file does conversion between units.  In particular, it provides
     * calculateSize to convert other units into ems.
     */
    // Thus, multiplying a length by this number converts the length from units
    // into pts.  Dividing the result by ptPerEm gives the number of ems
    // *assuming* a font size of ptPerEm (normal size, normal style).

    const ptPerUnit = {
      // https://en.wikibooks.org/wiki/LaTeX/Lengths and
      // https://tex.stackexchange.com/a/8263
      "pt": 1,
      // TeX point
      "mm": 7227 / 2540,
      // millimeter
      "cm": 7227 / 254,
      // centimeter
      "in": 72.27,
      // inch
      "bp": 803 / 800,
      // big (PostScript) points
      "pc": 12,
      // pica
      "dd": 1238 / 1157,
      // didot
      "cc": 14856 / 1157,
      // cicero (12 didot)
      "nd": 685 / 642,
      // new didot
      "nc": 1370 / 107,
      // new cicero (12 new didot)
      "sp": 1 / 65536,
      // scaled point (TeX's internal smallest unit)
      // https://tex.stackexchange.com/a/41371
      "px": 803 / 800 // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX

    }; // Dictionary of relative units, for fast validity testing.

    const relativeUnit = {
      "ex": true,
      "em": true,
      "mu": true
    };

    /**
     * Determine whether the specified unit (either a string defining the unit
     * or a "size" parse node containing a unit field) is valid.
     */
    const validUnit = function validUnit(unit) {
      if (typeof unit !== "string") {
        unit = unit.unit;
      }

      return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
    };
    /*
     * Convert a "size" parse node (with numeric "number" and string "unit" fields,
     * as parsed by functions.js argType "size") into a CSS em value for the
     * current style/scale.  `options` gives the current options.
     */

    const calculateSize = function calculateSize(sizeValue, options) {
      let scale;

      if (sizeValue.unit in ptPerUnit) {
        // Absolute units
        scale = ptPerUnit[sizeValue.unit] // Convert unit to pt
        / options.fontMetrics().ptPerEm // Convert pt to CSS em
        / options.sizeMultiplier; // Unscale to make absolute units
      } else if (sizeValue.unit === "mu") {
        // `mu` units scale with scriptstyle/scriptscriptstyle.
        scale = options.fontMetrics().cssEmPerMu;
      } else {
        // Other relative units always refer to the *textstyle* font
        // in the current size.
        let unitOptions;

        if (options.style.isTight()) {
          // isTight() means current style is script/scriptscript.
          unitOptions = options.havingStyle(options.style.text());
        } else {
          unitOptions = options;
        } // TODO: In TeX these units are relative to the quad of the current
        // *text* font, e.g. cmr10. KaTeX instead uses values from the
        // comparably-sized *Computer Modern symbol* font. At 10pt, these
        // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;
        // cmr5=1.361133, cmsy5=1.472241. Consider $\scriptsize a\kern1emb$.
        // TeX \showlists shows a kern of 1.13889 * fontsize;
        // KaTeX shows a kern of 1.171 * fontsize.


        if (sizeValue.unit === "ex") {
          scale = unitOptions.fontMetrics().xHeight;
        } else if (sizeValue.unit === "em") {
          scale = unitOptions.fontMetrics().quad;
        } else {
          throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
        }

        if (unitOptions !== options) {
          scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
        }
      }

      return Math.min(sizeValue.number * scale, options.maxSize);
    };

    /* eslint no-console:0 */
    // The following have to be loaded from Main-Italic font, using class mathit
    const mathitLetters = ["\\imath", "ı", // dotless i
    "\\jmath", "ȷ", // dotless j
    "\\pounds", "\\mathsterling", "\\textsterling", "£"];
    /**
     * Looks up the given symbol in fontMetrics, after applying any symbol
     * replacements defined in symbol.js
     */

    const lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.
    fontName, mode) {
      // Replace the value with its replaced value from symbol.js
      if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
      }

      return {
        value: value,
        metrics: getCharacterMetrics(value, fontName, mode)
      };
    };
    /**
     * Makes a symbolNode after translation via the list of symbols in symbols.js.
     * Correctly pulls out metrics for the character, and optionally takes a list of
     * classes to be attached to the node.
     *
     * TODO: make argument order closer to makeSpan
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     * TODO(#953): Make `options` mandatory and always pass it in.
     */


    const makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
      const lookup = lookupSymbol(value, fontName, mode);
      const metrics = lookup.metrics;
      value = lookup.value;
      let symbolNode;

      if (metrics) {
        let italic = metrics.italic;

        if (mode === "text" || options && options.font === "mathit") {
          italic = 0;
        }

        symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
      } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn("No character metrics for '" + value + "' in style '" + fontName + "'");
        symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
      }

      if (options) {
        symbolNode.maxFontSize = options.sizeMultiplier;

        if (options.style.isTight()) {
          symbolNode.classes.push("mtight");
        }

        const color = options.getColor();

        if (color) {
          symbolNode.style.color = color;
        }
      }

      return symbolNode;
    };
    /**
     * Makes a symbol in Main-Regular or AMS-Regular.
     * Used for rel, bin, open, close, inner, and punct.
     *
     * TODO(#953): Make `options` mandatory and always pass it in.
     */


    const mathsym = function mathsym(value, mode, options, classes) {
      if (classes === void 0) {
        classes = [];
      }

      // Decide what font to render the symbol in by its entry in the symbols
      // table.
      // Have a special case for when the value = \ because the \ is used as a
      // textord in unsupported command errors but cannot be parsed as a regular
      // text ordinal and is therefore not present as a symbol in the symbols
      // table for text, as well as a special case for boldsymbol because it
      // can be used for bold + and -
      if (options && options.font && options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
        return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
      } else if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
      } else {
        return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
      }
    };
    /**
     * Determines which of the two font names (Main-Italic and Math-Italic) and
     * corresponding style tags (maindefault or mathit) to use for default math font,
     * depending on the symbol.
     */


    const mathdefault = function mathdefault(value, mode, options, classes) {
      if (/[0-9]/.test(value.charAt(0)) || // glyphs for \imath and \jmath do not exist in Math-Italic so we
      // need to use Main-Italic instead
      utils.contains(mathitLetters, value)) {
        return {
          fontName: "Main-Italic",
          fontClass: "mathit"
        };
      } else {
        return {
          fontName: "Math-Italic",
          fontClass: "mathdefault"
        };
      }
    };
    /**
     * Determines which of the font names (Main-Italic, Math-Italic, and Caligraphic)
     * and corresponding style tags (mathit, mathdefault, or mathcal) to use for font
     * "mathnormal", depending on the symbol.  Use this function instead of fontMap for
     * font "mathnormal".
     */


    const mathnormal = function mathnormal(value, mode, options, classes) {
      if (utils.contains(mathitLetters, value)) {
        return {
          fontName: "Main-Italic",
          fontClass: "mathit"
        };
      } else if (/[0-9]/.test(value.charAt(0))) {
        return {
          fontName: "Caligraphic-Regular",
          fontClass: "mathcal"
        };
      } else {
        return {
          fontName: "Math-Italic",
          fontClass: "mathdefault"
        };
      }
    };
    /**
     * Determines which of the two font names (Main-Bold and Math-BoldItalic) and
     * corresponding style tags (mathbf or boldsymbol) to use for font "boldsymbol",
     * depending on the symbol.  Use this function instead of fontMap for font
     * "boldsymbol".
     */


    const boldsymbol = function boldsymbol(value, mode, options, classes) {
      if (lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
        return {
          fontName: "Math-BoldItalic",
          fontClass: "boldsymbol"
        };
      } else {
        // Some glyphs do not exist in Math-BoldItalic so we need to use
        // Main-Bold instead.
        return {
          fontName: "Main-Bold",
          fontClass: "mathbf"
        };
      }
    };
    /**
     * Makes either a mathord or textord in the correct font and color.
     */


    const makeOrd = function makeOrd(group, options, type) {
      const mode = group.mode;
      const text = group.text;
      const classes = ["mord"]; // Math mode or Old font (i.e. \rm)

      const isFont = mode === "math" || mode === "text" && options.font;
      const fontOrFamily = isFont ? options.font : options.fontFamily;

      if (text.charCodeAt(0) === 0xD835) {
        // surrogate pairs get special treatment
        const _wideCharacterFont = wideCharacterFont(text, mode),
              wideFontName = _wideCharacterFont[0],
              wideFontClass = _wideCharacterFont[1];

        return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
      } else if (fontOrFamily) {
        let fontName;
        let fontClasses;

        if (fontOrFamily === "boldsymbol" || fontOrFamily === "mathnormal") {
          const fontData = fontOrFamily === "boldsymbol" ? boldsymbol(text, mode, options, classes) : mathnormal(text, mode, options, classes);
          fontName = fontData.fontName;
          fontClasses = [fontData.fontClass];
        } else if (utils.contains(mathitLetters, text)) {
          fontName = "Main-Italic";
          fontClasses = ["mathit"];
        } else if (isFont) {
          fontName = fontMap[fontOrFamily].fontName;
          fontClasses = [fontOrFamily];
        } else {
          fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
          fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
        }

        if (lookupSymbol(text, fontName, mode).metrics) {
          return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
        } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === "Typewriter") {
          // Deconstruct ligatures in monospace fonts (\texttt, \tt).
          const parts = [];

          for (let i = 0; i < text.length; i++) {
            parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
          }

          return makeFragment(parts);
        }
      } // Makes a symbol in the default font for mathords and textords.


      if (type === "mathord") {
        const fontLookup = mathdefault(text, mode, options, classes);
        return makeSymbol(text, fontLookup.fontName, mode, options, classes.concat([fontLookup.fontClass]));
      } else if (type === "textord") {
        const font = symbols[mode][text] && symbols[mode][text].font;

        if (font === "ams") {
          const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
          return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
        } else if (font === "main" || !font) {
          const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
          return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
        } else {
          // fonts added by plugins
          const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class

          return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
        }
      } else {
        throw new Error("unexpected type: " + type + " in makeOrd");
      }
    };
    /**
     * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,
     * and styles.
     */


    const canCombine = (prev, next) => {
      if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
        return false;
      }

      for (const style in prev.style) {
        if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
          return false;
        }
      }

      for (const style in next.style) {
        if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
          return false;
        }
      }

      return true;
    };
    /**
     * Combine consequetive domTree.symbolNodes into a single symbolNode.
     * Note: this function mutates the argument.
     */


    const tryCombineChars = chars => {
      for (let i = 0; i < chars.length - 1; i++) {
        const prev = chars[i];
        const next = chars[i + 1];

        if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
          prev.text += next.text;
          prev.height = Math.max(prev.height, next.height);
          prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use
          // it to add padding to the right of the span created from
          // the combined characters.

          prev.italic = next.italic;
          chars.splice(i + 1, 1);
          i--;
        }
      }

      return chars;
    };
    /**
     * Calculate the height, depth, and maxFontSize of an element based on its
     * children.
     */


    const sizeElementFromChildren = function sizeElementFromChildren(elem) {
      let height = 0;
      let depth = 0;
      let maxFontSize = 0;

      for (let i = 0; i < elem.children.length; i++) {
        const child = elem.children[i];

        if (child.height > height) {
          height = child.height;
        }

        if (child.depth > depth) {
          depth = child.depth;
        }

        if (child.maxFontSize > maxFontSize) {
          maxFontSize = child.maxFontSize;
        }
      }

      elem.height = height;
      elem.depth = depth;
      elem.maxFontSize = maxFontSize;
    };
    /**
     * Makes a span with the given list of classes, list of children, and options.
     *
     * TODO(#953): Ensure that `options` is always provided (currently some call
     * sites don't pass it) and make the type below mandatory.
     * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
     * should if present come first in `classes`.
     */


    const makeSpan = function makeSpan(classes, children, options, style) {
      const span = new Span(classes, children, options, style);
      sizeElementFromChildren(span);
      return span;
    }; // SVG one is simpler -- doesn't require height, depth, max-font setting.
    // This is also a separate method for typesafety.


    const makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);

    const makeLineSpan = function makeLineSpan(className, options, thickness) {
      const line = makeSpan([className], [], options);
      line.height = thickness || options.fontMetrics().defaultRuleThickness;
      line.style.borderBottomWidth = line.height + "em";
      line.maxFontSize = 1.0;
      return line;
    };
    /**
     * Makes an anchor with the given href, list of classes, list of children,
     * and options.
     */


    const makeAnchor = function makeAnchor(href, classes, children, options) {
      const anchor = new Anchor(href, classes, children, options);
      sizeElementFromChildren(anchor);
      return anchor;
    };
    /**
     * Makes a document fragment with the given list of children.
     */


    const makeFragment = function makeFragment(children) {
      const fragment = new DocumentFragment(children);
      sizeElementFromChildren(fragment);
      return fragment;
    };
    /**
     * Wraps group in a span if it's a document fragment, allowing to apply classes
     * and styles
     */


    const wrapFragment = function wrapFragment(group, options) {
      if (group instanceof DocumentFragment) {
        return makeSpan([], [group], options);
      }

      return group;
    }; // These are exact object types to catch typos in the names of the optional fields.


    // Computes the updated `children` list and the overall depth.
    //
    // This helper function for makeVList makes it easier to enforce type safety by
    // allowing early exits (returns) in the logic.
    const getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {
      if (params.positionType === "individualShift") {
        const oldChildren = params.children;
        const children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be
        // shifted to the correct specified shift

        const depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        let currPos = depth;

        for (let i = 1; i < oldChildren.length; i++) {
          const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
          const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
          currPos = currPos + diff;
          children.push({
            type: "kern",
            size
          });
          children.push(oldChildren[i]);
        }

        return {
          children,
          depth
        };
      }

      let depth;

      if (params.positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        let bottom = params.positionData;

        for (let i = 0; i < params.children.length; i++) {
          const child = params.children[i];
          bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
        }

        depth = bottom;
      } else if (params.positionType === "bottom") {
        depth = -params.positionData;
      } else {
        const firstChild = params.children[0];

        if (firstChild.type !== "elem") {
          throw new Error('First child must have type "elem".');
        }

        if (params.positionType === "shift") {
          depth = -firstChild.elem.depth - params.positionData;
        } else if (params.positionType === "firstBaseline") {
          depth = -firstChild.elem.depth;
        } else {
          throw new Error(`Invalid positionType ${params.positionType}.`);
        }
      }

      return {
        children: params.children,
        depth
      };
    };
    /**
     * Makes a vertical list by stacking elements and kerns on top of each other.
     * Allows for many different ways of specifying the positioning method.
     *
     * See VListParam documentation above.
     */


    const makeVList = function makeVList(params, options) {
      const _getVListChildrenAndD = getVListChildrenAndDepth(params),
            children = _getVListChildrenAndD.children,
            depth = _getVListChildrenAndD.depth; // Create a strut that is taller than any list item. The strut is added to
      // each item, where it will determine the item's baseline. Since it has
      // `overflow:hidden`, the strut's top edge will sit on the item's line box's
      // top edge and the strut's bottom edge will sit on the item's baseline,
      // with no additional line-height spacing. This allows the item baseline to
      // be positioned precisely without worrying about font ascent and
      // line-height.


      let pstrutSize = 0;

      for (let i = 0; i < children.length; i++) {
        const child = children[i];

        if (child.type === "elem") {
          const elem = child.elem;
          pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
        }
      }

      pstrutSize += 2;
      const pstrut = makeSpan(["pstrut"], []);
      pstrut.style.height = pstrutSize + "em"; // Create a new list of actual children at the correct offsets

      const realChildren = [];
      let minPos = depth;
      let maxPos = depth;
      let currPos = depth;

      for (let i = 0; i < children.length; i++) {
        const child = children[i];

        if (child.type === "kern") {
          currPos += child.size;
        } else {
          const elem = child.elem;
          const classes = child.wrapperClasses || [];
          const style = child.wrapperStyle || {};
          const childWrap = makeSpan(classes, [pstrut, elem], undefined, style);
          childWrap.style.top = -pstrutSize - currPos - elem.depth + "em";

          if (child.marginLeft) {
            childWrap.style.marginLeft = child.marginLeft;
          }

          if (child.marginRight) {
            childWrap.style.marginRight = child.marginRight;
          }

          realChildren.push(childWrap);
          currPos += elem.height + elem.depth;
        }

        minPos = Math.min(minPos, currPos);
        maxPos = Math.max(maxPos, currPos);
      } // The vlist contents go in a table-cell with `vertical-align:bottom`.
      // This cell's bottom edge will determine the containing table's baseline
      // without overly expanding the containing line-box.


      const vlist = makeSpan(["vlist"], realChildren);
      vlist.style.height = maxPos + "em"; // A second row is used if necessary to represent the vlist's depth.

      let rows;

      if (minPos < 0) {
        // We will define depth in an empty span with display: table-cell.
        // It should render with the height that we define. But Chrome, in
        // contenteditable mode only, treats that span as if it contains some
        // text content. And that min-height over-rides our desired height.
        // So we put another empty span inside the depth strut span.
        const emptySpan = makeSpan([], []);
        const depthStrut = makeSpan(["vlist"], [emptySpan]);
        depthStrut.style.height = -minPos + "em"; // Safari wants the first row to have inline content; otherwise it
        // puts the bottom of the *second* row on the baseline.

        const topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200b")]);
        rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
      } else {
        rows = [makeSpan(["vlist-r"], [vlist])];
      }

      const vtable = makeSpan(["vlist-t"], rows);

      if (rows.length === 2) {
        vtable.classes.push("vlist-t2");
      }

      vtable.height = maxPos;
      vtable.depth = -minPos;
      return vtable;
    }; // Glue is a concept from TeX which is a flexible space between elements in
    // either a vertical or horizontal list. In KaTeX, at least for now, it's
    // static space between elements in a horizontal layout.


    const makeGlue = (measurement, options) => {
      // Make an empty span for the space
      const rule = makeSpan(["mspace"], [], options);
      const size = calculateSize(measurement, options);
      rule.style.marginRight = `${size}em`;
      return rule;
    }; // Takes font options, and returns the appropriate fontLookup name


    const retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {
      let baseFontName = "";

      switch (fontFamily) {
        case "amsrm":
          baseFontName = "AMS";
          break;

        case "textrm":
          baseFontName = "Main";
          break;

        case "textsf":
          baseFontName = "SansSerif";
          break;

        case "texttt":
          baseFontName = "Typewriter";
          break;

        default:
          baseFontName = fontFamily;
        // use fonts added by a plugin
      }

      let fontStylesName;

      if (fontWeight === "textbf" && fontShape === "textit") {
        fontStylesName = "BoldItalic";
      } else if (fontWeight === "textbf") {
        fontStylesName = "Bold";
      } else if (fontWeight === "textit") {
        fontStylesName = "Italic";
      } else {
        fontStylesName = "Regular";
      }

      return `${baseFontName}-${fontStylesName}`;
    };
    /**
     * Maps TeX font commands to objects containing:
     * - variant: string used for "mathvariant" attribute in buildMathML.js
     * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
     */
    // A map between tex font commands an MathML mathvariant attribute values


    const fontMap = {
      // styles
      "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
      },
      "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
      },
      "textit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      "mathit": {
        variant: "italic",
        fontName: "Main-Italic"
      },
      // Default math font, "mathnormal" and "boldsymbol" are missing because they
      // require the use of several fonts: Main-Italic and Math-Italic for default
      // math font, Main-Italic, Math-Italic, Caligraphic for "mathnormal", and
      // Math-BoldItalic and Main-Bold for "boldsymbol".  This is handled by a
      // special case in makeOrd which ends up calling mathdefault, mathnormal,
      // and boldsymbol.
      // families
      "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
      },
      "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
      },
      "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
      },
      "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
      },
      "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
      },
      "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
      }
    };
    const svgData = {
      //   path, width, height
      vec: ["vec", 0.471, 0.714],
      // values from the font glyph
      oiintSize1: ["oiintSize1", 0.957, 0.499],
      // oval to overlay the integrand
      oiintSize2: ["oiintSize2", 1.472, 0.659],
      oiiintSize1: ["oiiintSize1", 1.304, 0.499],
      oiiintSize2: ["oiiintSize2", 1.98, 0.659]
    };

    const staticSvg = function staticSvg(value, options) {
      // Create a span with inline SVG for the element.
      const _svgData$value = svgData[value],
            pathName = _svgData$value[0],
            width = _svgData$value[1],
            height = _svgData$value[2];
      const path = new PathNode(pathName);
      const svgNode = new SvgNode([path], {
        "width": width + "em",
        "height": height + "em",
        // Override CSS rule `.katex svg { width: 100% }`
        "style": "width:" + width + "em",
        "viewBox": "0 0 " + 1000 * width + " " + 1000 * height,
        "preserveAspectRatio": "xMinYMin"
      });
      const span = makeSvgSpan(["overlay"], [svgNode], options);
      span.height = height;
      span.style.height = height + "em";
      span.style.width = width + "em";
      return span;
    };

    var buildCommon = {
      fontMap,
      makeSymbol,
      mathsym,
      makeSpan,
      makeSvgSpan,
      makeLineSpan,
      makeAnchor,
      makeFragment,
      wrapFragment,
      makeVList,
      makeOrd,
      makeGlue,
      staticSvg,
      svgData,
      tryCombineChars
    };

    /**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */
    function assertNodeType(node, type) {
      const typedNode = checkNodeType(node, type);

      if (!typedNode) {
        throw new Error(`Expected node of type ${type}, but got ` + (node ? `node of type ${node.type}` : String(node)));
      } // $FlowFixMe: Unsure why.


      return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function checkNodeType(node, type) {
      if (node && node.type === type) {
        // The definition of ParseNode<TYPE> doesn't communicate to flow that
        // `type: TYPE` (as that's not explicitly mentioned anywhere), though that
        // happens to be true for all our value types.
        // $FlowFixMe
        return node;
      }

      return null;
    }
    /**
     * Asserts that the node is of the given type and returns it with stricter
     * typing. Throws if the node's type does not match.
     */

    function assertAtomFamily(node, family) {
      const typedNode = checkAtomFamily(node, family);

      if (!typedNode) {
        throw new Error(`Expected node of type "atom" and family "${family}", but got ` + (node ? node.type === "atom" ? `atom of family ${node.family}` : `node of type ${node.type}` : String(node)));
      }

      return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function checkAtomFamily(node, family) {
      return node && node.type === "atom" && node.family === family ? node : null;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function assertSymbolNodeType(node) {
      const typedNode = checkSymbolNodeType(node);

      if (!typedNode) {
        throw new Error(`Expected node of symbol group type, but got ` + (node ? `node of type ${node.type}` : String(node)));
      }

      return typedNode;
    }
    /**
     * Returns the node more strictly typed iff it is of the given type. Otherwise,
     * returns null.
     */

    function checkSymbolNodeType(node) {
      if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
        // $FlowFixMe
        return node;
      }

      return null;
    }

    /**
     * Describes spaces between different classes of atoms.
     */
    const thinspace = {
      number: 3,
      unit: "mu"
    };
    const mediumspace = {
      number: 4,
      unit: "mu"
    };
    const thickspace = {
      number: 5,
      unit: "mu"
    }; // Making the type below exact with all optional fields doesn't work due to
    // - https://github.com/facebook/flow/issues/4582
    // - https://github.com/facebook/flow/issues/5688
    // However, since *all* fields are optional, $Shape<> works as suggested in 5688
    // above.

    // Spacing relationships for display and text styles
    const spacings = {
      mord: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        minner: thinspace
      },
      mbin: {
        mord: mediumspace,
        mop: mediumspace,
        mopen: mediumspace,
        minner: mediumspace
      },
      mrel: {
        mord: thickspace,
        mop: thickspace,
        mopen: thickspace,
        minner: thickspace
      },
      mopen: {},
      mclose: {
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        minner: thinspace
      },
      mpunct: {
        mord: thinspace,
        mop: thinspace,
        mrel: thickspace,
        mopen: thinspace,
        mclose: thinspace,
        mpunct: thinspace,
        minner: thinspace
      },
      minner: {
        mord: thinspace,
        mop: thinspace,
        mbin: mediumspace,
        mrel: thickspace,
        mopen: thinspace,
        mpunct: thinspace,
        minner: thinspace
      }
    }; // Spacing relationships for script and scriptscript styles

    const tightSpacings = {
      mord: {
        mop: thinspace
      },
      mop: {
        mord: thinspace,
        mop: thinspace
      },
      mbin: {},
      mrel: {},
      mopen: {},
      mclose: {
        mop: thinspace
      },
      mpunct: {},
      minner: {
        mop: thinspace
      }
    };

    /**
     * All registered functions.
     * `functions.js` just exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary.
     */
    const _functions = {};
    /**
     * All HTML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */

    const _htmlGroupBuilders = {};
    /**
     * All MathML builders. Should be only used in the `define*` and the `build*ML`
     * functions.
     */

    const _mathmlGroupBuilders = {};
    function defineFunction(_ref) {
      let type = _ref.type,
          nodeType = _ref.nodeType,
          names = _ref.names,
          props = _ref.props,
          handler = _ref.handler,
          htmlBuilder = _ref.htmlBuilder,
          mathmlBuilder = _ref.mathmlBuilder;
      // Set default values of functions
      const data = {
        type,
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: props.greediness === undefined ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        consumeMode: props.consumeMode,
        handler: handler
      };

      for (let i = 0; i < names.length; ++i) {
        // TODO: The value type of _functions should be a type union of all
        // possible `FunctionSpec<>` possibilities instead of `FunctionSpec<*>`,
        // which is an existential type.
        // $FlowFixMe
        _functions[names[i]] = data;
      }

      if (type) {
        if (htmlBuilder) {
          _htmlGroupBuilders[type] = htmlBuilder;
        }

        if (mathmlBuilder) {
          _mathmlGroupBuilders[type] = mathmlBuilder;
        }
      }
    }
    /**
     * Use this to register only the HTML and MathML builders for a function (e.g.
     * if the function's ParseNode is generated in Parser.js rather than via a
     * stand-alone handler provided to `defineFunction`).
     */

    function defineFunctionBuilders(_ref2) {
      let type = _ref2.type,
          htmlBuilder = _ref2.htmlBuilder,
          mathmlBuilder = _ref2.mathmlBuilder;
      defineFunction({
        type,
        names: [],
        props: {
          numArgs: 0
        },

        handler() {
          throw new Error('Should never be called.');
        },

        htmlBuilder,
        mathmlBuilder
      });
    } // Since the corresponding buildHTML/buildMathML function expects a
    // list of elements, we normalize for different kinds of arguments

    const ordargument = function ordargument(arg) {
      const node = checkNodeType(arg, "ordgroup");
      return node ? node.body : [arg];
    };

    /**
     * This file does the main work of building a domTree structure from a parse
     * tree. The entry point is the `buildHTML` function, which takes a parse tree.
     * Then, the buildExpression, buildGroup, and various groupBuilders functions
     * are called, to produce a final HTML tree.
     */
    const makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
    // depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
    // and the text before Rule 19.

    const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
    const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
    const styleMap = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    const DomEnum = {
      mord: "mord",
      mop: "mop",
      mbin: "mbin",
      mrel: "mrel",
      mopen: "mopen",
      mclose: "mclose",
      mpunct: "mpunct",
      minner: "minner"
    };

    /**
     * Take a list of nodes, build them in order, and return a list of the built
     * nodes. documentFragments are flattened into their contents, so the
     * returned list contains no fragments. `isRealGroup` is true if `expression`
     * is a real group (no atoms will be added on either side), as opposed to
     * a partial group (e.g. one created by \color). `surrounding` is an array
     * consisting type of nodes that will be added to the left and right.
     */
    const buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
      if (surrounding === void 0) {
        surrounding = [null, null];
      }

      // Parse expressions into `groups`.
      const groups = [];

      for (let i = 0; i < expression.length; i++) {
        const output = buildGroup(expression[i], options);

        if (output instanceof DocumentFragment) {
          const children = output.children;
          groups.push(...children);
        } else {
          groups.push(output);
        }
      } // If `expression` is a partial group, let the parent handle spacings
      // to avoid processing groups multiple times.


      if (!isRealGroup) {
        return groups;
      }

      let glueOptions = options;

      if (expression.length === 1) {
        const node = checkNodeType(expression[0], "sizing") || checkNodeType(expression[0], "styling");

        if (!node) ; else if (node.type === "sizing") {
          glueOptions = options.havingSize(node.size);
        } else if (node.type === "styling") {
          glueOptions = options.havingStyle(styleMap[node.style]);
        }
      } // Dummy spans for determining spacings between surrounding atoms.
      // If `expression` has no atoms on the left or right, class "leftmost"
      // or "rightmost", respectively, is used to indicate it.


      const dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
      const dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options); // TODO: These code assumes that a node's math class is the first element
      // of its `classes` array. A later cleanup should ensure this, for
      // instance by changing the signature of `makeSpan`.
      // Before determining what spaces to insert, perform bin cancellation.
      // Binary operators change to ordinary symbols in some contexts.

      traverseNonSpaceNodes(groups, (node, prev) => {
        const prevType = prev.classes[0];
        const type = node.classes[0];

        if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
          prev.classes[0] = "mord";
        } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
          node.classes[0] = "mord";
        }
      }, {
        node: dummyPrev
      }, dummyNext);
      traverseNonSpaceNodes(groups, (node, prev) => {
        const prevType = getTypeOfDomTree(prev);
        const type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.

        const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;

        if (space) {
          // Insert glue (spacing) after the `prev`.
          return buildCommon.makeGlue(space, glueOptions);
        }
      }, {
        node: dummyPrev
      }, dummyNext);
      return groups;
    }; // Depth-first traverse non-space `nodes`, calling `callback` with the current and
    // previous node as arguments, optionally returning a node to insert after the
    // previous node. `prev` is an object with the previous node and `insertAfter`
    // function to insert after it. `next` is a node that will be added to the right.
    // Used for bin cancellation and inserting spacings.

    const traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next) {
      if (next) {
        // temporarily append the right node, if exists
        nodes.push(next);
      }

      let i = 0;

      for (; i < nodes.length; i++) {
        const node = nodes[i];
        const partialGroup = checkPartialGroup(node);

        if (partialGroup) {
          // Recursive DFS
          traverseNonSpaceNodes(partialGroup.children, callback, prev);
          continue;
        } // Ignore explicit spaces (e.g., \;, \,) when determining what implicit
        // spacing should go between atoms of different classes


        if (node.classes[0] === "mspace") {
          continue;
        }

        const result = callback(node, prev.node);

        if (result) {
          if (prev.insertAfter) {
            prev.insertAfter(result);
          } else {
            // insert at front
            nodes.unshift(result);
            i++;
          }
        }

        prev.node = node;

        prev.insertAfter = (index => n => {
          nodes.splice(index + 1, 0, n);
          i++;
        })(i);
      }

      if (next) {
        nodes.pop();
      }
    }; // Check if given node is a partial group, i.e., does not affect spacing around.


    const checkPartialGroup = function checkPartialGroup(node) {
      if (node instanceof DocumentFragment || node instanceof Anchor) {
        return node;
      }

      return null;
    }; // Return the outermost node of a domTree.


    const getOutermostNode = function getOutermostNode(node, side) {
      const partialGroup = checkPartialGroup(node);

      if (partialGroup) {
        const children = partialGroup.children;

        if (children.length) {
          if (side === "right") {
            return getOutermostNode(children[children.length - 1], "right");
          } else if (side === "left") {
            return getOutermostNode(children[0], "left");
          }
        }
      }

      return node;
    }; // Return math atom class (mclass) of a domTree.
    // If `side` is given, it will get the type of the outermost node at given side.


    const getTypeOfDomTree = function getTypeOfDomTree(node, side) {
      if (!node) {
        return null;
      }

      if (side) {
        node = getOutermostNode(node, side);
      } // This makes a lot of assumptions as to where the type of atom
      // appears.  We should do a better job of enforcing this.


      return DomEnum[node.classes[0]] || null;
    };
    const makeNullDelimiter = function makeNullDelimiter(options, classes) {
      const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
      return makeSpan$1(classes.concat(moreClasses));
    };
    /**
     * buildGroup is the function that takes a group and calls the correct groupType
     * function for it. It also handles the interaction of size and style changes
     * between parents and children.
     */

    const buildGroup = function buildGroup(group, options, baseOptions) {
      if (!group) {
        return makeSpan$1();
      }

      if (_htmlGroupBuilders[group.type]) {
        // Call the groupBuilders function
        let groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account
        // for that size difference.

        if (baseOptions && options.size !== baseOptions.size) {
          groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
          const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          groupNode.height *= multiplier;
          groupNode.depth *= multiplier;
        }

        return groupNode;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    /**
     * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)
     * into an unbreakable HTML node of class .base, with proper struts to
     * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to
     * make up the entire expression as a sequence of unbreakable units.
     */

    function buildHTMLUnbreakable(children, options) {
      // Compute height and depth of this chunk.
      const body = makeSpan$1(["base"], children, options); // Add strut, which ensures that the top of the HTML element falls at
      // the height of the expression, and the bottom of the HTML element
      // falls at the depth of the expression.
      // We used to have separate top and bottom struts, where the bottom strut
      // would like to use `vertical-align: top`, but in IE 9 this lowers the
      // baseline of the box to the bottom of this strut (instead of staying in
      // the normal place) so we use an absolute value for vertical-align instead.

      const strut = makeSpan$1(["strut"]);
      strut.style.height = body.height + body.depth + "em";
      strut.style.verticalAlign = -body.depth + "em";
      body.children.unshift(strut);
      return body;
    }
    /**
     * Take an entire parse tree, and build it into an appropriate set of HTML
     * nodes.
     */


    function buildHTML(tree, options) {
      // Strip off outer tag wrapper for processing below.
      let tag = null;

      if (tree.length === 1 && tree[0].type === "tag") {
        tag = tree[0].tag;
        tree = tree[0].body;
      } // Build the expression contained in the tree


      const expression = buildExpression(tree, options, true);
      const children = []; // Create one base node for each chunk between potential line breaks.
      // The TeXBook [p.173] says "A formula will be broken only after a
      // relation symbol like $=$ or $<$ or $\rightarrow$, or after a binary
      // operation symbol like $+$ or $-$ or $\times$, where the relation or
      // binary operation is on the ``outer level'' of the formula (i.e., not
      // enclosed in {...} and not part of an \over construction)."

      let parts = [];

      for (let i = 0; i < expression.length; i++) {
        parts.push(expression[i]);

        if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
          // Put any post-operator glue on same line as operator.
          // Watch for \nobreak along the way, and stop at \newline.
          let nobreak = false;

          while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
            i++;
            parts.push(expression[i]);

            if (expression[i].hasClass("nobreak")) {
              nobreak = true;
            }
          } // Don't allow break if \nobreak among the post-operator glue.


          if (!nobreak) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          }
        } else if (expression[i].hasClass("newline")) {
          // Write the line except the newline
          parts.pop();

          if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
            parts = [];
          } // Put the newline at the top level


          children.push(expression[i]);
        }
      }

      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
      } // Now, if there was a tag, build it too and append it as a final child.


      let tagChild;

      if (tag) {
        tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
        tagChild.classes = ["tag"];
        children.push(tagChild);
      }

      const htmlNode = makeSpan$1(["katex-html"], children);
      htmlNode.setAttribute("aria-hidden", "true"); // Adjust the strut of the tag to be the maximum height of all children
      // (the height of the enclosing htmlNode) for proper vertical alignment.

      if (tagChild) {
        const strut = tagChild.children[0];
        strut.style.height = htmlNode.height + htmlNode.depth + "em";
        strut.style.verticalAlign = -htmlNode.depth + "em";
      }

      return htmlNode;
    }

    /**
     * These objects store data about MathML nodes. This is the MathML equivalent
     * of the types in domTree.js. Since MathML handles its own rendering, and
     * since we're mainly using MathML to improve accessibility, we don't manage
     * any of the styling state that the plain DOM nodes do.
     *
     * The `toNode` and `toMarkup` functions work simlarly to how they do in
     * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
     */
    function newDocumentFragment(children) {
      return new DocumentFragment(children);
    }
    /**
     * This node represents a general purpose MathML node of any type. The
     * constructor requires the type of node to create (for example, `"mo"` or
     * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
     */

    class MathNode {
      constructor(type, children) {
        this.type = void 0;
        this.attributes = void 0;
        this.children = void 0;
        this.type = type;
        this.attributes = {};
        this.children = children || [];
      }
      /**
       * Sets an attribute on a MathML node. MathML depends on attributes to convey a
       * semantic content, so this is used heavily.
       */


      setAttribute(name, value) {
        this.attributes[name] = value;
      }
      /**
       * Gets an attribute on a MathML node.
       */


      getAttribute(name) {
        return this.attributes[name];
      }
      /**
       * Converts the math node into a MathML-namespaced DOM element.
       */


      toNode() {
        const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }

        for (let i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }

        return node;
      }
      /**
       * Converts the math node into an HTML markup string.
       */


      toMarkup() {
        let markup = "<" + this.type; // Add the attributes

        for (const attr in this.attributes) {
          if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
          }
        }

        markup += ">";

        for (let i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }

        markup += "</" + this.type + ">";
        return markup;
      }
      /**
       * Converts the math node into a string, similar to innerText, but escaped.
       */


      toText() {
        return this.children.map(child => child.toText()).join("");
      }

    }
    /**
     * This node represents a piece of text.
     */

    class TextNode {
      constructor(text) {
        this.text = void 0;
        this.text = text;
      }
      /**
       * Converts the text node into a DOM text node.
       */


      toNode() {
        return document.createTextNode(this.text);
      }
      /**
       * Converts the text node into escaped HTML markup
       * (representing the text itself).
       */


      toMarkup() {
        return utils.escape(this.toText());
      }
      /**
       * Converts the text node into a string
       * (representing the text iteself).
       */


      toText() {
        return this.text;
      }

    }
    /**
     * This node represents a space, but may render as <mspace.../> or as text,
     * depending on the width.
     */

    class SpaceNode {
      /**
       * Create a Space node with width given in CSS ems.
       */
      constructor(width) {
        this.width = void 0;
        this.character = void 0;
        this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html
        // for a table of space-like characters.  We use Unicode
        // representations instead of &LongNames; as it's not clear how to
        // make the latter via document.createTextNode.

        if (width >= 0.05555 && width <= 0.05556) {
          this.character = "\u200a"; // &VeryThinSpace;
        } else if (width >= 0.1666 && width <= 0.1667) {
          this.character = "\u2009"; // &ThinSpace;
        } else if (width >= 0.2222 && width <= 0.2223) {
          this.character = "\u2005"; // &MediumSpace;
        } else if (width >= 0.2777 && width <= 0.2778) {
          this.character = "\u2005\u200a"; // &ThickSpace;
        } else if (width >= -0.05556 && width <= -0.05555) {
          this.character = "\u200a\u2063"; // &NegativeVeryThinSpace;
        } else if (width >= -0.1667 && width <= -0.1666) {
          this.character = "\u2009\u2063"; // &NegativeThinSpace;
        } else if (width >= -0.2223 && width <= -0.2222) {
          this.character = "\u205f\u2063"; // &NegativeMediumSpace;
        } else if (width >= -0.2778 && width <= -0.2777) {
          this.character = "\u2005\u2063"; // &NegativeThickSpace;
        } else {
          this.character = null;
        }
      }
      /**
       * Converts the math node into a MathML-namespaced DOM element.
       */


      toNode() {
        if (this.character) {
          return document.createTextNode(this.character);
        } else {
          const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
          node.setAttribute("width", this.width + "em");
          return node;
        }
      }
      /**
       * Converts the math node into an HTML markup string.
       */


      toMarkup() {
        if (this.character) {
          return `<mtext>${this.character}</mtext>`;
        } else {
          return `<mspace width="${this.width}em"/>`;
        }
      }
      /**
       * Converts the math node into a string, similar to innerText.
       */


      toText() {
        if (this.character) {
          return this.character;
        } else {
          return " ";
        }
      }

    }

    var mathMLTree = {
      MathNode,
      TextNode,
      SpaceNode,
      newDocumentFragment
    };

    /**
     * This file converts a parse tree into a cooresponding MathML tree. The main
     * entry point is the `buildMathML` function, which takes a parse tree from the
     * parser.
     */

    /**
     * Takes a symbol and converts it into a MathML text node after performing
     * optional replacement from symbols.js.
     */
    const makeText = function makeText(text, mode, options) {
      if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
        text = symbols[mode][text].replace;
      }

      return new mathMLTree.TextNode(text);
    };
    /**
     * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
     * unless the array has length 1.  Always returns a single node.
     */

    const makeRow = function makeRow(body) {
      if (body.length === 1) {
        return body[0];
      } else {
        return new mathMLTree.MathNode("mrow", body);
      }
    };
    /**
     * Returns the math variant as a string or null if none is required.
     */

    const getVariant = function getVariant(group, options) {
      // Handle \text... font specifiers as best we can.
      // MathML has a limited list of allowable mathvariant specifiers; see
      // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt
      if (options.fontFamily === "texttt") {
        return "monospace";
      } else if (options.fontFamily === "textsf") {
        if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "sans-serif-bold-italic";
        } else if (options.fontShape === "textit") {
          return "sans-serif-italic";
        } else if (options.fontWeight === "textbf") {
          return "bold-sans-serif";
        } else {
          return "sans-serif";
        }
      } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
        return "bold-italic";
      } else if (options.fontShape === "textit") {
        return "italic";
      } else if (options.fontWeight === "textbf") {
        return "bold";
      }

      const font = options.font;

      if (!font || font === "mathnormal") {
        return null;
      }

      const mode = group.mode;

      if (font === "mathit") {
        return "italic";
      } else if (font === "boldsymbol") {
        return "bold-italic";
      }

      let text = group.text;

      if (utils.contains(["\\imath", "\\jmath"], text)) {
        return null;
      }

      if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
      }

      const fontName = buildCommon.fontMap[font].fontName;

      if (getCharacterMetrics(text, fontName, mode)) {
        return buildCommon.fontMap[font].variant;
      }

      return null;
    };
    /**
     * Takes a list of nodes, builds them, and returns a list of the generated
     * MathML nodes.  Also combine consecutive <mtext> outputs into a single
     * <mtext> tag.
     */

    const buildExpression$1 = function buildExpression(expression, options) {
      const groups = [];
      let lastGroup;

      for (let i = 0; i < expression.length; i++) {
        const group = buildGroup$1(expression[i], options);

        if (group instanceof MathNode && lastGroup instanceof MathNode) {
          // Concatenate adjacent <mtext>s
          if (group.type === 'mtext' && lastGroup.type === 'mtext' && group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {
            lastGroup.children.push(...group.children);
            continue; // Concatenate adjacent <mn>s
          } else if (group.type === 'mn' && lastGroup.type === 'mn') {
            lastGroup.children.push(...group.children);
            continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>
          } else if (group.type === 'mi' && group.children.length === 1 && lastGroup.type === 'mn') {
            const child = group.children[0];

            if (child instanceof TextNode && child.text === '.') {
              lastGroup.children.push(...group.children);
              continue;
            }
          }
        }

        groups.push(group);
        lastGroup = group;
      } // TODO(kevinb): combine \\not with mrels and mords


      return groups;
    };
    /**
     * Equivalent to buildExpression, but wraps the elements in an <mrow>
     * if there's more than one.  Returns a single node instead of an array.
     */

    const buildExpressionRow = function buildExpressionRow(expression, options) {
      return makeRow(buildExpression$1(expression, options));
    };
    /**
     * Takes a group from the parser and calls the appropriate groupBuilders function
     * on it to produce a MathML node.
     */

    const buildGroup$1 = function buildGroup(group, options) {
      if (!group) {
        return new mathMLTree.MathNode("mrow");
      }

      if (_mathmlGroupBuilders[group.type]) {
        // Call the groupBuilders function
        const result = _mathmlGroupBuilders[group.type](group, options);
        return result;
      } else {
        throw new ParseError("Got group of unknown type: '" + group.type + "'");
      }
    };
    /**
     * Takes a full parse tree and settings and builds a MathML representation of
     * it. In particular, we put the elements from building the parse tree into a
     * <semantics> tag so we can also include that TeX source as an annotation.
     *
     * Note that we actually return a domTree element with a `<math>` inside it so
     * we can do appropriate styling.
     */

    function buildMathML(tree, texExpression, options) {
      const expression = buildExpression$1(tree, options); // Wrap up the expression in an mrow so it is presented in the semantics
      // tag correctly, unless it's a single <mrow> or <mtable>.

      let wrapper;

      if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
        wrapper = expression[0];
      } else {
        wrapper = new mathMLTree.MathNode("mrow", expression);
      } // Build a TeX annotation of the source


      const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
      annotation.setAttribute("encoding", "application/x-tex");
      const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
      const math = new mathMLTree.MathNode("math", [semantics]); // You can't style <math> nodes, so we wrap the node in a span.
      // NOTE: The span class is not typed to have <math> nodes as children, and
      // we don't want to make the children type more generic since the children
      // of span are expected to have more fields in `buildHtml` contexts.
      // $FlowFixMe

      return buildCommon.makeSpan(["katex-mathml"], [math]);
    }

    const optionsFromSettings = function optionsFromSettings(settings) {
      return new Options({
        style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
        maxSize: settings.maxSize
      });
    };

    const displayWrap = function displayWrap(node, settings) {
      if (settings.displayMode) {
        const classes = ["katex-display"];

        if (settings.leqno) {
          classes.push("leqno");
        }

        if (settings.fleqn) {
          classes.push("fleqn");
        }

        node = buildCommon.makeSpan(classes, [node]);
      }

      return node;
    };

    const buildTree = function buildTree(tree, expression, settings) {
      const options = optionsFromSettings(settings);
      const mathMLNode = buildMathML(tree, expression, options);
      const htmlNode = buildHTML(tree, options);
      const katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
      return displayWrap(katexNode, settings);
    };
    const buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
      const options = optionsFromSettings(settings);
      const htmlNode = buildHTML(tree, options);
      const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
      return displayWrap(katexNode, settings);
    };

    /**
     * This file provides support to buildMathML.js and buildHTML.js
     * for stretchy wide elements rendered from SVG files
     * and other CSS trickery.
     */
    const stretchyCodePoint = {
      widehat: "^",
      widecheck: "ˇ",
      widetilde: "~",
      utilde: "~",
      overleftarrow: "\u2190",
      underleftarrow: "\u2190",
      xleftarrow: "\u2190",
      overrightarrow: "\u2192",
      underrightarrow: "\u2192",
      xrightarrow: "\u2192",
      underbrace: "\u23b5",
      overbrace: "\u23de",
      overleftrightarrow: "\u2194",
      underleftrightarrow: "\u2194",
      xleftrightarrow: "\u2194",
      Overrightarrow: "\u21d2",
      xRightarrow: "\u21d2",
      overleftharpoon: "\u21bc",
      xleftharpoonup: "\u21bc",
      overrightharpoon: "\u21c0",
      xrightharpoonup: "\u21c0",
      xLeftarrow: "\u21d0",
      xLeftrightarrow: "\u21d4",
      xhookleftarrow: "\u21a9",
      xhookrightarrow: "\u21aa",
      xmapsto: "\u21a6",
      xrightharpoondown: "\u21c1",
      xleftharpoondown: "\u21bd",
      xrightleftharpoons: "\u21cc",
      xleftrightharpoons: "\u21cb",
      xtwoheadleftarrow: "\u219e",
      xtwoheadrightarrow: "\u21a0",
      xlongequal: "=",
      xtofrom: "\u21c4",
      xrightleftarrows: "\u21c4",
      xrightequilibrium: "\u21cc",
      // Not a perfect match.
      xleftequilibrium: "\u21cb" // None better available.

    };

    const mathMLnode = function mathMLnode(label) {
      const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
      node.setAttribute("stretchy", "true");
      return node;
    }; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.
    // Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)
    // Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)
    // Licensed under the SIL Open Font License, Version 1.1.
    // See \nhttp://scripts.sil.org/OFL
    // Very Long SVGs
    //    Many of the KaTeX stretchy wide elements use a long SVG image and an
    //    overflow: hidden tactic to achieve a stretchy image while avoiding
    //    distortion of arrowheads or brace corners.
    //    The SVG typically contains a very long (400 em) arrow.
    //    The SVG is in a container span that has overflow: hidden, so the span
    //    acts like a window that exposes only part of the  SVG.
    //    The SVG always has a longer, thinner aspect ratio than the container span.
    //    After the SVG fills 100% of the height of the container span,
    //    there is a long arrow shaft left over. That left-over shaft is not shown.
    //    Instead, it is sliced off because the span's CSS has overflow: hidden.
    //    Thus, the reader sees an arrow that matches the subject matter width
    //    without distortion.
    //    Some functions, such as \cancel, need to vary their aspect ratio. These
    //    functions do not get the overflow SVG treatment.
    // Second Brush Stroke
    //    Low resolution monitors struggle to display images in fine detail.
    //    So browsers apply anti-aliasing. A long straight arrow shaft therefore
    //    will sometimes appear as if it has a blurred edge.
    //    To mitigate this, these SVG files contain a second "brush-stroke" on the
    //    arrow shafts. That is, a second long thin rectangular SVG path has been
    //    written directly on top of each arrow shaft. This reinforcement causes
    //    some of the screen pixels to display as black instead of the anti-aliased
    //    gray pixel that a  single path would generate. So we get arrow shafts
    //    whose edges appear to be sharper.
    // In the katexImagesData object just below, the dimensions all
    // correspond to path geometry inside the relevant SVG.
    // For example, \overrightarrow uses the same arrowhead as glyph U+2192
    // from the KaTeX Main font. The scaling factor is 1000.
    // That is, inside the font, that arrowhead is 522 units tall, which
    // corresponds to 0.522 em inside the document.


    const katexImagesData = {
      //   path(s), minWidth, height, align
      overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
      xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
      Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
      xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
      xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
      overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
      overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
      xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
      xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
      xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
      overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
      underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
      underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
      xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
      xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
      xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
      xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
      xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
      overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
      undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
      xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
      xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
      // The next three arrows are from the mhchem package.
      // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
      // document as \xrightarrow or \xrightleftharpoons. Those have
      // min-length = 1.75em, so we set min-length on these next three to match.
      xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
      xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
      xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
    };

    const groupLength = function groupLength(arg) {
      if (arg.type === "ordgroup") {
        return arg.body.length;
      } else {
        return 1;
      }
    };

    const svgSpan = function svgSpan(group, options) {
      // Create a span with inline SVG for the element.
      function buildSvgSpan_() {
        let viewBoxWidth = 400000; // default

        const label = group.label.substr(1);

        if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
          // Each type in the `if` statement corresponds to one of the ParseNode
          // types below. This narrowing is required to access `grp.base`.
          const grp = group; // There are four SVG images available for each function.
          // Choose a taller image when there are more characters.

          const numChars = groupLength(grp.base);
          let viewBoxHeight;
          let pathName;
          let height;

          if (numChars > 5) {
            if (label === "widehat" || label === "widecheck") {
              viewBoxHeight = 420;
              viewBoxWidth = 2364;
              height = 0.42;
              pathName = label + "4";
            } else {
              viewBoxHeight = 312;
              viewBoxWidth = 2340;
              height = 0.34;
              pathName = "tilde4";
            }
          } else {
            const imgIndex = [1, 1, 2, 2, 3, 3][numChars];

            if (label === "widehat" || label === "widecheck") {
              viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
              viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
              height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
              pathName = label + imgIndex;
            } else {
              viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
              viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
              height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
              pathName = "tilde" + imgIndex;
            }
          }

          const path = new PathNode(pathName);
          const svgNode = new SvgNode([path], {
            "width": "100%",
            "height": height + "em",
            "viewBox": `0 0 ${viewBoxWidth} ${viewBoxHeight}`,
            "preserveAspectRatio": "none"
          });
          return {
            span: buildCommon.makeSvgSpan([], [svgNode], options),
            minWidth: 0,
            height
          };
        } else {
          const spans = [];
          const data = katexImagesData[label];
          const paths = data[0],
                minWidth = data[1],
                viewBoxHeight = data[2];
          const height = viewBoxHeight / 1000;
          const numSvgChildren = paths.length;
          let widthClasses;
          let aligns;

          if (numSvgChildren === 1) {
            // $FlowFixMe: All these cases must be of the 4-tuple type.
            const align1 = data[3];
            widthClasses = ["hide-tail"];
            aligns = [align1];
          } else if (numSvgChildren === 2) {
            widthClasses = ["halfarrow-left", "halfarrow-right"];
            aligns = ["xMinYMin", "xMaxYMin"];
          } else if (numSvgChildren === 3) {
            widthClasses = ["brace-left", "brace-center", "brace-right"];
            aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
          } else {
            throw new Error(`Correct katexImagesData or update code here to support
                    ${numSvgChildren} children.`);
          }

          for (let i = 0; i < numSvgChildren; i++) {
            const path = new PathNode(paths[i]);
            const svgNode = new SvgNode([path], {
              "width": "400em",
              "height": height + "em",
              "viewBox": `0 0 ${viewBoxWidth} ${viewBoxHeight}`,
              "preserveAspectRatio": aligns[i] + " slice"
            });
            const span = buildCommon.makeSvgSpan([widthClasses[i]], [svgNode], options);

            if (numSvgChildren === 1) {
              return {
                span,
                minWidth,
                height
              };
            } else {
              span.style.height = height + "em";
              spans.push(span);
            }
          }

          return {
            span: buildCommon.makeSpan(["stretchy"], spans, options),
            minWidth,
            height
          };
        }
      } // buildSvgSpan_()


      const _buildSvgSpan_ = buildSvgSpan_(),
            span = _buildSvgSpan_.span,
            minWidth = _buildSvgSpan_.minWidth,
            height = _buildSvgSpan_.height; // Note that we are returning span.depth = 0.
      // Any adjustments relative to the baseline must be done in buildHTML.


      span.height = height;
      span.style.height = height + "em";

      if (minWidth > 0) {
        span.style.minWidth = minWidth + "em";
      }

      return span;
    };

    const encloseSpan = function encloseSpan(inner, label, pad, options) {
      // Return an image span for \cancel, \bcancel, \xcancel, or \fbox
      let img;
      const totalHeight = inner.height + inner.depth + 2 * pad;

      if (/fbox|color/.test(label)) {
        img = buildCommon.makeSpan(["stretchy", label], [], options);

        if (label === "fbox") {
          const color = options.color && options.getColor();

          if (color) {
            img.style.borderColor = color;
          }
        }
      } else {
        // \cancel, \bcancel, or \xcancel
        // Since \cancel's SVG is inline and it omits the viewBox attribute,
        // its stroke-width will not vary with span area.
        const lines = [];

        if (/^[bx]cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "0",
            "x2": "100%",
            "y2": "100%",
            "stroke-width": "0.046em"
          }));
        }

        if (/^x?cancel$/.test(label)) {
          lines.push(new LineNode({
            "x1": "0",
            "y1": "100%",
            "x2": "100%",
            "y2": "0",
            "stroke-width": "0.046em"
          }));
        }

        const svgNode = new SvgNode(lines, {
          "width": "100%",
          "height": totalHeight + "em"
        });
        img = buildCommon.makeSvgSpan([], [svgNode], options);
      }

      img.height = totalHeight;
      img.style.height = totalHeight + "em";
      return img;
    };

    var stretchy = {
      encloseSpan,
      mathMLnode,
      svgSpan
    };

    // NOTE: Unlike most `htmlBuilder`s, this one handles not only "accent", but
    const htmlBuilder = (grp, options) => {
      // Accents are handled in the TeXbook pg. 443, rule 12.
      let base;
      let group;
      const supSub = checkNodeType(grp, "supsub");
      let supSubGroup;

      if (supSub) {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.
        // The real accent group is the base of the supsub group
        group = assertNodeType(supSub.base, "accent"); // The character box is the base of the accent group

        base = group.base; // Stick the character box into the base of the supsub group

        supSub.base = base; // Rerender the supsub group with its new base, and store that
        // result.

        supSubGroup = assertSpan(buildGroup(supSub, options)); // reset original base

        supSub.base = group;
      } else {
        group = assertNodeType(grp, "accent");
        base = group.base;
      } // Build the base group


      const body = buildGroup(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?

      const mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line "If the
      // nucleus is not a single character, let s = 0; otherwise set s to the
      // kern amount for the nucleus followed by the \skewchar of its font."
      // Note that our skew metrics are just the kern between each character
      // and the skewchar.

      let skew = 0;

      if (mustShift) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        const baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it

        const baseGroup = buildGroup(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.

        skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
      } // calculate the amount of space between the body and the accent


      let clearance = Math.min(body.height, options.fontMetrics().xHeight); // Build the accent

      let accentBody;

      if (!group.isStretchy) {
        let accent;
        let width;

        if (group.label === "\\vec") {
          // Before version 0.9, \vec used the combining font glyph U+20D7.
          // But browsers, especially Safari, are not consistent in how they
          // render combining characters when not preceded by a character.
          // So now we use an SVG.
          // If Safari reforms, we should consider reverting to the glyph.
          accent = buildCommon.staticSvg("vec", options);
          width = buildCommon.svgData.vec[1];
        } else {
          accent = buildCommon.makeSymbol(group.label, "Main-Regular", group.mode, options); // Remove the italic correction of the accent, because it only serves to
          // shift the accent over to a place we don't want.

          accent.italic = 0;
          width = accent.width;
        }

        accentBody = buildCommon.makeSpan(["accent-body"], [accent]); // "Full" accents expand the width of the resulting symbol to be
        // at least the width of the accent, and overlap directly onto the
        // character without any vertical offset.

        const accentFull = group.label === "\\textcircled";

        if (accentFull) {
          accentBody.classes.push('accent-full');
          clearance = body.height;
        } // Shift the accent over by the skew.


        let left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`
        // so that the accent doesn't contribute to the bounding box.
        // We need to shift the character by its width (effectively half
        // its width) to compensate.

        if (!accentFull) {
          left -= width / 2;
        }

        accentBody.style.left = left + "em"; // \textcircled uses the \bigcirc glyph, so it needs some
        // vertical adjustment to match LaTeX.

        if (group.label === "\\textcircled") {
          accentBody.style.top = ".2em";
        }

        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: -clearance
          }, {
            type: "elem",
            elem: accentBody
          }]
        }, options);
      } else {
        accentBody = stretchy.svgSpan(group, options);
        accentBody = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"],
            wrapperStyle: skew > 0 ? {
              width: `calc(100% - ${2 * skew}em)`,
              marginLeft: `${2 * skew}em`
            } : undefined
          }]
        }, options);
      }

      const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);

      if (supSubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.

        supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.

        supSubGroup.classes[0] = "mord";
        return supSubGroup;
      } else {
        return accentWrap;
      }
    };

    const mathmlBuilder = (group, options) => {
      const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
      const node = new mathMLTree.MathNode("mover", [buildGroup$1(group.base, options), accentNode]);
      node.setAttribute("accent", "true");
      return node;
    };

    const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(accent => `\\${accent}`).join("|")); // Accents

    defineFunction({
      type: "accent",
      names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        const base = args[0];
        const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
        const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
        return {
          type: "accent",
          mode: context.parser.mode,
          label: context.funcName,
          isStretchy: isStretchy,
          isShifty: isShifty,
          base: base
        };
      },
      htmlBuilder,
      mathmlBuilder
    }); // Text-mode accents

    defineFunction({
      type: "accent",
      names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
      props: {
        numArgs: 1,
        allowedInText: true,
        allowedInMath: false
      },
      handler: (context, args) => {
        const base = args[0];
        return {
          type: "accent",
          mode: context.parser.mode,
          label: context.funcName,
          isStretchy: false,
          isShifty: true,
          base: base
        };
      },
      htmlBuilder,
      mathmlBuilder
    });

    // Horizontal overlap functions
    defineFunction({
      type: "accentUnder",
      names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const base = args[0];
        return {
          type: "accentUnder",
          mode: parser.mode,
          label: funcName,
          base: base
        };
      },
      htmlBuilder: (group, options) => {
        // Treat under accents much like underlines.
        const innerGroup = buildGroup(group.base, options);
        const accentBody = stretchy.svgSpan(group, options);
        const kern = group.label === "\\utilde" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns

        const vlist = buildCommon.makeVList({
          positionType: "bottom",
          positionData: accentBody.height + kern,
          children: [{
            type: "elem",
            elem: accentBody,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: kern
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
      },
      mathmlBuilder: (group, options) => {
        const accentNode = stretchy.mathMLnode(group.label);
        const node = new mathMLTree.MathNode("munder", [buildGroup$1(group.base, options), accentNode]);
        node.setAttribute("accentunder", "true");
        return node;
      }
    });

    // Stretchy arrows with an optional argument
    defineFunction({
      type: "xArrow",
      names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", // The next 3 functions are here to support the mhchem extension.
      // Direct use of these functions is discouraged and may break someday.
      "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },

      handler(_ref, args, optArgs) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        return {
          type: "xArrow",
          mode: parser.mode,
          label: funcName,
          body: args[0],
          below: optArgs[0]
        };
      },

      // Flow is unable to correctly infer the type of `group`, even though it's
      // unamibiguously determined from the passed-in `type` above.
      htmlBuilder(group, options) {
        const style = options.style; // Build the argument groups in the appropriate style.
        // Ref: amsmath.dtx:   \hbox{$\scriptstyle\mkern#3mu{#6}\mkern#4mu$}%
        // Some groups can return document fragments.  Handle those by wrapping
        // them in a span.

        let newOptions = options.havingStyle(style.sup());
        const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
        upperGroup.classes.push("x-arrow-pad");
        let lowerGroup;

        if (group.below) {
          // Build the lower group
          newOptions = options.havingStyle(style.sub());
          lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
          lowerGroup.classes.push("x-arrow-pad");
        }

        const arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.
        // The point we want on the math axis is at 0.5 * arrowBody.height.

        const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\if0#2\else\mkern#2mu\fi

        let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu

        if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
          upperShift -= upperGroup.depth; // shift up if depth encroaches
        } // Generate the vlist


        let vlist;

        if (lowerGroup) {
          const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }, {
              type: "elem",
              elem: lowerGroup,
              shift: lowerShift
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: upperGroup,
              shift: upperShift
            }, {
              type: "elem",
              elem: arrowBody,
              shift: arrowShift
            }]
          }, options);
        } // $FlowFixMe: Replace this with passing "svg-align" into makeVList.


        vlist.children[0].children[0].children[1].classes.push("svg-align");
        return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        const arrowNode = stretchy.mathMLnode(group.label);
        let node;
        let lowerNode;

        if (group.body) {
          const upperNode = buildGroup$1(group.body, options);

          if (group.below) {
            lowerNode = buildGroup$1(group.below, options);
            node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
          } else {
            node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
          }
        } else if (group.below) {
          lowerNode = buildGroup$1(group.below, options);
          node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
        } else {
          node = new mathMLTree.MathNode("mover", [arrowNode]);
        }

        return node;
      }

    });

    // {123} and converts into symbol with code 123.  It is used by the *macro*
    // \char defined in macros.js.

    defineFunction({
      type: "textord",
      names: ["\\@char"],
      props: {
        numArgs: 1,
        allowedInText: true
      },

      handler(_ref, args) {
        let parser = _ref.parser;
        const arg = assertNodeType(args[0], "ordgroup");
        const group = arg.body;
        let number = "";

        for (let i = 0; i < group.length; i++) {
          const node = assertNodeType(group[i], "textord");
          number += node.text;
        }

        const code = parseInt(number);

        if (isNaN(code)) {
          throw new ParseError(`\\@char has non-numeric argument ${number}`);
        }

        return {
          type: "textord",
          mode: parser.mode,
          text: String.fromCharCode(code)
        };
      }

    });

    const htmlBuilder$1 = (group, options) => {
      const elements = buildExpression(group.body, options.withColor(group.color), false); // \color isn't supposed to affect the type of the elements it contains.
      // To accomplish this, we wrap the results in a fragment, so the inner
      // elements will be able to directly interact with their neighbors. For
      // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`

      return buildCommon.makeFragment(elements);
    };

    const mathmlBuilder$1 = (group, options) => {
      const inner = buildExpression$1(group.body, options);
      const node = new mathMLTree.MathNode("mstyle", inner);
      node.setAttribute("mathcolor", group.color);
      return node;
    };

    defineFunction({
      type: "color",
      names: ["\\textcolor"],
      props: {
        numArgs: 2,
        allowedInText: true,
        greediness: 3,
        argTypes: ["color", "original"]
      },

      handler(_ref, args) {
        let parser = _ref.parser;
        const color = assertNodeType(args[0], "color-token").color;
        const body = args[1];
        return {
          type: "color",
          mode: parser.mode,
          color,
          body: ordargument(body)
        };
      },

      htmlBuilder: htmlBuilder$1,
      mathmlBuilder: mathmlBuilder$1
    }); // TODO(kevinb): define these using macros

    defineFunction({
      type: "color",
      names: ["\\blue", "\\orange", "\\pink", "\\red", "\\green", "\\gray", "\\purple", "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE", "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE", "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE", "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE", "\\redA", "\\redB", "\\redC", "\\redD", "\\redE", "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE", "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE", "\\mintA", "\\mintB", "\\mintC", "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE", "\\grayF", "\\grayG", "\\grayH", "\\grayI", "\\kaBlue", "\\kaGreen"],
      props: {
        numArgs: 1,
        allowedInText: true,
        greediness: 3
      },

      handler(_ref2, args) {
        let parser = _ref2.parser,
            funcName = _ref2.funcName;
        const body = args[0];
        return {
          type: "color",
          mode: parser.mode,
          color: "katex-" + funcName.slice(1),
          body: ordargument(body)
        };
      },

      htmlBuilder: htmlBuilder$1,
      mathmlBuilder: mathmlBuilder$1
    });
    defineFunction({
      type: "color",
      names: ["\\color"],
      props: {
        numArgs: 1,
        allowedInText: true,
        greediness: 3,
        argTypes: ["color"]
      },

      handler(_ref3, args) {
        let parser = _ref3.parser,
            breakOnTokenText = _ref3.breakOnTokenText;
        const color = assertNodeType(args[0], "color-token").color; // If we see a styling function, parse out the implicit body

        const body = parser.parseExpression(true, breakOnTokenText);
        return {
          type: "color",
          mode: parser.mode,
          color,
          body
        };
      },

      htmlBuilder: htmlBuilder$1,
      mathmlBuilder: mathmlBuilder$1
    });

    // Row breaks within tabular environments, and line breaks at top level
    // same signature, we implement them as one megafunction, with newRow
    // indicating whether we're in the \cr case, and newLine indicating whether
    // to break the line in the \newline case.

    defineFunction({
      type: "cr",
      names: ["\\cr", "\\newline"],
      props: {
        numArgs: 0,
        numOptionalArgs: 1,
        argTypes: ["size"],
        allowedInText: true
      },

      handler(_ref, args, optArgs) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const size = optArgs[0];
        const newRow = funcName === "\\cr";
        let newLine = false;

        if (!newRow) {
          if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline " + "does nothing in display mode")) {
            newLine = false;
          } else {
            newLine = true;
          }
        }

        return {
          type: "cr",
          mode: parser.mode,
          newLine,
          newRow,
          size: size && assertNodeType(size, "size").value
        };
      },

      // The following builders are called only at the top level,
      // not within tabular/array environments.
      htmlBuilder(group, options) {
        if (group.newRow) {
          throw new ParseError("\\cr valid only within a tabular/array environment");
        }

        const span = buildCommon.makeSpan(["mspace"], [], options);

        if (group.newLine) {
          span.classes.push("newline");

          if (group.size) {
            span.style.marginTop = calculateSize(group.size, options) + "em";
          }
        }

        return span;
      },

      mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mspace");

        if (group.newLine) {
          node.setAttribute("linebreak", "newline");

          if (group.size) {
            node.setAttribute("height", calculateSize(group.size, options) + "em");
          }
        }

        return node;
      }

    });

    /**
     * This file deals with creating delimiters of various sizes. The TeXbook
     * discusses these routines on page 441-442, in the "Another subroutine sets box
     * x to a specified variable delimiter" paragraph.
     *
     * There are three main routines here. `makeSmallDelim` makes a delimiter in the
     * normal font, but in either text, script, or scriptscript style.
     * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
     * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
     * smaller pieces that are stacked on top of one another.
     *
     * The functions take a parameter `center`, which determines if the delimiter
     * should be centered around the axis.
     *
     * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
     * one of the given sizes. This is used for things like `\bigl`.
     * `customSizedDelim` makes a delimiter with a given total height+depth. It is
     * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
     * delimiter which surrounds an expression of a given height an depth. It is
     * used in `\left` and `\right`.
     */

    /**
     * Get the metrics for a given symbol and font, after transformation (i.e.
     * after following replacement from symbols.js)
     */
    const getMetrics = function getMetrics(symbol, font, mode) {
      const replace = symbols.math[symbol] && symbols.math[symbol].replace;
      const metrics = getCharacterMetrics(replace || symbol, font, mode);

      if (!metrics) {
        throw new Error(`Unsupported symbol ${symbol} and font size ${font}.`);
      }

      return metrics;
    };
    /**
     * Puts a delimiter span in a given style, and adds appropriate height, depth,
     * and maxFontSizes.
     */


    const styleWrap = function styleWrap(delim, toStyle, options, classes) {
      const newOptions = options.havingBaseStyle(toStyle);
      const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
      const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
      span.height *= delimSizeMultiplier;
      span.depth *= delimSizeMultiplier;
      span.maxFontSize = newOptions.sizeMultiplier;
      return span;
    };

    const centerSpan = function centerSpan(span, options, style) {
      const newOptions = options.havingBaseStyle(style);
      const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
      span.classes.push("delimcenter");
      span.style.top = shift + "em";
      span.height -= shift;
      span.depth += shift;
    };
    /**
     * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
     * font, but is restyled to either be in textstyle, scriptstyle, or
     * scriptscriptstyle.
     */


    const makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
      const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
      const span = styleWrap(text, style, options, classes);

      if (center) {
        centerSpan(span, options, style);
      }

      return span;
    };
    /**
     * Builds a symbol in the given font size (note size is an integer)
     */


    const mathrmSize = function mathrmSize(value, size, mode, options) {
      return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
    };
    /**
     * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
     * Size3, or Size4 fonts. It is always rendered in textstyle.
     */


    const makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
      const inner = mathrmSize(delim, size, mode, options);
      const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), Style$1.TEXT, options, classes);

      if (center) {
        centerSpan(span, options, Style$1.TEXT);
      }

      return span;
    };
    /**
     * Make an inner span with the given offset and in the given font. This is used
     * in `makeStackedDelim` to make the stacking pieces for the delimiter.
     */


    const makeInner = function makeInner(symbol, font, mode) {
      let sizeClass; // Apply the correct CSS class to choose the right font.

      if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
      } else
        /* if (font === "Size4-Regular") */
        {
          sizeClass = "delim-size4";
        }

      const inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element
      // in the appropriate tag that VList uses.

      return {
        type: "elem",
        elem: inner
      };
    };
    /**
     * Make a stacked delimiter out of a given delimiter, with the total height at
     * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
     */


    const makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
      // There are four parts, the top, an optional middle, a repeated part, and a
      // bottom.
      let top;
      let middle;
      let repeat;
      let bottom;
      top = repeat = bottom = delim;
      middle = null; // Also keep track of what font the delimiters are in

      let font = "Size1-Regular"; // We set the parts and font based on the symbol. Note that we use
      // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
      // repeats of the arrows

      if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
      } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
      } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
      } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
      } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
      } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
      } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
      } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
      } else if (delim === "\\lfloor" || delim === "\u230a") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
      } else if (delim === "\\lceil" || delim === "\u2308") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
      } else if (delim === "\\rfloor" || delim === "\u230b") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
      } else if (delim === "\\rceil" || delim === "\u2309") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
      } else if (delim === "(" || delim === "\\lparen") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
      } else if (delim === ")" || delim === "\\rparen") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
      } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lgroup" || delim === "\u27ee") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rgroup" || delim === "\u27ef") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\lmoustache" || delim === "\u23b0") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } else if (delim === "\\rmoustache" || delim === "\u23b1") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
      } // Get the metrics of the four sections


      const topMetrics = getMetrics(top, font, mode);
      const topHeightTotal = topMetrics.height + topMetrics.depth;
      const repeatMetrics = getMetrics(repeat, font, mode);
      const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
      const bottomMetrics = getMetrics(bottom, font, mode);
      const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
      let middleHeightTotal = 0;
      let middleFactor = 1;

      if (middle !== null) {
        const middleMetrics = getMetrics(middle, font, mode);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
      } // Calcuate the minimal height that the delimiter can have.
      // It is at least the size of the top, bottom, and optional middle combined.


      const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need

      const repeatCount = Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)); // Compute the total height of the delimiter including all the symbols

      const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note
      // that in this context, "center" means that the delimiter should be
      // centered around the axis in the current style, while normally it is
      // centered around the axis in textstyle.

      let axisHeight = options.fontMetrics().axisHeight;

      if (center) {
        axisHeight *= options.sizeMultiplier;
      } // Calculate the depth


      const depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist
      // Keep a list of the inner pieces

      const inners = []; // Add the bottom symbol

      inners.push(makeInner(bottom, font, mode));

      if (middle === null) {
        // Add that many symbols
        for (let i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }
      } else {
        // When there is a middle bit, we need the middle part and two repeated
        // sections
        for (let i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }

        inners.push(makeInner(middle, font, mode));

        for (let i = 0; i < repeatCount; i++) {
          inners.push(makeInner(repeat, font, mode));
        }
      } // Add the top symbol


      inners.push(makeInner(top, font, mode)); // Finally, build the vlist

      const newOptions = options.havingBaseStyle(Style$1.TEXT);
      const inner = buildCommon.makeVList({
        positionType: "bottom",
        positionData: depth,
        children: inners
      }, newOptions);
      return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), Style$1.TEXT, options, classes);
    }; // All surds have 0.08em padding above the viniculum inside the SVG.
    // That keeps browser span height rounding error from pinching the line.


    const vbPad = 80; // padding above the surd, measured inside the viewBox.

    const emPad = 0.08; // padding, in ems, measured in the document.

    const sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, options) {
      let alternate;

      if (sqrtName === "sqrtTall") {
        // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular
        // One path edge has a variable length. It runs from the viniculumn
        // to a point near (14 units) the bottom of the surd. The viniculum
        // is 40 units thick. So the length of the line in question is:
        const vertSegment = viewBoxHeight - 54 - vbPad;
        alternate = `M702 ${vbPad}H400000v40H742v${vertSegment}l-4 4-4 4c-.667.7
-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667
-294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155
 77-156c66 199.333 139 419.667 219 661 l218 661zM702 ${vbPad}H400000v40H742z`;
      }

      const pathNode = new PathNode(sqrtName, alternate);
      const svg = new SvgNode([pathNode], {
        // Note: 1000:1 ratio of viewBox to document em width.
        "width": "400em",
        "height": height + "em",
        "viewBox": "0 0 400000 " + viewBoxHeight,
        "preserveAspectRatio": "xMinYMin slice"
      });
      return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
    };
    /**
     * Make a sqrt image of the given height,
     */


    const makeSqrtImage = function makeSqrtImage(height, options) {
      // Define a newOptions that removes the effect of size changes such as \Huge.
      // We don't pick different a height surd for \Huge. For it, we scale up.
      const newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.

      const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
      let sizeMultiplier = newOptions.sizeMultiplier; // default
      // Create a span containing an SVG image of a sqrt symbol.

      let span;
      let spanHeight = 0;
      let texHeight = 0;
      let viewBoxHeight = 0;
      let advanceWidth; // We create viewBoxes with 80 units of "padding" above each surd.
      // Then browser rounding error on the parent span height will not
      // encroach on the ink of the viniculum. But that padding is not
      // included in the TeX-like `height` used for calculation of
      // vertical alignment. So texHeight = span.height < span.style.height.

      if (delim.type === "small") {
        // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.
        viewBoxHeight = 1000 + vbPad; // 1000 unit glyph height.

        if (height < 1.0) {
          sizeMultiplier = 1.0; // mimic a \textfont radical
        } else if (height < 1.4) {
          sizeMultiplier = 0.7; // mimic a \scriptfont radical
        }

        spanHeight = (1.0 + emPad) / sizeMultiplier;
        texHeight = 1.00 / sizeMultiplier;
        span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, options);
        span.style.minWidth = "0.853em";
        advanceWidth = 0.833 / sizeMultiplier; // from the font.
      } else if (delim.type === "large") {
        // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.
        viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];
        texHeight = sizeToMaxHeight[delim.size] / sizeMultiplier;
        spanHeight = (sizeToMaxHeight[delim.size] + emPad) / sizeMultiplier;
        span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, options);
        span.style.minWidth = "1.02em";
        advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.
      } else {
        // Tall sqrt. In TeX, this would be stacked using multiple glyphs.
        // We'll use a single SVG to accomplish the same thing.
        spanHeight = height + emPad;
        texHeight = height;
        viewBoxHeight = Math.floor(1000 * height) + vbPad;
        span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, options);
        span.style.minWidth = "0.742em";
        advanceWidth = 1.056;
      }

      span.height = texHeight;
      span.style.height = spanHeight + "em";
      return {
        span,
        advanceWidth,
        // Calculate the actual line width.
        // This actually should depend on the chosen font -- e.g. \boldmath
        // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
        // have thicker rules.
        ruleWidth: options.fontMetrics().sqrtRuleThickness * sizeMultiplier
      };
    }; // There are three kinds of delimiters, delimiters that stack when they become
    // too large


    const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"]; // delimiters that always stack

    const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1"]; // and delimiters that never stack

    const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]; // Metrics of the different sizes. Found by looking at TeX's output of
    // $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
    // Used to create stacked delimiters of appropriate sizes in makeSizedDelim.

    const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
    /**
     * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
     */

    const makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
      // < and > turn into \langle and \rangle in delimiters
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      } // Sized delimiters are never centered.


      if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
      } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
      } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
      }
    };
    /**
     * There are three different sequences of delimiter sizes that the delimiters
     * follow depending on the kind of delimiter. This is used when creating custom
     * sized delimiters to decide whether to create a small, large, or stacked
     * delimiter.
     *
     * In real TeX, these sequences aren't explicitly defined, but are instead
     * defined inside the font metrics. Since there are only three sequences that
     * are possible for the delimiters that TeX defines, it is easier to just encode
     * them explicitly here.
     */


    // Delimiters that never stack try small delimiters and large delimiters only
    const stackNeverDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }]; // Delimiters that always stack try the small delimiters first, then stack

    const stackAlwaysDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "stack"
    }]; // Delimiters that stack when large try the small and then large delimiters, and
    // stack afterwards

    const stackLargeDelimiterSequence = [{
      type: "small",
      style: Style$1.SCRIPTSCRIPT
    }, {
      type: "small",
      style: Style$1.SCRIPT
    }, {
      type: "small",
      style: Style$1.TEXT
    }, {
      type: "large",
      size: 1
    }, {
      type: "large",
      size: 2
    }, {
      type: "large",
      size: 3
    }, {
      type: "large",
      size: 4
    }, {
      type: "stack"
    }];
    /**
     * Get the font used in a delimiter based on what kind of delimiter it is.
     * TODO(#963) Use more specific font family return type once that is introduced.
     */

    const delimTypeToFont = function delimTypeToFont(type) {
      if (type.type === "small") {
        return "Main-Regular";
      } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
      } else if (type.type === "stack") {
        return "Size4-Regular";
      } else {
        throw new Error(`Add support for delim type '${type.type}' here.`);
      }
    };
    /**
     * Traverse a sequence of types of delimiters to decide what kind of delimiter
     * should be used to create a delimiter of the given height+depth.
     */


    const traverseSequence = function traverseSequence(delim, height, sequence, options) {
      // Here, we choose the index we should start at in the sequences. In smaller
      // sizes (which correspond to larger numbers in style.size) we start earlier
      // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
      // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
      const start = Math.min(2, 3 - options.style.size);

      for (let i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
          // This is always the last delimiter, so we just break the loop now.
          break;
        }

        const metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
        let heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
          const newOptions = options.havingBaseStyle(sequence[i].style);
          heightDepth *= newOptions.sizeMultiplier;
        } // Check if the delimiter at this size works for the given height.


        if (heightDepth > height) {
          return sequence[i];
        }
      } // If we reached the end of the sequence, return the last sequence element.


      return sequence[sequence.length - 1];
    };
    /**
     * Make a delimiter of a given height+depth, with optional centering. Here, we
     * traverse the sequences, and create a delimiter that the sequence tells us to.
     */


    const makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
      if (delim === "<" || delim === "\\lt" || delim === "\u27e8") {
        delim = "\\langle";
      } else if (delim === ">" || delim === "\\gt" || delim === "\u27e9") {
        delim = "\\rangle";
      } // Decide what sequence to use


      let sequence;

      if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
      } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
      } else {
        sequence = stackAlwaysDelimiterSequence;
      } // Look through the sequence


      const delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.
      // Depending on the sequence element we decided on, call the
      // appropriate function.

      if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
      } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
      } else
        /* if (delimType.type === "stack") */
        {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
    };
    /**
     * Make a delimiter for use with `\left` and `\right`, given a height and depth
     * of an expression that the delimiters surround.
     */


    const makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {
      // We always center \left/\right delimiters, so the axis is always shifted
      const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right

      const delimiterFactor = 901;
      const delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;
      const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
      const totalHeight = Math.max( // In real TeX, calculations are done using integral values which are
      // 65536 per pt, or 655360 per em. So, the division here truncates in
      // TeX but doesn't here, producing different results. If we wanted to
      // exactly match TeX's calculation, we could do
      //   Math.floor(655360 * maxDistFromAxis / 500) *
      //    delimiterFactor / 655360
      // (To see the difference, compare
      //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
      // in TeX and KaTeX)
      maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total
      // height

      return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
    };

    var delimiter = {
      sqrtImage: makeSqrtImage,
      sizedDelim: makeSizedDelim,
      customSizedDelim: makeCustomSizedDelim,
      leftRightDelim: makeLeftRightDelim
    };

    // Extra data needed for the delimiter handler down below
    const delimiterSizes = {
      "\\bigl": {
        mclass: "mopen",
        size: 1
      },
      "\\Bigl": {
        mclass: "mopen",
        size: 2
      },
      "\\biggl": {
        mclass: "mopen",
        size: 3
      },
      "\\Biggl": {
        mclass: "mopen",
        size: 4
      },
      "\\bigr": {
        mclass: "mclose",
        size: 1
      },
      "\\Bigr": {
        mclass: "mclose",
        size: 2
      },
      "\\biggr": {
        mclass: "mclose",
        size: 3
      },
      "\\Biggr": {
        mclass: "mclose",
        size: 4
      },
      "\\bigm": {
        mclass: "mrel",
        size: 1
      },
      "\\Bigm": {
        mclass: "mrel",
        size: 2
      },
      "\\biggm": {
        mclass: "mrel",
        size: 3
      },
      "\\Biggm": {
        mclass: "mrel",
        size: 4
      },
      "\\big": {
        mclass: "mord",
        size: 1
      },
      "\\Big": {
        mclass: "mord",
        size: 2
      },
      "\\bigg": {
        mclass: "mord",
        size: 3
      },
      "\\Bigg": {
        mclass: "mord",
        size: 4
      }
    };
    const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230a", "\u230b", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27e8", "\\rangle", "\u27e9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27ee", "\u27ef", "\\lmoustache", "\\rmoustache", "\u23b0", "\u23b1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];

    // Delimiter functions
    function checkDelimiter(delim, context) {
      const symDelim = checkSymbolNodeType(delim);

      if (symDelim && utils.contains(delimiters, symDelim.text)) {
        return symDelim;
      } else {
        throw new ParseError("Invalid delimiter: '" + (symDelim ? symDelim.text : JSON.stringify(delim)) + "' after '" + context.funcName + "'", delim);
      }
    }

    defineFunction({
      type: "delimsizing",
      names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        const delim = checkDelimiter(args[0], context);
        return {
          type: "delimsizing",
          mode: context.parser.mode,
          size: delimiterSizes[context.funcName].size,
          mclass: delimiterSizes[context.funcName].mclass,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        if (group.delim === ".") {
          // Empty delimiters still count as elements, even though they don't
          // show anything.
          return buildCommon.makeSpan([group.mclass]);
        } // Use delimiter.sizedDelim to generate the delimiter.


        return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
      },
      mathmlBuilder: group => {
        const children = [];

        if (group.delim !== ".") {
          children.push(makeText(group.delim, group.mode));
        }

        const node = new mathMLTree.MathNode("mo", children);

        if (group.mclass === "mopen" || group.mclass === "mclose") {
          // Only some of the delimsizing functions act as fences, and they
          // return "mopen" or "mclose" mclass.
          node.setAttribute("fence", "true");
        } else {
          // Explicitly disable fencing if it's not a fence, to override the
          // defaults.
          node.setAttribute("fence", "false");
        }

        return node;
      }
    });

    function assertParsed(group) {
      if (!group.body) {
        throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
      }
    }

    defineFunction({
      type: "leftright-right",
      names: ["\\right"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        // \left case below triggers parsing of \right in
        //   `const right = parser.parseFunction();`
        // uses this return value.
        return {
          type: "leftright-right",
          mode: context.parser.mode,
          delim: checkDelimiter(args[0], context).text
        };
      }
    });
    defineFunction({
      type: "leftright",
      names: ["\\left"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        const delim = checkDelimiter(args[0], context);
        const parser = context.parser; // Parse out the implicit body

        ++parser.leftrightDepth; // parseExpression stops before '\\right'

        const body = parser.parseExpression(false);
        --parser.leftrightDepth; // Check the next token

        parser.expect("\\right", false);
        const right = assertNodeType(parser.parseFunction(), "leftright-right");
        return {
          type: "leftright",
          mode: parser.mode,
          body,
          left: delim.text,
          right: right.delim
        };
      },
      htmlBuilder: (group, options) => {
        assertParsed(group); // Build the inner expression

        const inner = buildExpression(group.body, options, true, ["mopen", "mclose"]);
        let innerHeight = 0;
        let innerDepth = 0;
        let hadMiddle = false; // Calculate its height and depth

        for (let i = 0; i < inner.length; i++) {
          // Property `isMiddle` not defined on `span`. See comment in
          // "middle"'s htmlBuilder.
          // $FlowFixMe
          if (inner[i].isMiddle) {
            hadMiddle = true;
          } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
          }
        } // The size of delimiters is the same, regardless of what style we are
        // in. Thus, to correctly calculate the size of delimiter we need around
        // a group, we scale down the inner size based on the size.


        innerHeight *= options.sizeMultiplier;
        innerDepth *= options.sizeMultiplier;
        let leftDelim;

        if (group.left === ".") {
          // Empty delimiters in \left and \right make null delimiter spaces.
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          // Otherwise, use leftRightDelim to generate the correct sized
          // delimiter.
          leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
        } // Add it to the beginning of the expression


        inner.unshift(leftDelim); // Handle middle delimiters

        if (hadMiddle) {
          for (let i = 1; i < inner.length; i++) {
            const middleDelim = inner[i]; // Property `isMiddle` not defined on `span`. See comment in
            // "middle"'s htmlBuilder.
            // $FlowFixMe

            const isMiddle = middleDelim.isMiddle;

            if (isMiddle) {
              // Apply the options that were active when \middle was called
              inner[i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
            }
          }
        }

        let rightDelim; // Same for the right delimiter

        if (group.right === ".") {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, options, group.mode, ["mclose"]);
        } // Add it to the end of the expression.


        inner.push(rightDelim);
        return buildCommon.makeSpan(["minner"], inner, options);
      },
      mathmlBuilder: (group, options) => {
        assertParsed(group);
        const inner = buildExpression$1(group.body, options);

        if (group.left !== ".") {
          const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
          leftNode.setAttribute("fence", "true");
          inner.unshift(leftNode);
        }

        if (group.right !== ".") {
          const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
          rightNode.setAttribute("fence", "true");
          inner.push(rightNode);
        }

        return makeRow(inner);
      }
    });
    defineFunction({
      type: "middle",
      names: ["\\middle"],
      props: {
        numArgs: 1
      },
      handler: (context, args) => {
        const delim = checkDelimiter(args[0], context);

        if (!context.parser.leftrightDepth) {
          throw new ParseError("\\middle without preceding \\left", delim);
        }

        return {
          type: "middle",
          mode: context.parser.mode,
          delim: delim.text
        };
      },
      htmlBuilder: (group, options) => {
        let middleDelim;

        if (group.delim === ".") {
          middleDelim = makeNullDelimiter(options, []);
        } else {
          middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
          const isMiddle = {
            delim: group.delim,
            options
          }; // Property `isMiddle` not defined on `span`. It is only used in
          // this file above.
          // TODO: Fix this violation of the `span` type and possibly rename
          // things since `isMiddle` sounds like a boolean, but is a struct.
          // $FlowFixMe

          middleDelim.isMiddle = isMiddle;
        }

        return middleDelim;
      },
      mathmlBuilder: (group, options) => {
        const middleNode = new mathMLTree.MathNode("mo", [makeText(group.delim, group.mode)]);
        middleNode.setAttribute("fence", "true");
        return middleNode;
      }
    });

    const htmlBuilder$2 = (group, options) => {
      // \cancel, \bcancel, \xcancel, \sout, \fbox, \colorbox, \fcolorbox
      // Some groups can return document fragments.  Handle those by wrapping
      // them in a span.
      const inner = buildCommon.wrapFragment(buildGroup(group.body, options), options);
      const label = group.label.substr(1);
      const scale = options.sizeMultiplier;
      let img;
      let imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different
      // depending on whether the subject is wider than it is tall, or vice versa.
      // We don't know the width of a group, so as a proxy, we test if
      // the subject is a single character. This captures most of the
      // subjects that should get the "tall" treatment.

      const isSingleChar = utils.isCharacterBox(group.body);

      if (label === "sout") {
        img = buildCommon.makeSpan(["stretchy", "sout"]);
        img.height = options.fontMetrics().defaultRuleThickness / scale;
        imgShift = -0.5 * options.fontMetrics().xHeight;
      } else {
        // Add horizontal padding
        if (/cancel/.test(label)) {
          if (!isSingleChar) {
            inner.classes.push("cancel-pad");
          }
        } else {
          inner.classes.push("boxpad");
        } // Add vertical padding


        let vertPad = 0; // ref: LaTeX source2e: \fboxsep = 3pt;  \fboxrule = .4pt
        // ref: cancel package: \advance\totalheight2\p@ % "+2"

        if (/box/.test(label)) {
          vertPad = label === "colorbox" ? 0.3 : 0.34;
        } else {
          vertPad = isSingleChar ? 0.2 : 0;
        }

        img = stretchy.encloseSpan(inner, label, vertPad, options);
        imgShift = inner.depth + vertPad;

        if (group.backgroundColor) {
          img.style.backgroundColor = group.backgroundColor;

          if (group.borderColor) {
            img.style.borderColor = group.borderColor;
          }
        }
      }

      let vlist;

      if (group.backgroundColor) {
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [// Put the color background behind inner;
          {
            type: "elem",
            elem: img,
            shift: imgShift
          }, {
            type: "elem",
            elem: inner,
            shift: 0
          }]
        }, options);
      } else {
        vlist = buildCommon.makeVList({
          positionType: "individualShift",
          children: [// Write the \cancel stroke on top of inner.
          {
            type: "elem",
            elem: inner,
            shift: 0
          }, {
            type: "elem",
            elem: img,
            shift: imgShift,
            wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
          }]
        }, options);
      }

      if (/cancel/.test(label)) {
        // The cancel package documentation says that cancel lines add their height
        // to the expression, but tests show that isn't how it actually works.
        vlist.height = inner.height;
        vlist.depth = inner.depth;
      }

      if (/cancel/.test(label) && !isSingleChar) {
        // cancel does not create horiz space for its line extension.
        return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
      } else {
        return buildCommon.makeSpan(["mord"], [vlist], options);
      }
    };

    const mathmlBuilder$2 = (group, options) => {
      const node = new mathMLTree.MathNode("menclose", [buildGroup$1(group.body, options)]);

      switch (group.label) {
        case "\\cancel":
          node.setAttribute("notation", "updiagonalstrike");
          break;

        case "\\bcancel":
          node.setAttribute("notation", "downdiagonalstrike");
          break;

        case "\\sout":
          node.setAttribute("notation", "horizontalstrike");
          break;

        case "\\fbox":
          node.setAttribute("notation", "box");
          break;

        case "\\fcolorbox":
          // TODO(ron): I don't know any way to set the border color.
          node.setAttribute("notation", "box");
          break;

        case "\\xcancel":
          node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
          break;
      }

      if (group.backgroundColor) {
        node.setAttribute("mathbackground", group.backgroundColor);
      }

      return node;
    };

    defineFunction({
      type: "enclose",
      names: ["\\colorbox"],
      props: {
        numArgs: 2,
        allowedInText: true,
        greediness: 3,
        argTypes: ["color", "text"]
      },

      handler(_ref, args, optArgs) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const color = assertNodeType(args[0], "color-token").color;
        const body = args[1];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor: color,
          body
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$2
    });
    defineFunction({
      type: "enclose",
      names: ["\\fcolorbox"],
      props: {
        numArgs: 3,
        allowedInText: true,
        greediness: 3,
        argTypes: ["color", "color", "text"]
      },

      handler(_ref2, args, optArgs) {
        let parser = _ref2.parser,
            funcName = _ref2.funcName;
        const borderColor = assertNodeType(args[0], "color-token").color;
        const backgroundColor = assertNodeType(args[1], "color-token").color;
        const body = args[2];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          backgroundColor,
          borderColor,
          body
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$2
    });
    defineFunction({
      type: "enclose",
      names: ["\\fbox"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        allowedInText: true
      },

      handler(_ref3, args) {
        let parser = _ref3.parser;
        return {
          type: "enclose",
          mode: parser.mode,
          label: "\\fbox",
          body: args[0]
        };
      }

    });
    defineFunction({
      type: "enclose",
      names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
      props: {
        numArgs: 1
      },

      handler(_ref4, args, optArgs) {
        let parser = _ref4.parser,
            funcName = _ref4.funcName;
        const body = args[0];
        return {
          type: "enclose",
          mode: parser.mode,
          label: funcName,
          body
        };
      },

      htmlBuilder: htmlBuilder$2,
      mathmlBuilder: mathmlBuilder$2
    });

    /**
     * All registered environments.
     * `environments.js` exports this same dictionary again and makes it public.
     * `Parser.js` requires this dictionary via `environments.js`.
     */
    const _environments = {};
    function defineEnvironment(_ref) {
      let type = _ref.type,
          names = _ref.names,
          props = _ref.props,
          handler = _ref.handler,
          htmlBuilder = _ref.htmlBuilder,
          mathmlBuilder = _ref.mathmlBuilder;
      // Set default values of environments.
      const data = {
        type,
        numArgs: props.numArgs || 0,
        greediness: 1,
        allowedInText: false,
        numOptionalArgs: 0,
        handler
      };

      for (let i = 0; i < names.length; ++i) {
        // TODO: The value type of _environments should be a type union of all
        // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is
        // an existential type.
        // $FlowFixMe
        _environments[names[i]] = data;
      }

      if (htmlBuilder) {
        _htmlGroupBuilders[type] = htmlBuilder;
      }

      if (mathmlBuilder) {
        _mathmlGroupBuilders[type] = mathmlBuilder;
      }
    }

    function getHLines(parser) {
      // Return an array. The array length = number of hlines.
      // Each element in the array tells if the line is dashed.
      const hlineInfo = [];
      parser.consumeSpaces();
      let nxt = parser.nextToken.text;

      while (nxt === "\\hline" || nxt === "\\hdashline") {
        parser.consume();
        hlineInfo.push(nxt === "\\hdashline");
        parser.consumeSpaces();
        nxt = parser.nextToken.text;
      }

      return hlineInfo;
    }
    /**
     * Parse the body of the environment, with rows delimited by \\ and
     * columns delimited by &, and create a nested list in row-major order
     * with one group per cell.  If given an optional argument style
     * ("text", "display", etc.), then each cell is cast into that style.
     */


    function parseArray(parser, _ref, style) {
      let hskipBeforeAndAfter = _ref.hskipBeforeAndAfter,
          addJot = _ref.addJot,
          cols = _ref.cols,
          arraystretch = _ref.arraystretch;
      // Parse body of array with \\ temporarily mapped to \cr
      parser.gullet.beginGroup();
      parser.gullet.macros.set("\\\\", "\\cr"); // Get current arraystretch if it's not set by the environment

      if (!arraystretch) {
        const stretch = parser.gullet.expandMacroAsText("\\arraystretch");

        if (stretch == null) {
          // Default \arraystretch from lttab.dtx
          arraystretch = 1;
        } else {
          arraystretch = parseFloat(stretch);

          if (!arraystretch || arraystretch < 0) {
            throw new ParseError(`Invalid \\arraystretch: ${stretch}`);
          }
        }
      }

      let row = [];
      const body = [row];
      const rowGaps = [];
      const hLinesBeforeRow = []; // Test for \hline at the top of the array.

      hLinesBeforeRow.push(getHLines(parser));

      while (true) {
        // eslint-disable-line no-constant-condition
        let cell = parser.parseExpression(false, "\\cr");
        cell = {
          type: "ordgroup",
          mode: parser.mode,
          body: cell
        };

        if (style) {
          cell = {
            type: "styling",
            mode: parser.mode,
            style,
            body: [cell]
          };
        }

        row.push(cell);
        const next = parser.nextToken.text;

        if (next === "&") {
          parser.consume();
        } else if (next === "\\end") {
          // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
          // the last line is empty.
          // NOTE: Currently, `cell` is the last item added into `row`.
          if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
            body.pop();
          }

          if (hLinesBeforeRow.length < body.length + 1) {
            hLinesBeforeRow.push([]);
          }

          break;
        } else if (next === "\\cr") {
          const cr = assertNodeType(parser.parseFunction(), "cr");
          rowGaps.push(cr.size); // check for \hline(s) following the row separator

          hLinesBeforeRow.push(getHLines(parser));
          row = [];
          body.push(row);
        } else {
          throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
        }
      }

      parser.gullet.endGroup();
      return {
        type: "array",
        mode: parser.mode,
        addJot,
        arraystretch,
        body,
        cols,
        rowGaps,
        hskipBeforeAndAfter,
        hLinesBeforeRow
      };
    } // Decides on a style for cells in an array according to whether the given
    // environment name starts with the letter 'd'.


    function dCellStyle(envName) {
      if (envName.substr(0, 1) === "d") {
        return "display";
      } else {
        return "text";
      }
    }

    const htmlBuilder$3 = function htmlBuilder(group, options) {
      let r;
      let c;
      const nr = group.body.length;
      const hLinesBeforeRow = group.hLinesBeforeRow;
      let nc = 0;
      let body = new Array(nr);
      const hlines = []; // Horizontal spacing

      const pt = 1 / options.fontMetrics().ptPerEm;
      const arraycolsep = 5 * pt; // \arraycolsep in article.cls
      // Vertical spacing

      const baselineskip = 12 * pt; // see size10.clo
      // Default \jot from ltmath.dtx
      // TODO(edemaine): allow overriding \jot via \setlength (#687)

      const jot = 3 * pt;
      const arrayskip = group.arraystretch * baselineskip;
      const arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and

      const arstrutDepth = 0.3 * arrayskip; // \@arstrutbox in lttab.dtx

      let totalHeight = 0; // Set a position for \hline(s) at the top of the array, if any.

      function setHLinePos(hlinesInGap) {
        for (let i = 0; i < hlinesInGap.length; ++i) {
          if (i > 0) {
            totalHeight += 0.25;
          }

          hlines.push({
            pos: totalHeight,
            isDashed: hlinesInGap[i]
          });
        }
      }

      setHLinePos(hLinesBeforeRow[0]);

      for (r = 0; r < group.body.length; ++r) {
        const inrow = group.body[r];
        let height = arstrutHeight; // \@array adds an \@arstrut

        let depth = arstrutDepth; // to each tow (via the template)

        if (nc < inrow.length) {
          nc = inrow.length;
        }

        const outrow = new Array(inrow.length);

        for (c = 0; c < inrow.length; ++c) {
          const elt = buildGroup(inrow[c], options);

          if (depth < elt.depth) {
            depth = elt.depth;
          }

          if (height < elt.height) {
            height = elt.height;
          }

          outrow[c] = elt;
        }

        const rowGap = group.rowGaps[r];
        let gap = 0;

        if (rowGap) {
          gap = calculateSize(rowGap, options);

          if (gap > 0) {
            // \@argarraycr
            gap += arstrutDepth;

            if (depth < gap) {
              depth = gap; // \@xargarraycr
            }

            gap = 0;
          }
        } // In AMS multiline environments such as aligned and gathered, rows
        // correspond to lines that have additional \jot added to the
        // \baselineskip via \openup.


        if (group.addJot) {
          depth += jot;
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr

        body[r] = outrow; // Set a position for \hline(s), if any.

        setHLinePos(hLinesBeforeRow[r + 1]);
      }

      const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
      const colDescriptions = group.cols || [];
      const cols = [];
      let colSep;
      let colDescrNum;

      for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column
      // descriptions, so trailing separators don't get lost.
      c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
        let colDescr = colDescriptions[colDescrNum] || {};
        let firstSeparator = true;

        while (colDescr.type === "separator") {
          // If there is more than one separator in a row, add a space
          // between them.
          if (!firstSeparator) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
            cols.push(colSep);
          }

          if (colDescr.separator === "|") {
            const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
            separator.style.height = totalHeight + "em";
            separator.style.verticalAlign = -(totalHeight - offset) + "em";
            cols.push(separator);
          } else if (colDescr.separator === ":") {
            const separator = buildCommon.makeSpan(["vertical-separator", "vs-dashed"], [], options);
            separator.style.height = totalHeight + "em";
            separator.style.verticalAlign = -(totalHeight - offset) + "em";
            cols.push(separator);
          } else {
            throw new ParseError("Invalid separator type: " + colDescr.separator);
          }

          colDescrNum++;
          colDescr = colDescriptions[colDescrNum] || {};
          firstSeparator = false;
        }

        if (c >= nc) {
          continue;
        }

        let sepwidth;

        if (c > 0 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.pregap, arraycolsep);

          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = sepwidth + "em";
            cols.push(colSep);
          }
        }

        let col = [];

        for (r = 0; r < nr; ++r) {
          const row = body[r];
          const elem = row[c];

          if (!elem) {
            continue;
          }

          const shift = row.pos - offset;
          elem.depth = row.depth;
          elem.height = row.height;
          col.push({
            type: "elem",
            elem: elem,
            shift: shift
          });
        }

        col = buildCommon.makeVList({
          positionType: "individualShift",
          children: col
        }, options);
        col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
        cols.push(col);

        if (c < nc - 1 || group.hskipBeforeAndAfter) {
          sepwidth = utils.deflt(colDescr.postgap, arraycolsep);

          if (sepwidth !== 0) {
            colSep = buildCommon.makeSpan(["arraycolsep"], []);
            colSep.style.width = sepwidth + "em";
            cols.push(colSep);
          }
        }
      }

      body = buildCommon.makeSpan(["mtable"], cols); // Add \hline(s), if any.

      if (hlines.length > 0) {
        const line = buildCommon.makeLineSpan("hline", options, 0.05);
        const dashes = buildCommon.makeLineSpan("hdashline", options, 0.05);
        const vListElems = [{
          type: "elem",
          elem: body,
          shift: 0
        }];

        while (hlines.length > 0) {
          const hline = hlines.pop();
          const lineShift = hline.pos - offset;

          if (hline.isDashed) {
            vListElems.push({
              type: "elem",
              elem: dashes,
              shift: lineShift
            });
          } else {
            vListElems.push({
              type: "elem",
              elem: line,
              shift: lineShift
            });
          }
        }

        body = buildCommon.makeVList({
          positionType: "individualShift",
          children: vListElems
        }, options);
      }

      return buildCommon.makeSpan(["mord"], [body], options);
    };

    const mathmlBuilder$3 = function mathmlBuilder(group, options) {
      return new mathMLTree.MathNode("mtable", group.body.map(function (row) {
        return new mathMLTree.MathNode("mtr", row.map(function (cell) {
          return new mathMLTree.MathNode("mtd", [buildGroup$1(cell, options)]);
        }));
      }));
    }; // Convenience function for aligned and alignedat environments.


    const alignedHandler = function alignedHandler(context, args) {
      const cols = [];
      const res = parseArray(context.parser, {
        cols,
        addJot: true
      }, "display"); // Determining number of columns.
      // 1. If the first argument is given, we use it as a number of columns,
      //    and makes sure that each row doesn't exceed that number.
      // 2. Otherwise, just count number of columns = maximum number
      //    of cells in each row ("aligned" mode -- isAligned will be true).
      //
      // At the same time, prepend empty group {} at beginning of every second
      // cell in each row (starting with second cell) so that operators become
      // binary.  This behavior is implemented in amsmath's \start@aligned.

      let numMaths;
      let numCols = 0;
      const emptyGroup = {
        type: "ordgroup",
        mode: context.mode,
        body: []
      };
      const ordgroup = checkNodeType(args[0], "ordgroup");

      if (ordgroup) {
        let arg0 = "";

        for (let i = 0; i < ordgroup.body.length; i++) {
          const textord = assertNodeType(ordgroup.body[i], "textord");
          arg0 += textord.text;
        }

        numMaths = Number(arg0);
        numCols = numMaths * 2;
      }

      const isAligned = !numCols;
      res.body.forEach(function (row) {
        for (let i = 1; i < row.length; i += 2) {
          // Modify ordgroup node within styling node
          const styling = assertNodeType(row[i], "styling");
          const ordgroup = assertNodeType(styling.body[0], "ordgroup");
          ordgroup.body.unshift(emptyGroup);
        }

        if (!isAligned) {
          // Case 1
          const curMaths = row.length / 2;

          if (numMaths < curMaths) {
            throw new ParseError("Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`, row[0]);
          }
        } else if (numCols < row.length) {
          // Case 2
          numCols = row.length;
        }
      }); // Adjusting alignment.
      // In aligned mode, we add one \qquad between columns;
      // otherwise we add nothing.

      for (let i = 0; i < numCols; ++i) {
        let align = "r";
        let pregap = 0;

        if (i % 2 === 1) {
          align = "l";
        } else if (i > 0 && isAligned) {
          // "aligned" mode.
          pregap = 1; // add one \quad
        }

        cols[i] = {
          type: "align",
          align: align,
          pregap: pregap,
          postgap: 0
        };
      }

      return res;
    }; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation
    // is part of the source2e.pdf file of LaTeX2e source documentation.
    // {darray} is an {array} environment where cells are set in \displaystyle,
    // as defined in nccmath.sty.


    defineEnvironment({
      type: "array",
      names: ["array", "darray"],
      props: {
        numArgs: 1
      },

      handler(context, args) {
        // Since no types are specified above, the two possibilities are
        // - The argument is wrapped in {} or [], in which case Parser's
        //   parseGroup() returns an "ordgroup" wrapping some symbol node.
        // - The argument is a bare symbol node.
        const symNode = checkSymbolNodeType(args[0]);
        const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
        const cols = colalign.map(function (nde) {
          const node = assertSymbolNodeType(nde);
          const ca = node.text;

          if ("lcr".indexOf(ca) !== -1) {
            return {
              type: "align",
              align: ca
            };
          } else if (ca === "|") {
            return {
              type: "separator",
              separator: "|"
            };
          } else if (ca === ":") {
            return {
              type: "separator",
              separator: ":"
            };
          }

          throw new ParseError("Unknown column alignment: " + ca, nde);
        });
        const res = {
          cols,
          hskipBeforeAndAfter: true // \@preamble in lttab.dtx

        };
        return parseArray(context.parser, res, dCellStyle(context.envName));
      },

      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // The matrix environments of amsmath builds on the array environment
    // of LaTeX, which is discussed above.

    defineEnvironment({
      type: "array",
      names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
      props: {
        numArgs: 0
      },

      handler(context) {
        const delimiters = {
          "matrix": null,
          "pmatrix": ["(", ")"],
          "bmatrix": ["[", "]"],
          "Bmatrix": ["\\{", "\\}"],
          "vmatrix": ["|", "|"],
          "Vmatrix": ["\\Vert", "\\Vert"]
        }[context.envName]; // \hskip -\arraycolsep in amsmath

        const payload = {
          hskipBeforeAndAfter: false
        };
        const res = parseArray(context.parser, payload, dCellStyle(context.envName));
        return delimiters ? {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: delimiters[0],
          right: delimiters[1]
        } : res;
      },

      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // A cases environment (in amsmath.sty) is almost equivalent to
    // \def\arraystretch{1.2}%
    // \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
    // {dcases} is a {cases} environment where cells are set in \displaystyle,
    // as defined in mathtools.sty.

    defineEnvironment({
      type: "array",
      names: ["cases", "dcases"],
      props: {
        numArgs: 0
      },

      handler(context) {
        const payload = {
          arraystretch: 1.2,
          cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: 1.0
            /* 1em quad */

          }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
          }]
        };
        const res = parseArray(context.parser, payload, dCellStyle(context.envName));
        return {
          type: "leftright",
          mode: context.mode,
          body: [res],
          left: "\\{",
          right: "."
        };
      },

      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // An aligned environment is like the align* environment
    // except it operates within math mode.
    // Note that we assume \nomallineskiplimit to be zero,
    // so that \strut@ is the same as \strut.

    defineEnvironment({
      type: "array",
      names: ["aligned"],
      props: {
        numArgs: 0
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // A gathered environment is like an array environment with one centered
    // column, but where rows are considered lines so get \jot line spacing
    // and contents are set in \displaystyle.

    defineEnvironment({
      type: "array",
      names: ["gathered"],
      props: {
        numArgs: 0
      },

      handler(context) {
        const res = {
          cols: [{
            type: "align",
            align: "c"
          }],
          addJot: true
        };
        return parseArray(context.parser, res, "display");
      },

      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // alignat environment is like an align environment, but one must explicitly
    // specify maximum number of columns in each row, and can adjust spacing between
    // each columns.

    defineEnvironment({
      type: "array",
      names: ["alignedat"],
      // One for numbered and for unnumbered;
      // but, KaTeX doesn't supports math numbering yet,
      // they make no difference for now.
      props: {
        numArgs: 1
      },
      handler: alignedHandler,
      htmlBuilder: htmlBuilder$3,
      mathmlBuilder: mathmlBuilder$3
    }); // Catch \hline outside array environment

    defineFunction({
      type: "text",
      // Doesn't matter what this is.
      names: ["\\hline", "\\hdashline"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: true
      },

      handler(context, args) {
        throw new ParseError(`${context.funcName} valid only within array environment`);
      }

    });

    const environments = _environments;

    // defineEnvironment definitions.
    // $FlowFixMe, "environment" handler returns an environment ParseNode

    defineFunction({
      type: "environment",
      names: ["\\begin", "\\end"],
      props: {
        numArgs: 1,
        argTypes: ["text"]
      },

      handler(_ref, args) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const nameGroup = args[0];

        if (nameGroup.type !== "ordgroup") {
          throw new ParseError("Invalid environment name", nameGroup);
        }

        let envName = "";

        for (let i = 0; i < nameGroup.body.length; ++i) {
          envName += assertNodeType(nameGroup.body[i], "textord").text;
        }

        if (funcName === "\\begin") {
          // begin...end is similar to left...right
          if (!environments.hasOwnProperty(envName)) {
            throw new ParseError("No such environment: " + envName, nameGroup);
          } // Build the environment object. Arguments and other information will
          // be made available to the begin and end methods using properties.


          const env = environments[envName];

          const _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env),
                args = _parser$parseArgument.args,
                optArgs = _parser$parseArgument.optArgs;

          const context = {
            mode: parser.mode,
            envName,
            parser
          };
          const result = env.handler(context, args, optArgs);
          parser.expect("\\end", false);
          const endNameToken = parser.nextToken;
          const end = assertNodeType(parser.parseFunction(), "environment");

          if (end.name !== envName) {
            throw new ParseError(`Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`, endNameToken);
          }

          return result;
        }

        return {
          type: "environment",
          mode: parser.mode,
          name: envName,
          nameGroup
        };
      }

    });

    const makeSpan$2 = buildCommon.makeSpan;

    function htmlBuilder$4(group, options) {
      const elements = buildExpression(group.body, options, true);
      return makeSpan$2([group.mclass], elements, options);
    }

    function mathmlBuilder$4(group, options) {
      const inner = buildExpression$1(group.body, options);
      return mathMLTree.newDocumentFragment(inner);
    } // Math class commands except \mathop


    defineFunction({
      type: "mclass",
      names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const body = args[0];
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: "m" + funcName.substr(5),
          body: ordargument(body)
        };
      },

      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$4
    });
    const binrelClass = arg => {
      // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
      // (by rendering separately and with {}s before and after, and measuring
      // the change in spacing).  We'll do roughly the same by detecting the
      // atom type directly.
      const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;

      if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
        return "m" + atom.family;
      } else {
        return "mord";
      }
    }; // \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
    // This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.

    defineFunction({
      type: "mclass",
      names: ["\\@binrel"],
      props: {
        numArgs: 2
      },

      handler(_ref2, args) {
        let parser = _ref2.parser;
        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(args[0]),
          body: [args[1]]
        };
      }

    }); // Build a relation or stacked op by placing one symbol on top of another

    defineFunction({
      type: "mclass",
      names: ["\\stackrel", "\\overset", "\\underset"],
      props: {
        numArgs: 2
      },

      handler(_ref3, args) {
        let parser = _ref3.parser,
            funcName = _ref3.funcName;
        const baseArg = args[1];
        const shiftedArg = args[0];
        let mclass;

        if (funcName !== "\\stackrel") {
          // LaTeX applies \binrel spacing to \overset and \underset.
          mclass = binrelClass(baseArg);
        } else {
          mclass = "mrel"; // for \stackrel
        }

        const baseOp = {
          type: "op",
          mode: baseArg.mode,
          limits: true,
          alwaysHandleSupSub: true,
          symbol: false,
          suppressBaseShift: funcName !== "\\stackrel",
          body: ordargument(baseArg)
        };
        const supsub = {
          type: "supsub",
          mode: shiftedArg.mode,
          base: baseOp,
          sup: funcName === "\\underset" ? null : shiftedArg,
          sub: funcName === "\\underset" ? shiftedArg : null
        };
        return {
          type: "mclass",
          mode: parser.mode,
          mclass,
          body: [supsub]
        };
      },

      htmlBuilder: htmlBuilder$4,
      mathmlBuilder: mathmlBuilder$4
    });

    // TODO(kevinb): implement \\sl and \\sc

    const htmlBuilder$5 = (group, options) => {
      const font = group.font;
      const newOptions = options.withFont(font);
      return buildGroup(group.body, newOptions);
    };

    const mathmlBuilder$5 = (group, options) => {
      const font = group.font;
      const newOptions = options.withFont(font);
      return buildGroup$1(group.body, newOptions);
    };

    const fontAliases = {
      "\\Bbb": "\\mathbb",
      "\\bold": "\\mathbf",
      "\\frak": "\\mathfrak",
      "\\bm": "\\boldsymbol"
    };
    defineFunction({
      type: "font",
      names: [// styles, except \boldsymbol defined below
      "\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", // families
      "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", // aliases, except \bm defined below
      "\\Bbb", "\\bold", "\\frak"],
      props: {
        numArgs: 1,
        greediness: 2
      },
      handler: (_ref, args) => {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const body = args[0];
        let func = funcName;

        if (func in fontAliases) {
          func = fontAliases[func];
        }

        return {
          type: "font",
          mode: parser.mode,
          font: func.slice(1),
          body
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$5
    });
    defineFunction({
      type: "mclass",
      names: ["\\boldsymbol", "\\bm"],
      props: {
        numArgs: 1,
        greediness: 2
      },
      handler: (_ref2, args) => {
        let parser = _ref2.parser;
        const body = args[0]; // amsbsy.sty's \boldsymbol uses \binrel spacing to inherit the
        // argument's bin|rel|ord status

        return {
          type: "mclass",
          mode: parser.mode,
          mclass: binrelClass(body),
          body: [{
            type: "font",
            mode: parser.mode,
            font: "boldsymbol",
            body
          }]
        };
      }
    }); // Old font changing functions

    defineFunction({
      type: "font",
      names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it"],
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        let parser = _ref3.parser,
            funcName = _ref3.funcName,
            breakOnTokenText = _ref3.breakOnTokenText;
        const mode = parser.mode;
        const body = parser.parseExpression(true, breakOnTokenText);
        const style = `math${funcName.slice(1)}`;
        return {
          type: "font",
          mode: mode,
          font: style,
          body: {
            type: "ordgroup",
            mode: parser.mode,
            body
          }
        };
      },
      htmlBuilder: htmlBuilder$5,
      mathmlBuilder: mathmlBuilder$5
    });

    const htmlBuilder$6 = (group, options) => {
      // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
      // Figure out what style this fraction should be in based on the
      // function used
      let style = options.style;

      if (group.size === "display") {
        style = Style$1.DISPLAY;
      } else if (group.size === "text" && style.size === Style$1.DISPLAY.size) {
        // We're in a \tfrac but incoming style is displaystyle, so:
        style = Style$1.TEXT;
      } else if (group.size === "script") {
        style = Style$1.SCRIPT;
      } else if (group.size === "scriptscript") {
        style = Style$1.SCRIPTSCRIPT;
      }

      const nstyle = style.fracNum();
      const dstyle = style.fracDen();
      let newOptions;
      newOptions = options.havingStyle(nstyle);
      const numerm = buildGroup(group.numer, newOptions, options);

      if (group.continued) {
        // \cfrac inserts a \strut into the numerator.
        // Get \strut dimensions from TeXbook page 353.
        const hStrut = 8.5 / options.fontMetrics().ptPerEm;
        const dStrut = 3.5 / options.fontMetrics().ptPerEm;
        numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
        numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
      }

      newOptions = options.havingStyle(dstyle);
      const denomm = buildGroup(group.denom, newOptions, options);
      let rule;
      let ruleWidth;
      let ruleSpacing;

      if (group.hasBarLine) {
        if (group.barSize) {
          ruleWidth = calculateSize(group.barSize, options);
          rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
        } else {
          rule = buildCommon.makeLineSpan("frac-line", options);
        }

        ruleWidth = rule.height;
        ruleSpacing = rule.height;
      } else {
        rule = null;
        ruleWidth = 0;
        ruleSpacing = options.fontMetrics().defaultRuleThickness;
      } // Rule 15b


      let numShift;
      let clearance;
      let denomShift;

      if (style.size === Style$1.DISPLAY.size) {
        numShift = options.fontMetrics().num1;

        if (ruleWidth > 0) {
          clearance = 3 * ruleSpacing;
        } else {
          clearance = 7 * ruleSpacing;
        }

        denomShift = options.fontMetrics().denom1;
      } else {
        if (ruleWidth > 0) {
          numShift = options.fontMetrics().num2;
          clearance = ruleSpacing;
        } else {
          numShift = options.fontMetrics().num3;
          clearance = 3 * ruleSpacing;
        }

        denomShift = options.fontMetrics().denom2;
      }

      let frac;

      if (!rule) {
        // Rule 15c
        const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);

        if (candidateClearance < clearance) {
          numShift += 0.5 * (clearance - candidateClearance);
          denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      } else {
        // Rule 15d
        const axisHeight = options.fontMetrics().axisHeight;

        if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
          numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
        }

        if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
          denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
        }

        const midShift = -(axisHeight - 0.5 * ruleWidth);
        frac = buildCommon.makeVList({
          positionType: "individualShift",
          children: [{
            type: "elem",
            elem: denomm,
            shift: denomShift
          }, {
            type: "elem",
            elem: rule,
            shift: midShift
          }, {
            type: "elem",
            elem: numerm,
            shift: -numShift
          }]
        }, options);
      } // Since we manually change the style sometimes (with \dfrac or \tfrac),
      // account for the possible size change here.


      newOptions = options.havingStyle(style);
      frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
      frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e

      let delimSize;

      if (style.size === Style$1.DISPLAY.size) {
        delimSize = options.fontMetrics().delim1;
      } else {
        delimSize = options.fontMetrics().delim2;
      }

      let leftDelim;
      let rightDelim;

      if (group.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
      } else {
        leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
      }

      if (group.continued) {
        rightDelim = buildCommon.makeSpan([]); // zero width for \cfrac
      } else if (group.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
      } else {
        rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
      }

      return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
    };

    const mathmlBuilder$6 = (group, options) => {
      const node = new mathMLTree.MathNode("mfrac", [buildGroup$1(group.numer, options), buildGroup$1(group.denom, options)]);

      if (!group.hasBarLine) {
        node.setAttribute("linethickness", "0px");
      } else if (group.barSize) {
        const ruleWidth = calculateSize(group.barSize, options);
        node.setAttribute("linethickness", ruleWidth + "em");
      }

      if (group.leftDelim != null || group.rightDelim != null) {
        const withDelims = [];

        if (group.leftDelim != null) {
          const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim)]);
          leftOp.setAttribute("fence", "true");
          withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.rightDelim != null) {
          const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim)]);
          rightOp.setAttribute("fence", "true");
          withDelims.push(rightOp);
        }

        return makeRow(withDelims);
      }

      return node;
    };

    defineFunction({
      type: "genfrac",
      names: ["\\cfrac", "\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", // can’t be entered directly
      "\\\\bracefrac", "\\\\brackfrac"],
      props: {
        numArgs: 2,
        greediness: 2
      },
      handler: (_ref, args) => {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const numer = args[0];
        const denom = args[1];
        let hasBarLine;
        let leftDelim = null;
        let rightDelim = null;
        let size = "auto";

        switch (funcName) {
          case "\\cfrac":
          case "\\dfrac":
          case "\\frac":
          case "\\tfrac":
            hasBarLine = true;
            break;

          case "\\\\atopfrac":
            hasBarLine = false;
            break;

          case "\\dbinom":
          case "\\binom":
          case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;

          case "\\\\bracefrac":
            hasBarLine = false;
            leftDelim = "\\{";
            rightDelim = "\\}";
            break;

          case "\\\\brackfrac":
            hasBarLine = false;
            leftDelim = "[";
            rightDelim = "]";
            break;

          default:
            throw new Error("Unrecognized genfrac command");
        }

        switch (funcName) {
          case "\\cfrac":
          case "\\dfrac":
          case "\\dbinom":
            size = "display";
            break;

          case "\\tfrac":
          case "\\tbinom":
            size = "text";
            break;
        }

        return {
          type: "genfrac",
          mode: parser.mode,
          continued: funcName === "\\cfrac",
          numer,
          denom,
          hasBarLine,
          leftDelim,
          rightDelim,
          size,
          barSize: null
        };
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$6
    }); // Infix generalized fractions -- these are not rendered directly, but replaced
    // immediately by one of the variants above.

    defineFunction({
      type: "infix",
      names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
      props: {
        numArgs: 0,
        infix: true
      },

      handler(_ref2) {
        let parser = _ref2.parser,
            funcName = _ref2.funcName,
            token = _ref2.token;
        let replaceWith;

        switch (funcName) {
          case "\\over":
            replaceWith = "\\frac";
            break;

          case "\\choose":
            replaceWith = "\\binom";
            break;

          case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;

          case "\\brace":
            replaceWith = "\\\\bracefrac";
            break;

          case "\\brack":
            replaceWith = "\\\\brackfrac";
            break;

          default:
            throw new Error("Unrecognized infix genfrac command");
        }

        return {
          type: "infix",
          mode: parser.mode,
          replaceWith,
          token
        };
      }

    });
    const stylArray = ["display", "text", "script", "scriptscript"];

    const delimFromValue = function delimFromValue(delimString) {
      let delim = null;

      if (delimString.length > 0) {
        delim = delimString;
        delim = delim === "." ? null : delim;
      }

      return delim;
    };

    defineFunction({
      type: "genfrac",
      names: ["\\genfrac"],
      props: {
        numArgs: 6,
        greediness: 6,
        argTypes: ["math", "math", "size", "text", "math", "math"]
      },

      handler(_ref3, args) {
        let parser = _ref3.parser;
        const numer = args[4];
        const denom = args[5]; // Look into the parse nodes to get the desired delimiters.

        let leftNode = checkNodeType(args[0], "atom");

        if (leftNode) {
          leftNode = assertAtomFamily(args[0], "open");
        }

        const leftDelim = leftNode ? delimFromValue(leftNode.text) : null;
        let rightNode = checkNodeType(args[1], "atom");

        if (rightNode) {
          rightNode = assertAtomFamily(args[1], "close");
        }

        const rightDelim = rightNode ? delimFromValue(rightNode.text) : null;
        const barNode = assertNodeType(args[2], "size");
        let hasBarLine;
        let barSize = null;

        if (barNode.isBlank) {
          // \genfrac acts differently than \above.
          // \genfrac treats an empty size group as a signal to use a
          // standard bar size. \above would see size = 0 and omit the bar.
          hasBarLine = true;
        } else {
          barSize = barNode.value;
          hasBarLine = barSize.number > 0;
        } // Find out if we want displaystyle, textstyle, etc.


        let size = "auto";
        let styl = checkNodeType(args[3], "ordgroup");

        if (styl) {
          if (styl.body.length > 0) {
            const textOrd = assertNodeType(styl.body[0], "textord");
            size = stylArray[Number(textOrd.text)];
          }
        } else {
          styl = assertNodeType(args[3], "textord");
          size = stylArray[Number(styl.text)];
        }

        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim,
          rightDelim,
          size
        };
      },

      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$6
    }); // \above is an infix fraction that also defines a fraction bar size.

    defineFunction({
      type: "infix",
      names: ["\\above"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        infix: true
      },

      handler(_ref4, args) {
        let parser = _ref4.parser,
            funcName = _ref4.funcName,
            token = _ref4.token;
        return {
          type: "infix",
          mode: parser.mode,
          replaceWith: "\\\\abovefrac",
          size: assertNodeType(args[0], "size").value,
          token
        };
      }

    });
    defineFunction({
      type: "genfrac",
      names: ["\\\\abovefrac"],
      props: {
        numArgs: 3,
        argTypes: ["math", "size", "math"]
      },
      handler: (_ref5, args) => {
        let parser = _ref5.parser,
            funcName = _ref5.funcName;
        const numer = args[0];
        const barSize = assert(assertNodeType(args[1], "infix").size);
        const denom = args[2];
        const hasBarLine = barSize.number > 0;
        return {
          type: "genfrac",
          mode: parser.mode,
          numer,
          denom,
          continued: false,
          hasBarLine,
          barSize,
          leftDelim: null,
          rightDelim: null,
          size: "auto"
        };
      },
      htmlBuilder: htmlBuilder$6,
      mathmlBuilder: mathmlBuilder$6
    });

    // NOTE: Unlike most `htmlBuilder`s, this one handles not only "horizBrace", but
    const htmlBuilder$7 = (grp, options) => {
      const style = options.style; // Pull out the `ParseNode<"horizBrace">` if `grp` is a "supsub" node.

      let supSubGroup;
      let group;
      const supSub = checkNodeType(grp, "supsub");

      if (supSub) {
        // Ref: LaTeX source2e: }}}}\limits}
        // i.e. LaTeX treats the brace similar to an op and passes it
        // with \limits, so we need to assign supsub style.
        supSubGroup = supSub.sup ? buildGroup(supSub.sup, options.havingStyle(style.sup()), options) : buildGroup(supSub.sub, options.havingStyle(style.sub()), options);
        group = assertNodeType(supSub.base, "horizBrace");
      } else {
        group = assertNodeType(grp, "horizBrace");
      } // Build the base group


      const body = buildGroup(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element

      const braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        ┏━━━━━━━━┓
      // This first vlist contains the content and the brace:   equation

      let vlist;

      if (group.isOver) {
        vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: body
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: braceBody
          }]
        }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

        vlist.children[0].children[0].children[1].classes.push("svg-align");
      } else {
        vlist = buildCommon.makeVList({
          positionType: "bottom",
          positionData: body.depth + 0.1 + braceBody.height,
          children: [{
            type: "elem",
            elem: braceBody
          }, {
            type: "kern",
            size: 0.1
          }, {
            type: "elem",
            elem: body
          }]
        }, options); // $FlowFixMe: Replace this with passing "svg-align" into makeVList.

        vlist.children[0].children[0].children[0].classes.push("svg-align");
      }

      if (supSubGroup) {
        // To write the supsub, wrap the first vlist in another vlist:
        // They can't all go in the same vlist, because the note might be
        // wider than the equation. We want the equation to control the
        // brace width.
        //      note          long note           long note
        //   ┏━━━━━━━━┓   or    ┏━━━┓     not    ┏━━━━━━━━━┓
        //    equation           eqn                 eqn
        const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);

        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: vSpan
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: supSubGroup
            }]
          }, options);
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
            children: [{
              type: "elem",
              elem: supSubGroup
            }, {
              type: "kern",
              size: 0.2
            }, {
              type: "elem",
              elem: vSpan
            }]
          }, options);
        }
      }

      return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    };

    const mathmlBuilder$7 = (group, options) => {
      const accentNode = stretchy.mathMLnode(group.label);
      return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup$1(group.base, options), accentNode]);
    }; // Horizontal stretchy braces


    defineFunction({
      type: "horizBrace",
      names: ["\\overbrace", "\\underbrace"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        return {
          type: "horizBrace",
          mode: parser.mode,
          label: funcName,
          isOver: /^\\over/.test(funcName),
          base: args[0]
        };
      },

      htmlBuilder: htmlBuilder$7,
      mathmlBuilder: mathmlBuilder$7
    });

    defineFunction({
      type: "href",
      names: ["\\href"],
      props: {
        numArgs: 2,
        argTypes: ["url", "original"],
        allowedInText: true
      },
      handler: (_ref, args) => {
        let parser = _ref.parser;
        const body = args[1];
        const href = assertNodeType(args[0], "url").url;
        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        const elements = buildExpression(group.body, options, false);
        return buildCommon.makeAnchor(group.href, [], elements, options);
      },
      mathmlBuilder: (group, options) => {
        let math = buildExpressionRow(group.body, options);

        if (!(math instanceof MathNode)) {
          math = new MathNode("mrow", [math]);
        }

        math.setAttribute("href", group.href);
        return math;
      }
    });
    defineFunction({
      type: "href",
      names: ["\\url"],
      props: {
        numArgs: 1,
        argTypes: ["url"],
        allowedInText: true
      },
      handler: (_ref2, args) => {
        let parser = _ref2.parser;
        const href = assertNodeType(args[0], "url").url;
        const chars = [];

        for (let i = 0; i < href.length; i++) {
          let c = href[i];

          if (c === "~") {
            c = "\\textasciitilde";
          }

          chars.push({
            type: "textord",
            mode: "text",
            text: c
          });
        }

        const body = {
          type: "text",
          mode: parser.mode,
          font: "\\texttt",
          body: chars
        };
        return {
          type: "href",
          mode: parser.mode,
          href,
          body: ordargument(body)
        };
      }
    });

    defineFunction({
      type: "htmlmathml",
      names: ["\\html@mathml"],
      props: {
        numArgs: 2,
        allowedInText: true
      },
      handler: (_ref, args) => {
        let parser = _ref.parser;
        return {
          type: "htmlmathml",
          mode: parser.mode,
          html: ordargument(args[0]),
          mathml: ordargument(args[1])
        };
      },
      htmlBuilder: (group, options) => {
        const elements = buildExpression(group.html, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        return buildExpressionRow(group.mathml, options);
      }
    });

    // Horizontal spacing commands

    defineFunction({
      type: "kern",
      names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
      props: {
        numArgs: 1,
        argTypes: ["size"],
        allowedInText: true
      },

      handler(_ref, args) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const size = assertNodeType(args[0], "size");

        if (parser.settings.strict) {
          const mathFunction = funcName[1] === 'm'; // \mkern, \mskip

          const muUnit = size.value.unit === 'mu';

          if (mathFunction) {
            if (!muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} supports only mu units, ` + `not ${size.value.unit} units`);
            }

            if (parser.mode !== "math") {
              parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} works only in math mode`);
            }
          } else {
            // !mathFunction
            if (muUnit) {
              parser.settings.reportNonstrict("mathVsTextUnits", `LaTeX's ${funcName} doesn't support mu units`);
            }
          }
        }

        return {
          type: "kern",
          mode: parser.mode,
          dimension: size.value
        };
      },

      htmlBuilder(group, options) {
        return buildCommon.makeGlue(group.dimension, options);
      },

      mathmlBuilder(group, options) {
        const dimension = calculateSize(group.dimension, options);
        return new mathMLTree.SpaceNode(dimension);
      }

    });

    // Horizontal overlap functions
    defineFunction({
      type: "lap",
      names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const body = args[0];
        return {
          type: "lap",
          mode: parser.mode,
          alignment: funcName.slice(5),
          body
        };
      },
      htmlBuilder: (group, options) => {
        // mathllap, mathrlap, mathclap
        let inner;

        if (group.alignment === "clap") {
          // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/
          inner = buildCommon.makeSpan([], [buildGroup(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span

          inner = buildCommon.makeSpan(["inner"], [inner], options);
        } else {
          inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
        }

        const fix = buildCommon.makeSpan(["fix"], []);
        let node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the
        // two items involved in the lap.
        // Next, use a strut to set the height of the HTML bounding box.
        // Otherwise, a tall argument may be misplaced.

        const strut = buildCommon.makeSpan(["strut"]);
        strut.style.height = node.height + node.depth + "em";
        strut.style.verticalAlign = -node.depth + "em";
        node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.

        node = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options); // Get the horizontal spacing correct relative to adjacent items.

        return buildCommon.makeSpan(["mord"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        // mathllap, mathrlap, mathclap
        const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);

        if (group.alignment !== "rlap") {
          const offset = group.alignment === "llap" ? "-1" : "-0.5";
          node.setAttribute("lspace", offset + "width");
        }

        node.setAttribute("width", "0px");
        return node;
      }
    });

    defineFunction({
      type: "styling",
      names: ["\\(", "$"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false,
        consumeMode: "math"
      },

      handler(_ref, args) {
        let funcName = _ref.funcName,
            parser = _ref.parser;
        const outerMode = parser.mode;
        parser.switchMode("math");
        const close = funcName === "\\(" ? "\\)" : "$";
        const body = parser.parseExpression(false, close); // We can't expand the next symbol after the closing $ until after
        // switching modes back.  So don't consume within expect.

        parser.expect(close, false);
        parser.switchMode(outerMode);
        parser.consume();
        return {
          type: "styling",
          mode: parser.mode,
          style: "text",
          body
        };
      }

    }); // Check for extra closing math delimiters

    defineFunction({
      type: "text",
      // Doesn't matter what this is.
      names: ["\\)", "\\]"],
      props: {
        numArgs: 0,
        allowedInText: true,
        allowedInMath: false
      },

      handler(context, args) {
        throw new ParseError(`Mismatched ${context.funcName}`);
      }

    });

    const chooseMathStyle = (group, options) => {
      switch (options.style.size) {
        case Style$1.DISPLAY.size:
          return group.display;

        case Style$1.TEXT.size:
          return group.text;

        case Style$1.SCRIPT.size:
          return group.script;

        case Style$1.SCRIPTSCRIPT.size:
          return group.scriptscript;

        default:
          return group.text;
      }
    };

    defineFunction({
      type: "mathchoice",
      names: ["\\mathchoice"],
      props: {
        numArgs: 4
      },
      handler: (_ref, args) => {
        let parser = _ref.parser;
        return {
          type: "mathchoice",
          mode: parser.mode,
          display: ordargument(args[0]),
          text: ordargument(args[1]),
          script: ordargument(args[2]),
          scriptscript: ordargument(args[3])
        };
      },
      htmlBuilder: (group, options) => {
        const body = chooseMathStyle(group, options);
        const elements = buildExpression(body, options, false);
        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        const body = chooseMathStyle(group, options);
        return buildExpressionRow(body, options);
      }
    });

    // Limits, symbols
    // NOTE: Unlike most `htmlBuilder`s, this one handles not only "op", but also
    const htmlBuilder$8 = (grp, options) => {
      // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
      let supGroup;
      let subGroup;
      let hasLimits = false;
      let group;
      const supSub = checkNodeType(grp, "supsub");

      if (supSub) {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = supSub.sup;
        subGroup = supSub.sub;
        group = assertNodeType(supSub.base, "op");
        hasLimits = true;
      } else {
        group = assertNodeType(grp, "op");
      }

      const style = options.style; // Most operators have a large successor symbol, but these don't.

      const noSuccessor = ["\\smallint"];
      let large = false;

      if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
      }

      let base;

      if (group.symbol) {
        // If this is a symbol, create the symbol.
        const fontName = large ? "Size2-Regular" : "Size1-Regular";
        let stash = "";

        if (group.name === "\\oiint" || group.name === "\\oiiint") {
          // No font glyphs yet, so use a glyph w/o the oval.
          // TODO: When font glyphs are available, delete this code.
          stash = group.name.substr(1); // $FlowFixMe

          group.name = stash === "oiint" ? "\\iint" : "\\iiint";
        }

        base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        if (stash.length > 0) {
          // We're in \oiint or \oiiint. Overlay the oval.
          // TODO: When font glyphs are available, delete this code.
          const italic = base.italic;
          const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
          base = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: base,
              shift: 0
            }, {
              type: "elem",
              elem: oval,
              shift: large ? 0.08 : 0
            }]
          }, options); // $FlowFixMe

          group.name = "\\" + stash;
          base.classes.unshift("mop"); // $FlowFixMe

          base.italic = italic;
        }
      } else if (group.body) {
        // If this is a list, compose that list.
        const inner = buildExpression(group.body, options, true);

        if (inner.length === 1 && inner[0] instanceof SymbolNode) {
          base = inner[0];
          base.classes[0] = "mop"; // replace old mclass
        } else {
          base = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
        }
      } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup
        const output = [];

        for (let i = 1; i < group.name.length; i++) {
          output.push(buildCommon.mathsym(group.name[i], group.mode));
        }

        base = buildCommon.makeSpan(["mop"], output, options);
      } // If content of op is a single symbol, shift it vertically.


      let baseShift = 0;
      let slant = 0;

      if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
        // We suppress the shift of the base of \overset and \underset. Otherwise,
        // shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.
        // $FlowFixMe

        slant = base.italic;
      }

      if (hasLimits) {
        // IE 8 clips \int if it is in a display: inline-block. We wrap it
        // in a new span so it is an inline, and works.
        base = buildCommon.makeSpan([], [base]);
        let sub;
        let sup; // We manually have to handle the superscripts and subscripts. This,
        // aside from the kern calculations, is copied from supsub.

        if (supGroup) {
          const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
          sup = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }

        if (subGroup) {
          const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
          sub = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
          };
        } // Build the final group as a vlist of the possible subscript, base,
        // and possible superscript.


        let finalGroup;

        if (sup && sub) {
          const bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: -slant + "em"
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: slant + "em"
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else if (sub) {
          const top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note
          // that we are supposed to shift the limits by 1/2 of the slant,
          // but since we are centering the limits adding a full slant of
          // margin will shift by 1/2 that.

          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub.elem,
              marginLeft: -slant + "em"
            }, {
              type: "kern",
              size: sub.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options);
        } else if (sup) {
          const bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup.kern
            }, {
              type: "elem",
              elem: sup.elem,
              marginLeft: slant + "em"
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else {
          // This case probably shouldn't occur (this would mean the
          // supsub was sending us a group with no superscript or
          // subscript) but be safe.
          return base;
        }

        return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
      } else {
        if (baseShift) {
          base.style.position = "relative";
          base.style.top = baseShift + "em";
        }

        return base;
      }
    };

    const mathmlBuilder$8 = (group, options) => {
      let node; // TODO(emily): handle big operators using the `largeop` attribute

      if (group.symbol) {
        // This is a symbol. Just add the symbol.
        node = new MathNode("mo", [makeText(group.name, group.mode)]);
      } else if (group.body) {
        // This is an operator with children. Add them.
        node = new MathNode("mo", buildExpression$1(group.body, options));
      } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup.
        node = new MathNode("mi", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.
        // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4

        const operator = new MathNode("mo", [makeText("\u2061", "text")]);
        return newDocumentFragment([node, operator]);
      }

      return node;
    };

    const singleCharBigOps = {
      "\u220F": "\\prod",
      "\u2210": "\\coprod",
      "\u2211": "\\sum",
      "\u22c0": "\\bigwedge",
      "\u22c1": "\\bigvee",
      "\u22c2": "\\bigcap",
      "\u22c3": "\\bigcup",
      "\u2a00": "\\bigodot",
      "\u2a01": "\\bigoplus",
      "\u2a02": "\\bigotimes",
      "\u2a04": "\\biguplus",
      "\u2a06": "\\bigsqcup"
    };
    defineFunction({
      type: "op",
      names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22c0", "\u22c1", "\u22c2", "\u22c3", "\u2a00", "\u2a01", "\u2a02", "\u2a04", "\u2a06"],
      props: {
        numArgs: 0
      },
      handler: (_ref, args) => {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        let fName = funcName;

        if (fName.length === 1) {
          fName = singleCharBigOps[fName];
        }

        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          symbol: true,
          name: fName
        };
      },
      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$8
    }); // Note: calling defineFunction with a type that's already been defined only
    // works because the same htmlBuilder and mathmlBuilder are being used.

    defineFunction({
      type: "op",
      names: ["\\mathop"],
      props: {
        numArgs: 1
      },
      handler: (_ref2, args) => {
        let parser = _ref2.parser;
        const body = args[0];
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          symbol: false,
          body: ordargument(body)
        };
      },
      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$8
    }); // There are 2 flags for operators; whether they produce limits in
    // displaystyle, and whether they are symbols and should grow in
    // displaystyle. These four groups cover the four possible choices.

    const singleCharIntegrals = {
      "\u222b": "\\int",
      "\u222c": "\\iint",
      "\u222d": "\\iiint",
      "\u222e": "\\oint",
      "\u222f": "\\oiint",
      "\u2230": "\\oiiint"
    }; // No limits, not symbols

    defineFunction({
      type: "op",
      names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
      props: {
        numArgs: 0
      },

      handler(_ref3) {
        let parser = _ref3.parser,
            funcName = _ref3.funcName;
        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          symbol: false,
          name: funcName
        };
      },

      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$8
    }); // Limits, not symbols

    defineFunction({
      type: "op",
      names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
      props: {
        numArgs: 0
      },

      handler(_ref4) {
        let parser = _ref4.parser,
            funcName = _ref4.funcName;
        return {
          type: "op",
          mode: parser.mode,
          limits: true,
          symbol: false,
          name: funcName
        };
      },

      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$8
    }); // No limits, symbols

    defineFunction({
      type: "op",
      names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222b", "\u222c", "\u222d", "\u222e", "\u222f", "\u2230"],
      props: {
        numArgs: 0
      },

      handler(_ref5) {
        let parser = _ref5.parser,
            funcName = _ref5.funcName;
        let fName = funcName;

        if (fName.length === 1) {
          fName = singleCharIntegrals[fName];
        }

        return {
          type: "op",
          mode: parser.mode,
          limits: false,
          symbol: true,
          name: fName
        };
      },

      htmlBuilder: htmlBuilder$8,
      mathmlBuilder: mathmlBuilder$8
    });

    // amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@

    defineFunction({
      type: "operatorname",
      names: ["\\operatorname"],
      props: {
        numArgs: 1
      },
      handler: (_ref, args) => {
        let parser = _ref.parser;
        const body = args[0];
        return {
          type: "operatorname",
          mode: parser.mode,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        if (group.body.length > 0) {
          const body = group.body.map(child => {
            // $FlowFixMe: Check if the node has a string `text` property.
            const childText = child.text;

            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child.mode,
                text: childText
              };
            } else {
              return child;
            }
          }); // Consolidate function names into symbol characters.

          const expression = buildExpression(body, options.withFont("mathrm"), true);

          for (let i = 0; i < expression.length; i++) {
            const child = expression[i];

            if (child instanceof SymbolNode) {
              // Per amsopn package,
              // change minus to hyphen and \ast to asterisk
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }

          return buildCommon.makeSpan(["mop"], expression, options);
        } else {
          return buildCommon.makeSpan(["mop"], [], options);
        }
      },
      mathmlBuilder: (group, options) => {
        // The steps taken here are similar to the html version.
        let expression = buildExpression$1(group.body, options.withFont("mathrm")); // Is expression a string or has it something like a fraction?

        let isAllString = true; // default

        for (let i = 0; i < expression.length; i++) {
          const node = expression[i];

          if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {
            switch (node.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              // Do nothing yet.

              case "mo":
                {
                  const child = node.children[0];

                  if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  } else {
                    isAllString = false;
                  }

                  break;
                }

              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }

        if (isAllString) {
          // Write a single TextNode instead of multiple nested tags.
          const word = expression.map(node => node.toText()).join("");
          expression = [new mathMLTree.TextNode(word)];
        }

        const identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal"); // \u2061 is the same as &ApplyFunction;
        // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp

        const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        return mathMLTree.newDocumentFragment([identifier, operator]);
      }
    });

    defineFunctionBuilders({
      type: "ordgroup",

      htmlBuilder(group, options) {
        if (group.semisimple) {
          return buildCommon.makeFragment(buildExpression(group.body, options, false));
        }

        return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
      },

      mathmlBuilder(group, options) {
        return buildExpressionRow(group.body, options);
      }

    });

    defineFunction({
      type: "overline",
      names: ["\\overline"],
      props: {
        numArgs: 1
      },

      handler(_ref, args) {
        let parser = _ref.parser;
        const body = args[0];
        return {
          type: "overline",
          mode: parser.mode,
          body
        };
      },

      htmlBuilder(group, options) {
        // Overlines are handled in the TeXbook pg 443, Rule 9.
        // Build the inner group in the cramped style.
        const innerGroup = buildGroup(group.body, options.havingCrampedStyle()); // Create the line above the body

        const line = buildCommon.makeLineSpan("overline-line", options); // Generate the vlist, with the appropriate kerns

        const vlist = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: innerGroup
          }, {
            type: "kern",
            size: 3 * line.height
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: line.height
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        const node = new mathMLTree.MathNode("mover", [buildGroup$1(group.body, options), operator]);
        node.setAttribute("accent", "true");
        return node;
      }

    });

    defineFunction({
      type: "phantom",
      names: ["\\phantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args) => {
        let parser = _ref.parser;
        const body = args[0];
        return {
          type: "phantom",
          mode: parser.mode,
          body: ordargument(body)
        };
      },
      htmlBuilder: (group, options) => {
        const elements = buildExpression(group.body, options.withPhantom(), false); // \phantom isn't supposed to affect the elements it contains.
        // See "color" for more details.

        return buildCommon.makeFragment(elements);
      },
      mathmlBuilder: (group, options) => {
        const inner = buildExpression$1(group.body, options);
        return new mathMLTree.MathNode("mphantom", inner);
      }
    });
    defineFunction({
      type: "hphantom",
      names: ["\\hphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref2, args) => {
        let parser = _ref2.parser;
        const body = args[0];
        return {
          type: "hphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
        node.height = 0;
        node.depth = 0;

        if (node.children) {
          for (let i = 0; i < node.children.length; i++) {
            node.children[i].height = 0;
            node.children[i].depth = 0;
          }
        } // See smash for comment re: use of makeVList


        node = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options); // For spacing, TeX treats \smash as a math group (same spacing as ord).

        return buildCommon.makeSpan(["mord"], [node], options);
      },
      mathmlBuilder: (group, options) => {
        const inner = buildExpression$1(ordargument(group.body), options);
        const node = new mathMLTree.MathNode("mphantom", inner);
        node.setAttribute("height", "0px");
        return node;
      }
    });
    defineFunction({
      type: "vphantom",
      names: ["\\vphantom"],
      props: {
        numArgs: 1,
        allowedInText: true
      },
      handler: (_ref3, args) => {
        let parser = _ref3.parser;
        const body = args[0];
        return {
          type: "vphantom",
          mode: parser.mode,
          body
        };
      },
      htmlBuilder: (group, options) => {
        const inner = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
        const fix = buildCommon.makeSpan(["fix"], []);
        return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
      },
      mathmlBuilder: (group, options) => {
        const inner = buildExpression$1(ordargument(group.body), options);
        const node = new mathMLTree.MathNode("mphantom", inner);
        node.setAttribute("width", "0px");
        return node;
      }
    });

    function sizingGroup(value, options, baseOptions) {
      const inner = buildExpression(value, options, false);
      const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize
      // manually. Handle nested size changes.

      for (let i = 0; i < inner.length; i++) {
        const pos = inner[i].classes.indexOf("sizing");

        if (pos < 0) {
          Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
        } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
          // This is a nested size change: e.g., inner[i] is the "b" in
          // `\Huge a \small b`. Override the old size (the `reset-` class)
          // but not the new size.
          inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
        }

        inner[i].height *= multiplier;
        inner[i].depth *= multiplier;
      }

      return buildCommon.makeFragment(inner);
    }
    const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
    const htmlBuilder$9 = (group, options) => {
      // Handle sizing operators like \Huge. Real TeX doesn't actually allow
      // these functions inside of math expressions, so we do some special
      // handling.
      const newOptions = options.havingSize(group.size);
      return sizingGroup(group.body, newOptions, options);
    };
    defineFunction({
      type: "sizing",
      names: sizeFuncs,
      props: {
        numArgs: 0,
        allowedInText: true
      },
      handler: (_ref, args) => {
        let breakOnTokenText = _ref.breakOnTokenText,
            funcName = _ref.funcName,
            parser = _ref.parser;
        const body = parser.parseExpression(false, breakOnTokenText);
        return {
          type: "sizing",
          mode: parser.mode,
          // Figure out what size to use based on the list of functions above
          size: sizeFuncs.indexOf(funcName) + 1,
          body
        };
      },
      htmlBuilder: htmlBuilder$9,
      mathmlBuilder: (group, options) => {
        const newOptions = options.havingSize(group.size);
        const inner = buildExpression$1(group.body, newOptions);
        const node = new mathMLTree.MathNode("mstyle", inner); // TODO(emily): This doesn't produce the correct size for nested size
        // changes, because we don't keep state of what style we're currently
        // in, so we can't reset the size to normal before changing it.  Now
        // that we're passing an options parameter we should be able to fix
        // this.

        node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
        return node;
      }
    });

    defineFunction({
      type: "raisebox",
      names: ["\\raisebox"],
      props: {
        numArgs: 2,
        argTypes: ["size", "text"],
        allowedInText: true
      },

      handler(_ref, args) {
        let parser = _ref.parser;
        const amount = assertNodeType(args[0], "size").value;
        const body = args[1];
        return {
          type: "raisebox",
          mode: parser.mode,
          dy: amount,
          body
        };
      },

      htmlBuilder(group, options) {
        const text = {
          type: "text",
          mode: group.mode,
          body: ordargument(group.body),
          font: "mathrm" // simulate \textrm

        };
        const sizedText = {
          type: "sizing",
          mode: group.mode,
          body: [text],
          size: 6 // simulate \normalsize

        };
        const body = htmlBuilder$9(sizedText, options);
        const dy = calculateSize(group.dy, options);
        return buildCommon.makeVList({
          positionType: "shift",
          positionData: -dy,
          children: [{
            type: "elem",
            elem: body
          }]
        }, options);
      },

      mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);
        const dy = group.dy.number + group.dy.unit;
        node.setAttribute("voffset", dy);
        return node;
      }

    });

    defineFunction({
      type: "rule",
      names: ["\\rule"],
      props: {
        numArgs: 2,
        numOptionalArgs: 1,
        argTypes: ["size", "size", "size"]
      },

      handler(_ref, args, optArgs) {
        let parser = _ref.parser;
        const shift = optArgs[0];
        const width = assertNodeType(args[0], "size");
        const height = assertNodeType(args[1], "size");
        return {
          type: "rule",
          mode: parser.mode,
          shift: shift && assertNodeType(shift, "size").value,
          width: width.value,
          height: height.value
        };
      },

      htmlBuilder(group, options) {
        // Make an empty span for the rule
        const rule = buildCommon.makeSpan(["mord", "rule"], [], options); // Calculate the shift, width, and height of the rule, and account for units

        let shift = 0;

        if (group.shift) {
          shift = calculateSize(group.shift, options);
        }

        const width = calculateSize(group.width, options);
        const height = calculateSize(group.height, options); // Style the rule to the right size

        rule.style.borderRightWidth = width + "em";
        rule.style.borderTopWidth = height + "em";
        rule.style.bottom = shift + "em"; // Record the height and width

        rule.width = width;
        rule.height = height + shift;
        rule.depth = -shift; // Font size is the number large enough that the browser will
        // reserve at least `absHeight` space above the baseline.
        // The 1.125 factor was empirically determined

        rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
        return rule;
      },

      mathmlBuilder(group, options) {
        // TODO(emily): Figure out if there's an actual way to draw black boxes
        // in MathML.
        const node = new mathMLTree.MathNode("mrow");
        return node;
      }

    });

    // smash, with optional [tb], as in AMS
    defineFunction({
      type: "smash",
      names: ["\\smash"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1,
        allowedInText: true
      },
      handler: (_ref, args, optArgs) => {
        let parser = _ref.parser;
        let smashHeight = false;
        let smashDepth = false;
        const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");

        if (tbArg) {
          // Optional [tb] argument is engaged.
          // ref: amsmath: \renewcommand{\smash}[1][tb]{%
          //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
          let letter = "";

          for (let i = 0; i < tbArg.body.length; ++i) {
            const node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.

            letter = node.text;

            if (letter === "t") {
              smashHeight = true;
            } else if (letter === "b") {
              smashDepth = true;
            } else {
              smashHeight = false;
              smashDepth = false;
              break;
            }
          }
        } else {
          smashHeight = true;
          smashDepth = true;
        }

        const body = args[0];
        return {
          type: "smash",
          mode: parser.mode,
          body,
          smashHeight,
          smashDepth
        };
      },
      htmlBuilder: (group, options) => {
        const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);

        if (!group.smashHeight && !group.smashDepth) {
          return node;
        }

        if (group.smashHeight) {
          node.height = 0; // In order to influence makeVList, we have to reset the children.

          if (node.children) {
            for (let i = 0; i < node.children.length; i++) {
              node.children[i].height = 0;
            }
          }
        }

        if (group.smashDepth) {
          node.depth = 0;

          if (node.children) {
            for (let i = 0; i < node.children.length; i++) {
              node.children[i].depth = 0;
            }
          }
        } // At this point, we've reset the TeX-like height and depth values.
        // But the span still has an HTML line height.
        // makeVList applies "display: table-cell", which prevents the browser
        // from acting on that line height. So we'll call makeVList now.


        const smashedNode = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: node
          }]
        }, options); // For spacing, TeX treats \hphantom as a math group (same spacing as ord).

        return buildCommon.makeSpan(["mord"], [smashedNode], options);
      },
      mathmlBuilder: (group, options) => {
        const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, options)]);

        if (group.smashHeight) {
          node.setAttribute("height", "0px");
        }

        if (group.smashDepth) {
          node.setAttribute("depth", "0px");
        }

        return node;
      }
    });

    defineFunction({
      type: "sqrt",
      names: ["\\sqrt"],
      props: {
        numArgs: 1,
        numOptionalArgs: 1
      },

      handler(_ref, args, optArgs) {
        let parser = _ref.parser;
        const index = optArgs[0];
        const body = args[0];
        return {
          type: "sqrt",
          mode: parser.mode,
          body,
          index
        };
      },

      htmlBuilder(group, options) {
        // Square roots are handled in the TeXbook pg. 443, Rule 11.
        // First, we do the same steps as in overline to build the inner group
        // and line
        let inner = buildGroup(group.body, options.havingCrampedStyle());

        if (inner.height === 0) {
          // Render a small surd.
          inner.height = options.fontMetrics().xHeight;
        } // Some groups can return document fragments.  Handle those by wrapping
        // them in a span.


        inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \surd delimiter

        const metrics = options.fontMetrics();
        const theta = metrics.defaultRuleThickness;
        let phi = theta;

        if (options.style.id < Style$1.TEXT.id) {
          phi = options.fontMetrics().xHeight;
        } // Calculate the clearance between the body and line


        let lineClearance = theta + phi / 4;
        const minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size

        const _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options),
              img = _delimiter$sqrtImage.span,
              ruleWidth = _delimiter$sqrtImage.ruleWidth,
              advanceWidth = _delimiter$sqrtImage.advanceWidth;

        const delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size

        if (delimDepth > inner.height + inner.depth + lineClearance) {
          lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
        } // Shift the sqrt image


        const imgShift = img.height - inner.height - lineClearance - ruleWidth;
        inner.style.paddingLeft = advanceWidth + "em"; // Overlay the image and the argument.

        const body = buildCommon.makeVList({
          positionType: "firstBaseline",
          children: [{
            type: "elem",
            elem: inner,
            wrapperClasses: ["svg-align"]
          }, {
            type: "kern",
            size: -(inner.height + imgShift)
          }, {
            type: "elem",
            elem: img
          }, {
            type: "kern",
            size: ruleWidth
          }]
        }, options);

        if (!group.index) {
          return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
        } else {
          // Handle the optional root index
          // The index is always in scriptscript style
          const newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
          const rootm = buildGroup(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX
          // source, in the definition of `\r@@t`.

          const toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly

          const rootVList = buildCommon.makeVList({
            positionType: "shift",
            positionData: -toShift,
            children: [{
              type: "elem",
              elem: rootm
            }]
          }, options); // Add a class surrounding it so we can add on the appropriate
          // kerning

          const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
          return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
        }
      },

      mathmlBuilder(group, options) {
        const body = group.body,
              index = group.index;
        return index ? new mathMLTree.MathNode("mroot", [buildGroup$1(body, options), buildGroup$1(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, options)]);
      }

    });

    const styleMap$1 = {
      "display": Style$1.DISPLAY,
      "text": Style$1.TEXT,
      "script": Style$1.SCRIPT,
      "scriptscript": Style$1.SCRIPTSCRIPT
    };
    defineFunction({
      type: "styling",
      names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
      props: {
        numArgs: 0,
        allowedInText: true
      },

      handler(_ref, args) {
        let breakOnTokenText = _ref.breakOnTokenText,
            funcName = _ref.funcName,
            parser = _ref.parser;
        // parse out the implicit body
        const body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.
        // here and in buildHTML and de-dupe the enumeration of all the styles).
        // $FlowFixMe: The names above exactly match the styles.

        const style = funcName.slice(1, funcName.length - 5);
        return {
          type: "styling",
          mode: parser.mode,
          // Figure out what style to use by pulling out the style from
          // the function name
          style,
          body
        };
      },

      htmlBuilder(group, options) {
        // Style changes are handled in the TeXbook on pg. 442, Rule 3.
        const newStyle = styleMap$1[group.style];
        const newOptions = options.havingStyle(newStyle).withFont('');
        return sizingGroup(group.body, newOptions, options);
      },

      mathmlBuilder(group, options) {
        // Figure out what style we're changing to.
        // TODO(kevinb): dedupe this with buildHTML.js
        // This will be easier of handling of styling nodes is in the same file.
        const styleMap = {
          "display": Style$1.DISPLAY,
          "text": Style$1.TEXT,
          "script": Style$1.SCRIPT,
          "scriptscript": Style$1.SCRIPTSCRIPT
        };
        const newStyle = styleMap[group.style];
        const newOptions = options.havingStyle(newStyle);
        const inner = buildExpression$1(group.body, newOptions);
        const node = new mathMLTree.MathNode("mstyle", inner);
        const styleAttributes = {
          "display": ["0", "true"],
          "text": ["0", "false"],
          "script": ["1", "false"],
          "scriptscript": ["2", "false"]
        };
        const attr = styleAttributes[group.style];
        node.setAttribute("scriptlevel", attr[0]);
        node.setAttribute("displaystyle", attr[1]);
        return node;
      }

    });

    /**
     * Sometimes, groups perform special rules when they have superscripts or
     * subscripts attached to them. This function lets the `supsub` group know that
     * Sometimes, groups perform special rules when they have superscripts or
     * its inner element should handle the superscripts and subscripts instead of
     * handling them itself.
     */
    const htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
      const base = group.base;

      if (!base) {
        return null;
      } else if (base.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        const delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
        return delegate ? htmlBuilder$8 : null;
      } else if (base.type === "accent") {
        return utils.isCharacterBox(base.base) ? htmlBuilder : null;
      } else if (base.type === "horizBrace") {
        const isSup = !group.sub;
        return isSup === base.isOver ? htmlBuilder$7 : null;
      } else {
        return null;
      }
    }; // Super scripts and subscripts, whose precise placement can depend on other
    // functions that precede them.


    defineFunctionBuilders({
      type: "supsub",

      htmlBuilder(group, options) {
        // Superscript and subscripts are handled in the TeXbook on page
        // 445-446, rules 18(a-f).
        // Here is where we defer to the inner group if it should handle
        // superscripts and subscripts itself.
        const builderDelegate = htmlBuilderDelegate(group, options);

        if (builderDelegate) {
          return builderDelegate(group, options);
        }

        const valueBase = group.base,
              valueSup = group.sup,
              valueSub = group.sub;
        const base = buildGroup(valueBase, options);
        let supm;
        let subm;
        const metrics = options.fontMetrics(); // Rule 18a

        let supShift = 0;
        let subShift = 0;
        const isCharacterBox = valueBase && utils.isCharacterBox(valueBase);

        if (valueSup) {
          const newOptions = options.havingStyle(options.style.sup());
          supm = buildGroup(valueSup, newOptions, options);

          if (!isCharacterBox) {
            supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }

        if (valueSub) {
          const newOptions = options.havingStyle(options.style.sub());
          subm = buildGroup(valueSub, newOptions, options);

          if (!isCharacterBox) {
            subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
          }
        } // Rule 18c


        let minSupShift;

        if (options.style === Style$1.DISPLAY) {
          minSupShift = metrics.sup1;
        } else if (options.style.cramped) {
          minSupShift = metrics.sup3;
        } else {
          minSupShift = metrics.sup2;
        } // scriptspace is a font-size-independent size, so scale it
        // appropriately for use as the marginRight.


        const multiplier = options.sizeMultiplier;
        const marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
        let marginLeft = null;

        if (subm) {
          // Subscripts shouldn't be shifted by the base's italic correction.
          // Account for that by shifting the subscript back the appropriate
          // amount. Note we only do this when the base is a single symbol.
          const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");

          if (base instanceof SymbolNode || isOiint) {
            // $FlowFixMe
            marginLeft = -base.italic + "em";
          }
        }

        let supsub;

        if (supm && subm) {
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          subShift = Math.max(subShift, metrics.sub2);
          const ruleWidth = metrics.defaultRuleThickness; // Rule 18e

          const maxWidth = 4 * ruleWidth;

          if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
            subShift = maxWidth - (supShift - supm.depth) + subm.height;
            const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);

            if (psi > 0) {
              supShift += psi;
              subShift -= psi;
            }
          }

          const vlistElem = [{
            type: "elem",
            elem: subm,
            shift: subShift,
            marginRight,
            marginLeft
          }, {
            type: "elem",
            elem: supm,
            shift: -supShift,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "individualShift",
            children: vlistElem
          }, options);
        } else if (subm) {
          // Rule 18b
          subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
          const vlistElem = [{
            type: "elem",
            elem: subm,
            marginLeft,
            marginRight
          }];
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: subShift,
            children: vlistElem
          }, options);
        } else if (supm) {
          // Rule 18c, d
          supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
          supsub = buildCommon.makeVList({
            positionType: "shift",
            positionData: -supShift,
            children: [{
              type: "elem",
              elem: supm,
              marginRight
            }]
          }, options);
        } else {
          throw new Error("supsub must have either sup or sub.");
        } // Wrap the supsub vlist in a span.msupsub to reset text-align.


        const mclass = getTypeOfDomTree(base, "right") || "mord";
        return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
      },

      mathmlBuilder(group, options) {
        // Is the inner group a relevant horizonal brace?
        let isBrace = false;
        let isOver;
        let isSup;
        const horizBrace = checkNodeType(group.base, "horizBrace");

        if (horizBrace) {
          isSup = !!group.sup;

          if (isSup === horizBrace.isOver) {
            isBrace = true;
            isOver = horizBrace.isOver;
          }
        }

        const children = [buildGroup$1(group.base, options)];

        if (group.sub) {
          children.push(buildGroup$1(group.sub, options));
        }

        if (group.sup) {
          children.push(buildGroup$1(group.sup, options));
        }

        let nodeType;

        if (isBrace) {
          nodeType = isOver ? "mover" : "munder";
        } else if (!group.sub) {
          const base = group.base;

          if (base && base.type === "op" && base.limits && options.style === Style$1.DISPLAY) {
            nodeType = "mover";
          } else {
            nodeType = "msup";
          }
        } else if (!group.sup) {
          const base = group.base;

          if (base && base.type === "op" && base.limits && options.style === Style$1.DISPLAY) {
            nodeType = "munder";
          } else {
            nodeType = "msub";
          }
        } else {
          const base = group.base;

          if (base && base.type === "op" && base.limits && options.style === Style$1.DISPLAY) {
            nodeType = "munderover";
          } else {
            nodeType = "msubsup";
          }
        }

        const node = new mathMLTree.MathNode(nodeType, children);
        return node;
      }

    });

    defineFunctionBuilders({
      type: "atom",

      htmlBuilder(group, options) {
        return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
      },

      mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);

        if (group.family === "bin") {
          const variant = getVariant(group, options);

          if (variant === "bold-italic") {
            node.setAttribute("mathvariant", variant);
          }
        } else if (group.family === "punct") {
          node.setAttribute("separator", "true");
        }

        return node;
      }

    });

    // "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
    const defaultVariant = {
      "mi": "italic",
      "mn": "normal",
      "mtext": "normal"
    };
    defineFunctionBuilders({
      type: "mathord",

      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "mathord");
      },

      mathmlBuilder(group, options) {
        const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
        const variant = getVariant(group, options) || "italic";

        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }

        return node;
      }

    });
    defineFunctionBuilders({
      type: "textord",

      htmlBuilder(group, options) {
        return buildCommon.makeOrd(group, options, "textord");
      },

      mathmlBuilder(group, options) {
        const text = makeText(group.text, group.mode, options);
        const variant = getVariant(group, options) || "normal";
        let node;

        if (group.mode === 'text') {
          node = new mathMLTree.MathNode("mtext", [text]);
        } else if (/[0-9]/.test(group.text)) {
          // TODO(kevinb) merge adjacent <mn> nodes
          // do it as a post processing step
          node = new mathMLTree.MathNode("mn", [text]);
        } else if (group.text === "\\prime") {
          node = new mathMLTree.MathNode("mo", [text]);
        } else {
          node = new mathMLTree.MathNode("mi", [text]);
        }

        if (variant !== defaultVariant[node.type]) {
          node.setAttribute("mathvariant", variant);
        }

        return node;
      }

    });

    const cssSpace = {
      "\\nobreak": "nobreak",
      "\\allowbreak": "allowbreak"
    }; // A lookup table to determine whether a spacing function/symbol should be
    // treated like a regular space character.  If a symbol or command is a key
    // in this table, then it should be a regular space character.  Furthermore,
    // the associated value may have a `className` specifying an extra CSS class
    // to add to the created `span`.

    const regularSpace = {
      " ": {},
      "\\ ": {},
      "~": {
        className: "nobreak"
      },
      "\\space": {},
      "\\nobreakspace": {
        className: "nobreak"
      }
    }; // ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
    // src/symbols.js.

    defineFunctionBuilders({
      type: "spacing",

      htmlBuilder(group, options) {
        if (regularSpace.hasOwnProperty(group.text)) {
          const className = regularSpace[group.text].className || ""; // Spaces are generated by adding an actual space. Each of these
          // things has an entry in the symbols table, so these will be turned
          // into appropriate outputs.

          if (group.mode === "text") {
            const ord = buildCommon.makeOrd(group, options, "textord");
            ord.classes.push(className);
            return ord;
          } else {
            return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
          }
        } else if (cssSpace.hasOwnProperty(group.text)) {
          // Spaces based on just a CSS class.
          return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
        } else {
          throw new ParseError(`Unknown type of space "${group.text}"`);
        }
      },

      mathmlBuilder(group, options) {
        let node;

        if (regularSpace.hasOwnProperty(group.text)) {
          node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
        } else if (cssSpace.hasOwnProperty(group.text)) {
          // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
          return new mathMLTree.MathNode("mspace");
        } else {
          throw new ParseError(`Unknown type of space "${group.text}"`);
        }

        return node;
      }

    });

    defineFunctionBuilders({
      type: "tag",

      mathmlBuilder(group, options) {
        const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mlabeledtr", [new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)]), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)])])]);
        table.setAttribute("side", "right");
        return table;
      }

    });

    const textFontFamilies = {
      "\\text": undefined,
      "\\textrm": "textrm",
      "\\textsf": "textsf",
      "\\texttt": "texttt",
      "\\textnormal": "textrm"
    };
    const textFontWeights = {
      "\\textbf": "textbf"
    };
    const textFontShapes = {
      "\\textit": "textit"
    };

    const optionsWithFont = (group, options) => {
      const font = group.font; // Checks if the argument is a font family or a font style.

      if (!font) {
        return options;
      } else if (textFontFamilies[font]) {
        return options.withTextFontFamily(textFontFamilies[font]);
      } else if (textFontWeights[font]) {
        return options.withTextFontWeight(textFontWeights[font]);
      } else {
        return options.withTextFontShape(textFontShapes[font]);
      }
    };

    defineFunction({
      type: "text",
      names: [// Font families
      "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", // Font weights
      "\\textbf", // Font Shapes
      "\\textit"],
      props: {
        numArgs: 1,
        argTypes: ["text"],
        greediness: 2,
        allowedInText: true,
        consumeMode: "text"
      },

      handler(_ref, args) {
        let parser = _ref.parser,
            funcName = _ref.funcName;
        const body = args[0];
        return {
          type: "text",
          mode: parser.mode,
          body: ordargument(body),
          font: funcName
        };
      },

      htmlBuilder(group, options) {
        const newOptions = optionsWithFont(group, options);
        const inner = buildExpression(group.body, newOptions, true);
        return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
      },

      mathmlBuilder(group, options) {
        const newOptions = optionsWithFont(group, options);
        return buildExpressionRow(group.body, newOptions);
      }

    });

    defineFunction({
      type: "underline",
      names: ["\\underline"],
      props: {
        numArgs: 1,
        allowedInText: true
      },

      handler(_ref, args) {
        let parser = _ref.parser;
        return {
          type: "underline",
          mode: parser.mode,
          body: args[0]
        };
      },

      htmlBuilder(group, options) {
        // Underlines are handled in the TeXbook pg 443, Rule 10.
        // Build the inner group.
        const innerGroup = buildGroup(group.body, options); // Create the line to go below the body

        const line = buildCommon.makeLineSpan("underline-line", options); // Generate the vlist, with the appropriate kerns

        const vlist = buildCommon.makeVList({
          positionType: "top",
          positionData: innerGroup.height,
          children: [{
            type: "kern",
            size: line.height
          }, {
            type: "elem",
            elem: line
          }, {
            type: "kern",
            size: 3 * line.height
          }, {
            type: "elem",
            elem: innerGroup
          }]
        }, options);
        return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
      },

      mathmlBuilder(group, options) {
        const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203e")]);
        operator.setAttribute("stretchy", "true");
        const node = new mathMLTree.MathNode("munder", [buildGroup$1(group.body, options), operator]);
        node.setAttribute("accentunder", "true");
        return node;
      }

    });

    defineFunction({
      type: "verb",
      names: ["\\verb"],
      props: {
        numArgs: 0,
        allowedInText: true
      },

      handler(context, args, optArgs) {
        // \verb and \verb* are dealt with directly in Parser.js.
        // If we end up here, it's because of a failure to match the two delimiters
        // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
        // terminated by end of line (or file).
        throw new ParseError("\\verb ended by end of line instead of matching delimiter");
      },

      htmlBuilder(group, options) {
        const text = makeVerb(group);
        const body = []; // \verb enters text mode and therefore is sized like \textstyle

        const newOptions = options.havingStyle(options.style.text());

        for (let i = 0; i < text.length; i++) {
          let c = text[i];

          if (c === '~') {
            c = '\\textasciitilde';
          }

          body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
        }

        return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
      },

      mathmlBuilder(group, options) {
        const text = new mathMLTree.TextNode(makeVerb(group));
        const node = new mathMLTree.MathNode("mtext", [text]);
        node.setAttribute("mathvariant", "monospace");
        return node;
      }

    });
    /**
     * Converts verb group into body string.
     *
     * \verb* replaces each space with an open box \u2423
     * \verb replaces each space with a no-break space \xA0
     */

    const makeVerb = group => group.body.replace(/ /g, group.star ? '\u2423' : '\xA0');

    /** Include this to ensure that all functions are defined. */
    const functions = _functions;

    /**
     * The Lexer class handles tokenizing the input in various ways. Since our
     * parser expects us to be able to backtrack, the lexer allows lexing from any
     * given starting point.
     *
     * Its main exposed function is the `lex` function, which takes a position to
     * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
     * function.
     *
     * The various `_innerLex` functions perform the actual lexing of different
     * kinds.
     */

    /* The following tokenRegex
     * - matches typical whitespace (but not NBSP etc.) using its first group
     * - does not match any control character \x00-\x1f except whitespace
     * - does not match a bare backslash
     * - matches any ASCII character except those just mentioned
     * - does not match the BMP private use area \uE000-\uF8FF
     * - does not match bare surrogate code units
     * - matches any BMP character except for those just described
     * - matches any valid Unicode surrogate pair
     * - matches a backslash followed by one or more letters
     * - matches a backslash followed by any BMP character, including newline
     * Just because the Lexer matches something doesn't mean it's valid input:
     * If there is no matching function or symbol definition, the Parser will
     * still reject the input.
     */
    const spaceRegexString = "[ \r\n\t]";
    const controlWordRegexString = "\\\\[a-zA-Z@]+";
    const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
    const controlWordWhitespaceRegexString = `${controlWordRegexString}${spaceRegexString}*`;
    const controlWordWhitespaceRegex = new RegExp(`^(${controlWordRegexString})${spaceRegexString}*$`);
    const combiningDiacriticalMarkString = "[\u0300-\u036f]";
    const combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
    const tokenRegexString = `(${spaceRegexString}+)|` + // whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
`${combiningDiacriticalMarkString}*`     + // ...plus accents
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
`${combiningDiacriticalMarkString}*`     + // ...plus accents
    "|\\\\verb\\*([^]).*?\\3" + // \verb*
    "|\\\\verb([^*a-zA-Z]).*?\\4" + // \verb unstarred
`|${controlWordWhitespaceRegexString}`     + // \macroName + spaces
`|${controlSymbolRegexString})`    ; // \\, \', etc.

    /** Main Lexer class */

    class Lexer {
      // category codes, only supports comment characters (14) for now
      constructor(input, settings) {
        this.input = void 0;
        this.settings = void 0;
        this.tokenRegex = void 0;
        this.catcodes = void 0;
        // Separate accents from characters
        this.input = input;
        this.settings = settings;
        this.tokenRegex = new RegExp(tokenRegexString, 'g');
        this.catcodes = {
          "%": 14 // comment character

        };
      }

      setCatcode(char, code) {
        this.catcodes[char] = code;
      }
      /**
       * This function lexes a single token.
       */


      lex() {
        const input = this.input;
        const pos = this.tokenRegex.lastIndex;

        if (pos === input.length) {
          return new Token("EOF", new SourceLocation(this, pos, pos));
        }

        const match = this.tokenRegex.exec(input);

        if (match === null || match.index !== pos) {
          throw new ParseError(`Unexpected character: '${input[pos]}'`, new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
        }

        let text = match[2] || " ";

        if (this.catcodes[text] === 14) {
          // comment character
          const nlIndex = input.indexOf('\n', this.tokenRegex.lastIndex);

          if (nlIndex === -1) {
            this.tokenRegex.lastIndex = input.length; // EOF

            this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would " + "fail because of commenting the end of math mode (e.g. $)");
          } else {
            this.tokenRegex.lastIndex = nlIndex + 1;
          }

          return this.lex();
        } // Trim any trailing whitespace from control word match


        const controlMatch = text.match(controlWordWhitespaceRegex);

        if (controlMatch) {
          text = controlMatch[1];
        }

        return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
      }

    }

    /**
     * A `Namespace` refers to a space of nameable things like macros or lengths,
     * which can be `set` either globally or local to a nested group, using an
     * undo stack similar to how TeX implements this functionality.
     * Performance-wise, `get` and local `set` take constant time, while global
     * `set` takes time proportional to the depth of group nesting.
     */
    class Namespace {
      /**
       * Both arguments are optional.  The first argument is an object of
       * built-in mappings which never change.  The second argument is an object
       * of initial (global-level) mappings, which will constantly change
       * according to any global/top-level `set`s done.
       */
      constructor(builtins, globalMacros) {
        if (builtins === void 0) {
          builtins = {};
        }

        if (globalMacros === void 0) {
          globalMacros = {};
        }

        this.current = void 0;
        this.builtins = void 0;
        this.undefStack = void 0;
        this.current = globalMacros;
        this.builtins = builtins;
        this.undefStack = [];
      }
      /**
       * Start a new nested group, affecting future local `set`s.
       */


      beginGroup() {
        this.undefStack.push({});
      }
      /**
       * End current nested group, restoring values before the group began.
       */


      endGroup() {
        if (this.undefStack.length === 0) {
          throw new ParseError("Unbalanced namespace destruction: attempt " + "to pop global namespace; please report this as a bug");
        }

        const undefs = this.undefStack.pop();

        for (const undef in undefs) {
          if (undefs.hasOwnProperty(undef)) {
            if (undefs[undef] === undefined) {
              delete this.current[undef];
            } else {
              this.current[undef] = undefs[undef];
            }
          }
        }
      }
      /**
       * Detect whether `name` has a definition.  Equivalent to
       * `get(name) != null`.
       */


      has(name) {
        return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
      }
      /**
       * Get the current value of a name, or `undefined` if there is no value.
       *
       * Note: Do not use `if (namespace.get(...))` to detect whether a macro
       * is defined, as the definition may be the empty string which evaluates
       * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
       * `if (namespace.has(...))`.
       */


      get(name) {
        if (this.current.hasOwnProperty(name)) {
          return this.current[name];
        } else {
          return this.builtins[name];
        }
      }
      /**
       * Set the current value of a name, and optionally set it globally too.
       * Local set() sets the current value and (when appropriate) adds an undo
       * operation to the undo stack.  Global set() may change the undo
       * operation at every level, so takes time linear in their number.
       */


      set(name, value, global) {
        if (global === void 0) {
          global = false;
        }

        if (global) {
          // Global set is equivalent to setting in all groups.  Simulate this
          // by destroying any undos currently scheduled for this name,
          // and adding an undo with the *new* value (in case it later gets
          // locally reset within this environment).
          for (let i = 0; i < this.undefStack.length; i++) {
            delete this.undefStack[i][name];
          }

          if (this.undefStack.length > 0) {
            this.undefStack[this.undefStack.length - 1][name] = value;
          }
        } else {
          // Undo this set at end of this group (possibly to `undefined`),
          // unless an undo is already in place, in which case that older
          // value is the correct one.
          const top = this.undefStack[this.undefStack.length - 1];

          if (top && !top.hasOwnProperty(name)) {
            top[name] = this.current[name];
          }
        }

        this.current[name] = value;
      }

    }

    /**
     * Predefined macros for KaTeX.
     * This can be used to define some commands in terms of others.
     */
    const builtinMacros = {};

    function defineMacro(name, body) {
      builtinMacros[name] = body;
    } //////////////////////////////////////////////////////////////////////
    // macro tools
    // LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
    // TeX source: \long\def\@firstoftwo#1#2{#1}

    defineMacro("\\@firstoftwo", function (context) {
      const args = context.consumeArgs(2);
      return {
        tokens: args[0],
        numArgs: 0
      };
    }); // LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
    // TeX source: \long\def\@secondoftwo#1#2{#2}

    defineMacro("\\@secondoftwo", function (context) {
      const args = context.consumeArgs(2);
      return {
        tokens: args[1],
        numArgs: 0
      };
    }); // LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
    // symbol.  If it matches #1, then the macro expands to #2; otherwise, #3.
    // Note, however, that it does not consume the next symbol in either case.

    defineMacro("\\@ifnextchar", function (context) {
      const args = context.consumeArgs(3); // symbol, if, else

      const nextToken = context.future();

      if (args[0].length === 1 && args[0][0].text === nextToken.text) {
        return {
          tokens: args[1],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[2],
          numArgs: 0
        };
      }
    }); // LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
    // If it is `*`, then it consumes the symbol, and the macro expands to #1;
    // otherwise, the macro expands to #2 (without consuming the symbol).
    // TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}

    defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"); // LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode

    defineMacro("\\TextOrMath", function (context) {
      const args = context.consumeArgs(2);

      if (context.mode === 'text') {
        return {
          tokens: args[0],
          numArgs: 0
        };
      } else {
        return {
          tokens: args[1],
          numArgs: 0
        };
      }
    }); // Lookup table for parsing numbers in base 8 through 16

    const digitToNumber = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    }; // TeX \char makes a literal character (catcode 12) using the following forms:
    // (see The TeXBook, p. 43)
    //   \char123  -- decimal
    //   \char'123 -- octal
    //   \char"123 -- hex
    //   \char`x   -- character that can be written (i.e. isn't active)
    //   \char`\x  -- character that cannot be written (e.g. %)
    // These all refer to characters from the font, so we turn them into special
    // calls to a function \@char dealt with in the Parser.

    defineMacro("\\char", function (context) {
      let token = context.popToken();
      let base;
      let number = '';

      if (token.text === "'") {
        base = 8;
        token = context.popToken();
      } else if (token.text === '"') {
        base = 16;
        token = context.popToken();
      } else if (token.text === "`") {
        token = context.popToken();

        if (token.text[0] === "\\") {
          number = token.text.charCodeAt(1);
        } else if (token.text === "EOF") {
          throw new ParseError("\\char` missing argument");
        } else {
          number = token.text.charCodeAt(0);
        }
      } else {
        base = 10;
      }

      if (base) {
        // Parse a number in the given base, starting with first `token`.
        number = digitToNumber[token.text];

        if (number == null || number >= base) {
          throw new ParseError(`Invalid base-${base} digit ${token.text}`);
        }

        let digit;

        while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
          number *= base;
          number += digit;
          context.popToken();
        }
      }

      return `\\@char{${number}}`;
    }); // Basic support for macro definitions:
    //     \def\macro{expansion}
    //     \def\macro#1{expansion}
    //     \def\macro#1#2{expansion}
    //     \def\macro#1#2#3#4#5#6#7#8#9{expansion}
    // Also the \gdef and \global\def equivalents

    const def = (context, global) => {
      let arg = context.consumeArgs(1)[0];

      if (arg.length !== 1) {
        throw new ParseError("\\gdef's first argument must be a macro name");
      }

      const name = arg[0].text; // Count argument specifiers, and check they are in the order #1 #2 ...

      let numArgs = 0;
      arg = context.consumeArgs(1)[0];

      while (arg.length === 1 && arg[0].text === "#") {
        arg = context.consumeArgs(1)[0];

        if (arg.length !== 1) {
          throw new ParseError(`Invalid argument number length "${arg.length}"`);
        }

        if (!/^[1-9]$/.test(arg[0].text)) {
          throw new ParseError(`Invalid argument number "${arg[0].text}"`);
        }

        numArgs++;

        if (parseInt(arg[0].text) !== numArgs) {
          throw new ParseError(`Argument number "${arg[0].text}" out of order`);
        }

        arg = context.consumeArgs(1)[0];
      } // Final arg is the expansion of the macro


      context.macros.set(name, {
        tokens: arg,
        numArgs
      }, global);
      return '';
    };

    defineMacro("\\gdef", context => def(context, true));
    defineMacro("\\def", context => def(context, false));
    defineMacro("\\global", context => {
      const next = context.consumeArgs(1)[0];

      if (next.length !== 1) {
        throw new ParseError("Invalid command after \\global");
      }

      const command = next[0].text; // TODO: Should expand command

      if (command === "\\def") {
        // \global\def is equivalent to \gdef
        return def(context, true);
      } else {
        throw new ParseError(`Invalid command '${command}' after \\global`);
      }
    }); // \newcommand{\macro}[args]{definition}
    // \renewcommand{\macro}[args]{definition}
    // TODO: Optional arguments: \newcommand{\macro}[args][default]{definition}

    const newcommand = (context, existsOK, nonexistsOK) => {
      let arg = context.consumeArgs(1)[0];

      if (arg.length !== 1) {
        throw new ParseError("\\newcommand's first argument must be a macro name");
      }

      const name = arg[0].text;
      const exists = context.isDefined(name);

      if (exists && !existsOK) {
        throw new ParseError(`\\newcommand{${name}} attempting to redefine ` + `${name}; use \\renewcommand`);
      }

      if (!exists && !nonexistsOK) {
        throw new ParseError(`\\renewcommand{${name}} when command ${name} ` + `does not yet exist; use \\newcommand`);
      }

      let numArgs = 0;
      arg = context.consumeArgs(1)[0];

      if (arg.length === 1 && arg[0].text === "[") {
        let argText = '';
        let token = context.expandNextToken();

        while (token.text !== "]" && token.text !== "EOF") {
          // TODO: Should properly expand arg, e.g., ignore {}s
          argText += token.text;
          token = context.expandNextToken();
        }

        if (!argText.match(/^\s*[0-9]+\s*$/)) {
          throw new ParseError(`Invalid number of arguments: ${argText}`);
        }

        numArgs = parseInt(argText);
        arg = context.consumeArgs(1)[0];
      } // Final arg is the expansion of the macro


      context.macros.set(name, {
        tokens: arg,
        numArgs
      });
      return '';
    };

    defineMacro("\\newcommand", context => newcommand(context, false, true));
    defineMacro("\\renewcommand", context => newcommand(context, true, false));
    defineMacro("\\providecommand", context => newcommand(context, true, true)); //////////////////////////////////////////////////////////////////////
    // Grouping
    // \let\bgroup={ \let\egroup=}

    defineMacro("\\bgroup", "{");
    defineMacro("\\egroup", "}"); // Symbols from latex.ltx:
    // \def\lq{`}
    // \def\rq{'}
    // \def \aa {\r a}
    // \def \AA {\r A}

    defineMacro("\\lq", "`");
    defineMacro("\\rq", "'");
    defineMacro("\\aa", "\\r a");
    defineMacro("\\AA", "\\r A"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.
    // \DeclareTextCommandDefault{\textcopyright}{\textcircled{c}}
    // \DeclareTextCommandDefault{\textregistered}{\textcircled{%
    //      \check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont R}}
    // \DeclareRobustCommand{\copyright}{%
    //    \ifmmode{\nfss@text{\textcopyright}}\else\textcopyright\fi}

    defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
    defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
    defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}"); // Characters omitted from Unicode range 1D400–1D7FF

    defineMacro("\u212C", "\\mathscr{B}"); // script

    defineMacro("\u2130", "\\mathscr{E}");
    defineMacro("\u2131", "\\mathscr{F}");
    defineMacro("\u210B", "\\mathscr{H}");
    defineMacro("\u2110", "\\mathscr{I}");
    defineMacro("\u2112", "\\mathscr{L}");
    defineMacro("\u2133", "\\mathscr{M}");
    defineMacro("\u211B", "\\mathscr{R}");
    defineMacro("\u212D", "\\mathfrak{C}"); // Fraktur

    defineMacro("\u210C", "\\mathfrak{H}");
    defineMacro("\u2128", "\\mathfrak{Z}"); // Unicode middle dot
    // The KaTeX fonts do not contain U+00B7. Instead, \cdotp displays
    // the dot at U+22C5 and gives it punct spacing.

    defineMacro("\u00b7", "\\cdotp"); // \llap and \rlap render their contents in text mode

    defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
    defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
    defineMacro("\\clap", "\\mathclap{\\textrm{#1}}"); // \not is defined by base/fontmath.ltx via
    // \DeclareMathSymbol{\not}{\mathrel}{symbols}{"36}
    // It's thus treated like a \mathrel, but defined by a symbol that has zero
    // width but extends to the right.  We use \rlap to get that spacing.

    defineMacro("\\not", '\\mathrel{\\mathrlap\\@not}'); // Negated symbols from base/fontmath.ltx:
    // \def\neq{\not=} \let\ne=\neq
    // \DeclareRobustCommand
    //   \notin{\mathrel{\m@th\mathpalette\c@ncel\in}}
    // \def\c@ncel#1#2{\m@th\ooalign{$\hfil#1\mkern1mu/\hfil$\crcr$#1#2$}}

    defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
    defineMacro("\\ne", "\\neq");
    defineMacro("\u2260", "\\neq");
    defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}" + "{\\mathrel{\\char`∉}}");
    defineMacro("\u2209", "\\notin"); // Unicode stacked relations

    defineMacro("\u2258", "\\html@mathml{" + "\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}" + "}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
    defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
    defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}" + "{\\mathrel{\\char`\u225B}}");
    defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}" + "{\\mathrel{\\char`\u225D}}");
    defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}" + "{\\mathrel{\\char`\u225E}}");
    defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"); // Misc Unicode

    defineMacro("\u27C2", "\\perp");
    defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
    defineMacro("\u220C", "\\notni");
    defineMacro("\u231C", "\\ulcorner");
    defineMacro("\u231D", "\\urcorner");
    defineMacro("\u231E", "\\llcorner");
    defineMacro("\u231F", "\\lrcorner");
    defineMacro("\u00A9", "\\copyright");
    defineMacro("\u00AE", "\\textregistered");
    defineMacro("\uFE0F", "\\textregistered"); //////////////////////////////////////////////////////////////////////
    // LaTeX_2ε
    // \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
    // \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
    // We'll call \varvdots, which gets a glyph from symbols.js.
    // The zero-width rule gets us an equivalent to the vertical 6pt kern.

    defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
    defineMacro("\u22ee", "\\vdots"); //////////////////////////////////////////////////////////////////////
    // amsmath.sty
    // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
    // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
    // but they are equivalent to \mathit{\Letter}.

    defineMacro("\\varGamma", "\\mathit{\\Gamma}");
    defineMacro("\\varDelta", "\\mathit{\\Delta}");
    defineMacro("\\varTheta", "\\mathit{\\Theta}");
    defineMacro("\\varLambda", "\\mathit{\\Lambda}");
    defineMacro("\\varXi", "\\mathit{\\Xi}");
    defineMacro("\\varPi", "\\mathit{\\Pi}");
    defineMacro("\\varSigma", "\\mathit{\\Sigma}");
    defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
    defineMacro("\\varPhi", "\\mathit{\\Phi}");
    defineMacro("\\varPsi", "\\mathit{\\Psi}");
    defineMacro("\\varOmega", "\\mathit{\\Omega}"); // \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
    // \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}

    defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}" + "\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu"); // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}}

    defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}"); // \def\iff{\DOTSB\;\Longleftrightarrow\;}
    // \def\implies{\DOTSB\;\Longrightarrow\;}
    // \def\impliedby{\DOTSB\;\Longleftarrow\;}

    defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
    defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
    defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"); // AMSMath's automatic \dots, based on \mdots@@ macro.

    const dotsByToken = {
      ',': '\\dotsc',
      '\\not': '\\dotsb',
      // \keybin@ checks for the following:
      '+': '\\dotsb',
      '=': '\\dotsb',
      '<': '\\dotsb',
      '>': '\\dotsb',
      '-': '\\dotsb',
      '*': '\\dotsb',
      ':': '\\dotsb',
      // Symbols whose definition starts with \DOTSB:
      '\\DOTSB': '\\dotsb',
      '\\coprod': '\\dotsb',
      '\\bigvee': '\\dotsb',
      '\\bigwedge': '\\dotsb',
      '\\biguplus': '\\dotsb',
      '\\bigcap': '\\dotsb',
      '\\bigcup': '\\dotsb',
      '\\prod': '\\dotsb',
      '\\sum': '\\dotsb',
      '\\bigotimes': '\\dotsb',
      '\\bigoplus': '\\dotsb',
      '\\bigodot': '\\dotsb',
      '\\bigsqcup': '\\dotsb',
      '\\And': '\\dotsb',
      '\\longrightarrow': '\\dotsb',
      '\\Longrightarrow': '\\dotsb',
      '\\longleftarrow': '\\dotsb',
      '\\Longleftarrow': '\\dotsb',
      '\\longleftrightarrow': '\\dotsb',
      '\\Longleftrightarrow': '\\dotsb',
      '\\mapsto': '\\dotsb',
      '\\longmapsto': '\\dotsb',
      '\\hookrightarrow': '\\dotsb',
      '\\doteq': '\\dotsb',
      // Symbols whose definition starts with \mathbin:
      '\\mathbin': '\\dotsb',
      // Symbols whose definition starts with \mathrel:
      '\\mathrel': '\\dotsb',
      '\\relbar': '\\dotsb',
      '\\Relbar': '\\dotsb',
      '\\xrightarrow': '\\dotsb',
      '\\xleftarrow': '\\dotsb',
      // Symbols whose definition starts with \DOTSI:
      '\\DOTSI': '\\dotsi',
      '\\int': '\\dotsi',
      '\\oint': '\\dotsi',
      '\\iint': '\\dotsi',
      '\\iiint': '\\dotsi',
      '\\iiiint': '\\dotsi',
      '\\idotsint': '\\dotsi',
      // Symbols whose definition starts with \DOTSX:
      '\\DOTSX': '\\dotsx'
    };
    defineMacro("\\dots", function (context) {
      // TODO: If used in text mode, should expand to \textellipsis.
      // However, in KaTeX, \textellipsis and \ldots behave the same
      // (in text mode), and it's unlikely we'd see any of the math commands
      // that affect the behavior of \dots when in text mode.  So fine for now
      // (until we support \ifmmode ... \else ... \fi).
      let thedots = '\\dotso';
      const next = context.expandAfterFuture().text;

      if (next in dotsByToken) {
        thedots = dotsByToken[next];
      } else if (next.substr(0, 4) === '\\not') {
        thedots = '\\dotsb';
      } else if (next in symbols.math) {
        if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {
          thedots = '\\dotsb';
        }
      }

      return thedots;
    });
    const spaceAfterDots = {
      // \rightdelim@ checks for the following:
      ')': true,
      ']': true,
      '\\rbrack': true,
      '\\}': true,
      '\\rbrace': true,
      '\\rangle': true,
      '\\rceil': true,
      '\\rfloor': true,
      '\\rgroup': true,
      '\\rmoustache': true,
      '\\right': true,
      '\\bigr': true,
      '\\biggr': true,
      '\\Bigr': true,
      '\\Biggr': true,
      // \extra@ also tests for the following:
      '$': true,
      // \extrap@ checks for the following:
      ';': true,
      '.': true,
      ',': true
    };
    defineMacro("\\dotso", function (context) {
      const next = context.future().text;

      if (next in spaceAfterDots) {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\dotsc", function (context) {
      const next = context.future().text; // \dotsc uses \extra@ but not \extrap@, instead specially checking for
      // ';' and '.', but doesn't check for ','.

      if (next in spaceAfterDots && next !== ',') {
        return "\\ldots\\,";
      } else {
        return "\\ldots";
      }
    });
    defineMacro("\\cdots", function (context) {
      const next = context.future().text;

      if (next in spaceAfterDots) {
        return "\\@cdots\\,";
      } else {
        return "\\@cdots";
      }
    });
    defineMacro("\\dotsb", "\\cdots");
    defineMacro("\\dotsm", "\\cdots");
    defineMacro("\\dotsi", "\\!\\cdots"); // amsmath doesn't actually define \dotsx, but \dots followed by a macro
    // starting with \DOTSX implies \dotso, and then \extra@ detects this case
    // and forces the added `\,`.

    defineMacro("\\dotsx", "\\ldots\\,"); // \let\DOTSI\relax
    // \let\DOTSB\relax
    // \let\DOTSX\relax

    defineMacro("\\DOTSI", "\\relax");
    defineMacro("\\DOTSB", "\\relax");
    defineMacro("\\DOTSX", "\\relax"); // Spacing, based on amsmath.sty's override of LaTeX defaults
    // \DeclareRobustCommand{\tmspace}[3]{%
    //   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}

    defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"); // \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip

    defineMacro("\\,", "\\tmspace+{3mu}{.1667em}"); // \let\thinspace\,

    defineMacro("\\thinspace", "\\,"); // \def\>{\mskip\medmuskip}
    // \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
    // TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu

    defineMacro("\\>", "\\mskip{4mu}");
    defineMacro("\\:", "\\tmspace+{4mu}{.2222em}"); // \let\medspace\:

    defineMacro("\\medspace", "\\:"); // \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip = 5mu plus 5mu

    defineMacro("\\;", "\\tmspace+{5mu}{.2777em}"); // \let\thickspace\;

    defineMacro("\\thickspace", "\\;"); // \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
    // TODO: math mode should use \thinmuskip

    defineMacro("\\!", "\\tmspace-{3mu}{.1667em}"); // \let\negthinspace\!

    defineMacro("\\negthinspace", "\\!"); // \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
    // TODO: math mode should use \medmuskip

    defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}"); // \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
    // TODO: math mode should use \thickmuskip

    defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}"); // \def\enspace{\kern.5em }

    defineMacro("\\enspace", "\\kern.5em "); // \def\enskip{\hskip.5em\relax}

    defineMacro("\\enskip", "\\hskip.5em\\relax"); // \def\quad{\hskip1em\relax}

    defineMacro("\\quad", "\\hskip1em\\relax"); // \def\qquad{\hskip2em\relax}

    defineMacro("\\qquad", "\\hskip2em\\relax"); // \tag@in@display form of \tag

    defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
    defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
    defineMacro("\\tag@literal", context => {
      if (context.macros.get("\\df@tag")) {
        throw new ParseError("Multiple \\tag");
      }

      return "\\gdef\\df@tag{\\text{#1}}";
    }); // \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
    //   {\operator@font mod}\penalty900
    //   \mkern5mu\nonscript\mskip-\medmuskip}
    // \newcommand{\pod}[1]{\allowbreak
    //   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
    // \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
    // \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
    //   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
    // TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu

    defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}" + "\\mathbin{\\rm mod}" + "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
    defineMacro("\\pod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
    defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
    defineMacro("\\mod", "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" + "{\\rm mod}\\,\\,#1"); // \pmb    --   A simulation of bold.
    // It works by typesetting three copies of the argument with small offsets.
    // Ref: a rather lengthy macro in ambsy.sty

    defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{" + "\\mathrlap{#1}" + "\\mathrlap{\\mkern0.4mu\\raisebox{0.4mu}{$#1$}}" + "{\\mkern0.8mu#1}" + "}}{\\mathbf{#1}}"); //////////////////////////////////////////////////////////////////////
    // LaTeX source2e
    // \\ defaults to \newline, but changes to \cr within array environment

    defineMacro("\\\\", "\\newline"); // \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
    // TODO: Doesn't normally work in math mode because \@ fails.  KaTeX doesn't
    // support \@ yet, so that's omitted, and we add \text so that the result
    // doesn't look funny in math mode.

    defineMacro("\\TeX", "\\textrm{\\html@mathml{" + "T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX" + "}{TeX}}"); // \DeclareRobustCommand{\LaTeX}{L\kern-.36em%
    //         {\sbox\z@ T%
    //          \vbox to\ht\z@{\hbox{\check@mathfonts
    //                               \fontsize\sf@size\z@
    //                               \math@fontsfalse\selectfont
    //                               A}%
    //                         \vss}%
    //         }%
    //         \kern-.15em%
    //         \TeX}
    // This code aligns the top of the A with the T (from the perspective of TeX's
    // boxes, though visually the A appears to extend above slightly).
    // We compute the corresponding \raisebox when A is rendered at \scriptsize,
    // which is size3, which has a scale factor of 0.7 (see Options.js).

    const latexRaiseA = metricMap['Main-Regular']["T".charCodeAt(0)][1] - 0.7 * metricMap['Main-Regular']["A".charCodeAt(0)][1] + "em";
    defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + `L\\kern-.36em\\raisebox{${latexRaiseA}}{\\scriptsize A}` + "\\kern-.15em\\TeX}{LaTeX}}"); // New KaTeX logo based on tweaking LaTeX logo

    defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + `K\\kern-.17em\\raisebox{${latexRaiseA}}{\\scriptsize A}` + "\\kern-.15em\\TeX}{KaTeX}}"); // \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
    // \def\@hspace#1{\hskip  #1\relax}
    // \def\@hspacer#1{\vrule \@width\z@\nobreak
    //                 \hskip #1\hskip \z@skip}

    defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
    defineMacro("\\@hspace", "\\hskip #1\\relax");
    defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"); //////////////////////////////////////////////////////////////////////
    // mathtools.sty
    //\providecommand\ordinarycolon{:}

    defineMacro("\\ordinarycolon", ":"); //\def\vcentcolon{\mathrel{\mathop\ordinarycolon}}
    //TODO(edemaine): Not yet centered. Fix via \raisebox or #726

    defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"); // \providecommand*\dblcolon{\vcentcolon\mathrel{\mkern-.9mu}\vcentcolon}

    defineMacro("\\dblcolon", "\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}"); // \providecommand*\coloneqq{\vcentcolon\mathrel{\mkern-1.2mu}=}

    defineMacro("\\coloneqq", "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}"); // \providecommand*\Coloneqq{\dblcolon\mathrel{\mkern-1.2mu}=}

    defineMacro("\\Coloneqq", "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}"); // \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

    defineMacro("\\coloneq", "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}"); // \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}

    defineMacro("\\Coloneq", "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}"); // \providecommand*\eqqcolon{=\mathrel{\mkern-1.2mu}\vcentcolon}

    defineMacro("\\eqqcolon", "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}"); // \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}

    defineMacro("\\Eqqcolon", "\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // \providecommand*\eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\vcentcolon}

    defineMacro("\\eqcolon", "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}"); // \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}

    defineMacro("\\Eqcolon", "\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}

    defineMacro("\\colonapprox", "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}"); // \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}

    defineMacro("\\Colonapprox", "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}"); // \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}

    defineMacro("\\colonsim", "\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}"); // \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}

    defineMacro("\\Colonsim", "\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}"); // Some Unicode characters are implemented with macros to mathtools functions.

    defineMacro("\u2254", "\\coloneqq"); // :=

    defineMacro("\u2255", "\\eqqcolon"); // =:

    defineMacro("\u2A74", "\\Coloneqq"); // ::=
    //////////////////////////////////////////////////////////////////////
    // colonequals.sty
    // Alternate names for mathtools's macros:

    defineMacro("\\ratio", "\\vcentcolon");
    defineMacro("\\coloncolon", "\\dblcolon");
    defineMacro("\\colonequals", "\\coloneqq");
    defineMacro("\\coloncolonequals", "\\Coloneqq");
    defineMacro("\\equalscolon", "\\eqqcolon");
    defineMacro("\\equalscoloncolon", "\\Eqqcolon");
    defineMacro("\\colonminus", "\\coloneq");
    defineMacro("\\coloncolonminus", "\\Coloneq");
    defineMacro("\\minuscolon", "\\eqcolon");
    defineMacro("\\minuscoloncolon", "\\Eqcolon"); // \colonapprox name is same in mathtools and colonequals.

    defineMacro("\\coloncolonapprox", "\\Colonapprox"); // \colonsim name is same in mathtools and colonequals.

    defineMacro("\\coloncolonsim", "\\Colonsim"); // Additional macros, implemented by analogy with mathtools definitions:

    defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
    defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
    defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"); // Present in newtxmath, pxfonts and txfonts

    defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
    defineMacro("\\limsup", "\\DOTSB\\mathop{\\operatorname{lim\\,sup}}\\limits");
    defineMacro("\\liminf", "\\DOTSB\\mathop{\\operatorname{lim\\,inf}}\\limits"); //////////////////////////////////////////////////////////////////////
    // semantic
    // The semantic package renders the next two items by calling a glyph from the
    // bbold package. Those glyphs do not exist in the KaTeX fonts. Hence the macros.

    defineMacro("\u27e6", "\\mathopen{[\\mkern-3.2mu[}"); // blackboard bold [

    defineMacro("\u27e7", "\\mathclose{]\\mkern-3.2mu]}"); // blackboard bold ]
    // TODO: Create variable sized versions of the last two items. I believe that
    // will require new font glyphs.
    //////////////////////////////////////////////////////////////////////
    // texvc.sty
    // The texvc package contains macros available in mediawiki pages.
    // We omit the functions deprecated at
    // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
    // We also omit texvc's \O, which conflicts with \text{\O}

    defineMacro("\\darr", "\\downarrow");
    defineMacro("\\dArr", "\\Downarrow");
    defineMacro("\\Darr", "\\Downarrow");
    defineMacro("\\lang", "\\langle");
    defineMacro("\\rang", "\\rangle");
    defineMacro("\\uarr", "\\uparrow");
    defineMacro("\\uArr", "\\Uparrow");
    defineMacro("\\Uarr", "\\Uparrow");
    defineMacro("\\N", "\\mathbb{N}");
    defineMacro("\\R", "\\mathbb{R}");
    defineMacro("\\Z", "\\mathbb{Z}");
    defineMacro("\\alef", "\\aleph");
    defineMacro("\\alefsym", "\\aleph");
    defineMacro("\\Alpha", "\\mathrm{A}");
    defineMacro("\\Beta", "\\mathrm{B}");
    defineMacro("\\bull", "\\bullet");
    defineMacro("\\Chi", "\\mathrm{X}");
    defineMacro("\\clubs", "\\clubsuit");
    defineMacro("\\cnums", "\\mathbb{C}");
    defineMacro("\\Complex", "\\mathbb{C}");
    defineMacro("\\Dagger", "\\ddagger");
    defineMacro("\\diamonds", "\\diamondsuit");
    defineMacro("\\empty", "\\emptyset");
    defineMacro("\\Epsilon", "\\mathrm{E}");
    defineMacro("\\Eta", "\\mathrm{H}");
    defineMacro("\\exist", "\\exists");
    defineMacro("\\harr", "\\leftrightarrow");
    defineMacro("\\hArr", "\\Leftrightarrow");
    defineMacro("\\Harr", "\\Leftrightarrow");
    defineMacro("\\hearts", "\\heartsuit");
    defineMacro("\\image", "\\Im");
    defineMacro("\\infin", "\\infty");
    defineMacro("\\Iota", "\\mathrm{I}");
    defineMacro("\\isin", "\\in");
    defineMacro("\\Kappa", "\\mathrm{K}");
    defineMacro("\\larr", "\\leftarrow");
    defineMacro("\\lArr", "\\Leftarrow");
    defineMacro("\\Larr", "\\Leftarrow");
    defineMacro("\\lrarr", "\\leftrightarrow");
    defineMacro("\\lrArr", "\\Leftrightarrow");
    defineMacro("\\Lrarr", "\\Leftrightarrow");
    defineMacro("\\Mu", "\\mathrm{M}");
    defineMacro("\\natnums", "\\mathbb{N}");
    defineMacro("\\Nu", "\\mathrm{N}");
    defineMacro("\\Omicron", "\\mathrm{O}");
    defineMacro("\\plusmn", "\\pm");
    defineMacro("\\rarr", "\\rightarrow");
    defineMacro("\\rArr", "\\Rightarrow");
    defineMacro("\\Rarr", "\\Rightarrow");
    defineMacro("\\real", "\\Re");
    defineMacro("\\reals", "\\mathbb{R}");
    defineMacro("\\Reals", "\\mathbb{R}");
    defineMacro("\\Rho", "\\mathrm{R}");
    defineMacro("\\sdot", "\\cdot");
    defineMacro("\\sect", "\\S");
    defineMacro("\\spades", "\\spadesuit");
    defineMacro("\\sub", "\\subset");
    defineMacro("\\sube", "\\subseteq");
    defineMacro("\\supe", "\\supseteq");
    defineMacro("\\Tau", "\\mathrm{T}");
    defineMacro("\\thetasym", "\\vartheta"); // TODO: defineMacro("\\varcoppa", "\\\mbox{\\coppa}");

    defineMacro("\\weierp", "\\wp");
    defineMacro("\\Zeta", "\\mathrm{Z}"); //////////////////////////////////////////////////////////////////////
    // statmath.sty
    // https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

    defineMacro("\\argmin", "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits");
    defineMacro("\\argmax", "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits");

    /**
     * This file contains the “gullet” where macros are expanded
     * until only non-macro tokens remain.
     */
    // List of commands that act like macros but aren't defined as a macro,
    // function, or symbol.  Used in `isDefined`.
    const implicitCommands = {
      "\\relax": true,
      // MacroExpander.js
      "^": true,
      // Parser.js
      "_": true,
      // Parser.js
      "\\limits": true,
      // Parser.js
      "\\nolimits": true // Parser.js

    };
    class MacroExpander {
      constructor(input, settings, mode) {
        this.settings = void 0;
        this.expansionCount = void 0;
        this.lexer = void 0;
        this.macros = void 0;
        this.stack = void 0;
        this.mode = void 0;
        this.settings = settings;
        this.expansionCount = 0;
        this.feed(input); // Make new global namespace

        this.macros = new Namespace(builtinMacros, settings.macros);
        this.mode = mode;
        this.stack = []; // contains tokens in REVERSE order
      }
      /**
       * Feed a new input string to the same MacroExpander
       * (with existing macros etc.).
       */


      feed(input) {
        this.lexer = new Lexer(input, this.settings);
      }
      /**
       * Switches between "text" and "math" modes.
       */


      switchMode(newMode) {
        this.mode = newMode;
      }
      /**
       * Start a new group nesting within all namespaces.
       */


      beginGroup() {
        this.macros.beginGroup();
      }
      /**
       * End current group nesting within all namespaces.
       */


      endGroup() {
        this.macros.endGroup();
      }
      /**
       * Returns the topmost token on the stack, without expanding it.
       * Similar in behavior to TeX's `\futurelet`.
       */


      future() {
        if (this.stack.length === 0) {
          this.pushToken(this.lexer.lex());
        }

        return this.stack[this.stack.length - 1];
      }
      /**
       * Remove and return the next unexpanded token.
       */


      popToken() {
        this.future(); // ensure non-empty stack

        return this.stack.pop();
      }
      /**
       * Add a given token to the token stack.  In particular, this get be used
       * to put back a token returned from one of the other methods.
       */


      pushToken(token) {
        this.stack.push(token);
      }
      /**
       * Append an array of tokens to the token stack.
       */


      pushTokens(tokens) {
        this.stack.push(...tokens);
      }
      /**
       * Consume all following space tokens, without expansion.
       */


      consumeSpaces() {
        for (;;) {
          const token = this.future();

          if (token.text === " ") {
            this.stack.pop();
          } else {
            break;
          }
        }
      }
      /**
       * Consume the specified number of arguments from the token stream,
       * and return the resulting array of arguments.
       */


      consumeArgs(numArgs) {
        const args = []; // obtain arguments, either single token or balanced {…} group

        for (let i = 0; i < numArgs; ++i) {
          this.consumeSpaces(); // ignore spaces before each argument

          const startOfArg = this.popToken();

          if (startOfArg.text === "{") {
            const arg = [];
            let depth = 1;

            while (depth !== 0) {
              const tok = this.popToken();
              arg.push(tok);

              if (tok.text === "{") {
                ++depth;
              } else if (tok.text === "}") {
                --depth;
              } else if (tok.text === "EOF") {
                throw new ParseError("End of input in macro argument", startOfArg);
              }
            }

            arg.pop(); // remove last }

            arg.reverse(); // like above, to fit in with stack order

            args[i] = arg;
          } else if (startOfArg.text === "EOF") {
            throw new ParseError("End of input expecting macro argument");
          } else {
            args[i] = [startOfArg];
          }
        }

        return args;
      }
      /**
       * Expand the next token only once if possible.
       *
       * If the token is expanded, the resulting tokens will be pushed onto
       * the stack in reverse order and will be returned as an array,
       * also in reverse order.
       *
       * If not, the next token will be returned without removing it
       * from the stack.  This case can be detected by a `Token` return value
       * instead of an `Array` return value.
       *
       * In either case, the next token will be on the top of the stack,
       * or the stack will be empty.
       *
       * Used to implement `expandAfterFuture` and `expandNextToken`.
       *
       * At the moment, macro expansion doesn't handle delimited macros,
       * i.e. things like those defined by \def\foo#1\end{…}.
       * See the TeX book page 202ff. for details on how those should behave.
       */


      expandOnce() {
        const topToken = this.popToken();
        const name = topToken.text;

        const expansion = this._getExpansion(name);

        if (expansion == null) {
          // mainly checking for undefined here
          // Fully expanded
          this.pushToken(topToken);
          return topToken;
        }

        this.expansionCount++;

        if (this.expansionCount > this.settings.maxExpand) {
          throw new ParseError("Too many expansions: infinite loop or " + "need to increase maxExpand setting");
        }

        let tokens = expansion.tokens;

        if (expansion.numArgs) {
          const args = this.consumeArgs(expansion.numArgs); // paste arguments in place of the placeholders

          tokens = tokens.slice(); // make a shallow copy

          for (let i = tokens.length - 1; i >= 0; --i) {
            let tok = tokens[i];

            if (tok.text === "#") {
              if (i === 0) {
                throw new ParseError("Incomplete placeholder at end of macro body", tok);
              }

              tok = tokens[--i]; // next token on stack

              if (tok.text === "#") {
                // ## → #
                tokens.splice(i + 1, 1); // drop first #
              } else if (/^[1-9]$/.test(tok.text)) {
                // replace the placeholder with the indicated argument
                tokens.splice(i, 2, ...args[+tok.text - 1]);
              } else {
                throw new ParseError("Not a valid argument number", tok);
              }
            }
          }
        } // Concatenate expansion onto top of stack.


        this.pushTokens(tokens);
        return tokens;
      }
      /**
       * Expand the next token only once (if possible), and return the resulting
       * top token on the stack (without removing anything from the stack).
       * Similar in behavior to TeX's `\expandafter\futurelet`.
       * Equivalent to expandOnce() followed by future().
       */


      expandAfterFuture() {
        this.expandOnce();
        return this.future();
      }
      /**
       * Recursively expand first token, then return first non-expandable token.
       */


      expandNextToken() {
        for (;;) {
          const expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.

          if (expanded instanceof Token) {
            // \relax stops the expansion, but shouldn't get returned (a
            // null return value couldn't get implemented as a function).
            if (expanded.text === "\\relax") {
              this.stack.pop();
            } else {
              return this.stack.pop(); // === expanded
            }
          }
        } // Flow unable to figure out that this pathway is impossible.
        // https://github.com/facebook/flow/issues/4808


        throw new Error(); // eslint-disable-line no-unreachable
      }
      /**
       * Fully expand the given macro name and return the resulting list of
       * tokens, or return `undefined` if no such macro is defined.
       */


      expandMacro(name) {
        if (!this.macros.get(name)) {
          return undefined;
        }

        const output = [];
        const oldStackLength = this.stack.length;
        this.pushToken(new Token(name));

        while (this.stack.length > oldStackLength) {
          const expanded = this.expandOnce(); // expandOnce returns Token if and only if it's fully expanded.

          if (expanded instanceof Token) {
            output.push(this.stack.pop());
          }
        }

        return output;
      }
      /**
       * Fully expand the given macro name and return the result as a string,
       * or return `undefined` if no such macro is defined.
       */


      expandMacroAsText(name) {
        const tokens = this.expandMacro(name);

        if (tokens) {
          return tokens.map(token => token.text).join("");
        } else {
          return tokens;
        }
      }
      /**
       * Returns the expanded macro as a reversed array of tokens and a macro
       * argument count.  Or returns `null` if no such macro.
       */


      _getExpansion(name) {
        const definition = this.macros.get(name);

        if (definition == null) {
          // mainly checking for undefined here
          return definition;
        }

        const expansion = typeof definition === "function" ? definition(this) : definition;

        if (typeof expansion === "string") {
          let numArgs = 0;

          if (expansion.indexOf("#") !== -1) {
            const stripped = expansion.replace(/##/g, "");

            while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
              ++numArgs;
            }
          }

          const bodyLexer = new Lexer(expansion, this.settings);
          const tokens = [];
          let tok = bodyLexer.lex();

          while (tok.text !== "EOF") {
            tokens.push(tok);
            tok = bodyLexer.lex();
          }

          tokens.reverse(); // to fit in with stack using push and pop

          const expanded = {
            tokens,
            numArgs
          };
          return expanded;
        }

        return expansion;
      }
      /**
       * Determine whether a command is currently "defined" (has some
       * functionality), meaning that it's a macro (in the current group),
       * a function, a symbol, or one of the special commands listed in
       * `implicitCommands`.
       */


      isDefined(name) {
        return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
      }

    }

    // Mapping of Unicode accent characters to their LaTeX equivalent in text and
    // math mode (when they exist).
    var unicodeAccents = {
      '\u0301': {
        text: "\\'",
        math: '\\acute'
      },
      '\u0300': {
        text: '\\`',
        math: '\\grave'
      },
      '\u0308': {
        text: '\\"',
        math: '\\ddot'
      },
      '\u0303': {
        text: '\\~',
        math: '\\tilde'
      },
      '\u0304': {
        text: '\\=',
        math: '\\bar'
      },
      '\u0306': {
        text: '\\u',
        math: '\\breve'
      },
      '\u030c': {
        text: '\\v',
        math: '\\check'
      },
      '\u0302': {
        text: '\\^',
        math: '\\hat'
      },
      '\u0307': {
        text: '\\.',
        math: '\\dot'
      },
      '\u030a': {
        text: '\\r',
        math: '\\mathring'
      },
      '\u030b': {
        text: '\\H'
      }
    };

    // This file is GENERATED by unicodeMake.js. DO NOT MODIFY.
    var unicodeSymbols = {
      "\u00e1": "\u0061\u0301",
      // á = \'{a}
      "\u00e0": "\u0061\u0300",
      // à = \`{a}
      "\u00e4": "\u0061\u0308",
      // ä = \"{a}
      "\u01df": "\u0061\u0308\u0304",
      // ǟ = \"\={a}
      "\u00e3": "\u0061\u0303",
      // ã = \~{a}
      "\u0101": "\u0061\u0304",
      // ā = \={a}
      "\u0103": "\u0061\u0306",
      // ă = \u{a}
      "\u1eaf": "\u0061\u0306\u0301",
      // ắ = \u\'{a}
      "\u1eb1": "\u0061\u0306\u0300",
      // ằ = \u\`{a}
      "\u1eb5": "\u0061\u0306\u0303",
      // ẵ = \u\~{a}
      "\u01ce": "\u0061\u030c",
      // ǎ = \v{a}
      "\u00e2": "\u0061\u0302",
      // â = \^{a}
      "\u1ea5": "\u0061\u0302\u0301",
      // ấ = \^\'{a}
      "\u1ea7": "\u0061\u0302\u0300",
      // ầ = \^\`{a}
      "\u1eab": "\u0061\u0302\u0303",
      // ẫ = \^\~{a}
      "\u0227": "\u0061\u0307",
      // ȧ = \.{a}
      "\u01e1": "\u0061\u0307\u0304",
      // ǡ = \.\={a}
      "\u00e5": "\u0061\u030a",
      // å = \r{a}
      "\u01fb": "\u0061\u030a\u0301",
      // ǻ = \r\'{a}
      "\u1e03": "\u0062\u0307",
      // ḃ = \.{b}
      "\u0107": "\u0063\u0301",
      // ć = \'{c}
      "\u010d": "\u0063\u030c",
      // č = \v{c}
      "\u0109": "\u0063\u0302",
      // ĉ = \^{c}
      "\u010b": "\u0063\u0307",
      // ċ = \.{c}
      "\u010f": "\u0064\u030c",
      // ď = \v{d}
      "\u1e0b": "\u0064\u0307",
      // ḋ = \.{d}
      "\u00e9": "\u0065\u0301",
      // é = \'{e}
      "\u00e8": "\u0065\u0300",
      // è = \`{e}
      "\u00eb": "\u0065\u0308",
      // ë = \"{e}
      "\u1ebd": "\u0065\u0303",
      // ẽ = \~{e}
      "\u0113": "\u0065\u0304",
      // ē = \={e}
      "\u1e17": "\u0065\u0304\u0301",
      // ḗ = \=\'{e}
      "\u1e15": "\u0065\u0304\u0300",
      // ḕ = \=\`{e}
      "\u0115": "\u0065\u0306",
      // ĕ = \u{e}
      "\u011b": "\u0065\u030c",
      // ě = \v{e}
      "\u00ea": "\u0065\u0302",
      // ê = \^{e}
      "\u1ebf": "\u0065\u0302\u0301",
      // ế = \^\'{e}
      "\u1ec1": "\u0065\u0302\u0300",
      // ề = \^\`{e}
      "\u1ec5": "\u0065\u0302\u0303",
      // ễ = \^\~{e}
      "\u0117": "\u0065\u0307",
      // ė = \.{e}
      "\u1e1f": "\u0066\u0307",
      // ḟ = \.{f}
      "\u01f5": "\u0067\u0301",
      // ǵ = \'{g}
      "\u1e21": "\u0067\u0304",
      // ḡ = \={g}
      "\u011f": "\u0067\u0306",
      // ğ = \u{g}
      "\u01e7": "\u0067\u030c",
      // ǧ = \v{g}
      "\u011d": "\u0067\u0302",
      // ĝ = \^{g}
      "\u0121": "\u0067\u0307",
      // ġ = \.{g}
      "\u1e27": "\u0068\u0308",
      // ḧ = \"{h}
      "\u021f": "\u0068\u030c",
      // ȟ = \v{h}
      "\u0125": "\u0068\u0302",
      // ĥ = \^{h}
      "\u1e23": "\u0068\u0307",
      // ḣ = \.{h}
      "\u00ed": "\u0069\u0301",
      // í = \'{i}
      "\u00ec": "\u0069\u0300",
      // ì = \`{i}
      "\u00ef": "\u0069\u0308",
      // ï = \"{i}
      "\u1e2f": "\u0069\u0308\u0301",
      // ḯ = \"\'{i}
      "\u0129": "\u0069\u0303",
      // ĩ = \~{i}
      "\u012b": "\u0069\u0304",
      // ī = \={i}
      "\u012d": "\u0069\u0306",
      // ĭ = \u{i}
      "\u01d0": "\u0069\u030c",
      // ǐ = \v{i}
      "\u00ee": "\u0069\u0302",
      // î = \^{i}
      "\u01f0": "\u006a\u030c",
      // ǰ = \v{j}
      "\u0135": "\u006a\u0302",
      // ĵ = \^{j}
      "\u1e31": "\u006b\u0301",
      // ḱ = \'{k}
      "\u01e9": "\u006b\u030c",
      // ǩ = \v{k}
      "\u013a": "\u006c\u0301",
      // ĺ = \'{l}
      "\u013e": "\u006c\u030c",
      // ľ = \v{l}
      "\u1e3f": "\u006d\u0301",
      // ḿ = \'{m}
      "\u1e41": "\u006d\u0307",
      // ṁ = \.{m}
      "\u0144": "\u006e\u0301",
      // ń = \'{n}
      "\u01f9": "\u006e\u0300",
      // ǹ = \`{n}
      "\u00f1": "\u006e\u0303",
      // ñ = \~{n}
      "\u0148": "\u006e\u030c",
      // ň = \v{n}
      "\u1e45": "\u006e\u0307",
      // ṅ = \.{n}
      "\u00f3": "\u006f\u0301",
      // ó = \'{o}
      "\u00f2": "\u006f\u0300",
      // ò = \`{o}
      "\u00f6": "\u006f\u0308",
      // ö = \"{o}
      "\u022b": "\u006f\u0308\u0304",
      // ȫ = \"\={o}
      "\u00f5": "\u006f\u0303",
      // õ = \~{o}
      "\u1e4d": "\u006f\u0303\u0301",
      // ṍ = \~\'{o}
      "\u1e4f": "\u006f\u0303\u0308",
      // ṏ = \~\"{o}
      "\u022d": "\u006f\u0303\u0304",
      // ȭ = \~\={o}
      "\u014d": "\u006f\u0304",
      // ō = \={o}
      "\u1e53": "\u006f\u0304\u0301",
      // ṓ = \=\'{o}
      "\u1e51": "\u006f\u0304\u0300",
      // ṑ = \=\`{o}
      "\u014f": "\u006f\u0306",
      // ŏ = \u{o}
      "\u01d2": "\u006f\u030c",
      // ǒ = \v{o}
      "\u00f4": "\u006f\u0302",
      // ô = \^{o}
      "\u1ed1": "\u006f\u0302\u0301",
      // ố = \^\'{o}
      "\u1ed3": "\u006f\u0302\u0300",
      // ồ = \^\`{o}
      "\u1ed7": "\u006f\u0302\u0303",
      // ỗ = \^\~{o}
      "\u022f": "\u006f\u0307",
      // ȯ = \.{o}
      "\u0231": "\u006f\u0307\u0304",
      // ȱ = \.\={o}
      "\u0151": "\u006f\u030b",
      // ő = \H{o}
      "\u1e55": "\u0070\u0301",
      // ṕ = \'{p}
      "\u1e57": "\u0070\u0307",
      // ṗ = \.{p}
      "\u0155": "\u0072\u0301",
      // ŕ = \'{r}
      "\u0159": "\u0072\u030c",
      // ř = \v{r}
      "\u1e59": "\u0072\u0307",
      // ṙ = \.{r}
      "\u015b": "\u0073\u0301",
      // ś = \'{s}
      "\u1e65": "\u0073\u0301\u0307",
      // ṥ = \'\.{s}
      "\u0161": "\u0073\u030c",
      // š = \v{s}
      "\u1e67": "\u0073\u030c\u0307",
      // ṧ = \v\.{s}
      "\u015d": "\u0073\u0302",
      // ŝ = \^{s}
      "\u1e61": "\u0073\u0307",
      // ṡ = \.{s}
      "\u1e97": "\u0074\u0308",
      // ẗ = \"{t}
      "\u0165": "\u0074\u030c",
      // ť = \v{t}
      "\u1e6b": "\u0074\u0307",
      // ṫ = \.{t}
      "\u00fa": "\u0075\u0301",
      // ú = \'{u}
      "\u00f9": "\u0075\u0300",
      // ù = \`{u}
      "\u00fc": "\u0075\u0308",
      // ü = \"{u}
      "\u01d8": "\u0075\u0308\u0301",
      // ǘ = \"\'{u}
      "\u01dc": "\u0075\u0308\u0300",
      // ǜ = \"\`{u}
      "\u01d6": "\u0075\u0308\u0304",
      // ǖ = \"\={u}
      "\u01da": "\u0075\u0308\u030c",
      // ǚ = \"\v{u}
      "\u0169": "\u0075\u0303",
      // ũ = \~{u}
      "\u1e79": "\u0075\u0303\u0301",
      // ṹ = \~\'{u}
      "\u016b": "\u0075\u0304",
      // ū = \={u}
      "\u1e7b": "\u0075\u0304\u0308",
      // ṻ = \=\"{u}
      "\u016d": "\u0075\u0306",
      // ŭ = \u{u}
      "\u01d4": "\u0075\u030c",
      // ǔ = \v{u}
      "\u00fb": "\u0075\u0302",
      // û = \^{u}
      "\u016f": "\u0075\u030a",
      // ů = \r{u}
      "\u0171": "\u0075\u030b",
      // ű = \H{u}
      "\u1e7d": "\u0076\u0303",
      // ṽ = \~{v}
      "\u1e83": "\u0077\u0301",
      // ẃ = \'{w}
      "\u1e81": "\u0077\u0300",
      // ẁ = \`{w}
      "\u1e85": "\u0077\u0308",
      // ẅ = \"{w}
      "\u0175": "\u0077\u0302",
      // ŵ = \^{w}
      "\u1e87": "\u0077\u0307",
      // ẇ = \.{w}
      "\u1e98": "\u0077\u030a",
      // ẘ = \r{w}
      "\u1e8d": "\u0078\u0308",
      // ẍ = \"{x}
      "\u1e8b": "\u0078\u0307",
      // ẋ = \.{x}
      "\u00fd": "\u0079\u0301",
      // ý = \'{y}
      "\u1ef3": "\u0079\u0300",
      // ỳ = \`{y}
      "\u00ff": "\u0079\u0308",
      // ÿ = \"{y}
      "\u1ef9": "\u0079\u0303",
      // ỹ = \~{y}
      "\u0233": "\u0079\u0304",
      // ȳ = \={y}
      "\u0177": "\u0079\u0302",
      // ŷ = \^{y}
      "\u1e8f": "\u0079\u0307",
      // ẏ = \.{y}
      "\u1e99": "\u0079\u030a",
      // ẙ = \r{y}
      "\u017a": "\u007a\u0301",
      // ź = \'{z}
      "\u017e": "\u007a\u030c",
      // ž = \v{z}
      "\u1e91": "\u007a\u0302",
      // ẑ = \^{z}
      "\u017c": "\u007a\u0307",
      // ż = \.{z}
      "\u00c1": "\u0041\u0301",
      // Á = \'{A}
      "\u00c0": "\u0041\u0300",
      // À = \`{A}
      "\u00c4": "\u0041\u0308",
      // Ä = \"{A}
      "\u01de": "\u0041\u0308\u0304",
      // Ǟ = \"\={A}
      "\u00c3": "\u0041\u0303",
      // Ã = \~{A}
      "\u0100": "\u0041\u0304",
      // Ā = \={A}
      "\u0102": "\u0041\u0306",
      // Ă = \u{A}
      "\u1eae": "\u0041\u0306\u0301",
      // Ắ = \u\'{A}
      "\u1eb0": "\u0041\u0306\u0300",
      // Ằ = \u\`{A}
      "\u1eb4": "\u0041\u0306\u0303",
      // Ẵ = \u\~{A}
      "\u01cd": "\u0041\u030c",
      // Ǎ = \v{A}
      "\u00c2": "\u0041\u0302",
      // Â = \^{A}
      "\u1ea4": "\u0041\u0302\u0301",
      // Ấ = \^\'{A}
      "\u1ea6": "\u0041\u0302\u0300",
      // Ầ = \^\`{A}
      "\u1eaa": "\u0041\u0302\u0303",
      // Ẫ = \^\~{A}
      "\u0226": "\u0041\u0307",
      // Ȧ = \.{A}
      "\u01e0": "\u0041\u0307\u0304",
      // Ǡ = \.\={A}
      "\u00c5": "\u0041\u030a",
      // Å = \r{A}
      "\u01fa": "\u0041\u030a\u0301",
      // Ǻ = \r\'{A}
      "\u1e02": "\u0042\u0307",
      // Ḃ = \.{B}
      "\u0106": "\u0043\u0301",
      // Ć = \'{C}
      "\u010c": "\u0043\u030c",
      // Č = \v{C}
      "\u0108": "\u0043\u0302",
      // Ĉ = \^{C}
      "\u010a": "\u0043\u0307",
      // Ċ = \.{C}
      "\u010e": "\u0044\u030c",
      // Ď = \v{D}
      "\u1e0a": "\u0044\u0307",
      // Ḋ = \.{D}
      "\u00c9": "\u0045\u0301",
      // É = \'{E}
      "\u00c8": "\u0045\u0300",
      // È = \`{E}
      "\u00cb": "\u0045\u0308",
      // Ë = \"{E}
      "\u1ebc": "\u0045\u0303",
      // Ẽ = \~{E}
      "\u0112": "\u0045\u0304",
      // Ē = \={E}
      "\u1e16": "\u0045\u0304\u0301",
      // Ḗ = \=\'{E}
      "\u1e14": "\u0045\u0304\u0300",
      // Ḕ = \=\`{E}
      "\u0114": "\u0045\u0306",
      // Ĕ = \u{E}
      "\u011a": "\u0045\u030c",
      // Ě = \v{E}
      "\u00ca": "\u0045\u0302",
      // Ê = \^{E}
      "\u1ebe": "\u0045\u0302\u0301",
      // Ế = \^\'{E}
      "\u1ec0": "\u0045\u0302\u0300",
      // Ề = \^\`{E}
      "\u1ec4": "\u0045\u0302\u0303",
      // Ễ = \^\~{E}
      "\u0116": "\u0045\u0307",
      // Ė = \.{E}
      "\u1e1e": "\u0046\u0307",
      // Ḟ = \.{F}
      "\u01f4": "\u0047\u0301",
      // Ǵ = \'{G}
      "\u1e20": "\u0047\u0304",
      // Ḡ = \={G}
      "\u011e": "\u0047\u0306",
      // Ğ = \u{G}
      "\u01e6": "\u0047\u030c",
      // Ǧ = \v{G}
      "\u011c": "\u0047\u0302",
      // Ĝ = \^{G}
      "\u0120": "\u0047\u0307",
      // Ġ = \.{G}
      "\u1e26": "\u0048\u0308",
      // Ḧ = \"{H}
      "\u021e": "\u0048\u030c",
      // Ȟ = \v{H}
      "\u0124": "\u0048\u0302",
      // Ĥ = \^{H}
      "\u1e22": "\u0048\u0307",
      // Ḣ = \.{H}
      "\u00cd": "\u0049\u0301",
      // Í = \'{I}
      "\u00cc": "\u0049\u0300",
      // Ì = \`{I}
      "\u00cf": "\u0049\u0308",
      // Ï = \"{I}
      "\u1e2e": "\u0049\u0308\u0301",
      // Ḯ = \"\'{I}
      "\u0128": "\u0049\u0303",
      // Ĩ = \~{I}
      "\u012a": "\u0049\u0304",
      // Ī = \={I}
      "\u012c": "\u0049\u0306",
      // Ĭ = \u{I}
      "\u01cf": "\u0049\u030c",
      // Ǐ = \v{I}
      "\u00ce": "\u0049\u0302",
      // Î = \^{I}
      "\u0130": "\u0049\u0307",
      // İ = \.{I}
      "\u0134": "\u004a\u0302",
      // Ĵ = \^{J}
      "\u1e30": "\u004b\u0301",
      // Ḱ = \'{K}
      "\u01e8": "\u004b\u030c",
      // Ǩ = \v{K}
      "\u0139": "\u004c\u0301",
      // Ĺ = \'{L}
      "\u013d": "\u004c\u030c",
      // Ľ = \v{L}
      "\u1e3e": "\u004d\u0301",
      // Ḿ = \'{M}
      "\u1e40": "\u004d\u0307",
      // Ṁ = \.{M}
      "\u0143": "\u004e\u0301",
      // Ń = \'{N}
      "\u01f8": "\u004e\u0300",
      // Ǹ = \`{N}
      "\u00d1": "\u004e\u0303",
      // Ñ = \~{N}
      "\u0147": "\u004e\u030c",
      // Ň = \v{N}
      "\u1e44": "\u004e\u0307",
      // Ṅ = \.{N}
      "\u00d3": "\u004f\u0301",
      // Ó = \'{O}
      "\u00d2": "\u004f\u0300",
      // Ò = \`{O}
      "\u00d6": "\u004f\u0308",
      // Ö = \"{O}
      "\u022a": "\u004f\u0308\u0304",
      // Ȫ = \"\={O}
      "\u00d5": "\u004f\u0303",
      // Õ = \~{O}
      "\u1e4c": "\u004f\u0303\u0301",
      // Ṍ = \~\'{O}
      "\u1e4e": "\u004f\u0303\u0308",
      // Ṏ = \~\"{O}
      "\u022c": "\u004f\u0303\u0304",
      // Ȭ = \~\={O}
      "\u014c": "\u004f\u0304",
      // Ō = \={O}
      "\u1e52": "\u004f\u0304\u0301",
      // Ṓ = \=\'{O}
      "\u1e50": "\u004f\u0304\u0300",
      // Ṑ = \=\`{O}
      "\u014e": "\u004f\u0306",
      // Ŏ = \u{O}
      "\u01d1": "\u004f\u030c",
      // Ǒ = \v{O}
      "\u00d4": "\u004f\u0302",
      // Ô = \^{O}
      "\u1ed0": "\u004f\u0302\u0301",
      // Ố = \^\'{O}
      "\u1ed2": "\u004f\u0302\u0300",
      // Ồ = \^\`{O}
      "\u1ed6": "\u004f\u0302\u0303",
      // Ỗ = \^\~{O}
      "\u022e": "\u004f\u0307",
      // Ȯ = \.{O}
      "\u0230": "\u004f\u0307\u0304",
      // Ȱ = \.\={O}
      "\u0150": "\u004f\u030b",
      // Ő = \H{O}
      "\u1e54": "\u0050\u0301",
      // Ṕ = \'{P}
      "\u1e56": "\u0050\u0307",
      // Ṗ = \.{P}
      "\u0154": "\u0052\u0301",
      // Ŕ = \'{R}
      "\u0158": "\u0052\u030c",
      // Ř = \v{R}
      "\u1e58": "\u0052\u0307",
      // Ṙ = \.{R}
      "\u015a": "\u0053\u0301",
      // Ś = \'{S}
      "\u1e64": "\u0053\u0301\u0307",
      // Ṥ = \'\.{S}
      "\u0160": "\u0053\u030c",
      // Š = \v{S}
      "\u1e66": "\u0053\u030c\u0307",
      // Ṧ = \v\.{S}
      "\u015c": "\u0053\u0302",
      // Ŝ = \^{S}
      "\u1e60": "\u0053\u0307",
      // Ṡ = \.{S}
      "\u0164": "\u0054\u030c",
      // Ť = \v{T}
      "\u1e6a": "\u0054\u0307",
      // Ṫ = \.{T}
      "\u00da": "\u0055\u0301",
      // Ú = \'{U}
      "\u00d9": "\u0055\u0300",
      // Ù = \`{U}
      "\u00dc": "\u0055\u0308",
      // Ü = \"{U}
      "\u01d7": "\u0055\u0308\u0301",
      // Ǘ = \"\'{U}
      "\u01db": "\u0055\u0308\u0300",
      // Ǜ = \"\`{U}
      "\u01d5": "\u0055\u0308\u0304",
      // Ǖ = \"\={U}
      "\u01d9": "\u0055\u0308\u030c",
      // Ǚ = \"\v{U}
      "\u0168": "\u0055\u0303",
      // Ũ = \~{U}
      "\u1e78": "\u0055\u0303\u0301",
      // Ṹ = \~\'{U}
      "\u016a": "\u0055\u0304",
      // Ū = \={U}
      "\u1e7a": "\u0055\u0304\u0308",
      // Ṻ = \=\"{U}
      "\u016c": "\u0055\u0306",
      // Ŭ = \u{U}
      "\u01d3": "\u0055\u030c",
      // Ǔ = \v{U}
      "\u00db": "\u0055\u0302",
      // Û = \^{U}
      "\u016e": "\u0055\u030a",
      // Ů = \r{U}
      "\u0170": "\u0055\u030b",
      // Ű = \H{U}
      "\u1e7c": "\u0056\u0303",
      // Ṽ = \~{V}
      "\u1e82": "\u0057\u0301",
      // Ẃ = \'{W}
      "\u1e80": "\u0057\u0300",
      // Ẁ = \`{W}
      "\u1e84": "\u0057\u0308",
      // Ẅ = \"{W}
      "\u0174": "\u0057\u0302",
      // Ŵ = \^{W}
      "\u1e86": "\u0057\u0307",
      // Ẇ = \.{W}
      "\u1e8c": "\u0058\u0308",
      // Ẍ = \"{X}
      "\u1e8a": "\u0058\u0307",
      // Ẋ = \.{X}
      "\u00dd": "\u0059\u0301",
      // Ý = \'{Y}
      "\u1ef2": "\u0059\u0300",
      // Ỳ = \`{Y}
      "\u0178": "\u0059\u0308",
      // Ÿ = \"{Y}
      "\u1ef8": "\u0059\u0303",
      // Ỹ = \~{Y}
      "\u0232": "\u0059\u0304",
      // Ȳ = \={Y}
      "\u0176": "\u0059\u0302",
      // Ŷ = \^{Y}
      "\u1e8e": "\u0059\u0307",
      // Ẏ = \.{Y}
      "\u0179": "\u005a\u0301",
      // Ź = \'{Z}
      "\u017d": "\u005a\u030c",
      // Ž = \v{Z}
      "\u1e90": "\u005a\u0302",
      // Ẑ = \^{Z}
      "\u017b": "\u005a\u0307",
      // Ż = \.{Z}
      "\u03ac": "\u03b1\u0301",
      // ά = \'{α}
      "\u1f70": "\u03b1\u0300",
      // ὰ = \`{α}
      "\u1fb1": "\u03b1\u0304",
      // ᾱ = \={α}
      "\u1fb0": "\u03b1\u0306",
      // ᾰ = \u{α}
      "\u03ad": "\u03b5\u0301",
      // έ = \'{ε}
      "\u1f72": "\u03b5\u0300",
      // ὲ = \`{ε}
      "\u03ae": "\u03b7\u0301",
      // ή = \'{η}
      "\u1f74": "\u03b7\u0300",
      // ὴ = \`{η}
      "\u03af": "\u03b9\u0301",
      // ί = \'{ι}
      "\u1f76": "\u03b9\u0300",
      // ὶ = \`{ι}
      "\u03ca": "\u03b9\u0308",
      // ϊ = \"{ι}
      "\u0390": "\u03b9\u0308\u0301",
      // ΐ = \"\'{ι}
      "\u1fd2": "\u03b9\u0308\u0300",
      // ῒ = \"\`{ι}
      "\u1fd1": "\u03b9\u0304",
      // ῑ = \={ι}
      "\u1fd0": "\u03b9\u0306",
      // ῐ = \u{ι}
      "\u03cc": "\u03bf\u0301",
      // ό = \'{ο}
      "\u1f78": "\u03bf\u0300",
      // ὸ = \`{ο}
      "\u03cd": "\u03c5\u0301",
      // ύ = \'{υ}
      "\u1f7a": "\u03c5\u0300",
      // ὺ = \`{υ}
      "\u03cb": "\u03c5\u0308",
      // ϋ = \"{υ}
      "\u03b0": "\u03c5\u0308\u0301",
      // ΰ = \"\'{υ}
      "\u1fe2": "\u03c5\u0308\u0300",
      // ῢ = \"\`{υ}
      "\u1fe1": "\u03c5\u0304",
      // ῡ = \={υ}
      "\u1fe0": "\u03c5\u0306",
      // ῠ = \u{υ}
      "\u03ce": "\u03c9\u0301",
      // ώ = \'{ω}
      "\u1f7c": "\u03c9\u0300",
      // ὼ = \`{ω}
      "\u038e": "\u03a5\u0301",
      // Ύ = \'{Υ}
      "\u1fea": "\u03a5\u0300",
      // Ὺ = \`{Υ}
      "\u03ab": "\u03a5\u0308",
      // Ϋ = \"{Υ}
      "\u1fe9": "\u03a5\u0304",
      // Ῡ = \={Υ}
      "\u1fe8": "\u03a5\u0306",
      // Ῠ = \u{Υ}
      "\u038f": "\u03a9\u0301",
      // Ώ = \'{Ω}
      "\u1ffa": "\u03a9\u0300" // Ὼ = \`{Ω}

    };

    /* eslint no-constant-condition:0 */

    /**
     * This file contains the parser used to parse out a TeX expression from the
     * input. Since TeX isn't context-free, standard parsers don't work particularly
     * well.
     *
     * The strategy of this parser is as such:
     *
     * The main functions (the `.parse...` ones) take a position in the current
     * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
     * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
     * individual tokens are needed at a position, the lexer is called to pull out a
     * token, which is then used.
     *
     * The parser has a property called "mode" indicating the mode that
     * the parser is currently in. Currently it has to be one of "math" or
     * "text", which denotes whether the current environment is a math-y
     * one or a text-y one (e.g. inside \text). Currently, this serves to
     * limit the functions which can be used in text mode.
     *
     * The main functions then return an object which contains the useful data that
     * was parsed at its given point, and a new position at the end of the parsed
     * data. The main functions can call each other and continue the parsing by
     * using the returned position as a new starting point.
     *
     * There are also extra `.handle...` functions, which pull out some reused
     * functionality into self-contained functions.
     *
     * The functions return ParseNodes.
     */
    class Parser {
      constructor(input, settings) {
        this.mode = void 0;
        this.gullet = void 0;
        this.settings = void 0;
        this.leftrightDepth = void 0;
        this.nextToken = void 0;
        // Start in math mode
        this.mode = "math"; // Create a new macro expander (gullet) and (indirectly via that) also a
        // new lexer (mouth) for this parser (stomach, in the language of TeX)

        this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing

        this.settings = settings; // Count leftright depth (for \middle errors)

        this.leftrightDepth = 0;
      }
      /**
       * Checks a result to make sure it has the right type, and throws an
       * appropriate error otherwise.
       */


      expect(text, consume) {
        if (consume === void 0) {
          consume = true;
        }

        if (this.nextToken.text !== text) {
          throw new ParseError("Expected '" + text + "', got '" + this.nextToken.text + "'", this.nextToken);
        }

        if (consume) {
          this.consume();
        }
      }
      /**
       * Considers the current look ahead token as consumed,
       * and fetches the one after that as the new look ahead.
       */


      consume() {
        this.nextToken = this.gullet.expandNextToken();
      }
      /**
       * Switches between "text" and "math" modes.
       */


      switchMode(newMode) {
        this.mode = newMode;
        this.gullet.switchMode(newMode);
      }
      /**
       * Main parsing function, which parses an entire input.
       */


      parse() {
        // Create a group namespace for the math expression.
        // (LaTeX creates a new group for every $...$, $$...$$, \[...\].)
        this.gullet.beginGroup(); // Use old \color behavior (same as LaTeX's \textcolor) if requested.
        // We do this within the group for the math expression, so it doesn't
        // pollute settings.macros.

        if (this.settings.colorIsTextColor) {
          this.gullet.macros.set("\\color", "\\textcolor");
        } // Try to parse the input


        this.consume();
        const parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end

        this.expect("EOF", false); // End the group namespace for the expression

        this.gullet.endGroup();
        return parse;
      }

      parseExpression(breakOnInfix, breakOnTokenText) {
        const body = []; // Keep adding atoms to the body until we can't parse any more atoms (either
        // we reached the end, a }, or a \right)

        while (true) {
          // Ignore spaces in math mode
          if (this.mode === "math") {
            this.consumeSpaces();
          }

          const lex = this.nextToken;

          if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
            break;
          }

          if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
          }

          if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
          }

          const atom = this.parseAtom(breakOnTokenText);

          if (!atom) {
            break;
          }

          body.push(atom);
        }

        if (this.mode === "text") {
          this.formLigatures(body);
        }

        return this.handleInfixNodes(body);
      }
      /**
       * Rewrites infix operators such as \over with corresponding commands such
       * as \frac.
       *
       * There can only be one infix operator per group.  If there's more than one
       * then the expression is ambiguous.  This can be resolved by adding {}.
       */


      handleInfixNodes(body) {
        let overIndex = -1;
        let funcName;

        for (let i = 0; i < body.length; i++) {
          const node = checkNodeType(body[i], "infix");

          if (node) {
            if (overIndex !== -1) {
              throw new ParseError("only one infix operator per group", node.token);
            }

            overIndex = i;
            funcName = node.replaceWith;
          }
        }

        if (overIndex !== -1 && funcName) {
          let numerNode;
          let denomNode;
          const numerBody = body.slice(0, overIndex);
          const denomBody = body.slice(overIndex + 1);

          if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
          } else {
            numerNode = {
              type: "ordgroup",
              mode: this.mode,
              body: numerBody
            };
          }

          if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
          } else {
            denomNode = {
              type: "ordgroup",
              mode: this.mode,
              body: denomBody
            };
          }

          let node;

          if (funcName === "\\\\abovefrac") {
            node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
          } else {
            node = this.callFunction(funcName, [numerNode, denomNode], []);
          }

          return [node];
        } else {
          return body;
        }
      } // The greediness of a superscript or subscript


      /**
       * Handle a subscript or superscript with nice errors.
       */
      handleSupSubscript(name) {
        const symbolToken = this.nextToken;
        const symbol = symbolToken.text;
        this.consume();
        this.consumeSpaces(); // ignore spaces before sup/subscript argument

        const group = this.parseGroup(name, false, Parser.SUPSUB_GREEDINESS);

        if (!group) {
          throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
        }

        return group;
      }
      /**
       * Converts the textual input of an unsupported command into a text node
       * contained within a color node whose color is determined by errorColor
       */


      handleUnsupportedCmd() {
        const text = this.nextToken.text;
        const textordArray = [];

        for (let i = 0; i < text.length; i++) {
          textordArray.push({
            type: "textord",
            mode: "text",
            text: text[i]
          });
        }

        const textNode = {
          type: "text",
          mode: this.mode,
          body: textordArray
        };
        const colorNode = {
          type: "color",
          mode: this.mode,
          color: this.settings.errorColor,
          body: [textNode]
        };
        this.consume();
        return colorNode;
      }
      /**
       * Parses a group with optional super/subscripts.
       */


      parseAtom(breakOnTokenText) {
        // The body of an atom is an implicit group, so that things like
        // \left(x\right)^2 work correctly.
        const base = this.parseGroup("atom", false, null, breakOnTokenText); // In text mode, we don't have superscripts or subscripts

        if (this.mode === "text") {
          return base;
        } // Note that base may be empty (i.e. null) at this point.


        let superscript;
        let subscript;

        while (true) {
          // Guaranteed in math mode, so eat any spaces first.
          this.consumeSpaces(); // Lex the first token

          const lex = this.nextToken;

          if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            const opNode = checkNodeType(base, "op");

            if (opNode) {
              const limits = lex.text === "\\limits";
              opNode.limits = limits;
              opNode.alwaysHandleSupSub = true;
            } else {
              throw new ParseError("Limit controls must follow a math operator", lex);
            }

            this.consume();
          } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }

            superscript = this.handleSupSubscript("superscript");
          } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
              throw new ParseError("Double subscript", lex);
            }

            subscript = this.handleSupSubscript("subscript");
          } else if (lex.text === "'") {
            // We got a prime
            if (superscript) {
              throw new ParseError("Double superscript", lex);
            }

            const prime = {
              type: "textord",
              mode: this.mode,
              text: "\\prime"
            }; // Many primes can be grouped together, so we handle this here

            const primes = [prime];
            this.consume(); // Keep lexing tokens until we get something that's not a prime

            while (this.nextToken.text === "'") {
              // For each one, add another prime to the list
              primes.push(prime);
              this.consume();
            } // If there's a superscript following the primes, combine that
            // superscript in with the primes.


            if (this.nextToken.text === "^") {
              primes.push(this.handleSupSubscript("superscript"));
            } // Put everything into an ordgroup as the superscript


            superscript = {
              type: "ordgroup",
              mode: this.mode,
              body: primes
            };
          } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
          }
        } // Base must be set if superscript or subscript are set per logic above,
        // but need to check here for type check to pass.


        if (superscript || subscript) {
          // If we got either a superscript or subscript, create a supsub
          return {
            type: "supsub",
            mode: this.mode,
            base: base,
            sup: superscript,
            sub: subscript
          };
        } else {
          // Otherwise return the original body
          return base;
        }
      }
      /**
       * Parses an entire function, including its base and all of its arguments.
       */


      parseFunction(breakOnTokenText, name, // For error reporting.
      greediness) {
        const token = this.nextToken;
        const func = token.text;
        const funcData = functions[func];

        if (!funcData) {
          return null;
        }

        if (greediness != null && funcData.greediness <= greediness) {
          throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
        } else if (this.mode === "text" && !funcData.allowedInText) {
          throw new ParseError("Can't use function '" + func + "' in text mode", token);
        } else if (this.mode === "math" && funcData.allowedInMath === false) {
          throw new ParseError("Can't use function '" + func + "' in math mode", token);
        } // hyperref package sets the catcode of % as an active character


        if (funcData.argTypes && funcData.argTypes[0] === "url") {
          this.gullet.lexer.setCatcode("%", 13);
        } // Consume the command token after possibly switching to the
        // mode specified by the function (for instant mode switching),
        // and then immediately switch back.


        if (funcData.consumeMode) {
          const oldMode = this.mode;
          this.switchMode(funcData.consumeMode);
          this.consume();
          this.switchMode(oldMode);
        } else {
          this.consume();
        }

        const _this$parseArguments = this.parseArguments(func, funcData),
              args = _this$parseArguments.args,
              optArgs = _this$parseArguments.optArgs;

        return this.callFunction(func, args, optArgs, token, breakOnTokenText);
      }
      /**
       * Call a function handler with a suitable context and arguments.
       */


      callFunction(name, args, optArgs, token, breakOnTokenText) {
        const context = {
          funcName: name,
          parser: this,
          token,
          breakOnTokenText
        };
        const func = functions[name];

        if (func && func.handler) {
          return func.handler(context, args, optArgs);
        } else {
          throw new ParseError(`No function handler for ${name}`);
        }
      }
      /**
       * Parses the arguments of a function or environment
       */


      parseArguments(func, // Should look like "\name" or "\begin{name}".
      funcData) {
        const totalArgs = funcData.numArgs + funcData.numOptionalArgs;

        if (totalArgs === 0) {
          return {
            args: [],
            optArgs: []
          };
        }

        const baseGreediness = funcData.greediness;
        const args = [];
        const optArgs = [];

        for (let i = 0; i < totalArgs; i++) {
          const argType = funcData.argTypes && funcData.argTypes[i];
          const isOptional = i < funcData.numOptionalArgs; // Ignore spaces between arguments.  As the TeXbook says:
          // "After you have said ‘\def\row#1#2{...}’, you are allowed to
          //  put spaces between the arguments (e.g., ‘\row x n’), because
          //  TeX doesn’t use single spaces as undelimited arguments."

          if (i > 0 && !isOptional) {
            this.consumeSpaces();
          } // Also consume leading spaces in math mode, as parseSymbol
          // won't know what to do with them.  This can only happen with
          // macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
          // In LaTeX, the \foo's get treated as (blank) arguments).
          // In KaTeX, for now, both spaces will get consumed.
          // TODO(edemaine)


          if (i === 0 && !isOptional && this.mode === "math") {
            this.consumeSpaces();
          }

          const nextToken = this.nextToken;
          const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional, baseGreediness);

          if (!arg) {
            if (isOptional) {
              optArgs.push(null);
              continue;
            }

            throw new ParseError("Expected group after '" + func + "'", nextToken);
          }

          (isOptional ? optArgs : args).push(arg);
        }

        return {
          args,
          optArgs
        };
      }
      /**
       * Parses a group when the mode is changing.
       */


      parseGroupOfType(name, type, optional, greediness) {
        switch (type) {
          case "color":
            return this.parseColorGroup(optional);

          case "size":
            return this.parseSizeGroup(optional);

          case "url":
            return this.parseUrlGroup(optional);

          case "math":
          case "text":
            return this.parseGroup(name, optional, greediness, undefined, type);

          case "raw":
            {
              if (optional && this.nextToken.text === "{") {
                return null;
              }

              const token = this.parseStringGroup("raw", optional, true);

              if (token) {
                return {
                  type: "raw",
                  mode: "text",
                  string: token.text
                };
              } else {
                throw new ParseError("Expected raw group", this.nextToken);
              }
            }

          case "original":
          case null:
          case undefined:
            return this.parseGroup(name, optional, greediness);

          default:
            throw new ParseError("Unknown group type as " + name, this.nextToken);
        }
      }

      consumeSpaces() {
        while (this.nextToken.text === " ") {
          this.consume();
        }
      }
      /**
       * Parses a group, essentially returning the string formed by the
       * brace-enclosed tokens plus some position information.
       */


      parseStringGroup(modeName, // Used to describe the mode in error messages.
      optional, raw) {
        const groupBegin = optional ? "[" : "{";
        const groupEnd = optional ? "]" : "}";
        const nextToken = this.nextToken;

        if (nextToken.text !== groupBegin) {
          if (optional) {
            return null;
          } else if (raw && nextToken.text !== "EOF" && /[^{}[\]]/.test(nextToken.text)) {
            // allow a single character in raw string group
            this.gullet.lexer.setCatcode("%", 14); // reset the catcode of %

            this.consume();
            return nextToken;
          }
        }

        const outerMode = this.mode;
        this.mode = "text";
        this.expect(groupBegin);
        let str = "";
        const firstToken = this.nextToken;
        let nested = 0; // allow nested braces in raw string group

        let lastToken = firstToken;

        while (raw && nested > 0 || this.nextToken.text !== groupEnd) {
          switch (this.nextToken.text) {
            case "EOF":
              throw new ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str));

            case groupBegin:
              nested++;
              break;

            case groupEnd:
              nested--;
              break;
          }

          lastToken = this.nextToken;
          str += lastToken.text;
          this.consume();
        }

        this.mode = outerMode;
        this.gullet.lexer.setCatcode("%", 14); // reset the catcode of %

        this.expect(groupEnd);
        return firstToken.range(lastToken, str);
      }
      /**
       * Parses a regex-delimited group: the largest sequence of tokens
       * whose concatenated strings match `regex`. Returns the string
       * formed by the tokens plus some position information.
       */


      parseRegexGroup(regex, modeName) {
        const outerMode = this.mode;
        this.mode = "text";
        const firstToken = this.nextToken;
        let lastToken = firstToken;
        let str = "";

        while (this.nextToken.text !== "EOF" && regex.test(str + this.nextToken.text)) {
          lastToken = this.nextToken;
          str += lastToken.text;
          this.consume();
        }

        if (str === "") {
          throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
        }

        this.mode = outerMode;
        return firstToken.range(lastToken, str);
      }
      /**
       * Parses a color description.
       */


      parseColorGroup(optional) {
        const res = this.parseStringGroup("color", optional);

        if (!res) {
          return null;
        }

        const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);

        if (!match) {
          throw new ParseError("Invalid color: '" + res.text + "'", res);
        }

        let color = match[0];

        if (/^[0-9a-f]{6}$/i.test(color)) {
          // We allow a 6-digit HTML color spec without a leading "#".
          // This follows the xcolor package's HTML color model.
          // Predefined color names are all missed by this RegEx pattern.
          color = "#" + color;
        }

        return {
          type: "color-token",
          mode: this.mode,
          color
        };
      }
      /**
       * Parses a size specification, consisting of magnitude and unit.
       */


      parseSizeGroup(optional) {
        let res;
        let isBlank = false;

        if (!optional && this.nextToken.text !== "{") {
          res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
        } else {
          res = this.parseStringGroup("size", optional);
        }

        if (!res) {
          return null;
        }

        if (!optional && res.text.length === 0) {
          // Because we've tested for what is !optional, this block won't
          // affect \kern, \hspace, etc. It will capture the mandatory arguments
          // to \genfrac and \above.
          res.text = "0pt"; // Enable \above{}

          isBlank = true; // This is here specifically for \genfrac
        }

        const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);

        if (!match) {
          throw new ParseError("Invalid size: '" + res.text + "'", res);
        }

        const data = {
          number: +(match[1] + match[2]),
          // sign + magnitude, cast to number
          unit: match[3]
        };

        if (!validUnit(data)) {
          throw new ParseError("Invalid unit: '" + data.unit + "'", res);
        }

        return {
          type: "size",
          mode: this.mode,
          value: data,
          isBlank
        };
      }
      /**
       * Parses an URL, checking escaped letters and allowed protocols.
       */


      parseUrlGroup(optional) {
        const res = this.parseStringGroup("url", optional, true); // get raw string

        if (!res) {
          return null;
        } // hyperref package allows backslashes alone in href, but doesn't
        // generate valid links in such cases; we interpret this as
        // "undefined" behaviour, and keep them as-is. Some browser will
        // replace backslashes with forward slashes.


        const url = res.text.replace(/\\([#$%&~_^{}])/g, '$1');
        let protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
        protocol = protocol != null ? protocol[1] : "_relative";
        const allowed = this.settings.allowedProtocols;

        if (!utils.contains(allowed, "*") && !utils.contains(allowed, protocol)) {
          throw new ParseError(`Forbidden protocol '${protocol}'`, res);
        }

        return {
          type: "url",
          mode: this.mode,
          url
        };
      }
      /**
       * If `optional` is false or absent, this parses an ordinary group,
       * which is either a single nucleus (like "x") or an expression
       * in braces (like "{x+y}") or an implicit group, a group that starts
       * at the current position, and ends right before a higher explicit
       * group ends, or at EOF.
       * If `optional` is true, it parses either a bracket-delimited expression
       * (like "[x+y]") or returns null to indicate the absence of a
       * bracket-enclosed group.
       * If `mode` is present, switches to that mode while parsing the group,
       * and switches back after.
       */


      parseGroup(name, // For error reporting.
      optional, greediness, breakOnTokenText, mode) {
        const outerMode = this.mode;
        const firstToken = this.nextToken;
        const text = firstToken.text; // Switch to specified mode

        if (mode) {
          this.switchMode(mode);
        }

        let groupEnd;
        let result; // Try to parse an open brace or \begingroup

        if (optional ? text === "[" : text === "{" || text === "\\begingroup") {
          groupEnd = Parser.endOfGroup[text]; // Start a new group namespace

          this.gullet.beginGroup(); // If we get a brace, parse an expression

          this.consume();
          const expression = this.parseExpression(false, groupEnd);
          const lastToken = this.nextToken; // End group namespace before consuming symbol after close brace

          this.gullet.endGroup();
          result = {
            type: "ordgroup",
            mode: this.mode,
            loc: SourceLocation.range(firstToken, lastToken),
            body: expression,
            // A group formed by \begingroup...\endgroup is a semi-simple group
            // which doesn't affect spacing in math mode, i.e., is transparent.
            // https://tex.stackexchange.com/questions/1930/when-should-one-
            // use-begingroup-instead-of-bgroup
            semisimple: text === "\\begingroup" || undefined
          };
        } else if (optional) {
          // Return nothing for an optional group
          result = null;
        } else {
          // If there exists a function with this name, parse the function.
          // Otherwise, just return a nucleus
          result = this.parseFunction(breakOnTokenText, name, greediness) || this.parseSymbol();

          if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
            if (this.settings.throwOnError) {
              throw new ParseError("Undefined control sequence: " + text, firstToken);
            }

            result = this.handleUnsupportedCmd();
          }
        } // Switch mode back


        if (mode) {
          this.switchMode(outerMode);
        } // Make sure we got a close brace


        if (groupEnd) {
          this.expect(groupEnd);
        }

        return result;
      }
      /**
       * Form ligature-like combinations of characters for text mode.
       * This includes inputs like "--", "---", "``" and "''".
       * The result will simply replace multiple textord nodes with a single
       * character in each value by a single textord node having multiple
       * characters in its value.  The representation is still ASCII source.
       * The group will be modified in place.
       */


      formLigatures(group) {
        let n = group.length - 1;

        for (let i = 0; i < n; ++i) {
          const a = group[i]; // $FlowFixMe: Not every node type has a `text` property.

          const v = a.text;

          if (v === "-" && group[i + 1].text === "-") {
            if (i + 1 < n && group[i + 2].text === "-") {
              group.splice(i, 3, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 2]),
                text: "---"
              });
              n -= 2;
            } else {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 1]),
                text: "--"
              });
              n -= 1;
            }
          }

          if ((v === "'" || v === "`") && group[i + 1].text === v) {
            group.splice(i, 2, {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(a, group[i + 1]),
              text: v + v
            });
            n -= 1;
          }
        }
      }
      /**
       * Parse a single symbol out of the string. Here, we handle single character
       * symbols and special functions like verbatim
       */


      parseSymbol() {
        const nucleus = this.nextToken;
        let text = nucleus.text;

        if (/^\\verb[^a-zA-Z]/.test(text)) {
          this.consume();
          let arg = text.slice(5);
          const star = arg.charAt(0) === "*";

          if (star) {
            arg = arg.slice(1);
          } // Lexer's tokenRegex is constructed to always have matching
          // first/last characters.


          if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
            throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
          }

          arg = arg.slice(1, -1); // remove first and last char

          return {
            type: "verb",
            mode: "text",
            body: arg,
            star
          };
        } // At this point, we should have a symbol, possibly with accents.
        // First expand any accented base symbol according to unicodeSymbols.


        if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {
          // This behavior is not strict (XeTeX-compatible) in math mode.
          if (this.settings.strict && this.mode === "math") {
            this.settings.reportNonstrict("unicodeTextInMathMode", `Accented Unicode text character "${text[0]}" used in ` + `math mode`, nucleus);
          }

          text = unicodeSymbols[text[0]] + text.substr(1);
        } // Strip off any combining characters


        const match = combiningDiacriticalMarksEndRegex.exec(text);

        if (match) {
          text = text.substring(0, match.index);

          if (text === 'i') {
            text = '\u0131'; // dotless i, in math and text mode
          } else if (text === 'j') {
            text = '\u0237'; // dotless j, in math and text mode
          }
        } // Recognize base symbol


        let symbol;

        if (symbols[this.mode][text]) {
          if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {
            this.settings.reportNonstrict("unicodeTextInMathMode", `Latin-1/Unicode text character "${text[0]}" used in ` + `math mode`, nucleus);
          }

          const group = symbols[this.mode][text].group;
          const loc = SourceLocation.range(nucleus);
          let s;

          if (ATOMS.hasOwnProperty(group)) {
            // $FlowFixMe
            const family = group;
            s = {
              type: "atom",
              mode: this.mode,
              family,
              loc,
              text
            };
          } else {
            // $FlowFixMe
            s = {
              type: group,
              mode: this.mode,
              loc,
              text
            };
          }

          symbol = s;
        } else if (text.charCodeAt(0) >= 0x80) {
          // no symbol for e.g. ^
          if (this.settings.strict) {
            if (!supportedCodepoint(text.charCodeAt(0))) {
              this.settings.reportNonstrict("unknownSymbol", `Unrecognized Unicode character "${text[0]}"` + ` (${text.charCodeAt(0)})`, nucleus);
            } else if (this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", `Unicode text character "${text[0]}" used in math mode`, nucleus);
            }
          }

          symbol = {
            type: "textord",
            mode: this.mode,
            loc: SourceLocation.range(nucleus),
            text
          };
        } else {
          return null; // EOF, ^, _, {, }, etc.
        }

        this.consume(); // Transform combining characters into accents

        if (match) {
          for (let i = 0; i < match[0].length; i++) {
            const accent = match[0][i];

            if (!unicodeAccents[accent]) {
              throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
            }

            const command = unicodeAccents[accent][this.mode];

            if (!command) {
              throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
            }

            symbol = {
              type: "accent",
              mode: this.mode,
              loc: SourceLocation.range(nucleus),
              label: command,
              isStretchy: false,
              isShifty: true,
              base: symbol
            };
          }
        }

        return symbol;
      }

    }
    Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
    Parser.endOfGroup = {
      "[": "]",
      "{": "}",
      "\\begingroup": "\\endgroup"
      /**
       * Parses an "expression", which is a list of atoms.
       *
       * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
       *                 happens when functions have higher precendence han infix
       *                 nodes in implicit parses.
       *
       * `breakOnTokenText`: The text of the token that the expression should end
       *                     with, or `null` if something else should end the
       *                     expression.
       */

    };
    Parser.SUPSUB_GREEDINESS = 1;

    /**
     * Provides a single function for parsing an expression using a Parser
     * TODO(emily): Remove this
     */

    /**
     * Parses an expression using a Parser, then returns the parsed result.
     */
    const parseTree = function parseTree(toParse, settings) {
      if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
      }

      const parser = new Parser(toParse, settings); // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors

      delete parser.gullet.macros.current["\\df@tag"];
      let tree = parser.parse(); // If the input used \tag, it will set the \df@tag macro to the tag.
      // In this case, we separately parse the tag and wrap the tree.

      if (parser.gullet.macros.get("\\df@tag")) {
        if (!settings.displayMode) {
          throw new ParseError("\\tag works only in display equations");
        }

        parser.gullet.feed("\\df@tag");
        tree = [{
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.parse()
        }];
      }

      return tree;
    };

    /* eslint no-console:0 */

    /**
     * Parse and build an expression, and place that expression in the DOM node
     * given.
     */
    let render = function render(expression, baseNode, options) {
      baseNode.textContent = "";
      const node = renderToDomTree(expression, options).toNode();
      baseNode.appendChild(node);
    }; // KaTeX's styles don't work properly in quirks mode. Print out an error, and
    // disable rendering.


    if (typeof document !== "undefined") {
      if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your " + "website has a suitable doctype.");

        render = function render() {
          throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
      }
    }
    /**
     * Parse and build an expression, and return the markup for that.
     */


    const renderToString = function renderToString(expression, options) {
      const markup = renderToDomTree(expression, options).toMarkup();
      return markup;
    };
    /**
     * Parse an expression and return the parse tree.
     */


    const generateParseTree = function generateParseTree(expression, options) {
      const settings = new Settings(options);
      return parseTree(expression, settings);
    };
    /**
     * If the given error is a KaTeX ParseError and options.throwOnError is false,
     * renders the invalid LaTeX as a span with hover title giving the KaTeX
     * error message.  Otherwise, simply throws the error.
     */


    const renderError = function renderError(error, expression, options) {
      if (options.throwOnError || !(error instanceof ParseError)) {
        throw error;
      }

      const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
      node.setAttribute("title", error.toString());
      node.setAttribute("style", `color:${options.errorColor}`);
      return node;
    };
    /**
     * Generates and returns the katex build tree. This is used for advanced
     * use cases (like rendering to custom output).
     */


    const renderToDomTree = function renderToDomTree(expression, options) {
      const settings = new Settings(options);

      try {
        const tree = parseTree(expression, settings);
        return buildTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };
    /**
     * Generates and returns the katex build tree, with just HTML (no MathML).
     * This is used for advanced use cases (like rendering to custom output).
     */


    const renderToHTMLTree = function renderToHTMLTree(expression, options) {
      const settings = new Settings(options);

      try {
        const tree = parseTree(expression, settings);
        return buildHTMLTree(tree, expression, settings);
      } catch (error) {
        return renderError(error, expression, settings);
      }
    };

    var katex = {
      /**
       * Current KaTeX version
       */
      version: "0.10.1",

      /**
       * Renders the given LaTeX into an HTML+MathML combination, and adds
       * it as a child to the specified DOM node.
       */
      render,

      /**
       * Renders the given LaTeX into an HTML+MathML combination string,
       * for sending to the client.
       */
      renderToString,

      /**
       * KaTeX error, usually during parsing.
       */
      ParseError,

      /**
       * Parses the given LaTeX into KaTeX's internal parse tree structure,
       * without rendering to HTML or MathML.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __parse: generateParseTree,

      /**
       * Renders the given LaTeX into an HTML+MathML internal DOM tree
       * representation, without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __renderToDomTree: renderToDomTree,

      /**
       * Renders the given LaTeX into an HTML internal DOM tree representation,
       * without MathML and without flattening that representation to a string.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __renderToHTMLTree: renderToHTMLTree,

      /**
       * extends internal font metrics object with a new object
       * each key in the new object represents a font name
      */
      __setFontMetrics: setFontMetrics,

      /**
       * adds a new symbol to builtin symbols table
       */
      __defineSymbol: defineSymbol,

      /**
       * adds a new macro to builtin macro list
       */
      __defineMacro: defineMacro,

      /**
       * Expose the dom tree node types, which can be useful for type checking nodes.
       *
       * NOTE: This method is not currently recommended for public use.
       * The internal tree representation is unstable and is very likely
       * to change. Use at your own risk.
       */
      __domTree: {
        Span,
        Anchor,
        SymbolNode,
        SvgNode,
        PathNode,
        LineNode
      }
    };

    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;',
        "`": '&#96;',
        "/": '&#47;',
        "\\": '&#92;',
    };
    function Sanitize(unSafeString){
       return unSafeString.replace(/[&<>"'`/\\]/g, (match)=>(map[match]));
    }

    class MarkdownRender{
        constructor(rendererName){
            this.rendererName=rendererName;
            this.regexLatex=/🥚[\s\S]*?🐤/g;//match latext sintax, pattern:  🥚{latext}🐤
            this.options="";
            this.start();
        }
        start(){
            let renderer="";
            const type=this.rendererName.toLowerCase();
            switch (type){
                case "katex":
                    renderer=new katexRederer();
                    break;
                case "mathjax": //for future compatibily with mathjax, for now it's the same as katex
                    renderer=new katexRederer();
                    break; 
                default:
                    renderer=new katexRederer();
                    break;  
            }
            this.options={renderer: this.getMarkedRender(renderer)};
        }
        getHTML(markdownValue){
            markdownValue= markdownValue.replace(/</g, "&lt;").replace(/💥/g, "<br>");
            return marked(markdownValue,this.options);
        }
        renderText(render,html){
            html=html.replace(/\\\s/g,"\\\\");//marked replace all "\\" for "\", but latex uses "\\" so I need to reverted, taking take not to replace for example \begin, that is why I match \{blank space}
            html=html.replace(/&amp;/g,"&");//marked replace all "&" for "&amp", but latex uses "&" so I need to reverted
            html=html.replace(this.regexLatex,function(me){
                const latex=me.replace("🥚",'').replace("🐤",'');//removing 🥚,🐤
                return render.getHTML(latex);
            });
            return html
        }
        getMarkedRender(render){
            let renderer = new marked.Renderer();
            renderer.paragraph =  (text) =>{
                let containsLatex=false;
                let html=text.replace(/^\s+/, '').replace(/\s+$/, '');//remove all \s(regex) at the beginning and at the end  so I can check check if the user wants an inline latex or a new line
                const first=html[0];
                const last=html[html.length-1];
                html=html.replace(/&amp;/g,"&");//marked replace all "&" for "&amp", but latex uses "&" so I need to reverted
                html=html.replace(/\\\s/g,"\\\\");//marked replace all "\\" for "\", but latex uses "\\" so I need to reverted, taking take not to replace for example \begin, that is why I match \{blank space}
                html=html.replace(this.regexLatex,function(me){
                    const latex=me.replace("🥚",'').replace("🐤",'');//removing 🥚,🐤
                    containsLatex=true;
                    return render.getHTML(latex);
                });
                if(containsLatex){
                    if(first.match(/\w/) || last.match(/\w/)){//here I check if user wants inline or in a new line
                        return `<p class="inlineKatex">${html}</p>`
                    }
                    return `<p class="alone">${html}</p>`
                }
                if(html.includes("<img src")){
                    if(first=="<" && last==">"){//here I check if user wants inline or in a new line
                        return `<p class="alone">${html}</p>`
                    }
                    return `<p class="inlineImage">${html}</p>`
                }
                return `<p>${html}</p>`
            };
            renderer.code = function (code,infostring,escaped){
                return `
            <pre class="prettyprint linenums"><code class="language-${infostring}">${code}</code></pre>
            `
            };
            renderer.list = (body, ordered, start)=> {
                const redered=this.renderText(render, body);
                if(ordered){
                    return `<ol>${redered}</ol>`
                }
                return `<ul>${redered}</ul>`
            };
            renderer.table = (header, body)=> {
                header=this.renderText(render, header);
                body=this.renderText(render, body);
                return `<table><thead>${header}</thead><tbody>${body}</tbody></table>`
            };
            return renderer 
        }
    }

    class katexRederer{
        constructor(){
            this.getHTML=this.getHTML.bind(this);
            this.options={displayMode: true,throwOnError: false,strict: "warn"};
        }
        getHTML(latex){
            return katex.renderToString(latex, this.options)
        }
    }

    /*If you are debugging the code you may wonder why sometimes I call CodeMirror.refresh();
      There are weird behaviors with CodeMirror, when the CodeMirror changes it's size, or when 
      goes from hiding to showing.
      Behaviors: 
            - not selecting text correctly.
            - CodeMirror not showing
      not showing any text until clicked, when clicked on an area .. etc
        //https://github.com/CodeMirror/CodeMirror/issues/4997
        //https://github.com/CodeMirror/CodeMirror/issues/2469
        For this reason I called it whenever it's size change or when I'm showing it
    */

    class Yaposi{
        constructor(mdRendererName,markdownInitial){
            this.Me="";
            this.CodeBlock={Module: CodeBlock, Handler: "" , Dom:""};
            this.Img={Module: Img, Handler: "" , Dom:""};
            this.Table={Module: Table, Handler: "" , Dom: ""};
            this.Toolbar={Module: Toolbar, Handler: "" , Dom: ""};
            this.CodeMirror={Module: CodeMirror, Handler: "" , Dom: ""};
            this.GetHTML=this.GetHTML.bind(this);
            this.GetMarkdown=this.GetMarkdown.bind(this);
            this.markdownRender = new MarkdownRender(mdRendererName);
            this.mdInitial=markdownInitial;
        }
        GetMarkdown(){//it returns markdown value, and scaped version of it
            const cm                = this.CodeMirror.Handler;    
            const cmValue           = cm.getValue();//-------------------------markdown value
            const scaped            = Sanitize(cmValue);
            return [cmValue,scaped]
        }
        GetHTML(){//it returns the markdown html result and scaped version of it
            const cm                = this.CodeMirror.Handler;    
            const cmValueRaw        = cm.getValue();//-------------------------markdown value
            const htmlValue         = this.markdownRender.getHTML(cmValueRaw);
            const scapedHTML        = Sanitize(htmlValue);
            return [htmlValue,scapedHTML]
        }
        SetValue(markdown){//set a markdown value to editor
            this.CodeMirror.Handler.setValue(markdown);
        }
        creatPreview(){
            const preview=document.createElement("div");
            const wrapper =document.createElement("div");
            wrapper.appendChild(preview);  
            wrapper.classList.add("yaposi-preview");
            wrapper.dataset.state="both";
            return [preview,wrapper]
        }
        Start(){
            const wrapper=document.createElement("div");
            wrapper.classList.add("yaposi");
            const cmWrapper=document.createElement("div");
            cmWrapper.classList.add("codeMirrorWrapper");
            wrapper.appendChild(cmWrapper);

            const cmModule = this.CodeMirror.Module;
            const cmConfig=    this.CodeMirrorConfig(this.mdInitial);
            const cmHandler = cmModule(cmWrapper, cmConfig);
            this.CodeMirror.Handler= cmHandler;

            /*creat preview */
            const [preview,wrapperPreview]=this.creatPreview();
            wrapper.appendChild(wrapperPreview); 
            this.previewContainer=preview;
            /*----------------------------*/ 
            /* Creat toolbar with it's listener */
            const tobModule  =  this.Toolbar.Module;
            const tobHandler =  new tobModule(cmHandler,wrapper);
            const tobDom     =  tobHandler.create();
            wrapper.prepend(tobDom);
            tobHandler.registerKeyMaps();

            this.Toolbar.Dom = tobDom;
            this.Toolbar.Handler= tobHandler;
            /*---------------------------- */
        
            /* creat the code full handler*/
            const cbModule  = this.CodeBlock.Module;
            const cbHandler = new cbModule(cmHandler);
            const cbDom     = cbHandler.create();
            wrapper.appendChild(cbDom);
            const cbIcon=tobDom.querySelector(`[data-name="code-block"]`);
            cbIcon.addEventListener("click",cbHandler.show);

            this.CodeBlock.Dom= cbDom;
            this.CodeBlock.Handler=cbHandler;
            /*----------------------------- */

            /* creat the upload image handler*/
            const imgModule = this.Img.Module;
            const imgHandler=new imgModule(cmHandler);
            const imgDom= imgHandler.create();
            wrapper.appendChild(imgDom);
            const imIcon=tobDom.querySelector(`[data-name="image"]`);
            imIcon.addEventListener("click",imgHandler.handle);

            this.Img.Dom= imgDom;
            this.Img.Handler= imgHandler;
            /*----------------------------- */

            /*creat table handler*/
            const tbModule  = this.Table.Module; 
            const tbHandler = new tbModule(cmHandler);
            const tbDom = tbHandler.create();
            wrapper.appendChild(tbDom);
            const tbIcon=tobDom.querySelector(`[data-name="table"]`);
            tbIcon.addEventListener("click",this.Table.show);

            this.Table.Dom = tbDom;
            this.Table.Handler= tbHandler;
            /*--------------------------- */
            this.render();
            cmHandler.on("change",()=>{this.render();});
           
            this.Me=wrapper;
            setTimeout(()=>{
                this.CodeMirror.Handler.focus();
                this.CodeMirror.Handler.refresh();
            },300);
            return wrapper
        }
        render() {
            const previewContainer      = this.previewContainer;
            const cm                    = this.CodeMirror.Handler;    
            let cmValue                 = cm.getValue();//-------------------------markdown value
            const htmlValue             = this.markdownRender.getHTML(cmValue);
            previewContainer.innerHTML  = htmlValue;
            PR.prettyPrint();
        }
        CodeMirrorConfig(markdownInitial){
            const me={
                value                     : markdownInitial,
                mode                      : "gfm",
                autofocus                 : true,
                autoCloseTags             : true,
                indentUnit                : 4,
                lineWrapping              : true,
                matchBrackets             : true,
                indentWithTabs            : true,
                styleActiveLine           : true,
                styleSelectedText         : true,
                autoCloseBrackets         : true,
                showTrailingSpace         : true,
                autoRefresh               : true,
                styleActiveLine           : true,
                lineNumbers               : true,
            };
            return me
        }
    }

    exports.MarkdownRender = MarkdownRender;
    exports.Yaposi = Yaposi;

     return exports
};
